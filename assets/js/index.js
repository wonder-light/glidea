'use strict';

var require$$0$5 = require('fs');
var require$$0$3 = require('constants');
var require$$0$4 = require('stream');
var require$$5$1 = require('util');
var require$$5$2 = require('assert');
var require$$1$1 = require('path');
var require$$0$6 = require('os');
var require$$0$7 = require('http');
var require$$1$3 = require('https');
var require$$1$2 = require('url');
var require$$2$2 = require('readline');
var require$$1$4 = require('child_process');
var require$$1$5 = require('string_decoder');
var require$$3$2 = require('zlib');
var require$$0$8 = require('crypto');
var require$$0$9 = require('querystring');
var require$$0$a = require('buffer');

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			if (this instanceof a) {
        return Reflect.construct(f, arguments, this.constructor);
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

function commonjsRequire(path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var fs$1 = {};

var universalify = {};

var hasRequiredUniversalify;
function requireUniversalify() {
  if (hasRequiredUniversalify) return universalify;
  hasRequiredUniversalify = 1;
  universalify.fromCallback = function (fn) {
    return Object.defineProperty(function (...args) {
      if (typeof args[args.length - 1] === 'function') fn.apply(this, args);else {
        return new Promise((resolve, reject) => {
          args.push((err, res) => err != null ? reject(err) : resolve(res));
          fn.apply(this, args);
        });
      }
    }, 'name', {
      value: fn.name
    });
  };
  universalify.fromPromise = function (fn) {
    return Object.defineProperty(function (...args) {
      const cb = args[args.length - 1];
      if (typeof cb !== 'function') return fn.apply(this, args);else {
        args.pop();
        fn.apply(this, args).then(r => cb(null, r), cb);
      }
    }, 'name', {
      value: fn.name
    });
  };
  return universalify;
}

var polyfills;
var hasRequiredPolyfills;
function requirePolyfills() {
  if (hasRequiredPolyfills) return polyfills;
  hasRequiredPolyfills = 1;
  var constants = require$$0$3;
  var origCwd = process.cwd;
  var cwd = null;
  var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
  process.cwd = function () {
    if (!cwd) cwd = origCwd.call(process);
    return cwd;
  };
  try {
    process.cwd();
  } catch (er) {}

  // This check is needed until node.js 12 is required
  if (typeof process.chdir === 'function') {
    var chdir = process.chdir;
    process.chdir = function (d) {
      cwd = null;
      chdir.call(process, d);
    };
    if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir);
  }
  polyfills = patch;
  function patch(fs) {
    // (re-)implement some things that are known busted or missing.

    // lchmod, broken prior to 0.6.2
    // back-port the fix here.
    if (constants.hasOwnProperty('O_SYMLINK') && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
      patchLchmod(fs);
    }

    // lutimes implementation, or no-op
    if (!fs.lutimes) {
      patchLutimes(fs);
    }

    // https://github.com/isaacs/node-graceful-fs/issues/4
    // Chown should not fail on einval or eperm if non-root.
    // It should not fail on enosys ever, as this just indicates
    // that a fs doesn't support the intended operation.

    fs.chown = chownFix(fs.chown);
    fs.fchown = chownFix(fs.fchown);
    fs.lchown = chownFix(fs.lchown);
    fs.chmod = chmodFix(fs.chmod);
    fs.fchmod = chmodFix(fs.fchmod);
    fs.lchmod = chmodFix(fs.lchmod);
    fs.chownSync = chownFixSync(fs.chownSync);
    fs.fchownSync = chownFixSync(fs.fchownSync);
    fs.lchownSync = chownFixSync(fs.lchownSync);
    fs.chmodSync = chmodFixSync(fs.chmodSync);
    fs.fchmodSync = chmodFixSync(fs.fchmodSync);
    fs.lchmodSync = chmodFixSync(fs.lchmodSync);
    fs.stat = statFix(fs.stat);
    fs.fstat = statFix(fs.fstat);
    fs.lstat = statFix(fs.lstat);
    fs.statSync = statFixSync(fs.statSync);
    fs.fstatSync = statFixSync(fs.fstatSync);
    fs.lstatSync = statFixSync(fs.lstatSync);

    // if lchmod/lchown do not exist, then make them no-ops
    if (fs.chmod && !fs.lchmod) {
      fs.lchmod = function (path, mode, cb) {
        if (cb) process.nextTick(cb);
      };
      fs.lchmodSync = function () {};
    }
    if (fs.chown && !fs.lchown) {
      fs.lchown = function (path, uid, gid, cb) {
        if (cb) process.nextTick(cb);
      };
      fs.lchownSync = function () {};
    }

    // on Windows, A/V software can lock the directory, causing this
    // to fail with an EACCES or EPERM if the directory contains newly
    // created files.  Try again on failure, for up to 60 seconds.

    // Set the timeout this long because some Windows Anti-Virus, such as Parity
    // bit9, may lock files for up to a minute, causing npm package install
    // failures. Also, take care to yield the scheduler. Windows scheduling gives
    // CPU to a busy looping process, which can cause the program causing the lock
    // contention to be starved of CPU by node, so the contention doesn't resolve.
    if (platform === "win32") {
      fs.rename = typeof fs.rename !== 'function' ? fs.rename : function (fs$rename) {
        function rename(from, to, cb) {
          var start = Date.now();
          var backoff = 0;
          fs$rename(from, to, function CB(er) {
            if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 60000) {
              setTimeout(function () {
                fs.stat(to, function (stater, st) {
                  if (stater && stater.code === "ENOENT") fs$rename(from, to, CB);else cb(er);
                });
              }, backoff);
              if (backoff < 100) backoff += 10;
              return;
            }
            if (cb) cb(er);
          });
        }
        if (Object.setPrototypeOf) Object.setPrototypeOf(rename, fs$rename);
        return rename;
      }(fs.rename);
    }

    // if read() returns EAGAIN, then just try it again.
    fs.read = typeof fs.read !== 'function' ? fs.read : function (fs$read) {
      function read(fd, buffer, offset, length, position, callback_) {
        var callback;
        if (callback_ && typeof callback_ === 'function') {
          var eagCounter = 0;
          callback = function (er, _, __) {
            if (er && er.code === 'EAGAIN' && eagCounter < 10) {
              eagCounter++;
              return fs$read.call(fs, fd, buffer, offset, length, position, callback);
            }
            callback_.apply(this, arguments);
          };
        }
        return fs$read.call(fs, fd, buffer, offset, length, position, callback);
      }

      // This ensures `util.promisify` works as it does for native `fs.read`.
      if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);
      return read;
    }(fs.read);
    fs.readSync = typeof fs.readSync !== 'function' ? fs.readSync : function (fs$readSync) {
      return function (fd, buffer, offset, length, position) {
        var eagCounter = 0;
        while (true) {
          try {
            return fs$readSync.call(fs, fd, buffer, offset, length, position);
          } catch (er) {
            if (er.code === 'EAGAIN' && eagCounter < 10) {
              eagCounter++;
              continue;
            }
            throw er;
          }
        }
      };
    }(fs.readSync);
    function patchLchmod(fs) {
      fs.lchmod = function (path, mode, callback) {
        fs.open(path, constants.O_WRONLY | constants.O_SYMLINK, mode, function (err, fd) {
          if (err) {
            if (callback) callback(err);
            return;
          }
          // prefer to return the chmod error, if one occurs,
          // but still try to close, and report closing errors if they occur.
          fs.fchmod(fd, mode, function (err) {
            fs.close(fd, function (err2) {
              if (callback) callback(err || err2);
            });
          });
        });
      };
      fs.lchmodSync = function (path, mode) {
        var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);

        // prefer to return the chmod error, if one occurs,
        // but still try to close, and report closing errors if they occur.
        var threw = true;
        var ret;
        try {
          ret = fs.fchmodSync(fd, mode);
          threw = false;
        } finally {
          if (threw) {
            try {
              fs.closeSync(fd);
            } catch (er) {}
          } else {
            fs.closeSync(fd);
          }
        }
        return ret;
      };
    }
    function patchLutimes(fs) {
      if (constants.hasOwnProperty("O_SYMLINK") && fs.futimes) {
        fs.lutimes = function (path, at, mt, cb) {
          fs.open(path, constants.O_SYMLINK, function (er, fd) {
            if (er) {
              if (cb) cb(er);
              return;
            }
            fs.futimes(fd, at, mt, function (er) {
              fs.close(fd, function (er2) {
                if (cb) cb(er || er2);
              });
            });
          });
        };
        fs.lutimesSync = function (path, at, mt) {
          var fd = fs.openSync(path, constants.O_SYMLINK);
          var ret;
          var threw = true;
          try {
            ret = fs.futimesSync(fd, at, mt);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs.closeSync(fd);
              } catch (er) {}
            } else {
              fs.closeSync(fd);
            }
          }
          return ret;
        };
      } else if (fs.futimes) {
        fs.lutimes = function (_a, _b, _c, cb) {
          if (cb) process.nextTick(cb);
        };
        fs.lutimesSync = function () {};
      }
    }
    function chmodFix(orig) {
      if (!orig) return orig;
      return function (target, mode, cb) {
        return orig.call(fs, target, mode, function (er) {
          if (chownErOk(er)) er = null;
          if (cb) cb.apply(this, arguments);
        });
      };
    }
    function chmodFixSync(orig) {
      if (!orig) return orig;
      return function (target, mode) {
        try {
          return orig.call(fs, target, mode);
        } catch (er) {
          if (!chownErOk(er)) throw er;
        }
      };
    }
    function chownFix(orig) {
      if (!orig) return orig;
      return function (target, uid, gid, cb) {
        return orig.call(fs, target, uid, gid, function (er) {
          if (chownErOk(er)) er = null;
          if (cb) cb.apply(this, arguments);
        });
      };
    }
    function chownFixSync(orig) {
      if (!orig) return orig;
      return function (target, uid, gid) {
        try {
          return orig.call(fs, target, uid, gid);
        } catch (er) {
          if (!chownErOk(er)) throw er;
        }
      };
    }
    function statFix(orig) {
      if (!orig) return orig;
      // Older versions of Node erroneously returned signed integers for
      // uid + gid.
      return function (target, options, cb) {
        if (typeof options === 'function') {
          cb = options;
          options = null;
        }
        function callback(er, stats) {
          if (stats) {
            if (stats.uid < 0) stats.uid += 0x100000000;
            if (stats.gid < 0) stats.gid += 0x100000000;
          }
          if (cb) cb.apply(this, arguments);
        }
        return options ? orig.call(fs, target, options, callback) : orig.call(fs, target, callback);
      };
    }
    function statFixSync(orig) {
      if (!orig) return orig;
      // Older versions of Node erroneously returned signed integers for
      // uid + gid.
      return function (target, options) {
        var stats = options ? orig.call(fs, target, options) : orig.call(fs, target);
        if (stats) {
          if (stats.uid < 0) stats.uid += 0x100000000;
          if (stats.gid < 0) stats.gid += 0x100000000;
        }
        return stats;
      };
    }

    // ENOSYS means that the fs doesn't support the op. Just ignore
    // that, because it doesn't matter.
    //
    // if there's no getuid, or if getuid() is something other
    // than 0, and the error is EINVAL or EPERM, then just ignore
    // it.
    //
    // This specific case is a silent failure in cp, install, tar,
    // and most other unix tools that manage permissions.
    //
    // When running as root, or if other types of errors are
    // encountered, then it's strict.
    function chownErOk(er) {
      if (!er) return true;
      if (er.code === "ENOSYS") return true;
      var nonroot = !process.getuid || process.getuid() !== 0;
      if (nonroot) {
        if (er.code === "EINVAL" || er.code === "EPERM") return true;
      }
      return false;
    }
  }
  return polyfills;
}

var legacyStreams;
var hasRequiredLegacyStreams;
function requireLegacyStreams() {
  if (hasRequiredLegacyStreams) return legacyStreams;
  hasRequiredLegacyStreams = 1;
  var Stream = require$$0$4.Stream;
  legacyStreams = legacy;
  function legacy(fs) {
    return {
      ReadStream: ReadStream,
      WriteStream: WriteStream
    };
    function ReadStream(path, options) {
      if (!(this instanceof ReadStream)) return new ReadStream(path, options);
      Stream.call(this);
      var self = this;
      this.path = path;
      this.fd = null;
      this.readable = true;
      this.paused = false;
      this.flags = 'r';
      this.mode = 438; /*=0666*/
      this.bufferSize = 64 * 1024;
      options = options || {};

      // Mixin options into this
      var keys = Object.keys(options);
      for (var index = 0, length = keys.length; index < length; index++) {
        var key = keys[index];
        this[key] = options[key];
      }
      if (this.encoding) this.setEncoding(this.encoding);
      if (this.start !== undefined) {
        if ('number' !== typeof this.start) {
          throw TypeError('start must be a Number');
        }
        if (this.end === undefined) {
          this.end = Infinity;
        } else if ('number' !== typeof this.end) {
          throw TypeError('end must be a Number');
        }
        if (this.start > this.end) {
          throw new Error('start must be <= end');
        }
        this.pos = this.start;
      }
      if (this.fd !== null) {
        process.nextTick(function () {
          self._read();
        });
        return;
      }
      fs.open(this.path, this.flags, this.mode, function (err, fd) {
        if (err) {
          self.emit('error', err);
          self.readable = false;
          return;
        }
        self.fd = fd;
        self.emit('open', fd);
        self._read();
      });
    }
    function WriteStream(path, options) {
      if (!(this instanceof WriteStream)) return new WriteStream(path, options);
      Stream.call(this);
      this.path = path;
      this.fd = null;
      this.writable = true;
      this.flags = 'w';
      this.encoding = 'binary';
      this.mode = 438; /*=0666*/
      this.bytesWritten = 0;
      options = options || {};

      // Mixin options into this
      var keys = Object.keys(options);
      for (var index = 0, length = keys.length; index < length; index++) {
        var key = keys[index];
        this[key] = options[key];
      }
      if (this.start !== undefined) {
        if ('number' !== typeof this.start) {
          throw TypeError('start must be a Number');
        }
        if (this.start < 0) {
          throw new Error('start must be >= zero');
        }
        this.pos = this.start;
      }
      this.busy = false;
      this._queue = [];
      if (this.fd === null) {
        this._open = fs.open;
        this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
        this.flush();
      }
    }
  }
  return legacyStreams;
}

var clone_1;
var hasRequiredClone$1;
function requireClone$1() {
  if (hasRequiredClone$1) return clone_1;
  hasRequiredClone$1 = 1;
  clone_1 = clone;
  var getPrototypeOf = Object.getPrototypeOf || function (obj) {
    return obj.__proto__;
  };
  function clone(obj) {
    if (obj === null || typeof obj !== 'object') return obj;
    if (obj instanceof Object) var copy = {
      __proto__: getPrototypeOf(obj)
    };else var copy = Object.create(null);
    Object.getOwnPropertyNames(obj).forEach(function (key) {
      Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
    });
    return copy;
  }
  return clone_1;
}

var gracefulFs;
var hasRequiredGracefulFs;
function requireGracefulFs() {
  if (hasRequiredGracefulFs) return gracefulFs;
  hasRequiredGracefulFs = 1;
  var fs = require$$0$5;
  var polyfills = requirePolyfills();
  var legacy = requireLegacyStreams();
  var clone = requireClone$1();
  var util = require$$5$1;

  /* istanbul ignore next - node 0.x polyfill */
  var gracefulQueue;
  var previousSymbol;

  /* istanbul ignore else - node 0.x polyfill */
  if (typeof Symbol === 'function' && typeof Symbol.for === 'function') {
    gracefulQueue = Symbol.for('graceful-fs.queue');
    // This is used in testing by future versions
    previousSymbol = Symbol.for('graceful-fs.previous');
  } else {
    gracefulQueue = '___graceful-fs.queue';
    previousSymbol = '___graceful-fs.previous';
  }
  function noop() {}
  function publishQueue(context, queue) {
    Object.defineProperty(context, gracefulQueue, {
      get: function () {
        return queue;
      }
    });
  }
  var debug = noop;
  if (util.debuglog) debug = util.debuglog('gfs4');else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) debug = function () {
    var m = util.format.apply(util, arguments);
    m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ');
    console.error(m);
  };

  // Once time initialization
  if (!fs[gracefulQueue]) {
    // This queue can be shared by multiple loaded instances
    var queue = commonjsGlobal[gracefulQueue] || [];
    publishQueue(fs, queue);

    // Patch fs.close/closeSync to shared queue version, because we need
    // to retry() whenever a close happens *anywhere* in the program.
    // This is essential when multiple graceful-fs instances are
    // in play at the same time.
    fs.close = function (fs$close) {
      function close(fd, cb) {
        return fs$close.call(fs, fd, function (err) {
          // This function uses the graceful-fs shared queue
          if (!err) {
            resetQueue();
          }
          if (typeof cb === 'function') cb.apply(this, arguments);
        });
      }
      Object.defineProperty(close, previousSymbol, {
        value: fs$close
      });
      return close;
    }(fs.close);
    fs.closeSync = function (fs$closeSync) {
      function closeSync(fd) {
        // This function uses the graceful-fs shared queue
        fs$closeSync.apply(fs, arguments);
        resetQueue();
      }
      Object.defineProperty(closeSync, previousSymbol, {
        value: fs$closeSync
      });
      return closeSync;
    }(fs.closeSync);
    if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
      process.on('exit', function () {
        debug(fs[gracefulQueue]);
        require$$5$2.equal(fs[gracefulQueue].length, 0);
      });
    }
  }
  if (!commonjsGlobal[gracefulQueue]) {
    publishQueue(commonjsGlobal, fs[gracefulQueue]);
  }
  gracefulFs = patch(clone(fs));
  if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
    gracefulFs = patch(fs);
    fs.__patched = true;
  }
  function patch(fs) {
    // Everything that references the open() function needs to be in here
    polyfills(fs);
    fs.gracefulify = patch;
    fs.createReadStream = createReadStream;
    fs.createWriteStream = createWriteStream;
    var fs$readFile = fs.readFile;
    fs.readFile = readFile;
    function readFile(path, options, cb) {
      if (typeof options === 'function') cb = options, options = null;
      return go$readFile(path, options, cb);
      function go$readFile(path, options, cb, startTime) {
        return fs$readFile(path, options, function (err) {
          if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$readFile, [path, options, cb], err, startTime || Date.now(), Date.now()]);else {
            if (typeof cb === 'function') cb.apply(this, arguments);
          }
        });
      }
    }
    var fs$writeFile = fs.writeFile;
    fs.writeFile = writeFile;
    function writeFile(path, data, options, cb) {
      if (typeof options === 'function') cb = options, options = null;
      return go$writeFile(path, data, options, cb);
      function go$writeFile(path, data, options, cb, startTime) {
        return fs$writeFile(path, data, options, function (err) {
          if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$writeFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()]);else {
            if (typeof cb === 'function') cb.apply(this, arguments);
          }
        });
      }
    }
    var fs$appendFile = fs.appendFile;
    if (fs$appendFile) fs.appendFile = appendFile;
    function appendFile(path, data, options, cb) {
      if (typeof options === 'function') cb = options, options = null;
      return go$appendFile(path, data, options, cb);
      function go$appendFile(path, data, options, cb, startTime) {
        return fs$appendFile(path, data, options, function (err) {
          if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$appendFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()]);else {
            if (typeof cb === 'function') cb.apply(this, arguments);
          }
        });
      }
    }
    var fs$copyFile = fs.copyFile;
    if (fs$copyFile) fs.copyFile = copyFile;
    function copyFile(src, dest, flags, cb) {
      if (typeof flags === 'function') {
        cb = flags;
        flags = 0;
      }
      return go$copyFile(src, dest, flags, cb);
      function go$copyFile(src, dest, flags, cb, startTime) {
        return fs$copyFile(src, dest, flags, function (err) {
          if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$copyFile, [src, dest, flags, cb], err, startTime || Date.now(), Date.now()]);else {
            if (typeof cb === 'function') cb.apply(this, arguments);
          }
        });
      }
    }
    var fs$readdir = fs.readdir;
    fs.readdir = readdir;
    var noReaddirOptionVersions = /^v[0-5]\./;
    function readdir(path, options, cb) {
      if (typeof options === 'function') cb = options, options = null;
      var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir(path, options, cb, startTime) {
        return fs$readdir(path, fs$readdirCallback(path, options, cb, startTime));
      } : function go$readdir(path, options, cb, startTime) {
        return fs$readdir(path, options, fs$readdirCallback(path, options, cb, startTime));
      };
      return go$readdir(path, options, cb);
      function fs$readdirCallback(path, options, cb, startTime) {
        return function (err, files) {
          if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$readdir, [path, options, cb], err, startTime || Date.now(), Date.now()]);else {
            if (files && files.sort) files.sort();
            if (typeof cb === 'function') cb.call(this, err, files);
          }
        };
      }
    }
    if (process.version.substr(0, 4) === 'v0.8') {
      var legStreams = legacy(fs);
      ReadStream = legStreams.ReadStream;
      WriteStream = legStreams.WriteStream;
    }
    var fs$ReadStream = fs.ReadStream;
    if (fs$ReadStream) {
      ReadStream.prototype = Object.create(fs$ReadStream.prototype);
      ReadStream.prototype.open = ReadStream$open;
    }
    var fs$WriteStream = fs.WriteStream;
    if (fs$WriteStream) {
      WriteStream.prototype = Object.create(fs$WriteStream.prototype);
      WriteStream.prototype.open = WriteStream$open;
    }
    Object.defineProperty(fs, 'ReadStream', {
      get: function () {
        return ReadStream;
      },
      set: function (val) {
        ReadStream = val;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(fs, 'WriteStream', {
      get: function () {
        return WriteStream;
      },
      set: function (val) {
        WriteStream = val;
      },
      enumerable: true,
      configurable: true
    });

    // legacy names
    var FileReadStream = ReadStream;
    Object.defineProperty(fs, 'FileReadStream', {
      get: function () {
        return FileReadStream;
      },
      set: function (val) {
        FileReadStream = val;
      },
      enumerable: true,
      configurable: true
    });
    var FileWriteStream = WriteStream;
    Object.defineProperty(fs, 'FileWriteStream', {
      get: function () {
        return FileWriteStream;
      },
      set: function (val) {
        FileWriteStream = val;
      },
      enumerable: true,
      configurable: true
    });
    function ReadStream(path, options) {
      if (this instanceof ReadStream) return fs$ReadStream.apply(this, arguments), this;else return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
    }
    function ReadStream$open() {
      var that = this;
      open(that.path, that.flags, that.mode, function (err, fd) {
        if (err) {
          if (that.autoClose) that.destroy();
          that.emit('error', err);
        } else {
          that.fd = fd;
          that.emit('open', fd);
          that.read();
        }
      });
    }
    function WriteStream(path, options) {
      if (this instanceof WriteStream) return fs$WriteStream.apply(this, arguments), this;else return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
    }
    function WriteStream$open() {
      var that = this;
      open(that.path, that.flags, that.mode, function (err, fd) {
        if (err) {
          that.destroy();
          that.emit('error', err);
        } else {
          that.fd = fd;
          that.emit('open', fd);
        }
      });
    }
    function createReadStream(path, options) {
      return new fs.ReadStream(path, options);
    }
    function createWriteStream(path, options) {
      return new fs.WriteStream(path, options);
    }
    var fs$open = fs.open;
    fs.open = open;
    function open(path, flags, mode, cb) {
      if (typeof mode === 'function') cb = mode, mode = null;
      return go$open(path, flags, mode, cb);
      function go$open(path, flags, mode, cb, startTime) {
        return fs$open(path, flags, mode, function (err, fd) {
          if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$open, [path, flags, mode, cb], err, startTime || Date.now(), Date.now()]);else {
            if (typeof cb === 'function') cb.apply(this, arguments);
          }
        });
      }
    }
    return fs;
  }
  function enqueue(elem) {
    debug('ENQUEUE', elem[0].name, elem[1]);
    fs[gracefulQueue].push(elem);
    retry();
  }

  // keep track of the timeout between retry() calls
  var retryTimer;

  // reset the startTime and lastTime to now
  // this resets the start of the 60 second overall timeout as well as the
  // delay between attempts so that we'll retry these jobs sooner
  function resetQueue() {
    var now = Date.now();
    for (var i = 0; i < fs[gracefulQueue].length; ++i) {
      // entries that are only a length of 2 are from an older version, don't
      // bother modifying those since they'll be retried anyway.
      if (fs[gracefulQueue][i].length > 2) {
        fs[gracefulQueue][i][3] = now; // startTime
        fs[gracefulQueue][i][4] = now; // lastTime
      }
    }
    // call retry to make sure we're actively processing the queue
    retry();
  }
  function retry() {
    // clear the timer and remove it to help prevent unintended concurrency
    clearTimeout(retryTimer);
    retryTimer = undefined;
    if (fs[gracefulQueue].length === 0) return;
    var elem = fs[gracefulQueue].shift();
    var fn = elem[0];
    var args = elem[1];
    // these items may be unset if they were added by an older graceful-fs
    var err = elem[2];
    var startTime = elem[3];
    var lastTime = elem[4];

    // if we don't have a startTime we have no way of knowing if we've waited
    // long enough, so go ahead and retry this item now
    if (startTime === undefined) {
      debug('RETRY', fn.name, args);
      fn.apply(null, args);
    } else if (Date.now() - startTime >= 60000) {
      // it's been more than 60 seconds total, bail now
      debug('TIMEOUT', fn.name, args);
      var cb = args.pop();
      if (typeof cb === 'function') cb.call(null, err);
    } else {
      // the amount of time between the last attempt and right now
      var sinceAttempt = Date.now() - lastTime;
      // the amount of time between when we first tried, and when we last tried
      // rounded up to at least 1
      var sinceStart = Math.max(lastTime - startTime, 1);
      // backoff. wait longer than the total time we've been retrying, but only
      // up to a maximum of 100ms
      var desiredDelay = Math.min(sinceStart * 1.2, 100);
      // it's been long enough since the last retry, do it again
      if (sinceAttempt >= desiredDelay) {
        debug('RETRY', fn.name, args);
        fn.apply(null, args.concat([startTime]));
      } else {
        // if we can't do this job yet, push it to the end of the queue
        // and let the next iteration check again
        fs[gracefulQueue].push(elem);
      }
    }

    // schedule our next run if one isn't already scheduled
    if (retryTimer === undefined) {
      retryTimer = setTimeout(retry, 0);
    }
  }
  return gracefulFs;
}

var hasRequiredFs$1;
function requireFs$1() {
  if (hasRequiredFs$1) return fs$1;
  hasRequiredFs$1 = 1;
  (function (exports) {

    // This is adapted from https://github.com/normalize/mz
    // Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors
    const u = requireUniversalify().fromCallback;
    const fs = requireGracefulFs();
    const api = ['access', 'appendFile', 'chmod', 'chown', 'close', 'copyFile', 'fchmod', 'fchown', 'fdatasync', 'fstat', 'fsync', 'ftruncate', 'futimes', 'lchmod', 'lchown', 'link', 'lstat', 'mkdir', 'mkdtemp', 'open', 'opendir', 'readdir', 'readFile', 'readlink', 'realpath', 'rename', 'rm', 'rmdir', 'stat', 'symlink', 'truncate', 'unlink', 'utimes', 'writeFile'].filter(key => {
      // Some commands are not available on some systems. Ex:
      // fs.cp was added in Node.js v16.7.0
      // fs.lchown is not available on at least some Linux
      return typeof fs[key] === 'function';
    });

    // Export cloned fs:
    Object.assign(exports, fs);

    // Universalify async methods:
    api.forEach(method => {
      exports[method] = u(fs[method]);
    });

    // We differ from mz/fs in that we still ship the old, broken, fs.exists()
    // since we are a drop-in replacement for the native module
    exports.exists = function (filename, callback) {
      if (typeof callback === 'function') {
        return fs.exists(filename, callback);
      }
      return new Promise(resolve => {
        return fs.exists(filename, resolve);
      });
    };

    // fs.read(), fs.write(), fs.readv(), & fs.writev() need special treatment due to multiple callback args

    exports.read = function (fd, buffer, offset, length, position, callback) {
      if (typeof callback === 'function') {
        return fs.read(fd, buffer, offset, length, position, callback);
      }
      return new Promise((resolve, reject) => {
        fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {
          if (err) return reject(err);
          resolve({
            bytesRead,
            buffer
          });
        });
      });
    };

    // Function signature can be
    // fs.write(fd, buffer[, offset[, length[, position]]], callback)
    // OR
    // fs.write(fd, string[, position[, encoding]], callback)
    // We need to handle both cases, so we use ...args
    exports.write = function (fd, buffer, ...args) {
      if (typeof args[args.length - 1] === 'function') {
        return fs.write(fd, buffer, ...args);
      }
      return new Promise((resolve, reject) => {
        fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {
          if (err) return reject(err);
          resolve({
            bytesWritten,
            buffer
          });
        });
      });
    };

    // Function signature is
    // s.readv(fd, buffers[, position], callback)
    // We need to handle the optional arg, so we use ...args
    exports.readv = function (fd, buffers, ...args) {
      if (typeof args[args.length - 1] === 'function') {
        return fs.readv(fd, buffers, ...args);
      }
      return new Promise((resolve, reject) => {
        fs.readv(fd, buffers, ...args, (err, bytesRead, buffers) => {
          if (err) return reject(err);
          resolve({
            bytesRead,
            buffers
          });
        });
      });
    };

    // Function signature is
    // s.writev(fd, buffers[, position], callback)
    // We need to handle the optional arg, so we use ...args
    exports.writev = function (fd, buffers, ...args) {
      if (typeof args[args.length - 1] === 'function') {
        return fs.writev(fd, buffers, ...args);
      }
      return new Promise((resolve, reject) => {
        fs.writev(fd, buffers, ...args, (err, bytesWritten, buffers) => {
          if (err) return reject(err);
          resolve({
            bytesWritten,
            buffers
          });
        });
      });
    };

    // fs.realpath.native sometimes not available if fs is monkey-patched
    if (typeof fs.realpath.native === 'function') {
      exports.realpath.native = u(fs.realpath.native);
    } else {
      process.emitWarning('fs.realpath.native is not a function. Is fs being monkey-patched?', 'Warning', 'fs-extra-WARN0003');
    }
  })(fs$1);
  return fs$1;
}

var makeDir = {};

var utils$6 = {};

var hasRequiredUtils$6;
function requireUtils$6() {
  if (hasRequiredUtils$6) return utils$6;
  hasRequiredUtils$6 = 1;
  const path = require$$1$1;

  // https://github.com/nodejs/node/issues/8987
  // https://github.com/libuv/libuv/pull/1088
  utils$6.checkPath = function checkPath(pth) {
    if (process.platform === 'win32') {
      const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path.parse(pth).root, ''));
      if (pathHasInvalidWinCharacters) {
        const error = new Error(`Path contains invalid characters: ${pth}`);
        error.code = 'EINVAL';
        throw error;
      }
    }
  };
  return utils$6;
}

var hasRequiredMakeDir;
function requireMakeDir() {
  if (hasRequiredMakeDir) return makeDir;
  hasRequiredMakeDir = 1;
  const fs = /*@__PURE__*/requireFs$1();
  const {
    checkPath
  } = /*@__PURE__*/requireUtils$6();
  const getMode = options => {
    const defaults = {
      mode: 0o777
    };
    if (typeof options === 'number') return options;
    return {
      ...defaults,
      ...options
    }.mode;
  };
  makeDir.makeDir = async (dir, options) => {
    checkPath(dir);
    return fs.mkdir(dir, {
      mode: getMode(options),
      recursive: true
    });
  };
  makeDir.makeDirSync = (dir, options) => {
    checkPath(dir);
    return fs.mkdirSync(dir, {
      mode: getMode(options),
      recursive: true
    });
  };
  return makeDir;
}

var mkdirs;
var hasRequiredMkdirs;
function requireMkdirs() {
  if (hasRequiredMkdirs) return mkdirs;
  hasRequiredMkdirs = 1;
  const u = requireUniversalify().fromPromise;
  const {
    makeDir: _makeDir,
    makeDirSync
  } = /*@__PURE__*/requireMakeDir();
  const makeDir = u(_makeDir);
  mkdirs = {
    mkdirs: makeDir,
    mkdirsSync: makeDirSync,
    // alias
    mkdirp: makeDir,
    mkdirpSync: makeDirSync,
    ensureDir: makeDir,
    ensureDirSync: makeDirSync
  };
  return mkdirs;
}

var pathExists_1;
var hasRequiredPathExists;
function requirePathExists() {
  if (hasRequiredPathExists) return pathExists_1;
  hasRequiredPathExists = 1;
  const u = requireUniversalify().fromPromise;
  const fs = /*@__PURE__*/requireFs$1();
  function pathExists(path) {
    return fs.access(path).then(() => true).catch(() => false);
  }
  pathExists_1 = {
    pathExists: u(pathExists),
    pathExistsSync: fs.existsSync
  };
  return pathExists_1;
}

var utimes;
var hasRequiredUtimes;
function requireUtimes() {
  if (hasRequiredUtimes) return utimes;
  hasRequiredUtimes = 1;
  const fs = /*@__PURE__*/requireFs$1();
  const u = requireUniversalify().fromPromise;
  async function utimesMillis(path, atime, mtime) {
    // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)
    const fd = await fs.open(path, 'r+');
    let closeErr = null;
    try {
      await fs.futimes(fd, atime, mtime);
    } finally {
      try {
        await fs.close(fd);
      } catch (e) {
        closeErr = e;
      }
    }
    if (closeErr) {
      throw closeErr;
    }
  }
  function utimesMillisSync(path, atime, mtime) {
    const fd = fs.openSync(path, 'r+');
    fs.futimesSync(fd, atime, mtime);
    return fs.closeSync(fd);
  }
  utimes = {
    utimesMillis: u(utimesMillis),
    utimesMillisSync
  };
  return utimes;
}

var stat;
var hasRequiredStat;
function requireStat() {
  if (hasRequiredStat) return stat;
  hasRequiredStat = 1;
  const fs = /*@__PURE__*/requireFs$1();
  const path = require$$1$1;
  const u = requireUniversalify().fromPromise;
  function getStats(src, dest, opts) {
    const statFunc = opts.dereference ? file => fs.stat(file, {
      bigint: true
    }) : file => fs.lstat(file, {
      bigint: true
    });
    return Promise.all([statFunc(src), statFunc(dest).catch(err => {
      if (err.code === 'ENOENT') return null;
      throw err;
    })]).then(([srcStat, destStat]) => ({
      srcStat,
      destStat
    }));
  }
  function getStatsSync(src, dest, opts) {
    let destStat;
    const statFunc = opts.dereference ? file => fs.statSync(file, {
      bigint: true
    }) : file => fs.lstatSync(file, {
      bigint: true
    });
    const srcStat = statFunc(src);
    try {
      destStat = statFunc(dest);
    } catch (err) {
      if (err.code === 'ENOENT') return {
        srcStat,
        destStat: null
      };
      throw err;
    }
    return {
      srcStat,
      destStat
    };
  }
  async function checkPaths(src, dest, funcName, opts) {
    const {
      srcStat,
      destStat
    } = await getStats(src, dest, opts);
    if (destStat) {
      if (areIdentical(srcStat, destStat)) {
        const srcBaseName = path.basename(src);
        const destBaseName = path.basename(dest);
        if (funcName === 'move' && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
          return {
            srcStat,
            destStat,
            isChangingCase: true
          };
        }
        throw new Error('Source and destination must not be the same.');
      }
      if (srcStat.isDirectory() && !destStat.isDirectory()) {
        throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
      }
      if (!srcStat.isDirectory() && destStat.isDirectory()) {
        throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
      }
    }
    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
      throw new Error(errMsg(src, dest, funcName));
    }
    return {
      srcStat,
      destStat
    };
  }
  function checkPathsSync(src, dest, funcName, opts) {
    const {
      srcStat,
      destStat
    } = getStatsSync(src, dest, opts);
    if (destStat) {
      if (areIdentical(srcStat, destStat)) {
        const srcBaseName = path.basename(src);
        const destBaseName = path.basename(dest);
        if (funcName === 'move' && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
          return {
            srcStat,
            destStat,
            isChangingCase: true
          };
        }
        throw new Error('Source and destination must not be the same.');
      }
      if (srcStat.isDirectory() && !destStat.isDirectory()) {
        throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
      }
      if (!srcStat.isDirectory() && destStat.isDirectory()) {
        throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
      }
    }
    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
      throw new Error(errMsg(src, dest, funcName));
    }
    return {
      srcStat,
      destStat
    };
  }

  // recursively check if dest parent is a subdirectory of src.
  // It works for all file types including symlinks since it
  // checks the src and dest inodes. It starts from the deepest
  // parent and stops once it reaches the src parent or the root path.
  async function checkParentPaths(src, srcStat, dest, funcName) {
    const srcParent = path.resolve(path.dirname(src));
    const destParent = path.resolve(path.dirname(dest));
    if (destParent === srcParent || destParent === path.parse(destParent).root) return;
    let destStat;
    try {
      destStat = await fs.stat(destParent, {
        bigint: true
      });
    } catch (err) {
      if (err.code === 'ENOENT') return;
      throw err;
    }
    if (areIdentical(srcStat, destStat)) {
      throw new Error(errMsg(src, dest, funcName));
    }
    return checkParentPaths(src, srcStat, destParent, funcName);
  }
  function checkParentPathsSync(src, srcStat, dest, funcName) {
    const srcParent = path.resolve(path.dirname(src));
    const destParent = path.resolve(path.dirname(dest));
    if (destParent === srcParent || destParent === path.parse(destParent).root) return;
    let destStat;
    try {
      destStat = fs.statSync(destParent, {
        bigint: true
      });
    } catch (err) {
      if (err.code === 'ENOENT') return;
      throw err;
    }
    if (areIdentical(srcStat, destStat)) {
      throw new Error(errMsg(src, dest, funcName));
    }
    return checkParentPathsSync(src, srcStat, destParent, funcName);
  }
  function areIdentical(srcStat, destStat) {
    return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
  }

  // return true if dest is a subdir of src, otherwise false.
  // It only checks the path strings.
  function isSrcSubdir(src, dest) {
    const srcArr = path.resolve(src).split(path.sep).filter(i => i);
    const destArr = path.resolve(dest).split(path.sep).filter(i => i);
    return srcArr.every((cur, i) => destArr[i] === cur);
  }
  function errMsg(src, dest, funcName) {
    return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
  }
  stat = {
    // checkPaths
    checkPaths: u(checkPaths),
    checkPathsSync,
    // checkParent
    checkParentPaths: u(checkParentPaths),
    checkParentPathsSync,
    // Misc
    isSrcSubdir,
    areIdentical
  };
  return stat;
}

var copy_1;
var hasRequiredCopy$1;
function requireCopy$1() {
  if (hasRequiredCopy$1) return copy_1;
  hasRequiredCopy$1 = 1;
  const fs = /*@__PURE__*/requireFs$1();
  const path = require$$1$1;
  const {
    mkdirs
  } = /*@__PURE__*/requireMkdirs();
  const {
    pathExists
  } = /*@__PURE__*/requirePathExists();
  const {
    utimesMillis
  } = /*@__PURE__*/requireUtimes();
  const stat = /*@__PURE__*/requireStat();
  async function copy(src, dest, opts = {}) {
    if (typeof opts === 'function') {
      opts = {
        filter: opts
      };
    }
    opts.clobber = 'clobber' in opts ? !!opts.clobber : true; // default to true for now
    opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber

    // Warn about using preserveTimestamps on 32-bit node
    if (opts.preserveTimestamps && process.arch === 'ia32') {
      process.emitWarning('Using the preserveTimestamps option in 32-bit node is not recommended;\n\n' + '\tsee https://github.com/jprichardson/node-fs-extra/issues/269', 'Warning', 'fs-extra-WARN0001');
    }
    const {
      srcStat,
      destStat
    } = await stat.checkPaths(src, dest, 'copy', opts);
    await stat.checkParentPaths(src, srcStat, dest, 'copy');
    const include = await runFilter(src, dest, opts);
    if (!include) return;

    // check if the parent of dest exists, and create it if it doesn't exist
    const destParent = path.dirname(dest);
    const dirExists = await pathExists(destParent);
    if (!dirExists) {
      await mkdirs(destParent);
    }
    await getStatsAndPerformCopy(destStat, src, dest, opts);
  }
  async function runFilter(src, dest, opts) {
    if (!opts.filter) return true;
    return opts.filter(src, dest);
  }
  async function getStatsAndPerformCopy(destStat, src, dest, opts) {
    const statFn = opts.dereference ? fs.stat : fs.lstat;
    const srcStat = await statFn(src);
    if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts);
    if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts);
    if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts);
    if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`);
    if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`);
    throw new Error(`Unknown file: ${src}`);
  }
  async function onFile(srcStat, destStat, src, dest, opts) {
    if (!destStat) return copyFile(srcStat, src, dest, opts);
    if (opts.overwrite) {
      await fs.unlink(dest);
      return copyFile(srcStat, src, dest, opts);
    }
    if (opts.errorOnExist) {
      throw new Error(`'${dest}' already exists`);
    }
  }
  async function copyFile(srcStat, src, dest, opts) {
    await fs.copyFile(src, dest);
    if (opts.preserveTimestamps) {
      // Make sure the file is writable before setting the timestamp
      // otherwise open fails with EPERM when invoked with 'r+'
      // (through utimes call)
      if (fileIsNotWritable(srcStat.mode)) {
        await makeFileWritable(dest, srcStat.mode);
      }

      // Set timestamps and mode correspondingly

      // Note that The initial srcStat.atime cannot be trusted
      // because it is modified by the read(2) system call
      // (See https://nodejs.org/api/fs.html#fs_stat_time_values)
      const updatedSrcStat = await fs.stat(src);
      await utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
    }
    return fs.chmod(dest, srcStat.mode);
  }
  function fileIsNotWritable(srcMode) {
    return (srcMode & 0o200) === 0;
  }
  function makeFileWritable(dest, srcMode) {
    return fs.chmod(dest, srcMode | 0o200);
  }
  async function onDir(srcStat, destStat, src, dest, opts) {
    // the dest directory might not exist, create it
    if (!destStat) {
      await fs.mkdir(dest);
    }
    const items = await fs.readdir(src);

    // loop through the files in the current directory to copy everything
    await Promise.all(items.map(async item => {
      const srcItem = path.join(src, item);
      const destItem = path.join(dest, item);

      // skip the item if it is matches by the filter function
      const include = await runFilter(srcItem, destItem, opts);
      if (!include) return;
      const {
        destStat
      } = await stat.checkPaths(srcItem, destItem, 'copy', opts);

      // If the item is a copyable file, `getStatsAndPerformCopy` will copy it
      // If the item is a directory, `getStatsAndPerformCopy` will call `onDir` recursively
      return getStatsAndPerformCopy(destStat, srcItem, destItem, opts);
    }));
    if (!destStat) {
      await fs.chmod(dest, srcStat.mode);
    }
  }
  async function onLink(destStat, src, dest, opts) {
    let resolvedSrc = await fs.readlink(src);
    if (opts.dereference) {
      resolvedSrc = path.resolve(process.cwd(), resolvedSrc);
    }
    if (!destStat) {
      return fs.symlink(resolvedSrc, dest);
    }
    let resolvedDest = null;
    try {
      resolvedDest = await fs.readlink(dest);
    } catch (e) {
      // dest exists and is a regular file or directory,
      // Windows may throw UNKNOWN error. If dest already exists,
      // fs throws error anyway, so no need to guard against it here.
      if (e.code === 'EINVAL' || e.code === 'UNKNOWN') return fs.symlink(resolvedSrc, dest);
      throw e;
    }
    if (opts.dereference) {
      resolvedDest = path.resolve(process.cwd(), resolvedDest);
    }
    if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
    }

    // do not copy if src is a subdir of dest since unlinking
    // dest in this case would result in removing src contents
    // and therefore a broken symlink would be created.
    if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
    }

    // copy the link
    await fs.unlink(dest);
    return fs.symlink(resolvedSrc, dest);
  }
  copy_1 = copy;
  return copy_1;
}

var copySync_1;
var hasRequiredCopySync;
function requireCopySync() {
  if (hasRequiredCopySync) return copySync_1;
  hasRequiredCopySync = 1;
  const fs = requireGracefulFs();
  const path = require$$1$1;
  const mkdirsSync = /*@__PURE__*/requireMkdirs().mkdirsSync;
  const utimesMillisSync = /*@__PURE__*/requireUtimes().utimesMillisSync;
  const stat = /*@__PURE__*/requireStat();
  function copySync(src, dest, opts) {
    if (typeof opts === 'function') {
      opts = {
        filter: opts
      };
    }
    opts = opts || {};
    opts.clobber = 'clobber' in opts ? !!opts.clobber : true; // default to true for now
    opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber

    // Warn about using preserveTimestamps on 32-bit node
    if (opts.preserveTimestamps && process.arch === 'ia32') {
      process.emitWarning('Using the preserveTimestamps option in 32-bit node is not recommended;\n\n' + '\tsee https://github.com/jprichardson/node-fs-extra/issues/269', 'Warning', 'fs-extra-WARN0002');
    }
    const {
      srcStat,
      destStat
    } = stat.checkPathsSync(src, dest, 'copy', opts);
    stat.checkParentPathsSync(src, srcStat, dest, 'copy');
    if (opts.filter && !opts.filter(src, dest)) return;
    const destParent = path.dirname(dest);
    if (!fs.existsSync(destParent)) mkdirsSync(destParent);
    return getStats(destStat, src, dest, opts);
  }
  function getStats(destStat, src, dest, opts) {
    const statSync = opts.dereference ? fs.statSync : fs.lstatSync;
    const srcStat = statSync(src);
    if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts);else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts);else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts);else if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`);else if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`);
    throw new Error(`Unknown file: ${src}`);
  }
  function onFile(srcStat, destStat, src, dest, opts) {
    if (!destStat) return copyFile(srcStat, src, dest, opts);
    return mayCopyFile(srcStat, src, dest, opts);
  }
  function mayCopyFile(srcStat, src, dest, opts) {
    if (opts.overwrite) {
      fs.unlinkSync(dest);
      return copyFile(srcStat, src, dest, opts);
    } else if (opts.errorOnExist) {
      throw new Error(`'${dest}' already exists`);
    }
  }
  function copyFile(srcStat, src, dest, opts) {
    fs.copyFileSync(src, dest);
    if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src, dest);
    return setDestMode(dest, srcStat.mode);
  }
  function handleTimestamps(srcMode, src, dest) {
    // Make sure the file is writable before setting the timestamp
    // otherwise open fails with EPERM when invoked with 'r+'
    // (through utimes call)
    if (fileIsNotWritable(srcMode)) makeFileWritable(dest, srcMode);
    return setDestTimestamps(src, dest);
  }
  function fileIsNotWritable(srcMode) {
    return (srcMode & 0o200) === 0;
  }
  function makeFileWritable(dest, srcMode) {
    return setDestMode(dest, srcMode | 0o200);
  }
  function setDestMode(dest, srcMode) {
    return fs.chmodSync(dest, srcMode);
  }
  function setDestTimestamps(src, dest) {
    // The initial srcStat.atime cannot be trusted
    // because it is modified by the read(2) system call
    // (See https://nodejs.org/api/fs.html#fs_stat_time_values)
    const updatedSrcStat = fs.statSync(src);
    return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
  }
  function onDir(srcStat, destStat, src, dest, opts) {
    if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts);
    return copyDir(src, dest, opts);
  }
  function mkDirAndCopy(srcMode, src, dest, opts) {
    fs.mkdirSync(dest);
    copyDir(src, dest, opts);
    return setDestMode(dest, srcMode);
  }
  function copyDir(src, dest, opts) {
    fs.readdirSync(src).forEach(item => copyDirItem(item, src, dest, opts));
  }
  function copyDirItem(item, src, dest, opts) {
    const srcItem = path.join(src, item);
    const destItem = path.join(dest, item);
    if (opts.filter && !opts.filter(srcItem, destItem)) return;
    const {
      destStat
    } = stat.checkPathsSync(srcItem, destItem, 'copy', opts);
    return getStats(destStat, srcItem, destItem, opts);
  }
  function onLink(destStat, src, dest, opts) {
    let resolvedSrc = fs.readlinkSync(src);
    if (opts.dereference) {
      resolvedSrc = path.resolve(process.cwd(), resolvedSrc);
    }
    if (!destStat) {
      return fs.symlinkSync(resolvedSrc, dest);
    } else {
      let resolvedDest;
      try {
        resolvedDest = fs.readlinkSync(dest);
      } catch (err) {
        // dest exists and is a regular file or directory,
        // Windows may throw UNKNOWN error. If dest already exists,
        // fs throws error anyway, so no need to guard against it here.
        if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlinkSync(resolvedSrc, dest);
        throw err;
      }
      if (opts.dereference) {
        resolvedDest = path.resolve(process.cwd(), resolvedDest);
      }
      if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
        throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
      }

      // prevent copy if src is a subdir of dest since unlinking
      // dest in this case would result in removing src contents
      // and therefore a broken symlink would be created.
      if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
        throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
      }
      return copyLink(resolvedSrc, dest);
    }
  }
  function copyLink(resolvedSrc, dest) {
    fs.unlinkSync(dest);
    return fs.symlinkSync(resolvedSrc, dest);
  }
  copySync_1 = copySync;
  return copySync_1;
}

var copy;
var hasRequiredCopy;
function requireCopy() {
  if (hasRequiredCopy) return copy;
  hasRequiredCopy = 1;
  const u = requireUniversalify().fromPromise;
  copy = {
    copy: u(/*@__PURE__*/requireCopy$1()),
    copySync: /*@__PURE__*/requireCopySync()
  };
  return copy;
}

var remove_1;
var hasRequiredRemove;
function requireRemove() {
  if (hasRequiredRemove) return remove_1;
  hasRequiredRemove = 1;
  const fs = requireGracefulFs();
  const u = requireUniversalify().fromCallback;
  function remove(path, callback) {
    fs.rm(path, {
      recursive: true,
      force: true
    }, callback);
  }
  function removeSync(path) {
    fs.rmSync(path, {
      recursive: true,
      force: true
    });
  }
  remove_1 = {
    remove: u(remove),
    removeSync
  };
  return remove_1;
}

var empty;
var hasRequiredEmpty;
function requireEmpty() {
  if (hasRequiredEmpty) return empty;
  hasRequiredEmpty = 1;
  const u = requireUniversalify().fromPromise;
  const fs = /*@__PURE__*/requireFs$1();
  const path = require$$1$1;
  const mkdir = /*@__PURE__*/requireMkdirs();
  const remove = /*@__PURE__*/requireRemove();
  const emptyDir = u(async function emptyDir(dir) {
    let items;
    try {
      items = await fs.readdir(dir);
    } catch {
      return mkdir.mkdirs(dir);
    }
    return Promise.all(items.map(item => remove.remove(path.join(dir, item))));
  });
  function emptyDirSync(dir) {
    let items;
    try {
      items = fs.readdirSync(dir);
    } catch {
      return mkdir.mkdirsSync(dir);
    }
    items.forEach(item => {
      item = path.join(dir, item);
      remove.removeSync(item);
    });
  }
  empty = {
    emptyDirSync,
    emptydirSync: emptyDirSync,
    emptyDir,
    emptydir: emptyDir
  };
  return empty;
}

var file;
var hasRequiredFile;
function requireFile() {
  if (hasRequiredFile) return file;
  hasRequiredFile = 1;
  const u = requireUniversalify().fromPromise;
  const path = require$$1$1;
  const fs = /*@__PURE__*/requireFs$1();
  const mkdir = /*@__PURE__*/requireMkdirs();
  async function createFile(file) {
    let stats;
    try {
      stats = await fs.stat(file);
    } catch {}
    if (stats && stats.isFile()) return;
    const dir = path.dirname(file);
    let dirStats = null;
    try {
      dirStats = await fs.stat(dir);
    } catch (err) {
      // if the directory doesn't exist, make it
      if (err.code === 'ENOENT') {
        await mkdir.mkdirs(dir);
        await fs.writeFile(file, '');
        return;
      } else {
        throw err;
      }
    }
    if (dirStats.isDirectory()) {
      await fs.writeFile(file, '');
    } else {
      // parent is not a directory
      // This is just to cause an internal ENOTDIR error to be thrown
      await fs.readdir(dir);
    }
  }
  function createFileSync(file) {
    let stats;
    try {
      stats = fs.statSync(file);
    } catch {}
    if (stats && stats.isFile()) return;
    const dir = path.dirname(file);
    try {
      if (!fs.statSync(dir).isDirectory()) {
        // parent is not a directory
        // This is just to cause an internal ENOTDIR error to be thrown
        fs.readdirSync(dir);
      }
    } catch (err) {
      // If the stat call above failed because the directory doesn't exist, create it
      if (err && err.code === 'ENOENT') mkdir.mkdirsSync(dir);else throw err;
    }
    fs.writeFileSync(file, '');
  }
  file = {
    createFile: u(createFile),
    createFileSync
  };
  return file;
}

var link;
var hasRequiredLink;
function requireLink() {
  if (hasRequiredLink) return link;
  hasRequiredLink = 1;
  const u = requireUniversalify().fromPromise;
  const path = require$$1$1;
  const fs = /*@__PURE__*/requireFs$1();
  const mkdir = /*@__PURE__*/requireMkdirs();
  const {
    pathExists
  } = /*@__PURE__*/requirePathExists();
  const {
    areIdentical
  } = /*@__PURE__*/requireStat();
  async function createLink(srcpath, dstpath) {
    let dstStat;
    try {
      dstStat = await fs.lstat(dstpath);
    } catch {
      // ignore error
    }
    let srcStat;
    try {
      srcStat = await fs.lstat(srcpath);
    } catch (err) {
      err.message = err.message.replace('lstat', 'ensureLink');
      throw err;
    }
    if (dstStat && areIdentical(srcStat, dstStat)) return;
    const dir = path.dirname(dstpath);
    const dirExists = await pathExists(dir);
    if (!dirExists) {
      await mkdir.mkdirs(dir);
    }
    await fs.link(srcpath, dstpath);
  }
  function createLinkSync(srcpath, dstpath) {
    let dstStat;
    try {
      dstStat = fs.lstatSync(dstpath);
    } catch {}
    try {
      const srcStat = fs.lstatSync(srcpath);
      if (dstStat && areIdentical(srcStat, dstStat)) return;
    } catch (err) {
      err.message = err.message.replace('lstat', 'ensureLink');
      throw err;
    }
    const dir = path.dirname(dstpath);
    const dirExists = fs.existsSync(dir);
    if (dirExists) return fs.linkSync(srcpath, dstpath);
    mkdir.mkdirsSync(dir);
    return fs.linkSync(srcpath, dstpath);
  }
  link = {
    createLink: u(createLink),
    createLinkSync
  };
  return link;
}

var symlinkPaths_1;
var hasRequiredSymlinkPaths;
function requireSymlinkPaths() {
  if (hasRequiredSymlinkPaths) return symlinkPaths_1;
  hasRequiredSymlinkPaths = 1;
  const path = require$$1$1;
  const fs = /*@__PURE__*/requireFs$1();
  const {
    pathExists
  } = /*@__PURE__*/requirePathExists();
  const u = requireUniversalify().fromPromise;

  /**
   * Function that returns two types of paths, one relative to symlink, and one
   * relative to the current working directory. Checks if path is absolute or
   * relative. If the path is relative, this function checks if the path is
   * relative to symlink or relative to current working directory. This is an
   * initiative to find a smarter `srcpath` to supply when building symlinks.
   * This allows you to determine which path to use out of one of three possible
   * types of source paths. The first is an absolute path. This is detected by
   * `path.isAbsolute()`. When an absolute path is provided, it is checked to
   * see if it exists. If it does it's used, if not an error is returned
   * (callback)/ thrown (sync). The other two options for `srcpath` are a
   * relative url. By default Node's `fs.symlink` works by creating a symlink
   * using `dstpath` and expects the `srcpath` to be relative to the newly
   * created symlink. If you provide a `srcpath` that does not exist on the file
   * system it results in a broken symlink. To minimize this, the function
   * checks to see if the 'relative to symlink' source file exists, and if it
   * does it will use it. If it does not, it checks if there's a file that
   * exists that is relative to the current working directory, if does its used.
   * This preserves the expectations of the original fs.symlink spec and adds
   * the ability to pass in `relative to current working direcotry` paths.
   */

  async function symlinkPaths(srcpath, dstpath) {
    if (path.isAbsolute(srcpath)) {
      try {
        await fs.lstat(srcpath);
      } catch (err) {
        err.message = err.message.replace('lstat', 'ensureSymlink');
        throw err;
      }
      return {
        toCwd: srcpath,
        toDst: srcpath
      };
    }
    const dstdir = path.dirname(dstpath);
    const relativeToDst = path.join(dstdir, srcpath);
    const exists = await pathExists(relativeToDst);
    if (exists) {
      return {
        toCwd: relativeToDst,
        toDst: srcpath
      };
    }
    try {
      await fs.lstat(srcpath);
    } catch (err) {
      err.message = err.message.replace('lstat', 'ensureSymlink');
      throw err;
    }
    return {
      toCwd: srcpath,
      toDst: path.relative(dstdir, srcpath)
    };
  }
  function symlinkPathsSync(srcpath, dstpath) {
    if (path.isAbsolute(srcpath)) {
      const exists = fs.existsSync(srcpath);
      if (!exists) throw new Error('absolute srcpath does not exist');
      return {
        toCwd: srcpath,
        toDst: srcpath
      };
    }
    const dstdir = path.dirname(dstpath);
    const relativeToDst = path.join(dstdir, srcpath);
    const exists = fs.existsSync(relativeToDst);
    if (exists) {
      return {
        toCwd: relativeToDst,
        toDst: srcpath
      };
    }
    const srcExists = fs.existsSync(srcpath);
    if (!srcExists) throw new Error('relative srcpath does not exist');
    return {
      toCwd: srcpath,
      toDst: path.relative(dstdir, srcpath)
    };
  }
  symlinkPaths_1 = {
    symlinkPaths: u(symlinkPaths),
    symlinkPathsSync
  };
  return symlinkPaths_1;
}

var symlinkType_1;
var hasRequiredSymlinkType;
function requireSymlinkType() {
  if (hasRequiredSymlinkType) return symlinkType_1;
  hasRequiredSymlinkType = 1;
  const fs = /*@__PURE__*/requireFs$1();
  const u = requireUniversalify().fromPromise;
  async function symlinkType(srcpath, type) {
    if (type) return type;
    let stats;
    try {
      stats = await fs.lstat(srcpath);
    } catch {
      return 'file';
    }
    return stats && stats.isDirectory() ? 'dir' : 'file';
  }
  function symlinkTypeSync(srcpath, type) {
    if (type) return type;
    let stats;
    try {
      stats = fs.lstatSync(srcpath);
    } catch {
      return 'file';
    }
    return stats && stats.isDirectory() ? 'dir' : 'file';
  }
  symlinkType_1 = {
    symlinkType: u(symlinkType),
    symlinkTypeSync
  };
  return symlinkType_1;
}

var symlink;
var hasRequiredSymlink;
function requireSymlink() {
  if (hasRequiredSymlink) return symlink;
  hasRequiredSymlink = 1;
  const u = requireUniversalify().fromPromise;
  const path = require$$1$1;
  const fs = /*@__PURE__*/requireFs$1();
  const {
    mkdirs,
    mkdirsSync
  } = /*@__PURE__*/requireMkdirs();
  const {
    symlinkPaths,
    symlinkPathsSync
  } = /*@__PURE__*/requireSymlinkPaths();
  const {
    symlinkType,
    symlinkTypeSync
  } = /*@__PURE__*/requireSymlinkType();
  const {
    pathExists
  } = /*@__PURE__*/requirePathExists();
  const {
    areIdentical
  } = /*@__PURE__*/requireStat();
  async function createSymlink(srcpath, dstpath, type) {
    let stats;
    try {
      stats = await fs.lstat(dstpath);
    } catch {}
    if (stats && stats.isSymbolicLink()) {
      const [srcStat, dstStat] = await Promise.all([fs.stat(srcpath), fs.stat(dstpath)]);
      if (areIdentical(srcStat, dstStat)) return;
    }
    const relative = await symlinkPaths(srcpath, dstpath);
    srcpath = relative.toDst;
    const toType = await symlinkType(relative.toCwd, type);
    const dir = path.dirname(dstpath);
    if (!(await pathExists(dir))) {
      await mkdirs(dir);
    }
    return fs.symlink(srcpath, dstpath, toType);
  }
  function createSymlinkSync(srcpath, dstpath, type) {
    let stats;
    try {
      stats = fs.lstatSync(dstpath);
    } catch {}
    if (stats && stats.isSymbolicLink()) {
      const srcStat = fs.statSync(srcpath);
      const dstStat = fs.statSync(dstpath);
      if (areIdentical(srcStat, dstStat)) return;
    }
    const relative = symlinkPathsSync(srcpath, dstpath);
    srcpath = relative.toDst;
    type = symlinkTypeSync(relative.toCwd, type);
    const dir = path.dirname(dstpath);
    const exists = fs.existsSync(dir);
    if (exists) return fs.symlinkSync(srcpath, dstpath, type);
    mkdirsSync(dir);
    return fs.symlinkSync(srcpath, dstpath, type);
  }
  symlink = {
    createSymlink: u(createSymlink),
    createSymlinkSync
  };
  return symlink;
}

var ensure;
var hasRequiredEnsure;
function requireEnsure() {
  if (hasRequiredEnsure) return ensure;
  hasRequiredEnsure = 1;
  const {
    createFile,
    createFileSync
  } = /*@__PURE__*/requireFile();
  const {
    createLink,
    createLinkSync
  } = /*@__PURE__*/requireLink();
  const {
    createSymlink,
    createSymlinkSync
  } = /*@__PURE__*/requireSymlink();
  ensure = {
    // file
    createFile,
    createFileSync,
    ensureFile: createFile,
    ensureFileSync: createFileSync,
    // link
    createLink,
    createLinkSync,
    ensureLink: createLink,
    ensureLinkSync: createLinkSync,
    // symlink
    createSymlink,
    createSymlinkSync,
    ensureSymlink: createSymlink,
    ensureSymlinkSync: createSymlinkSync
  };
  return ensure;
}

var utils$5;
var hasRequiredUtils$5;
function requireUtils$5() {
  if (hasRequiredUtils$5) return utils$5;
  hasRequiredUtils$5 = 1;
  function stringify(obj, {
    EOL = '\n',
    finalEOL = true,
    replacer = null,
    spaces
  } = {}) {
    const EOF = finalEOL ? EOL : '';
    const str = JSON.stringify(obj, replacer, spaces);
    return str.replace(/\n/g, EOL) + EOF;
  }
  function stripBom(content) {
    // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified
    if (Buffer.isBuffer(content)) content = content.toString('utf8');
    return content.replace(/^\uFEFF/, '');
  }
  utils$5 = {
    stringify,
    stripBom
  };
  return utils$5;
}

var jsonfile_1;
var hasRequiredJsonfile$1;
function requireJsonfile$1() {
  if (hasRequiredJsonfile$1) return jsonfile_1;
  hasRequiredJsonfile$1 = 1;
  let _fs;
  try {
    _fs = requireGracefulFs();
  } catch (_) {
    _fs = require$$0$5;
  }
  const universalify = requireUniversalify();
  const {
    stringify,
    stripBom
  } = requireUtils$5();
  async function _readFile(file, options = {}) {
    if (typeof options === 'string') {
      options = {
        encoding: options
      };
    }
    const fs = options.fs || _fs;
    const shouldThrow = 'throws' in options ? options.throws : true;
    let data = await universalify.fromCallback(fs.readFile)(file, options);
    data = stripBom(data);
    let obj;
    try {
      obj = JSON.parse(data, options ? options.reviver : null);
    } catch (err) {
      if (shouldThrow) {
        err.message = `${file}: ${err.message}`;
        throw err;
      } else {
        return null;
      }
    }
    return obj;
  }
  const readFile = universalify.fromPromise(_readFile);
  function readFileSync(file, options = {}) {
    if (typeof options === 'string') {
      options = {
        encoding: options
      };
    }
    const fs = options.fs || _fs;
    const shouldThrow = 'throws' in options ? options.throws : true;
    try {
      let content = fs.readFileSync(file, options);
      content = stripBom(content);
      return JSON.parse(content, options.reviver);
    } catch (err) {
      if (shouldThrow) {
        err.message = `${file}: ${err.message}`;
        throw err;
      } else {
        return null;
      }
    }
  }
  async function _writeFile(file, obj, options = {}) {
    const fs = options.fs || _fs;
    const str = stringify(obj, options);
    await universalify.fromCallback(fs.writeFile)(file, str, options);
  }
  const writeFile = universalify.fromPromise(_writeFile);
  function writeFileSync(file, obj, options = {}) {
    const fs = options.fs || _fs;
    const str = stringify(obj, options);
    // not sure if fs.writeFileSync returns anything, but just in case
    return fs.writeFileSync(file, str, options);
  }
  const jsonfile = {
    readFile,
    readFileSync,
    writeFile,
    writeFileSync
  };
  jsonfile_1 = jsonfile;
  return jsonfile_1;
}

var jsonfile;
var hasRequiredJsonfile;
function requireJsonfile() {
  if (hasRequiredJsonfile) return jsonfile;
  hasRequiredJsonfile = 1;
  const jsonFile = requireJsonfile$1();
  jsonfile = {
    // jsonfile exports
    readJson: jsonFile.readFile,
    readJsonSync: jsonFile.readFileSync,
    writeJson: jsonFile.writeFile,
    writeJsonSync: jsonFile.writeFileSync
  };
  return jsonfile;
}

var outputFile_1;
var hasRequiredOutputFile;
function requireOutputFile() {
  if (hasRequiredOutputFile) return outputFile_1;
  hasRequiredOutputFile = 1;
  const u = requireUniversalify().fromPromise;
  const fs = /*@__PURE__*/requireFs$1();
  const path = require$$1$1;
  const mkdir = /*@__PURE__*/requireMkdirs();
  const pathExists = /*@__PURE__*/requirePathExists().pathExists;
  async function outputFile(file, data, encoding = 'utf-8') {
    const dir = path.dirname(file);
    if (!(await pathExists(dir))) {
      await mkdir.mkdirs(dir);
    }
    return fs.writeFile(file, data, encoding);
  }
  function outputFileSync(file, ...args) {
    const dir = path.dirname(file);
    if (!fs.existsSync(dir)) {
      mkdir.mkdirsSync(dir);
    }
    fs.writeFileSync(file, ...args);
  }
  outputFile_1 = {
    outputFile: u(outputFile),
    outputFileSync
  };
  return outputFile_1;
}

var outputJson_1;
var hasRequiredOutputJson;
function requireOutputJson() {
  if (hasRequiredOutputJson) return outputJson_1;
  hasRequiredOutputJson = 1;
  const {
    stringify
  } = requireUtils$5();
  const {
    outputFile
  } = /*@__PURE__*/requireOutputFile();
  async function outputJson(file, data, options = {}) {
    const str = stringify(data, options);
    await outputFile(file, str, options);
  }
  outputJson_1 = outputJson;
  return outputJson_1;
}

var outputJsonSync_1;
var hasRequiredOutputJsonSync;
function requireOutputJsonSync() {
  if (hasRequiredOutputJsonSync) return outputJsonSync_1;
  hasRequiredOutputJsonSync = 1;
  const {
    stringify
  } = requireUtils$5();
  const {
    outputFileSync
  } = /*@__PURE__*/requireOutputFile();
  function outputJsonSync(file, data, options) {
    const str = stringify(data, options);
    outputFileSync(file, str, options);
  }
  outputJsonSync_1 = outputJsonSync;
  return outputJsonSync_1;
}

var json;
var hasRequiredJson;
function requireJson() {
  if (hasRequiredJson) return json;
  hasRequiredJson = 1;
  const u = requireUniversalify().fromPromise;
  const jsonFile = /*@__PURE__*/requireJsonfile();
  jsonFile.outputJson = u(/*@__PURE__*/requireOutputJson());
  jsonFile.outputJsonSync = /*@__PURE__*/requireOutputJsonSync();
  // aliases
  jsonFile.outputJSON = jsonFile.outputJson;
  jsonFile.outputJSONSync = jsonFile.outputJsonSync;
  jsonFile.writeJSON = jsonFile.writeJson;
  jsonFile.writeJSONSync = jsonFile.writeJsonSync;
  jsonFile.readJSON = jsonFile.readJson;
  jsonFile.readJSONSync = jsonFile.readJsonSync;
  json = jsonFile;
  return json;
}

var move_1;
var hasRequiredMove$1;
function requireMove$1() {
  if (hasRequiredMove$1) return move_1;
  hasRequiredMove$1 = 1;
  const fs = /*@__PURE__*/requireFs$1();
  const path = require$$1$1;
  const {
    copy
  } = /*@__PURE__*/requireCopy();
  const {
    remove
  } = /*@__PURE__*/requireRemove();
  const {
    mkdirp
  } = /*@__PURE__*/requireMkdirs();
  const {
    pathExists
  } = /*@__PURE__*/requirePathExists();
  const stat = /*@__PURE__*/requireStat();
  async function move(src, dest, opts = {}) {
    const overwrite = opts.overwrite || opts.clobber || false;
    const {
      srcStat,
      isChangingCase = false
    } = await stat.checkPaths(src, dest, 'move', opts);
    await stat.checkParentPaths(src, srcStat, dest, 'move');

    // If the parent of dest is not root, make sure it exists before proceeding
    const destParent = path.dirname(dest);
    const parsedParentPath = path.parse(destParent);
    if (parsedParentPath.root !== destParent) {
      await mkdirp(destParent);
    }
    return doRename(src, dest, overwrite, isChangingCase);
  }
  async function doRename(src, dest, overwrite, isChangingCase) {
    if (!isChangingCase) {
      if (overwrite) {
        await remove(dest);
      } else if (await pathExists(dest)) {
        throw new Error('dest already exists.');
      }
    }
    try {
      // Try w/ rename first, and try copy + remove if EXDEV
      await fs.rename(src, dest);
    } catch (err) {
      if (err.code !== 'EXDEV') {
        throw err;
      }
      await moveAcrossDevice(src, dest, overwrite);
    }
  }
  async function moveAcrossDevice(src, dest, overwrite) {
    const opts = {
      overwrite,
      errorOnExist: true,
      preserveTimestamps: true
    };
    await copy(src, dest, opts);
    return remove(src);
  }
  move_1 = move;
  return move_1;
}

var moveSync_1;
var hasRequiredMoveSync;
function requireMoveSync() {
  if (hasRequiredMoveSync) return moveSync_1;
  hasRequiredMoveSync = 1;
  const fs = requireGracefulFs();
  const path = require$$1$1;
  const copySync = /*@__PURE__*/requireCopy().copySync;
  const removeSync = /*@__PURE__*/requireRemove().removeSync;
  const mkdirpSync = /*@__PURE__*/requireMkdirs().mkdirpSync;
  const stat = /*@__PURE__*/requireStat();
  function moveSync(src, dest, opts) {
    opts = opts || {};
    const overwrite = opts.overwrite || opts.clobber || false;
    const {
      srcStat,
      isChangingCase = false
    } = stat.checkPathsSync(src, dest, 'move', opts);
    stat.checkParentPathsSync(src, srcStat, dest, 'move');
    if (!isParentRoot(dest)) mkdirpSync(path.dirname(dest));
    return doRename(src, dest, overwrite, isChangingCase);
  }
  function isParentRoot(dest) {
    const parent = path.dirname(dest);
    const parsedPath = path.parse(parent);
    return parsedPath.root === parent;
  }
  function doRename(src, dest, overwrite, isChangingCase) {
    if (isChangingCase) return rename(src, dest, overwrite);
    if (overwrite) {
      removeSync(dest);
      return rename(src, dest, overwrite);
    }
    if (fs.existsSync(dest)) throw new Error('dest already exists.');
    return rename(src, dest, overwrite);
  }
  function rename(src, dest, overwrite) {
    try {
      fs.renameSync(src, dest);
    } catch (err) {
      if (err.code !== 'EXDEV') throw err;
      return moveAcrossDevice(src, dest, overwrite);
    }
  }
  function moveAcrossDevice(src, dest, overwrite) {
    const opts = {
      overwrite,
      errorOnExist: true,
      preserveTimestamps: true
    };
    copySync(src, dest, opts);
    return removeSync(src);
  }
  moveSync_1 = moveSync;
  return moveSync_1;
}

var move;
var hasRequiredMove;
function requireMove() {
  if (hasRequiredMove) return move;
  hasRequiredMove = 1;
  const u = requireUniversalify().fromPromise;
  move = {
    move: u(/*@__PURE__*/requireMove$1()),
    moveSync: /*@__PURE__*/requireMoveSync()
  };
  return move;
}

var lib$3;
var hasRequiredLib$3;
function requireLib$3() {
  if (hasRequiredLib$3) return lib$3;
  hasRequiredLib$3 = 1;
  lib$3 = {
    // Export promiseified graceful-fs:
    ... /*@__PURE__*/requireFs$1(),
    // Export extra methods:
    ... /*@__PURE__*/requireCopy(),
    ... /*@__PURE__*/requireEmpty(),
    ... /*@__PURE__*/requireEnsure(),
    ... /*@__PURE__*/requireJson(),
    ... /*@__PURE__*/requireMkdirs(),
    ... /*@__PURE__*/requireMove(),
    ... /*@__PURE__*/requireOutputFile(),
    ... /*@__PURE__*/requirePathExists(),
    ... /*@__PURE__*/requireRemove()
  };
  return lib$3;
}

var ejs = {};

var utils$4 = {};

/*
 * EJS Embedded JavaScript templates
 * Copyright 2112 Matthew Eernisse (mde@fleegix.org)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
*/
var hasRequiredUtils$4;
function requireUtils$4() {
  if (hasRequiredUtils$4) return utils$4;
  hasRequiredUtils$4 = 1;
  (function (exports) {

    var regExpChars = /[|\\{}()[\]^$+*?.]/g;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var hasOwn = function (obj, key) {
      return hasOwnProperty.apply(obj, [key]);
    };

    /**
     * Escape characters reserved in regular expressions.
     *
     * If `string` is `undefined` or `null`, the empty string is returned.
     *
     * @param {String} string Input string
     * @return {String} Escaped string
     * @static
     * @private
     */
    exports.escapeRegExpChars = function (string) {
      // istanbul ignore if
      if (!string) {
        return '';
      }
      return String(string).replace(regExpChars, '\\$&');
    };
    var _ENCODE_HTML_RULES = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&#34;',
      "'": '&#39;'
    };
    var _MATCH_HTML = /[&<>'"]/g;
    function encode_char(c) {
      return _ENCODE_HTML_RULES[c] || c;
    }

    /**
     * Stringified version of constants used by {@link module:utils.escapeXML}.
     *
     * It is used in the process of generating {@link ClientFunction}s.
     *
     * @readonly
     * @type {String}
     */

    var escapeFuncStr = 'var _ENCODE_HTML_RULES = {\n' + '      "&": "&amp;"\n' + '    , "<": "&lt;"\n' + '    , ">": "&gt;"\n' + '    , \'"\': "&#34;"\n' + '    , "\'": "&#39;"\n' + '    }\n' + '  , _MATCH_HTML = /[&<>\'"]/g;\n' + 'function encode_char(c) {\n' + '  return _ENCODE_HTML_RULES[c] || c;\n' + '};\n';

    /**
     * Escape characters reserved in XML.
     *
     * If `markup` is `undefined` or `null`, the empty string is returned.
     *
     * @implements {EscapeCallback}
     * @param {String} markup Input string
     * @return {String} Escaped string
     * @static
     * @private
     */

    exports.escapeXML = function (markup) {
      return markup == undefined ? '' : String(markup).replace(_MATCH_HTML, encode_char);
    };
    function escapeXMLToString() {
      return Function.prototype.toString.call(this) + ';\n' + escapeFuncStr;
    }
    try {
      if (typeof Object.defineProperty === 'function') {
        // If the Function prototype is frozen, the "toString" property is non-writable. This means that any objects which inherit this property
        // cannot have the property changed using an assignment. If using strict mode, attempting that will cause an error. If not using strict
        // mode, attempting that will be silently ignored.
        // However, we can still explicitly shadow the prototype's "toString" property by defining a new "toString" property on this object.
        Object.defineProperty(exports.escapeXML, 'toString', {
          value: escapeXMLToString
        });
      } else {
        // If Object.defineProperty() doesn't exist, attempt to shadow this property using the assignment operator.
        exports.escapeXML.toString = escapeXMLToString;
      }
    } catch (err) {
      console.warn('Unable to set escapeXML.toString (is the Function prototype frozen?)');
    }

    /**
     * Naive copy of properties from one object to another.
     * Does not recurse into non-scalar properties
     * Does not check to see if the property has a value before copying
     *
     * @param  {Object} to   Destination object
     * @param  {Object} from Source object
     * @return {Object}      Destination object
     * @static
     * @private
     */
    exports.shallowCopy = function (to, from) {
      from = from || {};
      if (to !== null && to !== undefined) {
        for (var p in from) {
          if (!hasOwn(from, p)) {
            continue;
          }
          if (p === '__proto__' || p === 'constructor') {
            continue;
          }
          to[p] = from[p];
        }
      }
      return to;
    };

    /**
     * Naive copy of a list of key names, from one object to another.
     * Only copies property if it is actually defined
     * Does not recurse into non-scalar properties
     *
     * @param  {Object} to   Destination object
     * @param  {Object} from Source object
     * @param  {Array} list List of properties to copy
     * @return {Object}      Destination object
     * @static
     * @private
     */
    exports.shallowCopyFromList = function (to, from, list) {
      list = list || [];
      from = from || {};
      if (to !== null && to !== undefined) {
        for (var i = 0; i < list.length; i++) {
          var p = list[i];
          if (typeof from[p] != 'undefined') {
            if (!hasOwn(from, p)) {
              continue;
            }
            if (p === '__proto__' || p === 'constructor') {
              continue;
            }
            to[p] = from[p];
          }
        }
      }
      return to;
    };

    /**
     * Simple in-process cache implementation. Does not implement limits of any
     * sort.
     *
     * @implements {Cache}
     * @static
     * @private
     */
    exports.cache = {
      _data: {},
      set: function (key, val) {
        this._data[key] = val;
      },
      get: function (key) {
        return this._data[key];
      },
      remove: function (key) {
        delete this._data[key];
      },
      reset: function () {
        this._data = {};
      }
    };

    /**
     * Transforms hyphen case variable into camel case.
     *
     * @param {String} string Hyphen case string
     * @return {String} Camel case string
     * @static
     * @private
     */
    exports.hyphenToCamel = function (str) {
      return str.replace(/-[a-z]/g, function (match) {
        return match[1].toUpperCase();
      });
    };

    /**
     * Returns a null-prototype object in runtimes that support it
     *
     * @return {Object} Object, prototype will be set to null where possible
     * @static
     * @private
     */
    exports.createNullProtoObjWherePossible = function () {
      if (typeof Object.create == 'function') {
        return function () {
          return Object.create(null);
        };
      }
      if (!({
        __proto__: null
      } instanceof Object)) {
        return function () {
          return {
            __proto__: null
          };
        };
      }
      // Not possible, just pass through
      return function () {
        return {};
      };
    }();
    exports.hasOwnOnlyObject = function (obj) {
      var o = exports.createNullProtoObjWherePossible();
      for (var p in obj) {
        if (hasOwn(obj, p)) {
          o[p] = obj[p];
        }
      }
      return o;
    };
  })(utils$4);
  return utils$4;
}

var name$2 = "ejs";
var description$2 = "Embedded JavaScript templates";
var keywords$2 = [
	"template",
	"engine",
	"ejs"
];
var version$2 = "3.1.10";
var author$2 = "Matthew Eernisse <mde@fleegix.org> (http://fleegix.org)";
var license$2 = "Apache-2.0";
var bin$2 = {
	ejs: "./bin/cli.js"
};
var main$2 = "./lib/ejs.js";
var jsdelivr = "ejs.min.js";
var unpkg = "ejs.min.js";
var repository$2 = {
	type: "git",
	url: "git://github.com/mde/ejs.git"
};
var bugs$1 = "https://github.com/mde/ejs/issues";
var homepage$1 = "https://github.com/mde/ejs";
var dependencies$2 = {
	jake: "^10.8.5"
};
var devDependencies$2 = {
	browserify: "^16.5.1",
	eslint: "^6.8.0",
	"git-directory-deploy": "^1.5.1",
	jsdoc: "^4.0.2",
	"lru-cache": "^4.0.1",
	mocha: "^10.2.0",
	"uglify-js": "^3.3.16"
};
var engines$2 = {
	node: ">=0.10.0"
};
var scripts$2 = {
	test: "npx jake test"
};
var require$$3$1 = {
	name: name$2,
	description: description$2,
	keywords: keywords$2,
	version: version$2,
	author: author$2,
	license: license$2,
	bin: bin$2,
	main: main$2,
	jsdelivr: jsdelivr,
	unpkg: unpkg,
	repository: repository$2,
	bugs: bugs$1,
	homepage: homepage$1,
	dependencies: dependencies$2,
	devDependencies: devDependencies$2,
	engines: engines$2,
	scripts: scripts$2
};

/*
 * EJS Embedded JavaScript templates
 * Copyright 2112 Matthew Eernisse (mde@fleegix.org)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
*/
var hasRequiredEjs;
function requireEjs() {
  if (hasRequiredEjs) return ejs;
  hasRequiredEjs = 1;
  (function (exports) {

    /**
     * @file Embedded JavaScript templating engine. {@link http://ejs.co}
     * @author Matthew Eernisse <mde@fleegix.org>
     * @author Tiancheng "Timothy" Gu <timothygu99@gmail.com>
     * @project EJS
     * @license {@link http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0}
     */

    /**
     * EJS internal functions.
     *
     * Technically this "module" lies in the same file as {@link module:ejs}, for
     * the sake of organization all the private functions re grouped into this
     * module.
     *
     * @module ejs-internal
     * @private
     */

    /**
     * Embedded JavaScript templating engine.
     *
     * @module ejs
     * @public
     */
    var fs = require$$0$5;
    var path = require$$1$1;
    var utils = requireUtils$4();
    var scopeOptionWarned = false;
    /** @type {string} */
    var _VERSION_STRING = require$$3$1.version;
    var _DEFAULT_OPEN_DELIMITER = '<';
    var _DEFAULT_CLOSE_DELIMITER = '>';
    var _DEFAULT_DELIMITER = '%';
    var _DEFAULT_LOCALS_NAME = 'locals';
    var _NAME = 'ejs';
    var _REGEX_STRING = '(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)';
    var _OPTS_PASSABLE_WITH_DATA = ['delimiter', 'scope', 'context', 'debug', 'compileDebug', 'client', '_with', 'rmWhitespace', 'strict', 'filename', 'async'];
    // We don't allow 'cache' option to be passed in the data obj for
    // the normal `render` call, but this is where Express 2 & 3 put it
    // so we make an exception for `renderFile`
    var _OPTS_PASSABLE_WITH_DATA_EXPRESS = _OPTS_PASSABLE_WITH_DATA.concat('cache');
    var _BOM = /^\uFEFF/;
    var _JS_IDENTIFIER = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/;

    /**
     * EJS template function cache. This can be a LRU object from lru-cache NPM
     * module. By default, it is {@link module:utils.cache}, a simple in-process
     * cache that grows continuously.
     *
     * @type {Cache}
     */

    exports.cache = utils.cache;

    /**
     * Custom file loader. Useful for template preprocessing or restricting access
     * to a certain part of the filesystem.
     *
     * @type {fileLoader}
     */

    exports.fileLoader = fs.readFileSync;

    /**
     * Name of the object containing the locals.
     *
     * This variable is overridden by {@link Options}`.localsName` if it is not
     * `undefined`.
     *
     * @type {String}
     * @public
     */

    exports.localsName = _DEFAULT_LOCALS_NAME;

    /**
     * Promise implementation -- defaults to the native implementation if available
     * This is mostly just for testability
     *
     * @type {PromiseConstructorLike}
     * @public
     */

    exports.promiseImpl = new Function('return this;')().Promise;

    /**
     * Get the path to the included file from the parent file path and the
     * specified path.
     *
     * @param {String}  name     specified path
     * @param {String}  filename parent file path
     * @param {Boolean} [isDir=false] whether the parent file path is a directory
     * @return {String}
     */
    exports.resolveInclude = function (name, filename, isDir) {
      var dirname = path.dirname;
      var extname = path.extname;
      var resolve = path.resolve;
      var includePath = resolve(isDir ? filename : dirname(filename), name);
      var ext = extname(name);
      if (!ext) {
        includePath += '.ejs';
      }
      return includePath;
    };

    /**
     * Try to resolve file path on multiple directories
     *
     * @param  {String}        name  specified path
     * @param  {Array<String>} paths list of possible parent directory paths
     * @return {String}
     */
    function resolvePaths(name, paths) {
      var filePath;
      if (paths.some(function (v) {
        filePath = exports.resolveInclude(name, v, true);
        return fs.existsSync(filePath);
      })) {
        return filePath;
      }
    }

    /**
     * Get the path to the included file by Options
     *
     * @param  {String}  path    specified path
     * @param  {Options} options compilation options
     * @return {String}
     */
    function getIncludePath(path, options) {
      var includePath;
      var filePath;
      var views = options.views;
      var match = /^[A-Za-z]+:\\|^\//.exec(path);

      // Abs path
      if (match && match.length) {
        path = path.replace(/^\/*/, '');
        if (Array.isArray(options.root)) {
          includePath = resolvePaths(path, options.root);
        } else {
          includePath = exports.resolveInclude(path, options.root || '/', true);
        }
      }
      // Relative paths
      else {
        // Look relative to a passed filename first
        if (options.filename) {
          filePath = exports.resolveInclude(path, options.filename);
          if (fs.existsSync(filePath)) {
            includePath = filePath;
          }
        }
        // Then look in any views directories
        if (!includePath && Array.isArray(views)) {
          includePath = resolvePaths(path, views);
        }
        if (!includePath && typeof options.includer !== 'function') {
          throw new Error('Could not find the include file "' + options.escapeFunction(path) + '"');
        }
      }
      return includePath;
    }

    /**
     * Get the template from a string or a file, either compiled on-the-fly or
     * read from cache (if enabled), and cache the template if needed.
     *
     * If `template` is not set, the file specified in `options.filename` will be
     * read.
     *
     * If `options.cache` is true, this function reads the file from
     * `options.filename` so it must be set prior to calling this function.
     *
     * @memberof module:ejs-internal
     * @param {Options} options   compilation options
     * @param {String} [template] template source
     * @return {(TemplateFunction|ClientFunction)}
     * Depending on the value of `options.client`, either type might be returned.
     * @static
     */

    function handleCache(options, template) {
      var func;
      var filename = options.filename;
      var hasTemplate = arguments.length > 1;
      if (options.cache) {
        if (!filename) {
          throw new Error('cache option requires a filename');
        }
        func = exports.cache.get(filename);
        if (func) {
          return func;
        }
        if (!hasTemplate) {
          template = fileLoader(filename).toString().replace(_BOM, '');
        }
      } else if (!hasTemplate) {
        // istanbul ignore if: should not happen at all
        if (!filename) {
          throw new Error('Internal EJS error: no file name or template ' + 'provided');
        }
        template = fileLoader(filename).toString().replace(_BOM, '');
      }
      func = exports.compile(template, options);
      if (options.cache) {
        exports.cache.set(filename, func);
      }
      return func;
    }

    /**
     * Try calling handleCache with the given options and data and call the
     * callback with the result. If an error occurs, call the callback with
     * the error. Used by renderFile().
     *
     * @memberof module:ejs-internal
     * @param {Options} options    compilation options
     * @param {Object} data        template data
     * @param {RenderFileCallback} cb callback
     * @static
     */

    function tryHandleCache(options, data, cb) {
      var result;
      if (!cb) {
        if (typeof exports.promiseImpl == 'function') {
          return new exports.promiseImpl(function (resolve, reject) {
            try {
              result = handleCache(options)(data);
              resolve(result);
            } catch (err) {
              reject(err);
            }
          });
        } else {
          throw new Error('Please provide a callback function');
        }
      } else {
        try {
          result = handleCache(options)(data);
        } catch (err) {
          return cb(err);
        }
        cb(null, result);
      }
    }

    /**
     * fileLoader is independent
     *
     * @param {String} filePath ejs file path.
     * @return {String} The contents of the specified file.
     * @static
     */

    function fileLoader(filePath) {
      return exports.fileLoader(filePath);
    }

    /**
     * Get the template function.
     *
     * If `options.cache` is `true`, then the template is cached.
     *
     * @memberof module:ejs-internal
     * @param {String}  path    path for the specified file
     * @param {Options} options compilation options
     * @return {(TemplateFunction|ClientFunction)}
     * Depending on the value of `options.client`, either type might be returned
     * @static
     */

    function includeFile(path, options) {
      var opts = utils.shallowCopy(utils.createNullProtoObjWherePossible(), options);
      opts.filename = getIncludePath(path, opts);
      if (typeof options.includer === 'function') {
        var includerResult = options.includer(path, opts.filename);
        if (includerResult) {
          if (includerResult.filename) {
            opts.filename = includerResult.filename;
          }
          if (includerResult.template) {
            return handleCache(opts, includerResult.template);
          }
        }
      }
      return handleCache(opts);
    }

    /**
     * Re-throw the given `err` in context to the `str` of ejs, `filename`, and
     * `lineno`.
     *
     * @implements {RethrowCallback}
     * @memberof module:ejs-internal
     * @param {Error}  err      Error object
     * @param {String} str      EJS source
     * @param {String} flnm     file name of the EJS file
     * @param {Number} lineno   line number of the error
     * @param {EscapeCallback} esc
     * @static
     */

    function rethrow(err, str, flnm, lineno, esc) {
      var lines = str.split('\n');
      var start = Math.max(lineno - 3, 0);
      var end = Math.min(lines.length, lineno + 3);
      var filename = esc(flnm);
      // Error context
      var context = lines.slice(start, end).map(function (line, i) {
        var curr = i + start + 1;
        return (curr == lineno ? ' >> ' : '    ') + curr + '| ' + line;
      }).join('\n');

      // Alter exception message
      err.path = filename;
      err.message = (filename || 'ejs') + ':' + lineno + '\n' + context + '\n\n' + err.message;
      throw err;
    }
    function stripSemi(str) {
      return str.replace(/;(\s*$)/, '$1');
    }

    /**
     * Compile the given `str` of ejs into a template function.
     *
     * @param {String}  template EJS template
     *
     * @param {Options} [opts] compilation options
     *
     * @return {(TemplateFunction|ClientFunction)}
     * Depending on the value of `opts.client`, either type might be returned.
     * Note that the return type of the function also depends on the value of `opts.async`.
     * @public
     */

    exports.compile = function compile(template, opts) {
      var templ;

      // v1 compat
      // 'scope' is 'context'
      // FIXME: Remove this in a future version
      if (opts && opts.scope) {
        if (!scopeOptionWarned) {
          console.warn('`scope` option is deprecated and will be removed in EJS 3');
          scopeOptionWarned = true;
        }
        if (!opts.context) {
          opts.context = opts.scope;
        }
        delete opts.scope;
      }
      templ = new Template(template, opts);
      return templ.compile();
    };

    /**
     * Render the given `template` of ejs.
     *
     * If you would like to include options but not data, you need to explicitly
     * call this function with `data` being an empty object or `null`.
     *
     * @param {String}   template EJS template
     * @param {Object}  [data={}] template data
     * @param {Options} [opts={}] compilation and rendering options
     * @return {(String|Promise<String>)}
     * Return value type depends on `opts.async`.
     * @public
     */

    exports.render = function (template, d, o) {
      var data = d || utils.createNullProtoObjWherePossible();
      var opts = o || utils.createNullProtoObjWherePossible();

      // No options object -- if there are optiony names
      // in the data, copy them to options
      if (arguments.length == 2) {
        utils.shallowCopyFromList(opts, data, _OPTS_PASSABLE_WITH_DATA);
      }
      return handleCache(opts, template)(data);
    };

    /**
     * Render an EJS file at the given `path` and callback `cb(err, str)`.
     *
     * If you would like to include options but not data, you need to explicitly
     * call this function with `data` being an empty object or `null`.
     *
     * @param {String}             path     path to the EJS file
     * @param {Object}            [data={}] template data
     * @param {Options}           [opts={}] compilation and rendering options
     * @param {RenderFileCallback} cb callback
     * @public
     */

    exports.renderFile = function () {
      var args = Array.prototype.slice.call(arguments);
      var filename = args.shift();
      var cb;
      var opts = {
        filename: filename
      };
      var data;
      var viewOpts;

      // Do we have a callback?
      if (typeof arguments[arguments.length - 1] == 'function') {
        cb = args.pop();
      }
      // Do we have data/opts?
      if (args.length) {
        // Should always have data obj
        data = args.shift();
        // Normal passed opts (data obj + opts obj)
        if (args.length) {
          // Use shallowCopy so we don't pollute passed in opts obj with new vals
          utils.shallowCopy(opts, args.pop());
        }
        // Special casing for Express (settings + opts-in-data)
        else {
          // Express 3 and 4
          if (data.settings) {
            // Pull a few things from known locations
            if (data.settings.views) {
              opts.views = data.settings.views;
            }
            if (data.settings['view cache']) {
              opts.cache = true;
            }
            // Undocumented after Express 2, but still usable, esp. for
            // items that are unsafe to be passed along with data, like `root`
            viewOpts = data.settings['view options'];
            if (viewOpts) {
              utils.shallowCopy(opts, viewOpts);
            }
          }
          // Express 2 and lower, values set in app.locals, or people who just
          // want to pass options in their data. NOTE: These values will override
          // anything previously set in settings  or settings['view options']
          utils.shallowCopyFromList(opts, data, _OPTS_PASSABLE_WITH_DATA_EXPRESS);
        }
        opts.filename = filename;
      } else {
        data = utils.createNullProtoObjWherePossible();
      }
      return tryHandleCache(opts, data, cb);
    };

    /**
     * Clear intermediate JavaScript cache. Calls {@link Cache#reset}.
     * @public
     */

    /**
     * EJS template class
     * @public
     */
    exports.Template = Template;
    exports.clearCache = function () {
      exports.cache.reset();
    };
    function Template(text, optsParam) {
      var opts = utils.hasOwnOnlyObject(optsParam);
      var options = utils.createNullProtoObjWherePossible();
      this.templateText = text;
      /** @type {string | null} */
      this.mode = null;
      this.truncate = false;
      this.currentLine = 1;
      this.source = '';
      options.client = opts.client || false;
      options.escapeFunction = opts.escape || opts.escapeFunction || utils.escapeXML;
      options.compileDebug = opts.compileDebug !== false;
      options.debug = !!opts.debug;
      options.filename = opts.filename;
      options.openDelimiter = opts.openDelimiter || exports.openDelimiter || _DEFAULT_OPEN_DELIMITER;
      options.closeDelimiter = opts.closeDelimiter || exports.closeDelimiter || _DEFAULT_CLOSE_DELIMITER;
      options.delimiter = opts.delimiter || exports.delimiter || _DEFAULT_DELIMITER;
      options.strict = opts.strict || false;
      options.context = opts.context;
      options.cache = opts.cache || false;
      options.rmWhitespace = opts.rmWhitespace;
      options.root = opts.root;
      options.includer = opts.includer;
      options.outputFunctionName = opts.outputFunctionName;
      options.localsName = opts.localsName || exports.localsName || _DEFAULT_LOCALS_NAME;
      options.views = opts.views;
      options.async = opts.async;
      options.destructuredLocals = opts.destructuredLocals;
      options.legacyInclude = typeof opts.legacyInclude != 'undefined' ? !!opts.legacyInclude : true;
      if (options.strict) {
        options._with = false;
      } else {
        options._with = typeof opts._with != 'undefined' ? opts._with : true;
      }
      this.opts = options;
      this.regex = this.createRegex();
    }
    Template.modes = {
      EVAL: 'eval',
      ESCAPED: 'escaped',
      RAW: 'raw',
      COMMENT: 'comment',
      LITERAL: 'literal'
    };
    Template.prototype = {
      createRegex: function () {
        var str = _REGEX_STRING;
        var delim = utils.escapeRegExpChars(this.opts.delimiter);
        var open = utils.escapeRegExpChars(this.opts.openDelimiter);
        var close = utils.escapeRegExpChars(this.opts.closeDelimiter);
        str = str.replace(/%/g, delim).replace(/</g, open).replace(/>/g, close);
        return new RegExp(str);
      },
      compile: function () {
        /** @type {string} */
        var src;
        /** @type {ClientFunction} */
        var fn;
        var opts = this.opts;
        var prepended = '';
        var appended = '';
        /** @type {EscapeCallback} */
        var escapeFn = opts.escapeFunction;
        /** @type {FunctionConstructor} */
        var ctor;
        /** @type {string} */
        var sanitizedFilename = opts.filename ? JSON.stringify(opts.filename) : 'undefined';
        if (!this.source) {
          this.generateSource();
          prepended += '  var __output = "";\n' + '  function __append(s) { if (s !== undefined && s !== null) __output += s }\n';
          if (opts.outputFunctionName) {
            if (!_JS_IDENTIFIER.test(opts.outputFunctionName)) {
              throw new Error('outputFunctionName is not a valid JS identifier.');
            }
            prepended += '  var ' + opts.outputFunctionName + ' = __append;' + '\n';
          }
          if (opts.localsName && !_JS_IDENTIFIER.test(opts.localsName)) {
            throw new Error('localsName is not a valid JS identifier.');
          }
          if (opts.destructuredLocals && opts.destructuredLocals.length) {
            var destructuring = '  var __locals = (' + opts.localsName + ' || {}),\n';
            for (var i = 0; i < opts.destructuredLocals.length; i++) {
              var name = opts.destructuredLocals[i];
              if (!_JS_IDENTIFIER.test(name)) {
                throw new Error('destructuredLocals[' + i + '] is not a valid JS identifier.');
              }
              if (i > 0) {
                destructuring += ',\n  ';
              }
              destructuring += name + ' = __locals.' + name;
            }
            prepended += destructuring + ';\n';
          }
          if (opts._with !== false) {
            prepended += '  with (' + opts.localsName + ' || {}) {' + '\n';
            appended += '  }' + '\n';
          }
          appended += '  return __output;' + '\n';
          this.source = prepended + this.source + appended;
        }
        if (opts.compileDebug) {
          src = 'var __line = 1' + '\n' + '  , __lines = ' + JSON.stringify(this.templateText) + '\n' + '  , __filename = ' + sanitizedFilename + ';' + '\n' + 'try {' + '\n' + this.source + '} catch (e) {' + '\n' + '  rethrow(e, __lines, __filename, __line, escapeFn);' + '\n' + '}' + '\n';
        } else {
          src = this.source;
        }
        if (opts.client) {
          src = 'escapeFn = escapeFn || ' + escapeFn.toString() + ';' + '\n' + src;
          if (opts.compileDebug) {
            src = 'rethrow = rethrow || ' + rethrow.toString() + ';' + '\n' + src;
          }
        }
        if (opts.strict) {
          src = '"use strict";\n' + src;
        }
        if (opts.debug) {
          console.log(src);
        }
        if (opts.compileDebug && opts.filename) {
          src = src + '\n' + '//# sourceURL=' + sanitizedFilename + '\n';
        }
        try {
          if (opts.async) {
            // Have to use generated function for this, since in envs without support,
            // it breaks in parsing
            try {
              ctor = new Function('return (async function(){}).constructor;')();
            } catch (e) {
              if (e instanceof SyntaxError) {
                throw new Error('This environment does not support async/await');
              } else {
                throw e;
              }
            }
          } else {
            ctor = Function;
          }
          fn = new ctor(opts.localsName + ', escapeFn, include, rethrow', src);
        } catch (e) {
          // istanbul ignore else
          if (e instanceof SyntaxError) {
            if (opts.filename) {
              e.message += ' in ' + opts.filename;
            }
            e.message += ' while compiling ejs\n\n';
            e.message += 'If the above error is not helpful, you may want to try EJS-Lint:\n';
            e.message += 'https://github.com/RyanZim/EJS-Lint';
            if (!opts.async) {
              e.message += '\n';
              e.message += 'Or, if you meant to create an async function, pass `async: true` as an option.';
            }
          }
          throw e;
        }

        // Return a callable function which will execute the function
        // created by the source-code, with the passed data as locals
        // Adds a local `include` function which allows full recursive include
        var returnedFn = opts.client ? fn : function anonymous(data) {
          var include = function (path, includeData) {
            var d = utils.shallowCopy(utils.createNullProtoObjWherePossible(), data);
            if (includeData) {
              d = utils.shallowCopy(d, includeData);
            }
            return includeFile(path, opts)(d);
          };
          return fn.apply(opts.context, [data || utils.createNullProtoObjWherePossible(), escapeFn, include, rethrow]);
        };
        if (opts.filename && typeof Object.defineProperty === 'function') {
          var filename = opts.filename;
          var basename = path.basename(filename, path.extname(filename));
          try {
            Object.defineProperty(returnedFn, 'name', {
              value: basename,
              writable: false,
              enumerable: false,
              configurable: true
            });
          } catch (e) {/* ignore */}
        }
        return returnedFn;
      },
      generateSource: function () {
        var opts = this.opts;
        if (opts.rmWhitespace) {
          // Have to use two separate replace here as `^` and `$` operators don't
          // work well with `\r` and empty lines don't work well with the `m` flag.
          this.templateText = this.templateText.replace(/[\r\n]+/g, '\n').replace(/^\s+|\s+$/gm, '');
        }

        // Slurp spaces and tabs before <%_ and after _%>
        this.templateText = this.templateText.replace(/[ \t]*<%_/gm, '<%_').replace(/_%>[ \t]*/gm, '_%>');
        var self = this;
        var matches = this.parseTemplateText();
        var d = this.opts.delimiter;
        var o = this.opts.openDelimiter;
        var c = this.opts.closeDelimiter;
        if (matches && matches.length) {
          matches.forEach(function (line, index) {
            var closing;
            // If this is an opening tag, check for closing tags
            // FIXME: May end up with some false positives here
            // Better to store modes as k/v with openDelimiter + delimiter as key
            // Then this can simply check against the map
            if (line.indexOf(o + d) === 0 // If it is a tag
            && line.indexOf(o + d + d) !== 0) {
              // and is not escaped
              closing = matches[index + 2];
              if (!(closing == d + c || closing == '-' + d + c || closing == '_' + d + c)) {
                throw new Error('Could not find matching close tag for "' + line + '".');
              }
            }
            self.scanLine(line);
          });
        }
      },
      parseTemplateText: function () {
        var str = this.templateText;
        var pat = this.regex;
        var result = pat.exec(str);
        var arr = [];
        var firstPos;
        while (result) {
          firstPos = result.index;
          if (firstPos !== 0) {
            arr.push(str.substring(0, firstPos));
            str = str.slice(firstPos);
          }
          arr.push(result[0]);
          str = str.slice(result[0].length);
          result = pat.exec(str);
        }
        if (str) {
          arr.push(str);
        }
        return arr;
      },
      _addOutput: function (line) {
        if (this.truncate) {
          // Only replace single leading linebreak in the line after
          // -%> tag -- this is the single, trailing linebreak
          // after the tag that the truncation mode replaces
          // Handle Win / Unix / old Mac linebreaks -- do the \r\n
          // combo first in the regex-or
          line = line.replace(/^(?:\r\n|\r|\n)/, '');
          this.truncate = false;
        }
        if (!line) {
          return line;
        }

        // Preserve literal slashes
        line = line.replace(/\\/g, '\\\\');

        // Convert linebreaks
        line = line.replace(/\n/g, '\\n');
        line = line.replace(/\r/g, '\\r');

        // Escape double-quotes
        // - this will be the delimiter during execution
        line = line.replace(/"/g, '\\"');
        this.source += '    ; __append("' + line + '")' + '\n';
      },
      scanLine: function (line) {
        var self = this;
        var d = this.opts.delimiter;
        var o = this.opts.openDelimiter;
        var c = this.opts.closeDelimiter;
        var newLineCount = 0;
        newLineCount = line.split('\n').length - 1;
        switch (line) {
          case o + d:
          case o + d + '_':
            this.mode = Template.modes.EVAL;
            break;
          case o + d + '=':
            this.mode = Template.modes.ESCAPED;
            break;
          case o + d + '-':
            this.mode = Template.modes.RAW;
            break;
          case o + d + '#':
            this.mode = Template.modes.COMMENT;
            break;
          case o + d + d:
            this.mode = Template.modes.LITERAL;
            this.source += '    ; __append("' + line.replace(o + d + d, o + d) + '")' + '\n';
            break;
          case d + d + c:
            this.mode = Template.modes.LITERAL;
            this.source += '    ; __append("' + line.replace(d + d + c, d + c) + '")' + '\n';
            break;
          case d + c:
          case '-' + d + c:
          case '_' + d + c:
            if (this.mode == Template.modes.LITERAL) {
              this._addOutput(line);
            }
            this.mode = null;
            this.truncate = line.indexOf('-') === 0 || line.indexOf('_') === 0;
            break;
          default:
            // In script mode, depends on type of tag
            if (this.mode) {
              // If '//' is found without a line break, add a line break.
              switch (this.mode) {
                case Template.modes.EVAL:
                case Template.modes.ESCAPED:
                case Template.modes.RAW:
                  if (line.lastIndexOf('//') > line.lastIndexOf('\n')) {
                    line += '\n';
                  }
              }
              switch (this.mode) {
                // Just executing code
                case Template.modes.EVAL:
                  this.source += '    ; ' + line + '\n';
                  break;
                // Exec, esc, and output
                case Template.modes.ESCAPED:
                  this.source += '    ; __append(escapeFn(' + stripSemi(line) + '))' + '\n';
                  break;
                // Exec and output
                case Template.modes.RAW:
                  this.source += '    ; __append(' + stripSemi(line) + ')' + '\n';
                  break;
                case Template.modes.COMMENT:
                  // Do nothing
                  break;
                // Literal <%% mode, append as raw output
                case Template.modes.LITERAL:
                  this._addOutput(line);
                  break;
              }
            }
            // In string mode, just add the output
            else {
              this._addOutput(line);
            }
        }
        if (self.opts.compileDebug && newLineCount) {
          this.currentLine += newLineCount;
          this.source += '    ; __line = ' + this.currentLine + '\n';
        }
      }
    };

    /**
     * Escape characters reserved in XML.
     *
     * This is simply an export of {@link module:utils.escapeXML}.
     *
     * If `markup` is `undefined` or `null`, the empty string is returned.
     *
     * @param {String} markup Input string
     * @return {String} Escaped string
     * @public
     * @func
     * */
    exports.escapeXML = utils.escapeXML;

    /**
     * Express.js support.
     *
     * This is an alias for {@link module:ejs.renderFile}, in order to support
     * Express.js out-of-the-box.
     *
     * @func
     */

    exports.__express = exports.renderFile;

    /**
     * Version of EJS.
     *
     * @readonly
     * @type {String}
     * @public
     */

    exports.VERSION = _VERSION_STRING;

    /**
     * Name for detection of EJS.
     *
     * @readonly
     * @type {String}
     * @public
     */

    exports.name = _NAME;

    /* istanbul ignore if */
    if (typeof window != 'undefined') {
      window.ejs = exports;
    }
  })(ejs);
  return ejs;
}

var htmlminifier = {};

var clean = {exports: {}};

var optimize$3;
var hasRequiredOptimize$3;
function requireOptimize$3() {
  if (hasRequiredOptimize$3) return optimize$3;
  hasRequiredOptimize$3 = 1;
  function level0Optimize(tokens) {
    // noop as level 0 means no optimizations!
    return tokens;
  }
  optimize$3 = level0Optimize;
  return optimize$3;
}

var shortenHex_1;
var hasRequiredShortenHex;
function requireShortenHex() {
  if (hasRequiredShortenHex) return shortenHex_1;
  hasRequiredShortenHex = 1;
  var COLORS = {
    aliceblue: '#f0f8ff',
    antiquewhite: '#faebd7',
    aqua: '#0ff',
    aquamarine: '#7fffd4',
    azure: '#f0ffff',
    beige: '#f5f5dc',
    bisque: '#ffe4c4',
    black: '#000',
    blanchedalmond: '#ffebcd',
    blue: '#00f',
    blueviolet: '#8a2be2',
    brown: '#a52a2a',
    burlywood: '#deb887',
    cadetblue: '#5f9ea0',
    chartreuse: '#7fff00',
    chocolate: '#d2691e',
    coral: '#ff7f50',
    cornflowerblue: '#6495ed',
    cornsilk: '#fff8dc',
    crimson: '#dc143c',
    cyan: '#0ff',
    darkblue: '#00008b',
    darkcyan: '#008b8b',
    darkgoldenrod: '#b8860b',
    darkgray: '#a9a9a9',
    darkgreen: '#006400',
    darkgrey: '#a9a9a9',
    darkkhaki: '#bdb76b',
    darkmagenta: '#8b008b',
    darkolivegreen: '#556b2f',
    darkorange: '#ff8c00',
    darkorchid: '#9932cc',
    darkred: '#8b0000',
    darksalmon: '#e9967a',
    darkseagreen: '#8fbc8f',
    darkslateblue: '#483d8b',
    darkslategray: '#2f4f4f',
    darkslategrey: '#2f4f4f',
    darkturquoise: '#00ced1',
    darkviolet: '#9400d3',
    deeppink: '#ff1493',
    deepskyblue: '#00bfff',
    dimgray: '#696969',
    dimgrey: '#696969',
    dodgerblue: '#1e90ff',
    firebrick: '#b22222',
    floralwhite: '#fffaf0',
    forestgreen: '#228b22',
    fuchsia: '#f0f',
    gainsboro: '#dcdcdc',
    ghostwhite: '#f8f8ff',
    gold: '#ffd700',
    goldenrod: '#daa520',
    gray: '#808080',
    green: '#008000',
    greenyellow: '#adff2f',
    grey: '#808080',
    honeydew: '#f0fff0',
    hotpink: '#ff69b4',
    indianred: '#cd5c5c',
    indigo: '#4b0082',
    ivory: '#fffff0',
    khaki: '#f0e68c',
    lavender: '#e6e6fa',
    lavenderblush: '#fff0f5',
    lawngreen: '#7cfc00',
    lemonchiffon: '#fffacd',
    lightblue: '#add8e6',
    lightcoral: '#f08080',
    lightcyan: '#e0ffff',
    lightgoldenrodyellow: '#fafad2',
    lightgray: '#d3d3d3',
    lightgreen: '#90ee90',
    lightgrey: '#d3d3d3',
    lightpink: '#ffb6c1',
    lightsalmon: '#ffa07a',
    lightseagreen: '#20b2aa',
    lightskyblue: '#87cefa',
    lightslategray: '#778899',
    lightslategrey: '#778899',
    lightsteelblue: '#b0c4de',
    lightyellow: '#ffffe0',
    lime: '#0f0',
    limegreen: '#32cd32',
    linen: '#faf0e6',
    magenta: '#ff00ff',
    maroon: '#800000',
    mediumaquamarine: '#66cdaa',
    mediumblue: '#0000cd',
    mediumorchid: '#ba55d3',
    mediumpurple: '#9370db',
    mediumseagreen: '#3cb371',
    mediumslateblue: '#7b68ee',
    mediumspringgreen: '#00fa9a',
    mediumturquoise: '#48d1cc',
    mediumvioletred: '#c71585',
    midnightblue: '#191970',
    mintcream: '#f5fffa',
    mistyrose: '#ffe4e1',
    moccasin: '#ffe4b5',
    navajowhite: '#ffdead',
    navy: '#000080',
    oldlace: '#fdf5e6',
    olive: '#808000',
    olivedrab: '#6b8e23',
    orange: '#ffa500',
    orangered: '#ff4500',
    orchid: '#da70d6',
    palegoldenrod: '#eee8aa',
    palegreen: '#98fb98',
    paleturquoise: '#afeeee',
    palevioletred: '#db7093',
    papayawhip: '#ffefd5',
    peachpuff: '#ffdab9',
    peru: '#cd853f',
    pink: '#ffc0cb',
    plum: '#dda0dd',
    powderblue: '#b0e0e6',
    purple: '#800080',
    rebeccapurple: '#663399',
    red: '#f00',
    rosybrown: '#bc8f8f',
    royalblue: '#4169e1',
    saddlebrown: '#8b4513',
    salmon: '#fa8072',
    sandybrown: '#f4a460',
    seagreen: '#2e8b57',
    seashell: '#fff5ee',
    sienna: '#a0522d',
    silver: '#c0c0c0',
    skyblue: '#87ceeb',
    slateblue: '#6a5acd',
    slategray: '#708090',
    slategrey: '#708090',
    snow: '#fffafa',
    springgreen: '#00ff7f',
    steelblue: '#4682b4',
    tan: '#d2b48c',
    teal: '#008080',
    thistle: '#d8bfd8',
    tomato: '#ff6347',
    turquoise: '#40e0d0',
    violet: '#ee82ee',
    wheat: '#f5deb3',
    white: '#fff',
    whitesmoke: '#f5f5f5',
    yellow: '#ff0',
    yellowgreen: '#9acd32'
  };
  var toHex = {};
  var toName = {};
  for (var name in COLORS) {
    var hex = COLORS[name];
    if (name.length < hex.length) {
      toName[hex] = name;
    } else {
      toHex[name] = hex;
    }
  }
  var toHexPattern = new RegExp('(^| |,|\\))(' + Object.keys(toHex).join('|') + ')( |,|\\)|$)', 'ig');
  var toNamePattern = new RegExp('(' + Object.keys(toName).join('|') + ')([^a-f0-9]|$)', 'ig');
  function hexConverter(match, prefix, colorValue, suffix) {
    return prefix + toHex[colorValue.toLowerCase()] + suffix;
  }
  function nameConverter(match, colorValue, suffix) {
    return toName[colorValue.toLowerCase()] + suffix;
  }
  function shortenHex(value) {
    var hasHex = value.indexOf('#') > -1;
    var shortened = value.replace(toHexPattern, hexConverter);
    if (shortened != value) {
      shortened = shortened.replace(toHexPattern, hexConverter);
    }
    return hasHex ? shortened.replace(toNamePattern, nameConverter) : shortened;
  }
  shortenHex_1 = shortenHex;
  return shortenHex_1;
}

var shortenHsl_1;
var hasRequiredShortenHsl;
function requireShortenHsl() {
  if (hasRequiredShortenHsl) return shortenHsl_1;
  hasRequiredShortenHsl = 1;
  // HSL to RGB converter. Both methods adapted from:
  // http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript

  function hslToRgb(h, s, l) {
    var r, g, b;

    // normalize hue orientation b/w 0 and 360 degrees
    h = h % 360;
    if (h < 0) h += 360;
    h = ~~h / 360;
    if (s < 0) s = 0;else if (s > 100) s = 100;
    s = ~~s / 100;
    if (l < 0) l = 0;else if (l > 100) l = 100;
    l = ~~l / 100;
    if (s === 0) {
      r = g = b = l; // achromatic
    } else {
      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var p = 2 * l - q;
      r = hueToRgb(p, q, h + 1 / 3);
      g = hueToRgb(p, q, h);
      b = hueToRgb(p, q, h - 1 / 3);
    }
    return [~~(r * 255), ~~(g * 255), ~~(b * 255)];
  }
  function hueToRgb(p, q, t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p + (q - p) * 6 * t;
    if (t < 1 / 2) return q;
    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
    return p;
  }
  function shortenHsl(hue, saturation, lightness) {
    var asRgb = hslToRgb(hue, saturation, lightness);
    var redAsHex = asRgb[0].toString(16);
    var greenAsHex = asRgb[1].toString(16);
    var blueAsHex = asRgb[2].toString(16);
    return '#' + ((redAsHex.length == 1 ? '0' : '') + redAsHex) + ((greenAsHex.length == 1 ? '0' : '') + greenAsHex) + ((blueAsHex.length == 1 ? '0' : '') + blueAsHex);
  }
  shortenHsl_1 = shortenHsl;
  return shortenHsl_1;
}

var shortenRgb_1;
var hasRequiredShortenRgb;
function requireShortenRgb() {
  if (hasRequiredShortenRgb) return shortenRgb_1;
  hasRequiredShortenRgb = 1;
  function shortenRgb(red, green, blue) {
    var normalizedRed = Math.max(0, Math.min(parseInt(red), 255));
    var normalizedGreen = Math.max(0, Math.min(parseInt(green), 255));
    var normalizedBlue = Math.max(0, Math.min(parseInt(blue), 255));

    // Credit: Asen  http://jsbin.com/UPUmaGOc/2/edit?js,console
    return '#' + ('00000' + (normalizedRed << 16 | normalizedGreen << 8 | normalizedBlue).toString(16)).slice(-6);
  }
  shortenRgb_1 = shortenRgb;
  return shortenRgb_1;
}

var naturalCompare_1;
var hasRequiredNaturalCompare;
function requireNaturalCompare() {
  if (hasRequiredNaturalCompare) return naturalCompare_1;
  hasRequiredNaturalCompare = 1;
  // adapted from http://nedbatchelder.com/blog/200712.html#e20071211T054956

  var NUMBER_PATTERN = /([0-9]+)/;
  function naturalCompare(value1, value2) {
    var keys1 = ('' + value1).split(NUMBER_PATTERN).map(tryParseInt);
    var keys2 = ('' + value2).split(NUMBER_PATTERN).map(tryParseInt);
    var key1;
    var key2;
    var compareFirst = Math.min(keys1.length, keys2.length);
    var i, l;
    for (i = 0, l = compareFirst; i < l; i++) {
      key1 = keys1[i];
      key2 = keys2[i];
      if (key1 != key2) {
        return key1 > key2 ? 1 : -1;
      }
    }
    return keys1.length > keys2.length ? 1 : keys1.length == keys2.length ? 0 : -1;
  }
  function tryParseInt(value) {
    return '' + parseInt(value) == value ? parseInt(value) : value;
  }
  naturalCompare_1 = naturalCompare;
  return naturalCompare_1;
}

var sortSelectors_1;
var hasRequiredSortSelectors;
function requireSortSelectors() {
  if (hasRequiredSortSelectors) return sortSelectors_1;
  hasRequiredSortSelectors = 1;
  var naturalCompare = requireNaturalCompare();
  function naturalSorter(scope1, scope2) {
    return naturalCompare(scope1[1], scope2[1]);
  }
  function standardSorter(scope1, scope2) {
    return scope1[1] > scope2[1] ? 1 : -1;
  }
  function sortSelectors(selectors, method) {
    switch (method) {
      case 'natural':
        return selectors.sort(naturalSorter);
      case 'standard':
        return selectors.sort(standardSorter);
      case 'none':
      case false:
        return selectors;
    }
  }
  sortSelectors_1 = sortSelectors;
  return sortSelectors_1;
}

var override_1;
var hasRequiredOverride;
function requireOverride() {
  if (hasRequiredOverride) return override_1;
  hasRequiredOverride = 1;
  function override(source1, source2) {
    var target = {};
    var key1;
    var key2;
    var item;
    for (key1 in source1) {
      item = source1[key1];
      if (Array.isArray(item)) {
        target[key1] = item.slice(0);
      } else if (typeof item == 'object' && item !== null) {
        target[key1] = override(item, {});
      } else {
        target[key1] = item;
      }
    }
    for (key2 in source2) {
      item = source2[key2];
      if (key2 in target && Array.isArray(item)) {
        target[key2] = item.slice(0);
      } else if (key2 in target && typeof item == 'object' && item !== null) {
        target[key2] = override(target[key2], item);
      } else {
        target[key2] = item;
      }
    }
    return target;
  }
  override_1 = override;
  return override_1;
}

var format$1;
var hasRequiredFormat$1;
function requireFormat$1() {
  if (hasRequiredFormat$1) return format$1;
  hasRequiredFormat$1 = 1;
  var systemLineBreak = require$$0$6.EOL;
  var override = requireOverride();
  var Breaks = {
    AfterAtRule: 'afterAtRule',
    AfterBlockBegins: 'afterBlockBegins',
    AfterBlockEnds: 'afterBlockEnds',
    AfterComment: 'afterComment',
    AfterProperty: 'afterProperty',
    AfterRuleBegins: 'afterRuleBegins',
    AfterRuleEnds: 'afterRuleEnds',
    BeforeBlockEnds: 'beforeBlockEnds',
    BetweenSelectors: 'betweenSelectors'
  };
  var BreakWith = {
    CarriageReturnLineFeed: '\r\n',
    LineFeed: '\n',
    System: systemLineBreak
  };
  var IndentWith = {
    Space: ' ',
    Tab: '\t'
  };
  var Spaces = {
    AroundSelectorRelation: 'aroundSelectorRelation',
    BeforeBlockBegins: 'beforeBlockBegins',
    BeforeValue: 'beforeValue'
  };
  var DEFAULTS = {
    breaks: breaks(false),
    breakWith: BreakWith.System,
    indentBy: 0,
    indentWith: IndentWith.Space,
    spaces: spaces(false),
    wrapAt: false,
    semicolonAfterLastProperty: false
  };
  var BEAUTIFY_ALIAS = 'beautify';
  var KEEP_BREAKS_ALIAS = 'keep-breaks';
  var OPTION_SEPARATOR = ';';
  var OPTION_NAME_VALUE_SEPARATOR = ':';
  var HASH_VALUES_OPTION_SEPARATOR = ',';
  var HASH_VALUES_NAME_VALUE_SEPARATOR = '=';
  var FALSE_KEYWORD_1 = 'false';
  var FALSE_KEYWORD_2 = 'off';
  var TRUE_KEYWORD_1 = 'true';
  var TRUE_KEYWORD_2 = 'on';
  function breaks(value) {
    var breakOptions = {};
    breakOptions[Breaks.AfterAtRule] = value;
    breakOptions[Breaks.AfterBlockBegins] = value;
    breakOptions[Breaks.AfterBlockEnds] = value;
    breakOptions[Breaks.AfterComment] = value;
    breakOptions[Breaks.AfterProperty] = value;
    breakOptions[Breaks.AfterRuleBegins] = value;
    breakOptions[Breaks.AfterRuleEnds] = value;
    breakOptions[Breaks.BeforeBlockEnds] = value;
    breakOptions[Breaks.BetweenSelectors] = value;
    return breakOptions;
  }
  function spaces(value) {
    var spaceOptions = {};
    spaceOptions[Spaces.AroundSelectorRelation] = value;
    spaceOptions[Spaces.BeforeBlockBegins] = value;
    spaceOptions[Spaces.BeforeValue] = value;
    return spaceOptions;
  }
  function formatFrom(source) {
    if (source === undefined || source === false) {
      return false;
    }
    if (typeof source == 'object' && 'breakWith' in source) {
      source = override(source, {
        breakWith: mapBreakWith(source.breakWith)
      });
    }
    if (typeof source == 'object' && 'indentBy' in source) {
      source = override(source, {
        indentBy: parseInt(source.indentBy)
      });
    }
    if (typeof source == 'object' && 'indentWith' in source) {
      source = override(source, {
        indentWith: mapIndentWith(source.indentWith)
      });
    }
    if (typeof source == 'object') {
      return override(DEFAULTS, source);
    }
    if (typeof source == 'object') {
      return override(DEFAULTS, source);
    }
    if (typeof source == 'string' && source == BEAUTIFY_ALIAS) {
      return override(DEFAULTS, {
        breaks: breaks(true),
        indentBy: 2,
        spaces: spaces(true)
      });
    }
    if (typeof source == 'string' && source == KEEP_BREAKS_ALIAS) {
      return override(DEFAULTS, {
        breaks: {
          afterAtRule: true,
          afterBlockBegins: true,
          afterBlockEnds: true,
          afterComment: true,
          afterRuleEnds: true,
          beforeBlockEnds: true
        }
      });
    }
    if (typeof source == 'string') {
      return override(DEFAULTS, toHash(source));
    }
    return DEFAULTS;
  }
  function toHash(string) {
    return string.split(OPTION_SEPARATOR).reduce(function (accumulator, directive) {
      var parts = directive.split(OPTION_NAME_VALUE_SEPARATOR);
      var name = parts[0];
      var value = parts[1];
      if (name == 'breaks' || name == 'spaces') {
        accumulator[name] = hashValuesToHash(value);
      } else if (name == 'indentBy' || name == 'wrapAt') {
        accumulator[name] = parseInt(value);
      } else if (name == 'indentWith') {
        accumulator[name] = mapIndentWith(value);
      } else if (name == 'breakWith') {
        accumulator[name] = mapBreakWith(value);
      }
      return accumulator;
    }, {});
  }
  function hashValuesToHash(string) {
    return string.split(HASH_VALUES_OPTION_SEPARATOR).reduce(function (accumulator, directive) {
      var parts = directive.split(HASH_VALUES_NAME_VALUE_SEPARATOR);
      var name = parts[0];
      var value = parts[1];
      accumulator[name] = normalizeValue(value);
      return accumulator;
    }, {});
  }
  function normalizeValue(value) {
    switch (value) {
      case FALSE_KEYWORD_1:
      case FALSE_KEYWORD_2:
        return false;
      case TRUE_KEYWORD_1:
      case TRUE_KEYWORD_2:
        return true;
      default:
        return value;
    }
  }
  function mapBreakWith(value) {
    switch (value) {
      case 'windows':
      case 'crlf':
      case BreakWith.CarriageReturnLineFeed:
        return BreakWith.CarriageReturnLineFeed;
      case 'unix':
      case 'lf':
      case BreakWith.LineFeed:
        return BreakWith.LineFeed;
      default:
        return systemLineBreak;
    }
  }
  function mapIndentWith(value) {
    switch (value) {
      case 'space':
        return IndentWith.Space;
      case 'tab':
        return IndentWith.Tab;
      default:
        return value;
    }
  }
  format$1 = {
    Breaks: Breaks,
    Spaces: Spaces,
    formatFrom: formatFrom
  };
  return format$1;
}

var marker;
var hasRequiredMarker;
function requireMarker() {
  if (hasRequiredMarker) return marker;
  hasRequiredMarker = 1;
  var Marker = {
    ASTERISK: '*',
    AT: '@',
    BACK_SLASH: '\\',
    CARRIAGE_RETURN: '\r',
    CLOSE_CURLY_BRACKET: '}',
    CLOSE_ROUND_BRACKET: ')',
    CLOSE_SQUARE_BRACKET: ']',
    COLON: ':',
    COMMA: ',',
    DOUBLE_QUOTE: '"',
    EXCLAMATION: '!',
    FORWARD_SLASH: '/',
    INTERNAL: '-clean-css-',
    NEW_LINE_NIX: '\n',
    OPEN_CURLY_BRACKET: '{',
    OPEN_ROUND_BRACKET: '(',
    OPEN_SQUARE_BRACKET: '[',
    SEMICOLON: ';',
    SINGLE_QUOTE: '\'',
    SPACE: ' ',
    TAB: '\t',
    UNDERSCORE: '_'
  };
  marker = Marker;
  return marker;
}

var formatPosition_1;
var hasRequiredFormatPosition;
function requireFormatPosition() {
  if (hasRequiredFormatPosition) return formatPosition_1;
  hasRequiredFormatPosition = 1;
  function formatPosition(metadata) {
    var line = metadata[0];
    var column = metadata[1];
    var source = metadata[2];
    return source ? source + ':' + line + ':' + column : line + ':' + column;
  }
  formatPosition_1 = formatPosition;
  return formatPosition_1;
}

var tidyRules_1;
var hasRequiredTidyRules;
function requireTidyRules() {
  if (hasRequiredTidyRules) return tidyRules_1;
  hasRequiredTidyRules = 1;
  var Spaces = requireFormat$1().Spaces;
  var Marker = requireMarker();
  var formatPosition = requireFormatPosition();
  var CASE_ATTRIBUTE_PATTERN = /[\s"'][iI]\s*\]/;
  var CASE_RESTORE_PATTERN = /([\d\w])([iI])\]/g;
  var DOUBLE_QUOTE_CASE_PATTERN = /="([a-zA-Z][a-zA-Z\d\-_]+)"([iI])/g;
  var DOUBLE_QUOTE_PATTERN = /="([a-zA-Z][a-zA-Z\d\-_]+)"(\s|\])/g;
  var HTML_COMMENT_PATTERN = /^(?:(?:<!--|-->)\s*)+/;
  var SINGLE_QUOTE_CASE_PATTERN = /='([a-zA-Z][a-zA-Z\d\-_]+)'([iI])/g;
  var SINGLE_QUOTE_PATTERN = /='([a-zA-Z][a-zA-Z\d\-_]+)'(\s|\])/g;
  var RELATION_PATTERN = /[>\+~]/;
  var WHITESPACE_PATTERN = /\s/;
  var ASTERISK_PLUS_HTML_HACK = '*+html ';
  var ASTERISK_FIRST_CHILD_PLUS_HTML_HACK = '*:first-child+html ';
  var LESS_THAN = '<';
  function hasInvalidCharacters(value) {
    var isEscaped;
    var isInvalid = false;
    var character;
    var isQuote = false;
    var i, l;
    for (i = 0, l = value.length; i < l; i++) {
      character = value[i];
      if (isEscaped) ; else if (character == Marker.SINGLE_QUOTE || character == Marker.DOUBLE_QUOTE) {
        isQuote = !isQuote;
      } else if (!isQuote && (character == Marker.CLOSE_CURLY_BRACKET || character == Marker.EXCLAMATION || character == LESS_THAN || character == Marker.SEMICOLON)) {
        isInvalid = true;
        break;
      } else if (!isQuote && i === 0 && RELATION_PATTERN.test(character)) {
        isInvalid = true;
        break;
      }
      isEscaped = character == Marker.BACK_SLASH;
    }
    return isInvalid;
  }
  function removeWhitespace(value, format) {
    var stripped = [];
    var character;
    var isNewLineNix;
    var isNewLineWin;
    var isEscaped;
    var wasEscaped;
    var isQuoted;
    var isSingleQuoted;
    var isDoubleQuoted;
    var isAttribute;
    var isRelation;
    var isWhitespace;
    var roundBracketLevel = 0;
    var wasRelation = false;
    var wasWhitespace = false;
    var withCaseAttribute = CASE_ATTRIBUTE_PATTERN.test(value);
    var spaceAroundRelation = format && format.spaces[Spaces.AroundSelectorRelation];
    var i, l;
    for (i = 0, l = value.length; i < l; i++) {
      character = value[i];
      isNewLineNix = character == Marker.NEW_LINE_NIX;
      isNewLineWin = character == Marker.NEW_LINE_NIX && value[i - 1] == Marker.CARRIAGE_RETURN;
      isQuoted = isSingleQuoted || isDoubleQuoted;
      isRelation = !isAttribute && !isEscaped && roundBracketLevel === 0 && RELATION_PATTERN.test(character);
      isWhitespace = WHITESPACE_PATTERN.test(character);
      if (wasEscaped && isQuoted && isNewLineWin) {
        // swallow escaped new windows lines in comments
        stripped.pop();
        stripped.pop();
      } else if (isEscaped && isQuoted && isNewLineNix) {
        // swallow escaped new *nix lines in comments
        stripped.pop();
      } else if (isEscaped) {
        stripped.push(character);
      } else if (character == Marker.OPEN_SQUARE_BRACKET && !isQuoted) {
        stripped.push(character);
        isAttribute = true;
      } else if (character == Marker.CLOSE_SQUARE_BRACKET && !isQuoted) {
        stripped.push(character);
        isAttribute = false;
      } else if (character == Marker.OPEN_ROUND_BRACKET && !isQuoted) {
        stripped.push(character);
        roundBracketLevel++;
      } else if (character == Marker.CLOSE_ROUND_BRACKET && !isQuoted) {
        stripped.push(character);
        roundBracketLevel--;
      } else if (character == Marker.SINGLE_QUOTE && !isQuoted) {
        stripped.push(character);
        isSingleQuoted = true;
      } else if (character == Marker.DOUBLE_QUOTE && !isQuoted) {
        stripped.push(character);
        isDoubleQuoted = true;
      } else if (character == Marker.SINGLE_QUOTE && isQuoted) {
        stripped.push(character);
        isSingleQuoted = false;
      } else if (character == Marker.DOUBLE_QUOTE && isQuoted) {
        stripped.push(character);
        isDoubleQuoted = false;
      } else if (isWhitespace && wasRelation && !spaceAroundRelation) {
        continue;
      } else if (!isWhitespace && wasRelation && spaceAroundRelation) {
        stripped.push(Marker.SPACE);
        stripped.push(character);
      } else if (isWhitespace && (isAttribute || roundBracketLevel > 0) && !isQuoted) ; else if (isWhitespace && wasWhitespace && !isQuoted) ; else if ((isNewLineWin || isNewLineNix) && (isAttribute || roundBracketLevel > 0) && isQuoted) ; else if (isRelation && wasWhitespace && !spaceAroundRelation) {
        stripped.pop();
        stripped.push(character);
      } else if (isRelation && !wasWhitespace && spaceAroundRelation) {
        stripped.push(Marker.SPACE);
        stripped.push(character);
      } else if (isWhitespace) {
        stripped.push(Marker.SPACE);
      } else {
        stripped.push(character);
      }
      wasEscaped = isEscaped;
      isEscaped = character == Marker.BACK_SLASH;
      wasRelation = isRelation;
      wasWhitespace = isWhitespace;
    }
    return withCaseAttribute ? stripped.join('').replace(CASE_RESTORE_PATTERN, '$1 $2]') : stripped.join('');
  }
  function removeQuotes(value) {
    if (value.indexOf('\'') == -1 && value.indexOf('"') == -1) {
      return value;
    }
    return value.replace(SINGLE_QUOTE_CASE_PATTERN, '=$1 $2').replace(SINGLE_QUOTE_PATTERN, '=$1$2').replace(DOUBLE_QUOTE_CASE_PATTERN, '=$1 $2').replace(DOUBLE_QUOTE_PATTERN, '=$1$2');
  }
  function tidyRules(rules, removeUnsupported, adjacentSpace, format, warnings) {
    var list = [];
    var repeated = [];
    function removeHTMLComment(rule, match) {
      warnings.push('HTML comment \'' + match + '\' at ' + formatPosition(rule[2][0]) + '. Removing.');
      return '';
    }
    for (var i = 0, l = rules.length; i < l; i++) {
      var rule = rules[i];
      var reduced = rule[1];
      reduced = reduced.replace(HTML_COMMENT_PATTERN, removeHTMLComment.bind(null, rule));
      if (hasInvalidCharacters(reduced)) {
        warnings.push('Invalid selector \'' + rule[1] + '\' at ' + formatPosition(rule[2][0]) + '. Ignoring.');
        continue;
      }
      reduced = removeWhitespace(reduced, format);
      reduced = removeQuotes(reduced);
      if (adjacentSpace && reduced.indexOf('nav') > 0) {
        reduced = reduced.replace(/\+nav(\S|$)/, '+ nav$1');
      }
      if (removeUnsupported && reduced.indexOf(ASTERISK_PLUS_HTML_HACK) > -1) {
        continue;
      }
      if (removeUnsupported && reduced.indexOf(ASTERISK_FIRST_CHILD_PLUS_HTML_HACK) > -1) {
        continue;
      }
      if (reduced.indexOf('*') > -1) {
        reduced = reduced.replace(/\*([:#\.\[])/g, '$1').replace(/^(\:first\-child)?\+html/, '*$1+html');
      }
      if (repeated.indexOf(reduced) > -1) {
        continue;
      }
      rule[1] = reduced;
      repeated.push(reduced);
      list.push(rule);
    }
    if (list.length == 1 && list[0][1].length === 0) {
      warnings.push('Empty selector \'' + list[0][1] + '\' at ' + formatPosition(list[0][2][0]) + '. Ignoring.');
      list = [];
    }
    return list;
  }
  tidyRules_1 = tidyRules;
  return tidyRules_1;
}

var tidyBlock_1;
var hasRequiredTidyBlock;
function requireTidyBlock() {
  if (hasRequiredTidyBlock) return tidyBlock_1;
  hasRequiredTidyBlock = 1;
  var SUPPORTED_COMPACT_BLOCK_MATCHER = /^@media\W/;
  function tidyBlock(values, spaceAfterClosingBrace) {
    var withoutSpaceAfterClosingBrace;
    var i;
    for (i = values.length - 1; i >= 0; i--) {
      withoutSpaceAfterClosingBrace = !spaceAfterClosingBrace && SUPPORTED_COMPACT_BLOCK_MATCHER.test(values[i][1]);
      values[i][1] = values[i][1].replace(/\n|\r\n/g, ' ').replace(/\s+/g, ' ').replace(/(,|:|\() /g, '$1').replace(/ \)/g, ')').replace(/'([a-zA-Z][a-zA-Z\d\-_]+)'/, '$1').replace(/"([a-zA-Z][a-zA-Z\d\-_]+)"/, '$1').replace(withoutSpaceAfterClosingBrace ? /\) /g : null, ')');
    }
    return values;
  }
  tidyBlock_1 = tidyBlock;
  return tidyBlock_1;
}

var tidyAtRule_1;
var hasRequiredTidyAtRule;
function requireTidyAtRule() {
  if (hasRequiredTidyAtRule) return tidyAtRule_1;
  hasRequiredTidyAtRule = 1;
  function tidyAtRule(value) {
    return value.replace(/\s+/g, ' ').replace(/url\(\s+/g, 'url(').replace(/\s+\)/g, ')').trim();
  }
  tidyAtRule_1 = tidyAtRule;
  return tidyAtRule_1;
}

var hack;
var hasRequiredHack;
function requireHack() {
  if (hasRequiredHack) return hack;
  hasRequiredHack = 1;
  var Hack = {
    ASTERISK: 'asterisk',
    BANG: 'bang',
    BACKSLASH: 'backslash',
    UNDERSCORE: 'underscore'
  };
  hack = Hack;
  return hack;
}

var removeUnused_1;
var hasRequiredRemoveUnused;
function requireRemoveUnused() {
  if (hasRequiredRemoveUnused) return removeUnused_1;
  hasRequiredRemoveUnused = 1;
  function removeUnused(properties) {
    for (var i = properties.length - 1; i >= 0; i--) {
      var property = properties[i];
      if (property.unused) {
        property.all.splice(property.position, 1);
      }
    }
  }
  removeUnused_1 = removeUnused;
  return removeUnused_1;
}

var restoreFromOptimizing_1;
var hasRequiredRestoreFromOptimizing;
function requireRestoreFromOptimizing() {
  if (hasRequiredRestoreFromOptimizing) return restoreFromOptimizing_1;
  hasRequiredRestoreFromOptimizing = 1;
  var Hack = requireHack();
  var Marker = requireMarker();
  var ASTERISK_HACK = '*';
  var BACKSLASH_HACK = '\\';
  var IMPORTANT_TOKEN = '!important';
  var UNDERSCORE_HACK = '_';
  var BANG_HACK = '!ie';
  function restoreFromOptimizing(properties, restoreCallback) {
    var property;
    var restored;
    var current;
    var i;
    for (i = properties.length - 1; i >= 0; i--) {
      property = properties[i];
      if (property.unused) {
        continue;
      }
      if (!property.dirty && !property.important && !property.hack) {
        continue;
      }
      if (restoreCallback) {
        restored = restoreCallback(property);
        property.value = restored;
      } else {
        restored = property.value;
      }
      if (property.important) {
        restoreImportant(property);
      }
      if (property.hack) {
        restoreHack(property);
      }
      if ('all' in property) {
        current = property.all[property.position];
        current[1][1] = property.name;
        current.splice(2, current.length - 1);
        Array.prototype.push.apply(current, restored);
      }
    }
  }
  function restoreImportant(property) {
    property.value[property.value.length - 1][1] += IMPORTANT_TOKEN;
  }
  function restoreHack(property) {
    if (property.hack[0] == Hack.UNDERSCORE) {
      property.name = UNDERSCORE_HACK + property.name;
    } else if (property.hack[0] == Hack.ASTERISK) {
      property.name = ASTERISK_HACK + property.name;
    } else if (property.hack[0] == Hack.BACKSLASH) {
      property.value[property.value.length - 1][1] += BACKSLASH_HACK + property.hack[1];
    } else if (property.hack[0] == Hack.BANG) {
      property.value[property.value.length - 1][1] += Marker.SPACE + BANG_HACK;
    }
  }
  restoreFromOptimizing_1 = restoreFromOptimizing;
  return restoreFromOptimizing_1;
}

var token;
var hasRequiredToken;
function requireToken() {
  if (hasRequiredToken) return token;
  hasRequiredToken = 1;
  var Token = {
    AT_RULE: 'at-rule',
    // e.g. `@import`, `@charset`
    AT_RULE_BLOCK: 'at-rule-block',
    // e.g. `@font-face{...}`
    AT_RULE_BLOCK_SCOPE: 'at-rule-block-scope',
    // e.g. `@font-face`
    COMMENT: 'comment',
    // e.g. `/* comment */`
    NESTED_BLOCK: 'nested-block',
    // e.g. `@media screen{...}`, `@keyframes animation {...}`
    NESTED_BLOCK_SCOPE: 'nested-block-scope',
    // e.g. `@media`, `@keyframes`
    PROPERTY: 'property',
    // e.g. `color:red`
    PROPERTY_BLOCK: 'property-block',
    // e.g. `--var:{color:red}`
    PROPERTY_NAME: 'property-name',
    // e.g. `color`
    PROPERTY_VALUE: 'property-value',
    // e.g. `red`
    RAW: 'raw',
    // e.g. anything between /* clean-css ignore:start */ and /* clean-css ignore:end */ comments
    RULE: 'rule',
    // e.g `div > a{...}`
    RULE_SCOPE: 'rule-scope' // e.g `div > a`
  };
  token = Token;
  return token;
}

var wrapForOptimizing;
var hasRequiredWrapForOptimizing;
function requireWrapForOptimizing() {
  if (hasRequiredWrapForOptimizing) return wrapForOptimizing;
  hasRequiredWrapForOptimizing = 1;
  var Hack = requireHack();
  var Marker = requireMarker();
  var Token = requireToken();
  var Match = {
    ASTERISK: '*',
    BACKSLASH: '\\',
    BANG: '!',
    BANG_SUFFIX_PATTERN: /!\w+$/,
    IMPORTANT_TOKEN_PATTERN: new RegExp('!important$', 'i'),
    IMPORTANT_WORD_PATTERN: new RegExp('important$', 'i'),
    SUFFIX_BANG_PATTERN: /!$/,
    UNDERSCORE: '_',
    VARIABLE_REFERENCE_PATTERN: /var\(--.+\)$/
  };
  function wrapAll(properties, includeVariable, skipProperties) {
    var wrapped = [];
    var single;
    var property;
    var i;
    for (i = properties.length - 1; i >= 0; i--) {
      property = properties[i];
      if (property[0] != Token.PROPERTY) {
        continue;
      }
      if (!includeVariable && someVariableReferences(property)) {
        continue;
      }
      if (skipProperties && skipProperties.indexOf(property[1][1]) > -1) {
        continue;
      }
      single = wrapSingle(property);
      single.all = properties;
      single.position = i;
      wrapped.unshift(single);
    }
    return wrapped;
  }
  function someVariableReferences(property) {
    var i, l;
    var value;

    // skipping `property` and property name tokens
    for (i = 2, l = property.length; i < l; i++) {
      value = property[i];
      if (value[0] != Token.PROPERTY_VALUE) {
        continue;
      }
      if (isVariableReference(value[1])) {
        return true;
      }
    }
    return false;
  }
  function isVariableReference(value) {
    return Match.VARIABLE_REFERENCE_PATTERN.test(value);
  }
  function isMultiplex(property) {
    var value;
    var i, l;
    for (i = 3, l = property.length; i < l; i++) {
      value = property[i];
      if (value[0] == Token.PROPERTY_VALUE && (value[1] == Marker.COMMA || value[1] == Marker.FORWARD_SLASH)) {
        return true;
      }
    }
    return false;
  }
  function hackFrom(property) {
    var match = false;
    var name = property[1][1];
    var lastValue = property[property.length - 1];
    if (name[0] == Match.UNDERSCORE) {
      match = [Hack.UNDERSCORE];
    } else if (name[0] == Match.ASTERISK) {
      match = [Hack.ASTERISK];
    } else if (lastValue[1][0] == Match.BANG && !lastValue[1].match(Match.IMPORTANT_WORD_PATTERN)) {
      match = [Hack.BANG];
    } else if (lastValue[1].indexOf(Match.BANG) > 0 && !lastValue[1].match(Match.IMPORTANT_WORD_PATTERN) && Match.BANG_SUFFIX_PATTERN.test(lastValue[1])) {
      match = [Hack.BANG];
    } else if (lastValue[1].indexOf(Match.BACKSLASH) > 0 && lastValue[1].indexOf(Match.BACKSLASH) == lastValue[1].length - Match.BACKSLASH.length - 1) {
      match = [Hack.BACKSLASH, lastValue[1].substring(lastValue[1].indexOf(Match.BACKSLASH) + 1)];
    } else if (lastValue[1].indexOf(Match.BACKSLASH) === 0 && lastValue[1].length == 2) {
      match = [Hack.BACKSLASH, lastValue[1].substring(1)];
    }
    return match;
  }
  function isImportant(property) {
    if (property.length < 3) return false;
    var lastValue = property[property.length - 1];
    if (Match.IMPORTANT_TOKEN_PATTERN.test(lastValue[1])) {
      return true;
    } else if (Match.IMPORTANT_WORD_PATTERN.test(lastValue[1]) && Match.SUFFIX_BANG_PATTERN.test(property[property.length - 2][1])) {
      return true;
    }
    return false;
  }
  function stripImportant(property) {
    var lastValue = property[property.length - 1];
    var oneButLastValue = property[property.length - 2];
    if (Match.IMPORTANT_TOKEN_PATTERN.test(lastValue[1])) {
      lastValue[1] = lastValue[1].replace(Match.IMPORTANT_TOKEN_PATTERN, '');
    } else {
      lastValue[1] = lastValue[1].replace(Match.IMPORTANT_WORD_PATTERN, '');
      oneButLastValue[1] = oneButLastValue[1].replace(Match.SUFFIX_BANG_PATTERN, '');
    }
    if (lastValue[1].length === 0) {
      property.pop();
    }
    if (oneButLastValue[1].length === 0) {
      property.pop();
    }
  }
  function stripPrefixHack(property) {
    property[1][1] = property[1][1].substring(1);
  }
  function stripSuffixHack(property, hackFrom) {
    var lastValue = property[property.length - 1];
    lastValue[1] = lastValue[1].substring(0, lastValue[1].indexOf(hackFrom[0] == Hack.BACKSLASH ? Match.BACKSLASH : Match.BANG)).trim();
    if (lastValue[1].length === 0) {
      property.pop();
    }
  }
  function wrapSingle(property) {
    var importantProperty = isImportant(property);
    if (importantProperty) {
      stripImportant(property);
    }
    var whichHack = hackFrom(property);
    if (whichHack[0] == Hack.ASTERISK || whichHack[0] == Hack.UNDERSCORE) {
      stripPrefixHack(property);
    } else if (whichHack[0] == Hack.BACKSLASH || whichHack[0] == Hack.BANG) {
      stripSuffixHack(property, whichHack);
    }
    return {
      block: property[2] && property[2][0] == Token.PROPERTY_BLOCK,
      components: [],
      dirty: false,
      hack: whichHack,
      important: importantProperty,
      name: property[1][1],
      multiplex: property.length > 3 ? isMultiplex(property) : false,
      position: 0,
      shorthand: false,
      unused: false,
      value: property.slice(2)
    };
  }
  wrapForOptimizing = {
    all: wrapAll,
    single: wrapSingle
  };
  return wrapForOptimizing;
}

var roundingPrecision;
var hasRequiredRoundingPrecision;
function requireRoundingPrecision() {
  if (hasRequiredRoundingPrecision) return roundingPrecision;
  hasRequiredRoundingPrecision = 1;
  var override = requireOverride();
  var INTEGER_PATTERN = /^\d+$/;
  var ALL_UNITS = ['*', 'all'];
  var DEFAULT_PRECISION = 'off'; // all precision changes are disabled
  var DIRECTIVES_SEPARATOR = ','; // e.g. *=5,px=3
  var DIRECTIVE_VALUE_SEPARATOR = '='; // e.g. *=5

  function roundingPrecisionFrom(source) {
    return override(defaults(DEFAULT_PRECISION), buildPrecisionFrom(source));
  }
  function defaults(value) {
    return {
      'ch': value,
      'cm': value,
      'em': value,
      'ex': value,
      'in': value,
      'mm': value,
      'pc': value,
      'pt': value,
      'px': value,
      'q': value,
      'rem': value,
      'vh': value,
      'vmax': value,
      'vmin': value,
      'vw': value,
      '%': value
    };
  }
  function buildPrecisionFrom(source) {
    if (source === null || source === undefined) {
      return {};
    }
    if (typeof source == 'boolean') {
      return {};
    }
    if (typeof source == 'number' && source == -1) {
      return defaults(DEFAULT_PRECISION);
    }
    if (typeof source == 'number') {
      return defaults(source);
    }
    if (typeof source == 'string' && INTEGER_PATTERN.test(source)) {
      return defaults(parseInt(source));
    }
    if (typeof source == 'string' && source == DEFAULT_PRECISION) {
      return defaults(DEFAULT_PRECISION);
    }
    if (typeof source == 'object') {
      return source;
    }
    return source.split(DIRECTIVES_SEPARATOR).reduce(function (accumulator, directive) {
      var directiveParts = directive.split(DIRECTIVE_VALUE_SEPARATOR);
      var name = directiveParts[0];
      var value = parseInt(directiveParts[1]);
      if (isNaN(value) || value == -1) {
        value = DEFAULT_PRECISION;
      }
      if (ALL_UNITS.indexOf(name) > -1) {
        accumulator = override(accumulator, defaults(value));
      } else {
        accumulator[name] = value;
      }
      return accumulator;
    }, {});
  }
  roundingPrecision = {
    DEFAULT: DEFAULT_PRECISION,
    roundingPrecisionFrom: roundingPrecisionFrom
  };
  return roundingPrecision;
}

var optimizationLevel;
var hasRequiredOptimizationLevel;
function requireOptimizationLevel() {
  if (hasRequiredOptimizationLevel) return optimizationLevel;
  hasRequiredOptimizationLevel = 1;
  var roundingPrecisionFrom = requireRoundingPrecision().roundingPrecisionFrom;
  var override = requireOverride();
  var OptimizationLevel = {
    Zero: '0',
    One: '1',
    Two: '2'
  };
  var DEFAULTS = {};
  DEFAULTS[OptimizationLevel.Zero] = {};
  DEFAULTS[OptimizationLevel.One] = {
    cleanupCharsets: true,
    normalizeUrls: true,
    optimizeBackground: true,
    optimizeBorderRadius: true,
    optimizeFilter: true,
    optimizeFontWeight: true,
    optimizeOutline: true,
    removeEmpty: true,
    removeNegativePaddings: true,
    removeQuotes: true,
    removeWhitespace: true,
    replaceMultipleZeros: true,
    replaceTimeUnits: true,
    replaceZeroUnits: true,
    roundingPrecision: roundingPrecisionFrom(undefined),
    selectorsSortingMethod: 'standard',
    specialComments: 'all',
    tidyAtRules: true,
    tidyBlockScopes: true,
    tidySelectors: true,
    transform: noop
  };
  DEFAULTS[OptimizationLevel.Two] = {
    mergeAdjacentRules: true,
    mergeIntoShorthands: true,
    mergeMedia: true,
    mergeNonAdjacentRules: true,
    mergeSemantically: false,
    overrideProperties: true,
    removeEmpty: true,
    reduceNonAdjacentRules: true,
    removeDuplicateFontRules: true,
    removeDuplicateMediaBlocks: true,
    removeDuplicateRules: true,
    removeUnusedAtRules: false,
    restructureRules: false,
    skipProperties: []
  };
  var ALL_KEYWORD_1 = '*';
  var ALL_KEYWORD_2 = 'all';
  var FALSE_KEYWORD_1 = 'false';
  var FALSE_KEYWORD_2 = 'off';
  var TRUE_KEYWORD_1 = 'true';
  var TRUE_KEYWORD_2 = 'on';
  var LIST_VALUE_SEPARATOR = ',';
  var OPTION_SEPARATOR = ';';
  var OPTION_VALUE_SEPARATOR = ':';
  function noop() {}
  function optimizationLevelFrom(source) {
    var level = override(DEFAULTS, {});
    var Zero = OptimizationLevel.Zero;
    var One = OptimizationLevel.One;
    var Two = OptimizationLevel.Two;
    if (undefined === source) {
      delete level[Two];
      return level;
    }
    if (typeof source == 'string') {
      source = parseInt(source);
    }
    if (typeof source == 'number' && source === parseInt(Two)) {
      return level;
    }
    if (typeof source == 'number' && source === parseInt(One)) {
      delete level[Two];
      return level;
    }
    if (typeof source == 'number' && source === parseInt(Zero)) {
      delete level[Two];
      delete level[One];
      return level;
    }
    if (typeof source == 'object') {
      source = covertValuesToHashes(source);
    }
    if (One in source && 'roundingPrecision' in source[One]) {
      source[One].roundingPrecision = roundingPrecisionFrom(source[One].roundingPrecision);
    }
    if (Two in source && 'skipProperties' in source[Two] && typeof source[Two].skipProperties == 'string') {
      source[Two].skipProperties = source[Two].skipProperties.split(LIST_VALUE_SEPARATOR);
    }
    if (Zero in source || One in source || Two in source) {
      level[Zero] = override(level[Zero], source[Zero]);
    }
    if (One in source && ALL_KEYWORD_1 in source[One]) {
      level[One] = override(level[One], defaults(One, normalizeValue(source[One][ALL_KEYWORD_1])));
      delete source[One][ALL_KEYWORD_1];
    }
    if (One in source && ALL_KEYWORD_2 in source[One]) {
      level[One] = override(level[One], defaults(One, normalizeValue(source[One][ALL_KEYWORD_2])));
      delete source[One][ALL_KEYWORD_2];
    }
    if (One in source || Two in source) {
      level[One] = override(level[One], source[One]);
    } else {
      delete level[One];
    }
    if (Two in source && ALL_KEYWORD_1 in source[Two]) {
      level[Two] = override(level[Two], defaults(Two, normalizeValue(source[Two][ALL_KEYWORD_1])));
      delete source[Two][ALL_KEYWORD_1];
    }
    if (Two in source && ALL_KEYWORD_2 in source[Two]) {
      level[Two] = override(level[Two], defaults(Two, normalizeValue(source[Two][ALL_KEYWORD_2])));
      delete source[Two][ALL_KEYWORD_2];
    }
    if (Two in source) {
      level[Two] = override(level[Two], source[Two]);
    } else {
      delete level[Two];
    }
    return level;
  }
  function defaults(level, value) {
    var options = override(DEFAULTS[level], {});
    var key;
    for (key in options) {
      if (typeof options[key] == 'boolean') {
        options[key] = value;
      }
    }
    return options;
  }
  function normalizeValue(value) {
    switch (value) {
      case FALSE_KEYWORD_1:
      case FALSE_KEYWORD_2:
        return false;
      case TRUE_KEYWORD_1:
      case TRUE_KEYWORD_2:
        return true;
      default:
        return value;
    }
  }
  function covertValuesToHashes(source) {
    var clonedSource = override(source, {});
    var level;
    var i;
    for (i = 0; i <= 2; i++) {
      level = '' + i;
      if (level in clonedSource && (clonedSource[level] === undefined || clonedSource[level] === false)) {
        delete clonedSource[level];
      }
      if (level in clonedSource && clonedSource[level] === true) {
        clonedSource[level] = {};
      }
      if (level in clonedSource && typeof clonedSource[level] == 'string') {
        clonedSource[level] = covertToHash(clonedSource[level], level);
      }
    }
    return clonedSource;
  }
  function covertToHash(asString, level) {
    return asString.split(OPTION_SEPARATOR).reduce(function (accumulator, directive) {
      var parts = directive.split(OPTION_VALUE_SEPARATOR);
      var name = parts[0];
      var value = parts[1];
      var normalizedValue = normalizeValue(value);
      if (ALL_KEYWORD_1 == name || ALL_KEYWORD_2 == name) {
        accumulator = override(accumulator, defaults(level, normalizedValue));
      } else {
        accumulator[name] = normalizedValue;
      }
      return accumulator;
    }, {});
  }
  optimizationLevel = {
    OptimizationLevel: OptimizationLevel,
    optimizationLevelFrom: optimizationLevelFrom
  };
  return optimizationLevel;
}

var split_1;
var hasRequiredSplit;
function requireSplit() {
  if (hasRequiredSplit) return split_1;
  hasRequiredSplit = 1;
  var Marker = requireMarker();
  function split(value, separator) {
    var openLevel = Marker.OPEN_ROUND_BRACKET;
    var closeLevel = Marker.CLOSE_ROUND_BRACKET;
    var level = 0;
    var cursor = 0;
    var lastStart = 0;
    var lastValue;
    var lastCharacter;
    var len = value.length;
    var parts = [];
    if (value.indexOf(separator) == -1) {
      return [value];
    }
    if (value.indexOf(openLevel) == -1) {
      return value.split(separator);
    }
    while (cursor < len) {
      if (value[cursor] == openLevel) {
        level++;
      } else if (value[cursor] == closeLevel) {
        level--;
      }
      if (level === 0 && cursor > 0 && cursor + 1 < len && value[cursor] == separator) {
        parts.push(value.substring(lastStart, cursor));
        lastStart = cursor + 1;
      }
      cursor++;
    }
    if (lastStart < cursor + 1) {
      lastValue = value.substring(lastStart);
      lastCharacter = lastValue[lastValue.length - 1];
      if (lastCharacter == separator) {
        lastValue = lastValue.substring(0, lastValue.length - 1);
      }
      parts.push(lastValue);
    }
    return parts;
  }
  split_1 = split;
  return split_1;
}

var helpers;
var hasRequiredHelpers;
function requireHelpers() {
  if (hasRequiredHelpers) return helpers;
  hasRequiredHelpers = 1;
  var emptyCharacter = '';
  var Breaks = requireFormat$1().Breaks;
  var Spaces = requireFormat$1().Spaces;
  var Marker = requireMarker();
  var Token = requireToken();
  function supportsAfterClosingBrace(token) {
    return token[1][1] == 'background' || token[1][1] == 'transform' || token[1][1] == 'src';
  }
  function afterClosingBrace(token, valueIndex) {
    return token[valueIndex][1][token[valueIndex][1].length - 1] == Marker.CLOSE_ROUND_BRACKET;
  }
  function afterComma(token, valueIndex) {
    return token[valueIndex][1] == Marker.COMMA;
  }
  function afterSlash(token, valueIndex) {
    return token[valueIndex][1] == Marker.FORWARD_SLASH;
  }
  function beforeComma(token, valueIndex) {
    return token[valueIndex + 1] && token[valueIndex + 1][1] == Marker.COMMA;
  }
  function beforeSlash(token, valueIndex) {
    return token[valueIndex + 1] && token[valueIndex + 1][1] == Marker.FORWARD_SLASH;
  }
  function inFilter(token) {
    return token[1][1] == 'filter' || token[1][1] == '-ms-filter';
  }
  function disallowsSpace(context, token, valueIndex) {
    return !context.spaceAfterClosingBrace && supportsAfterClosingBrace(token) && afterClosingBrace(token, valueIndex) || beforeSlash(token, valueIndex) || afterSlash(token, valueIndex) || beforeComma(token, valueIndex) || afterComma(token, valueIndex);
  }
  function rules(context, tokens) {
    var store = context.store;
    for (var i = 0, l = tokens.length; i < l; i++) {
      store(context, tokens[i]);
      if (i < l - 1) {
        store(context, comma(context));
      }
    }
  }
  function body(context, tokens) {
    var lastPropertyAt = lastPropertyIndex(tokens);
    for (var i = 0, l = tokens.length; i < l; i++) {
      property(context, tokens, i, lastPropertyAt);
    }
  }
  function lastPropertyIndex(tokens) {
    var index = tokens.length - 1;
    for (; index >= 0; index--) {
      if (tokens[index][0] != Token.COMMENT) {
        break;
      }
    }
    return index;
  }
  function property(context, tokens, position, lastPropertyAt) {
    var store = context.store;
    var token = tokens[position];
    var propertyValue = token[2];
    var isPropertyBlock = propertyValue && propertyValue[0] === Token.PROPERTY_BLOCK;
    var needsSemicolon;
    if (context.format) {
      if (context.format.semicolonAfterLastProperty || isPropertyBlock) {
        needsSemicolon = true;
      } else if (position < lastPropertyAt) {
        needsSemicolon = true;
      } else {
        needsSemicolon = false;
      }
    } else {
      needsSemicolon = position < lastPropertyAt || isPropertyBlock;
    }
    var isLast = position === lastPropertyAt;
    switch (token[0]) {
      case Token.AT_RULE:
        store(context, token);
        store(context, semicolon(context, Breaks.AfterProperty, false));
        break;
      case Token.AT_RULE_BLOCK:
        rules(context, token[1]);
        store(context, openBrace(context, Breaks.AfterRuleBegins, true));
        body(context, token[2]);
        store(context, closeBrace(context, Breaks.AfterRuleEnds, false, isLast));
        break;
      case Token.COMMENT:
        store(context, token);
        break;
      case Token.PROPERTY:
        store(context, token[1]);
        store(context, colon(context));
        if (propertyValue) {
          value(context, token);
        }
        store(context, needsSemicolon ? semicolon(context, Breaks.AfterProperty, isLast) : emptyCharacter);
        break;
      case Token.RAW:
        store(context, token);
    }
  }
  function value(context, token) {
    var store = context.store;
    var j, m;
    if (token[2][0] == Token.PROPERTY_BLOCK) {
      store(context, openBrace(context, Breaks.AfterBlockBegins, false));
      body(context, token[2][1]);
      store(context, closeBrace(context, Breaks.AfterBlockEnds, false, true));
    } else {
      for (j = 2, m = token.length; j < m; j++) {
        store(context, token[j]);
        if (j < m - 1 && (inFilter(token) || !disallowsSpace(context, token, j))) {
          store(context, Marker.SPACE);
        }
      }
    }
  }
  function allowsBreak(context, where) {
    return context.format && context.format.breaks[where];
  }
  function allowsSpace(context, where) {
    return context.format && context.format.spaces[where];
  }
  function openBrace(context, where, needsPrefixSpace) {
    if (context.format) {
      context.indentBy += context.format.indentBy;
      context.indentWith = context.format.indentWith.repeat(context.indentBy);
      return (needsPrefixSpace && allowsSpace(context, Spaces.BeforeBlockBegins) ? Marker.SPACE : emptyCharacter) + Marker.OPEN_CURLY_BRACKET + (allowsBreak(context, where) ? context.format.breakWith : emptyCharacter) + context.indentWith;
    } else {
      return Marker.OPEN_CURLY_BRACKET;
    }
  }
  function closeBrace(context, where, beforeBlockEnd, isLast) {
    if (context.format) {
      context.indentBy -= context.format.indentBy;
      context.indentWith = context.format.indentWith.repeat(context.indentBy);
      return (allowsBreak(context, Breaks.AfterProperty) || beforeBlockEnd && allowsBreak(context, Breaks.BeforeBlockEnds) ? context.format.breakWith : emptyCharacter) + context.indentWith + Marker.CLOSE_CURLY_BRACKET + (isLast ? emptyCharacter : (allowsBreak(context, where) ? context.format.breakWith : emptyCharacter) + context.indentWith);
    } else {
      return Marker.CLOSE_CURLY_BRACKET;
    }
  }
  function colon(context) {
    return context.format ? Marker.COLON + (allowsSpace(context, Spaces.BeforeValue) ? Marker.SPACE : emptyCharacter) : Marker.COLON;
  }
  function semicolon(context, where, isLast) {
    return context.format ? Marker.SEMICOLON + (isLast || !allowsBreak(context, where) ? emptyCharacter : context.format.breakWith + context.indentWith) : Marker.SEMICOLON;
  }
  function comma(context) {
    return context.format ? Marker.COMMA + (allowsBreak(context, Breaks.BetweenSelectors) ? context.format.breakWith : emptyCharacter) + context.indentWith : Marker.COMMA;
  }
  function all(context, tokens) {
    var store = context.store;
    var token;
    var isLast;
    var i, l;
    for (i = 0, l = tokens.length; i < l; i++) {
      token = tokens[i];
      isLast = i == l - 1;
      switch (token[0]) {
        case Token.AT_RULE:
          store(context, token);
          store(context, semicolon(context, Breaks.AfterAtRule, isLast));
          break;
        case Token.AT_RULE_BLOCK:
          rules(context, token[1]);
          store(context, openBrace(context, Breaks.AfterRuleBegins, true));
          body(context, token[2]);
          store(context, closeBrace(context, Breaks.AfterRuleEnds, false, isLast));
          break;
        case Token.NESTED_BLOCK:
          rules(context, token[1]);
          store(context, openBrace(context, Breaks.AfterBlockBegins, true));
          all(context, token[2]);
          store(context, closeBrace(context, Breaks.AfterBlockEnds, true, isLast));
          break;
        case Token.COMMENT:
          store(context, token);
          store(context, allowsBreak(context, Breaks.AfterComment) ? context.format.breakWith : emptyCharacter);
          break;
        case Token.RAW:
          store(context, token);
          break;
        case Token.RULE:
          rules(context, token[1]);
          store(context, openBrace(context, Breaks.AfterRuleBegins, true));
          body(context, token[2]);
          store(context, closeBrace(context, Breaks.AfterRuleEnds, false, isLast));
          break;
      }
    }
  }
  helpers = {
    all: all,
    body: body,
    property: property,
    rules: rules,
    value: value
  };
  return helpers;
}

var oneTime;
var hasRequiredOneTime;
function requireOneTime() {
  if (hasRequiredOneTime) return oneTime;
  hasRequiredOneTime = 1;
  var helpers = requireHelpers();
  function store(serializeContext, token) {
    serializeContext.output.push(typeof token == 'string' ? token : token[1]);
  }
  function context() {
    var newContext = {
      output: [],
      store: store
    };
    return newContext;
  }
  function all(tokens) {
    var oneTimeContext = context();
    helpers.all(oneTimeContext, tokens);
    return oneTimeContext.output.join('');
  }
  function body(tokens) {
    var oneTimeContext = context();
    helpers.body(oneTimeContext, tokens);
    return oneTimeContext.output.join('');
  }
  function property(tokens, position) {
    var oneTimeContext = context();
    helpers.property(oneTimeContext, tokens, position, true);
    return oneTimeContext.output.join('');
  }
  function rules(tokens) {
    var oneTimeContext = context();
    helpers.rules(oneTimeContext, tokens);
    return oneTimeContext.output.join('');
  }
  function value(tokens) {
    var oneTimeContext = context();
    helpers.value(oneTimeContext, tokens);
    return oneTimeContext.output.join('');
  }
  oneTime = {
    all: all,
    body: body,
    property: property,
    rules: rules,
    value: value
  };
  return oneTime;
}

var optimize$2;
var hasRequiredOptimize$2;
function requireOptimize$2() {
  if (hasRequiredOptimize$2) return optimize$2;
  hasRequiredOptimize$2 = 1;
  var shortenHex = requireShortenHex();
  var shortenHsl = requireShortenHsl();
  var shortenRgb = requireShortenRgb();
  var sortSelectors = requireSortSelectors();
  var tidyRules = requireTidyRules();
  var tidyBlock = requireTidyBlock();
  var tidyAtRule = requireTidyAtRule();
  var Hack = requireHack();
  var removeUnused = requireRemoveUnused();
  var restoreFromOptimizing = requireRestoreFromOptimizing();
  var wrapForOptimizing = requireWrapForOptimizing().all;
  var OptimizationLevel = requireOptimizationLevel().OptimizationLevel;
  var Token = requireToken();
  var Marker = requireMarker();
  var formatPosition = requireFormatPosition();
  var split = requireSplit();
  var serializeRules = requireOneTime().rules;
  var IgnoreProperty = 'ignore-property';
  var CHARSET_TOKEN = '@charset';
  var CHARSET_REGEXP = new RegExp('^' + CHARSET_TOKEN, 'i');
  var DEFAULT_ROUNDING_PRECISION = requireRoundingPrecision().DEFAULT;
  var WHOLE_PIXEL_VALUE = /(?:^|\s|\()(-?\d+)px/;
  var TIME_VALUE = /^(\-?[\d\.]+)(m?s)$/;
  var HEX_VALUE_PATTERN = /[0-9a-f]/i;
  var PROPERTY_NAME_PATTERN = /^(?:\-chrome\-|\-[\w\-]+\w|\w[\w\-]+\w|\-\-\S+)$/;
  var IMPORT_PREFIX_PATTERN = /^@import/i;
  var QUOTED_PATTERN = /^('.*'|".*")$/;
  var QUOTED_BUT_SAFE_PATTERN = /^['"][a-zA-Z][a-zA-Z\d\-_]+['"]$/;
  var URL_PREFIX_PATTERN = /^url\(/i;
  var LOCAL_PREFIX_PATTERN = /^local\(/i;
  var VARIABLE_NAME_PATTERN = /^--\S+$/;
  function isLocal(value) {
    return LOCAL_PREFIX_PATTERN.test(value);
  }
  function isNegative(value) {
    return value && value[1][0] == '-' && parseFloat(value[1]) < 0;
  }
  function isQuoted(value) {
    return QUOTED_PATTERN.test(value);
  }
  function isUrl(value) {
    return URL_PREFIX_PATTERN.test(value);
  }
  function normalizeUrl(value) {
    return value.replace(URL_PREFIX_PATTERN, 'url(').replace(/\\?\n|\\?\r\n/g, '');
  }
  function optimizeBackground(property) {
    var values = property.value;
    if (values.length == 1 && values[0][1] == 'none') {
      values[0][1] = '0 0';
    }
    if (values.length == 1 && values[0][1] == 'transparent') {
      values[0][1] = '0 0';
    }
  }
  function optimizeBorderRadius(property) {
    var values = property.value;
    var spliceAt;
    if (values.length == 3 && values[1][1] == '/' && values[0][1] == values[2][1]) {
      spliceAt = 1;
    } else if (values.length == 5 && values[2][1] == '/' && values[0][1] == values[3][1] && values[1][1] == values[4][1]) {
      spliceAt = 2;
    } else if (values.length == 7 && values[3][1] == '/' && values[0][1] == values[4][1] && values[1][1] == values[5][1] && values[2][1] == values[6][1]) {
      spliceAt = 3;
    } else if (values.length == 9 && values[4][1] == '/' && values[0][1] == values[5][1] && values[1][1] == values[6][1] && values[2][1] == values[7][1] && values[3][1] == values[8][1]) {
      spliceAt = 4;
    }
    if (spliceAt) {
      property.value.splice(spliceAt);
      property.dirty = true;
    }
  }

  /**
   * @param {string} name
   * @param {string} value
   * @param {Object} compatibility
   * @return {string}
   */
  function optimizeColors(name, value, compatibility) {
    if (!value.match(/#|rgb|hsl/gi)) {
      return shortenHex(value);
    }
    value = value.replace(/(rgb|hsl)a?\((\-?\d+),(\-?\d+\%?),(\-?\d+\%?),(0*[1-9]+[0-9]*(\.?\d*)?)\)/gi, function (match, colorFn, p1, p2, p3, alpha) {
      return parseInt(alpha, 10) >= 1 ? colorFn + '(' + [p1, p2, p3].join(',') + ')' : match;
    }).replace(/rgb\((\-?\d+),(\-?\d+),(\-?\d+)\)/gi, function (match, red, green, blue) {
      return shortenRgb(red, green, blue);
    }).replace(/hsl\((-?\d+),(-?\d+)%?,(-?\d+)%?\)/gi, function (match, hue, saturation, lightness) {
      return shortenHsl(hue, saturation, lightness);
    }).replace(/(^|[^='"])#([0-9a-f]{6})/gi, function (match, prefix, color, at, inputValue) {
      var suffix = inputValue[at + match.length];
      if (suffix && HEX_VALUE_PATTERN.test(suffix)) {
        return match;
      } else if (color[0] == color[1] && color[2] == color[3] && color[4] == color[5]) {
        return (prefix + '#' + color[0] + color[2] + color[4]).toLowerCase();
      } else {
        return (prefix + '#' + color).toLowerCase();
      }
    }).replace(/(^|[^='"])#([0-9a-f]{3})/gi, function (match, prefix, color) {
      return prefix + '#' + color.toLowerCase();
    }).replace(/(rgb|rgba|hsl|hsla)\(([^\)]+)\)/gi, function (match, colorFunction, colorDef) {
      var tokens = colorDef.split(',');
      var colorFnLowercase = colorFunction && colorFunction.toLowerCase();
      var applies = colorFnLowercase == 'hsl' && tokens.length == 3 || colorFnLowercase == 'hsla' && tokens.length == 4 || colorFnLowercase == 'rgb' && tokens.length === 3 && colorDef.indexOf('%') > 0 || colorFnLowercase == 'rgba' && tokens.length == 4 && colorDef.indexOf('%') > 0;
      if (!applies) {
        return match;
      }
      if (tokens[1].indexOf('%') == -1) {
        tokens[1] += '%';
      }
      if (tokens[2].indexOf('%') == -1) {
        tokens[2] += '%';
      }
      return colorFunction + '(' + tokens.join(',') + ')';
    });
    if (compatibility.colors.opacity && name.indexOf('background') == -1) {
      value = value.replace(/(?:rgba|hsla)\(0,0%?,0%?,0\)/g, function (match) {
        if (split(value, ',').pop().indexOf('gradient(') > -1) {
          return match;
        }
        return 'transparent';
      });
    }
    return shortenHex(value);
  }
  function optimizeFilter(property) {
    if (property.value.length == 1) {
      property.value[0][1] = property.value[0][1].replace(/progid:DXImageTransform\.Microsoft\.(Alpha|Chroma)(\W)/, function (match, filter, suffix) {
        return filter.toLowerCase() + suffix;
      });
    }
    property.value[0][1] = property.value[0][1].replace(/,(\S)/g, ', $1').replace(/ ?= ?/g, '=');
  }
  function optimizeFontWeight(property, atIndex) {
    var value = property.value[atIndex][1];
    if (value == 'normal') {
      value = '400';
    } else if (value == 'bold') {
      value = '700';
    }
    property.value[atIndex][1] = value;
  }
  function optimizeMultipleZeros(property) {
    var values = property.value;
    var spliceAt;
    if (values.length == 4 && values[0][1] === '0' && values[1][1] === '0' && values[2][1] === '0' && values[3][1] === '0') {
      if (property.name.indexOf('box-shadow') > -1) {
        spliceAt = 2;
      } else {
        spliceAt = 1;
      }
    }
    if (spliceAt) {
      property.value.splice(spliceAt);
      property.dirty = true;
    }
  }
  function optimizeOutline(property) {
    var values = property.value;
    if (values.length == 1 && values[0][1] == 'none') {
      values[0][1] = '0';
    }
  }
  function optimizePixelLengths(_, value, compatibility) {
    if (!WHOLE_PIXEL_VALUE.test(value)) {
      return value;
    }
    return value.replace(WHOLE_PIXEL_VALUE, function (match, val) {
      var newValue;
      var intVal = parseInt(val);
      if (intVal === 0) {
        return match;
      }
      if (compatibility.properties.shorterLengthUnits && compatibility.units.pt && intVal * 3 % 4 === 0) {
        newValue = intVal * 3 / 4 + 'pt';
      }
      if (compatibility.properties.shorterLengthUnits && compatibility.units.pc && intVal % 16 === 0) {
        newValue = intVal / 16 + 'pc';
      }
      if (compatibility.properties.shorterLengthUnits && compatibility.units.in && intVal % 96 === 0) {
        newValue = intVal / 96 + 'in';
      }
      if (newValue) {
        newValue = match.substring(0, match.indexOf(val)) + newValue;
      }
      return newValue && newValue.length < match.length ? newValue : match;
    });
  }
  function optimizePrecision(_, value, precisionOptions) {
    if (!precisionOptions.enabled || value.indexOf('.') === -1) {
      return value;
    }
    return value.replace(precisionOptions.decimalPointMatcher, '$1$2$3').replace(precisionOptions.zeroMatcher, function (match, integerPart, fractionPart, unit) {
      var multiplier = precisionOptions.units[unit].multiplier;
      var parsedInteger = parseInt(integerPart);
      var integer = isNaN(parsedInteger) ? 0 : parsedInteger;
      var fraction = parseFloat(fractionPart);
      return Math.round((integer + fraction) * multiplier) / multiplier + unit;
    });
  }
  function optimizeTimeUnits(_, value) {
    if (!TIME_VALUE.test(value)) return value;
    return value.replace(TIME_VALUE, function (match, val, unit) {
      var newValue;
      if (unit == 'ms') {
        newValue = parseInt(val) / 1000 + 's';
      } else if (unit == 's') {
        newValue = parseFloat(val) * 1000 + 'ms';
      }
      return newValue.length < match.length ? newValue : match;
    });
  }
  function optimizeUnits(name, value, unitsRegexp) {
    if (/^(?:\-moz\-calc|\-webkit\-calc|calc|rgb|hsl|rgba|hsla)\(/.test(value)) {
      return value;
    }
    if (name == 'flex' || name == '-ms-flex' || name == '-webkit-flex' || name == 'flex-basis' || name == '-webkit-flex-basis') {
      return value;
    }
    if (value.indexOf('%') > 0 && (name == 'height' || name == 'max-height' || name == 'width' || name == 'max-width')) {
      return value;
    }
    return value.replace(unitsRegexp, '$1' + '0' + '$2').replace(unitsRegexp, '$1' + '0' + '$2');
  }
  function optimizeWhitespace(name, value) {
    if (name.indexOf('filter') > -1 || value.indexOf(' ') == -1 || value.indexOf('expression') === 0) {
      return value;
    }
    if (value.indexOf(Marker.SINGLE_QUOTE) > -1 || value.indexOf(Marker.DOUBLE_QUOTE) > -1) {
      return value;
    }
    value = value.replace(/\s+/g, ' ');
    if (value.indexOf('calc') > -1) {
      value = value.replace(/\) ?\/ ?/g, ')/ ');
    }
    return value.replace(/(\(;?)\s+/g, '$1').replace(/\s+(;?\))/g, '$1').replace(/, /g, ',');
  }
  function optimizeZeroDegUnit(_, value) {
    if (value.indexOf('0deg') == -1) {
      return value;
    }
    return value.replace(/\(0deg\)/g, '(0)');
  }
  function optimizeZeroUnits(name, value) {
    if (value.indexOf('0') == -1) {
      return value;
    }
    if (value.indexOf('-') > -1) {
      value = value.replace(/([^\w\d\-]|^)\-0([^\.]|$)/g, '$10$2').replace(/([^\w\d\-]|^)\-0([^\.]|$)/g, '$10$2');
    }
    return value.replace(/(^|\s)0+([1-9])/g, '$1$2').replace(/(^|\D)\.0+(\D|$)/g, '$10$2').replace(/(^|\D)\.0+(\D|$)/g, '$10$2').replace(/\.([1-9]*)0+(\D|$)/g, function (match, nonZeroPart, suffix) {
      return (nonZeroPart.length > 0 ? '.' : '') + nonZeroPart + suffix;
    }).replace(/(^|\D)0\.(\d)/g, '$1.$2');
  }
  function removeQuotes(name, value) {
    if (name == 'content' || name.indexOf('font-variation-settings') > -1 || name.indexOf('font-feature-settings') > -1 || name == 'grid' || name.indexOf('grid-') > -1) {
      return value;
    }
    return QUOTED_BUT_SAFE_PATTERN.test(value) ? value.substring(1, value.length - 1) : value;
  }
  function removeUrlQuotes(value) {
    return /^url\(['"].+['"]\)$/.test(value) && !/^url\(['"].*[\*\s\(\)'"].*['"]\)$/.test(value) && !/^url\(['"]data:[^;]+;charset/.test(value) ? value.replace(/["']/g, '') : value;
  }
  function transformValue(propertyName, propertyValue, rule, transformCallback) {
    var selector = serializeRules(rule);
    var transformedValue = transformCallback(propertyName, propertyValue, selector);
    if (transformedValue === undefined) {
      return propertyValue;
    } else if (transformedValue === false) {
      return IgnoreProperty;
    } else {
      return transformedValue;
    }
  }

  //

  function optimizeBody(rule, properties, context) {
    var options = context.options;
    var levelOptions = options.level[OptimizationLevel.One];
    var property, name, type, value;
    var valueIsUrl;
    var propertyToken;
    var _properties = wrapForOptimizing(properties, true);
    propertyLoop: for (var i = 0, l = _properties.length; i < l; i++) {
      property = _properties[i];
      name = property.name;
      if (!PROPERTY_NAME_PATTERN.test(name)) {
        propertyToken = property.all[property.position];
        context.warnings.push('Invalid property name \'' + name + '\' at ' + formatPosition(propertyToken[1][2][0]) + '. Ignoring.');
        property.unused = true;
      }
      if (property.value.length === 0) {
        propertyToken = property.all[property.position];
        context.warnings.push('Empty property \'' + name + '\' at ' + formatPosition(propertyToken[1][2][0]) + '. Ignoring.');
        property.unused = true;
      }
      if (property.hack && ((property.hack[0] == Hack.ASTERISK || property.hack[0] == Hack.UNDERSCORE) && !options.compatibility.properties.iePrefixHack || property.hack[0] == Hack.BACKSLASH && !options.compatibility.properties.ieSuffixHack || property.hack[0] == Hack.BANG && !options.compatibility.properties.ieBangHack)) {
        property.unused = true;
      }
      if (levelOptions.removeNegativePaddings && name.indexOf('padding') === 0 && (isNegative(property.value[0]) || isNegative(property.value[1]) || isNegative(property.value[2]) || isNegative(property.value[3]))) {
        property.unused = true;
      }
      if (!options.compatibility.properties.ieFilters && isLegacyFilter(property)) {
        property.unused = true;
      }
      if (property.unused) {
        continue;
      }
      if (property.block) {
        optimizeBody(rule, property.value[0][1], context);
        continue;
      }
      if (VARIABLE_NAME_PATTERN.test(name)) {
        continue;
      }
      for (var j = 0, m = property.value.length; j < m; j++) {
        type = property.value[j][0];
        value = property.value[j][1];
        valueIsUrl = isUrl(value);
        if (type == Token.PROPERTY_BLOCK) {
          property.unused = true;
          context.warnings.push('Invalid value token at ' + formatPosition(value[0][1][2][0]) + '. Ignoring.');
          break;
        }
        if (valueIsUrl && !context.validator.isUrl(value)) {
          property.unused = true;
          context.warnings.push('Broken URL \'' + value + '\' at ' + formatPosition(property.value[j][2][0]) + '. Ignoring.');
          break;
        }
        if (valueIsUrl) {
          value = levelOptions.normalizeUrls ? normalizeUrl(value) : value;
          value = !options.compatibility.properties.urlQuotes ? removeUrlQuotes(value) : value;
        } else if (isQuoted(value) || isLocal(value)) {
          value = levelOptions.removeQuotes ? removeQuotes(name, value) : value;
        } else {
          value = levelOptions.removeWhitespace ? optimizeWhitespace(name, value) : value;
          value = optimizePrecision(name, value, options.precision);
          value = optimizePixelLengths(name, value, options.compatibility);
          value = levelOptions.replaceTimeUnits ? optimizeTimeUnits(name, value) : value;
          value = levelOptions.replaceZeroUnits ? optimizeZeroUnits(name, value) : value;
          if (options.compatibility.properties.zeroUnits) {
            value = optimizeZeroDegUnit(name, value);
            value = optimizeUnits(name, value, options.unitsRegexp);
          }
          if (options.compatibility.properties.colors) {
            value = optimizeColors(name, value, options.compatibility);
          }
        }
        value = transformValue(name, value, rule, levelOptions.transform);
        if (value === IgnoreProperty) {
          property.unused = true;
          continue propertyLoop;
        }
        property.value[j][1] = value;
      }
      if (levelOptions.replaceMultipleZeros) {
        optimizeMultipleZeros(property);
      }
      if (name == 'background' && levelOptions.optimizeBackground) {
        optimizeBackground(property);
      } else if (name.indexOf('border') === 0 && name.indexOf('radius') > 0 && levelOptions.optimizeBorderRadius) {
        optimizeBorderRadius(property);
      } else if (name == 'filter' && levelOptions.optimizeFilter && options.compatibility.properties.ieFilters) {
        optimizeFilter(property);
      } else if (name == 'font-weight' && levelOptions.optimizeFontWeight) {
        optimizeFontWeight(property, 0);
      } else if (name == 'outline' && levelOptions.optimizeOutline) {
        optimizeOutline(property);
      }
    }
    restoreFromOptimizing(_properties);
    removeUnused(_properties);
    removeComments(properties, options);
  }
  function removeComments(tokens, options) {
    var token;
    var i;
    for (i = 0; i < tokens.length; i++) {
      token = tokens[i];
      if (token[0] != Token.COMMENT) {
        continue;
      }
      optimizeComment(token, options);
      if (token[1].length === 0) {
        tokens.splice(i, 1);
        i--;
      }
    }
  }
  function optimizeComment(token, options) {
    if (token[1][2] == Marker.EXCLAMATION && (options.level[OptimizationLevel.One].specialComments == 'all' || options.commentsKept < options.level[OptimizationLevel.One].specialComments)) {
      options.commentsKept++;
      return;
    }
    token[1] = [];
  }
  function cleanupCharsets(tokens) {
    var hasCharset = false;
    for (var i = 0, l = tokens.length; i < l; i++) {
      var token = tokens[i];
      if (token[0] != Token.AT_RULE) continue;
      if (!CHARSET_REGEXP.test(token[1])) continue;
      if (hasCharset || token[1].indexOf(CHARSET_TOKEN) == -1) {
        tokens.splice(i, 1);
        i--;
        l--;
      } else {
        hasCharset = true;
        tokens.splice(i, 1);
        tokens.unshift([Token.AT_RULE, token[1].replace(CHARSET_REGEXP, CHARSET_TOKEN)]);
      }
    }
  }
  function buildUnitRegexp(options) {
    var units = ['px', 'em', 'ex', 'cm', 'mm', 'in', 'pt', 'pc', '%'];
    var otherUnits = ['ch', 'rem', 'vh', 'vm', 'vmax', 'vmin', 'vw'];
    otherUnits.forEach(function (unit) {
      if (options.compatibility.units[unit]) {
        units.push(unit);
      }
    });
    return new RegExp('(^|\\s|\\(|,)0(?:' + units.join('|') + ')(\\W|$)', 'g');
  }
  function buildPrecisionOptions(roundingPrecision) {
    var precisionOptions = {
      matcher: null,
      units: {}
    };
    var optimizable = [];
    var unit;
    var value;
    for (unit in roundingPrecision) {
      value = roundingPrecision[unit];
      if (value != DEFAULT_ROUNDING_PRECISION) {
        precisionOptions.units[unit] = {};
        precisionOptions.units[unit].value = value;
        precisionOptions.units[unit].multiplier = Math.pow(10, value);
        optimizable.push(unit);
      }
    }
    if (optimizable.length > 0) {
      precisionOptions.enabled = true;
      precisionOptions.decimalPointMatcher = new RegExp('(\\d)\\.($|' + optimizable.join('|') + ')($|\\W)', 'g');
      precisionOptions.zeroMatcher = new RegExp('(\\d*)(\\.\\d+)(' + optimizable.join('|') + ')', 'g');
    }
    return precisionOptions;
  }
  function isImport(token) {
    return IMPORT_PREFIX_PATTERN.test(token[1]);
  }
  function isLegacyFilter(property) {
    var value;
    if (property.name == 'filter' || property.name == '-ms-filter') {
      value = property.value[0][1];
      return value.indexOf('progid') > -1 || value.indexOf('alpha') === 0 || value.indexOf('chroma') === 0;
    } else {
      return false;
    }
  }
  function level1Optimize(tokens, context) {
    var options = context.options;
    var levelOptions = options.level[OptimizationLevel.One];
    var ie7Hack = options.compatibility.selectors.ie7Hack;
    var adjacentSpace = options.compatibility.selectors.adjacentSpace;
    var spaceAfterClosingBrace = options.compatibility.properties.spaceAfterClosingBrace;
    var format = options.format;
    var mayHaveCharset = false;
    var afterRules = false;
    options.unitsRegexp = options.unitsRegexp || buildUnitRegexp(options);
    options.precision = options.precision || buildPrecisionOptions(levelOptions.roundingPrecision);
    options.commentsKept = options.commentsKept || 0;
    for (var i = 0, l = tokens.length; i < l; i++) {
      var token = tokens[i];
      switch (token[0]) {
        case Token.AT_RULE:
          token[1] = isImport(token) && afterRules ? '' : token[1];
          token[1] = levelOptions.tidyAtRules ? tidyAtRule(token[1]) : token[1];
          mayHaveCharset = true;
          break;
        case Token.AT_RULE_BLOCK:
          optimizeBody(token[1], token[2], context);
          afterRules = true;
          break;
        case Token.NESTED_BLOCK:
          token[1] = levelOptions.tidyBlockScopes ? tidyBlock(token[1], spaceAfterClosingBrace) : token[1];
          level1Optimize(token[2], context);
          afterRules = true;
          break;
        case Token.COMMENT:
          optimizeComment(token, options);
          break;
        case Token.RULE:
          token[1] = levelOptions.tidySelectors ? tidyRules(token[1], !ie7Hack, adjacentSpace, format, context.warnings) : token[1];
          token[1] = token[1].length > 1 ? sortSelectors(token[1], levelOptions.selectorsSortingMethod) : token[1];
          optimizeBody(token[1], token[2], context);
          afterRules = true;
          break;
      }
      if (token[0] == Token.COMMENT && token[1].length === 0 || levelOptions.removeEmpty && (token[1].length === 0 || token[2] && token[2].length === 0)) {
        tokens.splice(i, 1);
        i--;
        l--;
      }
    }
    if (levelOptions.cleanupCharsets && mayHaveCharset) {
      cleanupCharsets(tokens);
    }
    return tokens;
  }
  optimize$2 = level1Optimize;
  return optimize$2;
}

var isMergeable_1;
var hasRequiredIsMergeable;
function requireIsMergeable() {
  if (hasRequiredIsMergeable) return isMergeable_1;
  hasRequiredIsMergeable = 1;
  var Marker = requireMarker();
  var split = requireSplit();
  var DEEP_SELECTOR_PATTERN = /\/deep\//;
  var DOUBLE_COLON_PATTERN = /^::/;
  var NOT_PSEUDO = ':not';
  var PSEUDO_CLASSES_WITH_ARGUMENTS = [':dir', ':lang', ':not', ':nth-child', ':nth-last-child', ':nth-last-of-type', ':nth-of-type'];
  var RELATION_PATTERN = /[>\+~]/;
  var UNMIXABLE_PSEUDO_CLASSES = [':after', ':before', ':first-letter', ':first-line', ':lang'];
  var UNMIXABLE_PSEUDO_ELEMENTS = ['::after', '::before', '::first-letter', '::first-line'];
  var Level = {
    DOUBLE_QUOTE: 'double-quote',
    SINGLE_QUOTE: 'single-quote',
    ROOT: 'root'
  };
  function isMergeable(selector, mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging) {
    var singleSelectors = split(selector, Marker.COMMA);
    var singleSelector;
    var i, l;
    for (i = 0, l = singleSelectors.length; i < l; i++) {
      singleSelector = singleSelectors[i];
      if (singleSelector.length === 0 || isDeepSelector(singleSelector) || singleSelector.indexOf(Marker.COLON) > -1 && !areMergeable(singleSelector, extractPseudoFrom(singleSelector), mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging)) {
        return false;
      }
    }
    return true;
  }
  function isDeepSelector(selector) {
    return DEEP_SELECTOR_PATTERN.test(selector);
  }
  function extractPseudoFrom(selector) {
    var list = [];
    var character;
    var buffer = [];
    var level = Level.ROOT;
    var roundBracketLevel = 0;
    var isQuoted;
    var isEscaped;
    var isPseudo = false;
    var isRelation;
    var wasColon = false;
    var index;
    var len;
    for (index = 0, len = selector.length; index < len; index++) {
      character = selector[index];
      isRelation = !isEscaped && RELATION_PATTERN.test(character);
      isQuoted = level == Level.DOUBLE_QUOTE || level == Level.SINGLE_QUOTE;
      if (isEscaped) {
        buffer.push(character);
      } else if (character == Marker.DOUBLE_QUOTE && level == Level.ROOT) {
        buffer.push(character);
        level = Level.DOUBLE_QUOTE;
      } else if (character == Marker.DOUBLE_QUOTE && level == Level.DOUBLE_QUOTE) {
        buffer.push(character);
        level = Level.ROOT;
      } else if (character == Marker.SINGLE_QUOTE && level == Level.ROOT) {
        buffer.push(character);
        level = Level.SINGLE_QUOTE;
      } else if (character == Marker.SINGLE_QUOTE && level == Level.SINGLE_QUOTE) {
        buffer.push(character);
        level = Level.ROOT;
      } else if (isQuoted) {
        buffer.push(character);
      } else if (character == Marker.OPEN_ROUND_BRACKET) {
        buffer.push(character);
        roundBracketLevel++;
      } else if (character == Marker.CLOSE_ROUND_BRACKET && roundBracketLevel == 1 && isPseudo) {
        buffer.push(character);
        list.push(buffer.join(''));
        roundBracketLevel--;
        buffer = [];
        isPseudo = false;
      } else if (character == Marker.CLOSE_ROUND_BRACKET) {
        buffer.push(character);
        roundBracketLevel--;
      } else if (character == Marker.COLON && roundBracketLevel === 0 && isPseudo && !wasColon) {
        list.push(buffer.join(''));
        buffer = [];
        buffer.push(character);
      } else if (character == Marker.COLON && roundBracketLevel === 0 && !wasColon) {
        buffer = [];
        buffer.push(character);
        isPseudo = true;
      } else if (character == Marker.SPACE && roundBracketLevel === 0 && isPseudo) {
        list.push(buffer.join(''));
        buffer = [];
        isPseudo = false;
      } else if (isRelation && roundBracketLevel === 0 && isPseudo) {
        list.push(buffer.join(''));
        buffer = [];
        isPseudo = false;
      } else {
        buffer.push(character);
      }
      isEscaped = character == Marker.BACK_SLASH;
      wasColon = character == Marker.COLON;
    }
    if (buffer.length > 0 && isPseudo) {
      list.push(buffer.join(''));
    }
    return list;
  }
  function areMergeable(selector, matches, mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging) {
    return areAllowed(matches, mergeablePseudoClasses, mergeablePseudoElements) && needArguments(matches) && (matches.length < 2 || !someIncorrectlyChained(selector, matches)) && (matches.length < 2 || multiplePseudoMerging && allMixable(matches));
  }
  function areAllowed(matches, mergeablePseudoClasses, mergeablePseudoElements) {
    var match;
    var name;
    var i, l;
    for (i = 0, l = matches.length; i < l; i++) {
      match = matches[i];
      name = match.indexOf(Marker.OPEN_ROUND_BRACKET) > -1 ? match.substring(0, match.indexOf(Marker.OPEN_ROUND_BRACKET)) : match;
      if (mergeablePseudoClasses.indexOf(name) === -1 && mergeablePseudoElements.indexOf(name) === -1) {
        return false;
      }
    }
    return true;
  }
  function needArguments(matches) {
    var match;
    var name;
    var bracketOpensAt;
    var hasArguments;
    var i, l;
    for (i = 0, l = matches.length; i < l; i++) {
      match = matches[i];
      bracketOpensAt = match.indexOf(Marker.OPEN_ROUND_BRACKET);
      hasArguments = bracketOpensAt > -1;
      name = hasArguments ? match.substring(0, bracketOpensAt) : match;
      if (hasArguments && PSEUDO_CLASSES_WITH_ARGUMENTS.indexOf(name) == -1) {
        return false;
      }
      if (!hasArguments && PSEUDO_CLASSES_WITH_ARGUMENTS.indexOf(name) > -1) {
        return false;
      }
    }
    return true;
  }
  function someIncorrectlyChained(selector, matches) {
    var positionInSelector = 0;
    var match;
    var matchAt;
    var nextMatch;
    var nextMatchAt;
    var name;
    var nextName;
    var areChained;
    var i, l;
    for (i = 0, l = matches.length; i < l; i++) {
      match = matches[i];
      nextMatch = matches[i + 1];
      if (!nextMatch) {
        break;
      }
      matchAt = selector.indexOf(match, positionInSelector);
      nextMatchAt = selector.indexOf(match, matchAt + 1);
      positionInSelector = nextMatchAt;
      areChained = matchAt + match.length == nextMatchAt;
      if (areChained) {
        name = match.indexOf(Marker.OPEN_ROUND_BRACKET) > -1 ? match.substring(0, match.indexOf(Marker.OPEN_ROUND_BRACKET)) : match;
        nextName = nextMatch.indexOf(Marker.OPEN_ROUND_BRACKET) > -1 ? nextMatch.substring(0, nextMatch.indexOf(Marker.OPEN_ROUND_BRACKET)) : nextMatch;
        if (name != NOT_PSEUDO || nextName != NOT_PSEUDO) {
          return true;
        }
      }
    }
    return false;
  }
  function allMixable(matches) {
    var unmixableMatches = 0;
    var match;
    var i, l;
    for (i = 0, l = matches.length; i < l; i++) {
      match = matches[i];
      if (isPseudoElement(match)) {
        unmixableMatches += UNMIXABLE_PSEUDO_ELEMENTS.indexOf(match) > -1 ? 1 : 0;
      } else {
        unmixableMatches += UNMIXABLE_PSEUDO_CLASSES.indexOf(match) > -1 ? 1 : 0;
      }
      if (unmixableMatches > 1) {
        return false;
      }
    }
    return true;
  }
  function isPseudoElement(pseudo) {
    return DOUBLE_COLON_PATTERN.test(pseudo);
  }
  isMergeable_1 = isMergeable;
  return isMergeable_1;
}

var everyValuesPair_1;
var hasRequiredEveryValuesPair;
function requireEveryValuesPair() {
  if (hasRequiredEveryValuesPair) return everyValuesPair_1;
  hasRequiredEveryValuesPair = 1;
  var Marker = requireMarker();
  function everyValuesPair(fn, left, right) {
    var leftSize = left.value.length;
    var rightSize = right.value.length;
    var total = Math.max(leftSize, rightSize);
    var lowerBound = Math.min(leftSize, rightSize) - 1;
    var leftValue;
    var rightValue;
    var position;
    for (position = 0; position < total; position++) {
      leftValue = left.value[position] && left.value[position][1] || leftValue;
      rightValue = right.value[position] && right.value[position][1] || rightValue;
      if (leftValue == Marker.COMMA || rightValue == Marker.COMMA) {
        continue;
      }
      if (!fn(leftValue, rightValue, position, position <= lowerBound)) {
        return false;
      }
    }
    return true;
  }
  everyValuesPair_1 = everyValuesPair;
  return everyValuesPair_1;
}

var hasInherit_1;
var hasRequiredHasInherit;
function requireHasInherit() {
  if (hasRequiredHasInherit) return hasInherit_1;
  hasRequiredHasInherit = 1;
  function hasInherit(property) {
    for (var i = property.value.length - 1; i >= 0; i--) {
      if (property.value[i][1] == 'inherit') return true;
    }
    return false;
  }
  hasInherit_1 = hasInherit;
  return hasInherit_1;
}

var invalidPropertyError;
var hasRequiredInvalidPropertyError;
function requireInvalidPropertyError() {
  if (hasRequiredInvalidPropertyError) return invalidPropertyError;
  hasRequiredInvalidPropertyError = 1;
  function InvalidPropertyError(message) {
    this.name = 'InvalidPropertyError';
    this.message = message;
    this.stack = new Error().stack;
  }
  InvalidPropertyError.prototype = Object.create(Error.prototype);
  InvalidPropertyError.prototype.constructor = InvalidPropertyError;
  invalidPropertyError = InvalidPropertyError;
  return invalidPropertyError;
}

var breakUp;
var hasRequiredBreakUp;
function requireBreakUp() {
  if (hasRequiredBreakUp) return breakUp;
  hasRequiredBreakUp = 1;
  var InvalidPropertyError = requireInvalidPropertyError();
  var wrapSingle = requireWrapForOptimizing().single;
  var Token = requireToken();
  var Marker = requireMarker();
  var formatPosition = requireFormatPosition();
  function _anyIsInherit(values) {
    var i, l;
    for (i = 0, l = values.length; i < l; i++) {
      if (values[i][1] == 'inherit') {
        return true;
      }
    }
    return false;
  }
  function _colorFilter(validator) {
    return function (value) {
      return value[1] == 'invert' || validator.isColor(value[1]) || validator.isPrefixed(value[1]);
    };
  }
  function _styleFilter(validator) {
    return function (value) {
      return value[1] != 'inherit' && validator.isStyleKeyword(value[1]) && !validator.isColorFunction(value[1]);
    };
  }
  function _wrapDefault(name, property, compactable) {
    var descriptor = compactable[name];
    if (descriptor.doubleValues && descriptor.defaultValue.length == 2) {
      return wrapSingle([Token.PROPERTY, [Token.PROPERTY_NAME, name], [Token.PROPERTY_VALUE, descriptor.defaultValue[0]], [Token.PROPERTY_VALUE, descriptor.defaultValue[1]]]);
    } else if (descriptor.doubleValues && descriptor.defaultValue.length == 1) {
      return wrapSingle([Token.PROPERTY, [Token.PROPERTY_NAME, name], [Token.PROPERTY_VALUE, descriptor.defaultValue[0]]]);
    } else {
      return wrapSingle([Token.PROPERTY, [Token.PROPERTY_NAME, name], [Token.PROPERTY_VALUE, descriptor.defaultValue]]);
    }
  }
  function _widthFilter(validator) {
    return function (value) {
      return value[1] != 'inherit' && (validator.isWidth(value[1]) || validator.isUnit(value[1]) && !validator.isDynamicUnit(value[1])) && !validator.isStyleKeyword(value[1]) && !validator.isColorFunction(value[1]);
    };
  }
  function animation(property, compactable, validator) {
    var duration = _wrapDefault(property.name + '-duration', property, compactable);
    var timing = _wrapDefault(property.name + '-timing-function', property, compactable);
    var delay = _wrapDefault(property.name + '-delay', property, compactable);
    var iteration = _wrapDefault(property.name + '-iteration-count', property, compactable);
    var direction = _wrapDefault(property.name + '-direction', property, compactable);
    var fill = _wrapDefault(property.name + '-fill-mode', property, compactable);
    var play = _wrapDefault(property.name + '-play-state', property, compactable);
    var name = _wrapDefault(property.name + '-name', property, compactable);
    var components = [duration, timing, delay, iteration, direction, fill, play, name];
    var values = property.value;
    var value;
    var durationSet = false;
    var timingSet = false;
    var delaySet = false;
    var iterationSet = false;
    var directionSet = false;
    var fillSet = false;
    var playSet = false;
    var nameSet = false;
    var i;
    var l;
    if (property.value.length == 1 && property.value[0][1] == 'inherit') {
      duration.value = timing.value = delay.value = iteration.value = direction.value = fill.value = play.value = name.value = property.value;
      return components;
    }
    if (values.length > 1 && _anyIsInherit(values)) {
      throw new InvalidPropertyError('Invalid animation values at ' + formatPosition(values[0][2][0]) + '. Ignoring.');
    }
    for (i = 0, l = values.length; i < l; i++) {
      value = values[i];
      if (validator.isTime(value[1]) && !durationSet) {
        duration.value = [value];
        durationSet = true;
      } else if (validator.isTime(value[1]) && !delaySet) {
        delay.value = [value];
        delaySet = true;
      } else if ((validator.isGlobal(value[1]) || validator.isTimingFunction(value[1])) && !timingSet) {
        timing.value = [value];
        timingSet = true;
      } else if ((validator.isAnimationIterationCountKeyword(value[1]) || validator.isPositiveNumber(value[1])) && !iterationSet) {
        iteration.value = [value];
        iterationSet = true;
      } else if (validator.isAnimationDirectionKeyword(value[1]) && !directionSet) {
        direction.value = [value];
        directionSet = true;
      } else if (validator.isAnimationFillModeKeyword(value[1]) && !fillSet) {
        fill.value = [value];
        fillSet = true;
      } else if (validator.isAnimationPlayStateKeyword(value[1]) && !playSet) {
        play.value = [value];
        playSet = true;
      } else if ((validator.isAnimationNameKeyword(value[1]) || validator.isIdentifier(value[1])) && !nameSet) {
        name.value = [value];
        nameSet = true;
      } else {
        throw new InvalidPropertyError('Invalid animation value at ' + formatPosition(value[2][0]) + '. Ignoring.');
      }
    }
    return components;
  }
  function background(property, compactable, validator) {
    var image = _wrapDefault('background-image', property, compactable);
    var position = _wrapDefault('background-position', property, compactable);
    var size = _wrapDefault('background-size', property, compactable);
    var repeat = _wrapDefault('background-repeat', property, compactable);
    var attachment = _wrapDefault('background-attachment', property, compactable);
    var origin = _wrapDefault('background-origin', property, compactable);
    var clip = _wrapDefault('background-clip', property, compactable);
    var color = _wrapDefault('background-color', property, compactable);
    var components = [image, position, size, repeat, attachment, origin, clip, color];
    var values = property.value;
    var positionSet = false;
    var clipSet = false;
    var originSet = false;
    var repeatSet = false;
    var anyValueSet = false;
    if (property.value.length == 1 && property.value[0][1] == 'inherit') {
      // NOTE: 'inherit' is not a valid value for background-attachment
      color.value = image.value = repeat.value = position.value = size.value = origin.value = clip.value = property.value;
      return components;
    }
    if (property.value.length == 1 && property.value[0][1] == '0 0') {
      return components;
    }
    for (var i = values.length - 1; i >= 0; i--) {
      var value = values[i];
      if (validator.isBackgroundAttachmentKeyword(value[1])) {
        attachment.value = [value];
        anyValueSet = true;
      } else if (validator.isBackgroundClipKeyword(value[1]) || validator.isBackgroundOriginKeyword(value[1])) {
        if (clipSet) {
          origin.value = [value];
          originSet = true;
        } else {
          clip.value = [value];
          clipSet = true;
        }
        anyValueSet = true;
      } else if (validator.isBackgroundRepeatKeyword(value[1])) {
        if (repeatSet) {
          repeat.value.unshift(value);
        } else {
          repeat.value = [value];
          repeatSet = true;
        }
        anyValueSet = true;
      } else if (validator.isBackgroundPositionKeyword(value[1]) || validator.isBackgroundSizeKeyword(value[1]) || validator.isUnit(value[1]) || validator.isDynamicUnit(value[1])) {
        if (i > 0) {
          var previousValue = values[i - 1];
          if (previousValue[1] == Marker.FORWARD_SLASH) {
            size.value = [value];
          } else if (i > 1 && values[i - 2][1] == Marker.FORWARD_SLASH) {
            size.value = [previousValue, value];
            i -= 2;
          } else {
            if (!positionSet) position.value = [];
            position.value.unshift(value);
            positionSet = true;
          }
        } else {
          if (!positionSet) position.value = [];
          position.value.unshift(value);
          positionSet = true;
        }
        anyValueSet = true;
      } else if ((color.value[0][1] == compactable[color.name].defaultValue || color.value[0][1] == 'none') && (validator.isColor(value[1]) || validator.isPrefixed(value[1]))) {
        color.value = [value];
        anyValueSet = true;
      } else if (validator.isUrl(value[1]) || validator.isFunction(value[1])) {
        image.value = [value];
        anyValueSet = true;
      }
    }
    if (clipSet && !originSet) origin.value = clip.value.slice(0);
    if (!anyValueSet) {
      throw new InvalidPropertyError('Invalid background value at ' + formatPosition(values[0][2][0]) + '. Ignoring.');
    }
    return components;
  }
  function borderRadius(property, compactable) {
    var values = property.value;
    var splitAt = -1;
    for (var i = 0, l = values.length; i < l; i++) {
      if (values[i][1] == Marker.FORWARD_SLASH) {
        splitAt = i;
        break;
      }
    }
    if (splitAt === 0 || splitAt === values.length - 1) {
      throw new InvalidPropertyError('Invalid border-radius value at ' + formatPosition(values[0][2][0]) + '. Ignoring.');
    }
    var target = _wrapDefault(property.name, property, compactable);
    target.value = splitAt > -1 ? values.slice(0, splitAt) : values.slice(0);
    target.components = fourValues(target, compactable);
    var remainder = _wrapDefault(property.name, property, compactable);
    remainder.value = splitAt > -1 ? values.slice(splitAt + 1) : values.slice(0);
    remainder.components = fourValues(remainder, compactable);
    for (var j = 0; j < 4; j++) {
      target.components[j].multiplex = true;
      target.components[j].value = target.components[j].value.concat(remainder.components[j].value);
    }
    return target.components;
  }
  function font(property, compactable, validator) {
    var style = _wrapDefault('font-style', property, compactable);
    var variant = _wrapDefault('font-variant', property, compactable);
    var weight = _wrapDefault('font-weight', property, compactable);
    var stretch = _wrapDefault('font-stretch', property, compactable);
    var size = _wrapDefault('font-size', property, compactable);
    var height = _wrapDefault('line-height', property, compactable);
    var family = _wrapDefault('font-family', property, compactable);
    var components = [style, variant, weight, stretch, size, height, family];
    var values = property.value;
    var fuzzyMatched = 4; // style, variant, weight, and stretch
    var index = 0;
    var isStretchSet = false;
    var isStretchValid;
    var isStyleSet = false;
    var isStyleValid;
    var isVariantSet = false;
    var isVariantValid;
    var isWeightSet = false;
    var isWeightValid;
    var isSizeSet = false;
    var appendableFamilyName = false;
    if (!values[index]) {
      throw new InvalidPropertyError('Missing font values at ' + formatPosition(property.all[property.position][1][2][0]) + '. Ignoring.');
    }
    if (values.length == 1 && values[0][1] == 'inherit') {
      style.value = variant.value = weight.value = stretch.value = size.value = height.value = family.value = values;
      return components;
    }
    if (values.length == 1 && (validator.isFontKeyword(values[0][1]) || validator.isGlobal(values[0][1]) || validator.isPrefixed(values[0][1]))) {
      values[0][1] = Marker.INTERNAL + values[0][1];
      style.value = variant.value = weight.value = stretch.value = size.value = height.value = family.value = values;
      return components;
    }
    if (values.length < 2 || !_anyIsFontSize(values, validator) || !_anyIsFontFamily(values, validator)) {
      throw new InvalidPropertyError('Invalid font values at ' + formatPosition(property.all[property.position][1][2][0]) + '. Ignoring.');
    }
    if (values.length > 1 && _anyIsInherit(values)) {
      throw new InvalidPropertyError('Invalid font values at ' + formatPosition(values[0][2][0]) + '. Ignoring.');
    }

    // fuzzy match style, variant, weight, and stretch on first elements
    while (index < fuzzyMatched) {
      isStretchValid = validator.isFontStretchKeyword(values[index][1]) || validator.isGlobal(values[index][1]);
      isStyleValid = validator.isFontStyleKeyword(values[index][1]) || validator.isGlobal(values[index][1]);
      isVariantValid = validator.isFontVariantKeyword(values[index][1]) || validator.isGlobal(values[index][1]);
      isWeightValid = validator.isFontWeightKeyword(values[index][1]) || validator.isGlobal(values[index][1]);
      if (isStyleValid && !isStyleSet) {
        style.value = [values[index]];
        isStyleSet = true;
      } else if (isVariantValid && !isVariantSet) {
        variant.value = [values[index]];
        isVariantSet = true;
      } else if (isWeightValid && !isWeightSet) {
        weight.value = [values[index]];
        isWeightSet = true;
      } else if (isStretchValid && !isStretchSet) {
        stretch.value = [values[index]];
        isStretchSet = true;
      } else if (isStyleValid && isStyleSet || isVariantValid && isVariantSet || isWeightValid && isWeightSet || isStretchValid && isStretchSet) {
        throw new InvalidPropertyError('Invalid font style / variant / weight / stretch value at ' + formatPosition(values[0][2][0]) + '. Ignoring.');
      } else {
        break;
      }
      index++;
    }

    // now comes font-size ...
    if (validator.isFontSizeKeyword(values[index][1]) || validator.isUnit(values[index][1]) && !validator.isDynamicUnit(values[index][1])) {
      size.value = [values[index]];
      isSizeSet = true;
      index++;
    } else {
      throw new InvalidPropertyError('Missing font size at ' + formatPosition(values[0][2][0]) + '. Ignoring.');
    }
    if (!values[index]) {
      throw new InvalidPropertyError('Missing font family at ' + formatPosition(values[0][2][0]) + '. Ignoring.');
    }

    // ... and perhaps line-height
    if (isSizeSet && values[index] && values[index][1] == Marker.FORWARD_SLASH && values[index + 1] && (validator.isLineHeightKeyword(values[index + 1][1]) || validator.isUnit(values[index + 1][1]) || validator.isNumber(values[index + 1][1]))) {
      height.value = [values[index + 1]];
      index++;
      index++;
    }

    // ... and whatever comes next is font-family
    family.value = [];
    while (values[index]) {
      if (values[index][1] == Marker.COMMA) {
        appendableFamilyName = false;
      } else {
        if (appendableFamilyName) {
          family.value[family.value.length - 1][1] += Marker.SPACE + values[index][1];
        } else {
          family.value.push(values[index]);
        }
        appendableFamilyName = true;
      }
      index++;
    }
    if (family.value.length === 0) {
      throw new InvalidPropertyError('Missing font family at ' + formatPosition(values[0][2][0]) + '. Ignoring.');
    }
    return components;
  }
  function _anyIsFontSize(values, validator) {
    var value;
    var i, l;
    for (i = 0, l = values.length; i < l; i++) {
      value = values[i];
      if (validator.isFontSizeKeyword(value[1]) || validator.isUnit(value[1]) && !validator.isDynamicUnit(value[1]) || validator.isFunction(value[1])) {
        return true;
      }
    }
    return false;
  }
  function _anyIsFontFamily(values, validator) {
    var value;
    var i, l;
    for (i = 0, l = values.length; i < l; i++) {
      value = values[i];
      if (validator.isIdentifier(value[1])) {
        return true;
      }
    }
    return false;
  }
  function fourValues(property, compactable) {
    var componentNames = compactable[property.name].components;
    var components = [];
    var value = property.value;
    if (value.length < 1) return [];
    if (value.length < 2) value[1] = value[0].slice(0);
    if (value.length < 3) value[2] = value[0].slice(0);
    if (value.length < 4) value[3] = value[1].slice(0);
    for (var i = componentNames.length - 1; i >= 0; i--) {
      var component = wrapSingle([Token.PROPERTY, [Token.PROPERTY_NAME, componentNames[i]]]);
      component.value = [value[i]];
      components.unshift(component);
    }
    return components;
  }
  function multiplex(splitWith) {
    return function (property, compactable, validator) {
      var splitsAt = [];
      var values = property.value;
      var i, j, l, m;

      // find split commas
      for (i = 0, l = values.length; i < l; i++) {
        if (values[i][1] == ',') splitsAt.push(i);
      }
      if (splitsAt.length === 0) return splitWith(property, compactable, validator);
      var splitComponents = [];

      // split over commas, and into components
      for (i = 0, l = splitsAt.length; i <= l; i++) {
        var from = i === 0 ? 0 : splitsAt[i - 1] + 1;
        var to = i < l ? splitsAt[i] : values.length;
        var _property = _wrapDefault(property.name, property, compactable);
        _property.value = values.slice(from, to);
        splitComponents.push(splitWith(_property, compactable, validator));
      }
      var components = splitComponents[0];

      // group component values from each split
      for (i = 0, l = components.length; i < l; i++) {
        components[i].multiplex = true;
        for (j = 1, m = splitComponents.length; j < m; j++) {
          components[i].value.push([Token.PROPERTY_VALUE, Marker.COMMA]);
          Array.prototype.push.apply(components[i].value, splitComponents[j][i].value);
        }
      }
      return components;
    };
  }
  function listStyle(property, compactable, validator) {
    var type = _wrapDefault('list-style-type', property, compactable);
    var position = _wrapDefault('list-style-position', property, compactable);
    var image = _wrapDefault('list-style-image', property, compactable);
    var components = [type, position, image];
    if (property.value.length == 1 && property.value[0][1] == 'inherit') {
      type.value = position.value = image.value = [property.value[0]];
      return components;
    }
    var values = property.value.slice(0);
    var total = values.length;
    var index = 0;

    // `image` first...
    for (index = 0, total = values.length; index < total; index++) {
      if (validator.isUrl(values[index][1]) || values[index][1] == '0') {
        image.value = [values[index]];
        values.splice(index, 1);
        break;
      }
    }

    // ... then `position`
    for (index = 0, total = values.length; index < total; index++) {
      if (validator.isListStylePositionKeyword(values[index][1])) {
        position.value = [values[index]];
        values.splice(index, 1);
        break;
      }
    }

    // ... and what's left is a `type`
    if (values.length > 0 && (validator.isListStyleTypeKeyword(values[0][1]) || validator.isIdentifier(values[0][1]))) {
      type.value = [values[0]];
    }
    return components;
  }
  function transition(property, compactable, validator) {
    var prop = _wrapDefault(property.name + '-property', property, compactable);
    var duration = _wrapDefault(property.name + '-duration', property, compactable);
    var timing = _wrapDefault(property.name + '-timing-function', property, compactable);
    var delay = _wrapDefault(property.name + '-delay', property, compactable);
    var components = [prop, duration, timing, delay];
    var values = property.value;
    var value;
    var durationSet = false;
    var delaySet = false;
    var propSet = false;
    var timingSet = false;
    var i;
    var l;
    if (property.value.length == 1 && property.value[0][1] == 'inherit') {
      prop.value = duration.value = timing.value = delay.value = property.value;
      return components;
    }
    if (values.length > 1 && _anyIsInherit(values)) {
      throw new InvalidPropertyError('Invalid animation values at ' + formatPosition(values[0][2][0]) + '. Ignoring.');
    }
    for (i = 0, l = values.length; i < l; i++) {
      value = values[i];
      if (validator.isTime(value[1]) && !durationSet) {
        duration.value = [value];
        durationSet = true;
      } else if (validator.isTime(value[1]) && !delaySet) {
        delay.value = [value];
        delaySet = true;
      } else if ((validator.isGlobal(value[1]) || validator.isTimingFunction(value[1])) && !timingSet) {
        timing.value = [value];
        timingSet = true;
      } else if (validator.isIdentifier(value[1]) && !propSet) {
        prop.value = [value];
        propSet = true;
      } else {
        throw new InvalidPropertyError('Invalid animation value at ' + formatPosition(value[2][0]) + '. Ignoring.');
      }
    }
    return components;
  }
  function widthStyleColor(property, compactable, validator) {
    var descriptor = compactable[property.name];
    var components = [_wrapDefault(descriptor.components[0], property, compactable), _wrapDefault(descriptor.components[1], property, compactable), _wrapDefault(descriptor.components[2], property, compactable)];
    var color, style, width;
    for (var i = 0; i < 3; i++) {
      var component = components[i];
      if (component.name.indexOf('color') > 0) color = component;else if (component.name.indexOf('style') > 0) style = component;else width = component;
    }
    if (property.value.length == 1 && property.value[0][1] == 'inherit' || property.value.length == 3 && property.value[0][1] == 'inherit' && property.value[1][1] == 'inherit' && property.value[2][1] == 'inherit') {
      color.value = style.value = width.value = [property.value[0]];
      return components;
    }
    var values = property.value.slice(0);
    var match, matches;

    // NOTE: usually users don't follow the required order of parts in this shorthand,
    // so we'll try to parse it caring as little about order as possible

    if (values.length > 0) {
      matches = values.filter(_widthFilter(validator));
      match = matches.length > 1 && (matches[0][1] == 'none' || matches[0][1] == 'auto') ? matches[1] : matches[0];
      if (match) {
        width.value = [match];
        values.splice(values.indexOf(match), 1);
      }
    }
    if (values.length > 0) {
      match = values.filter(_styleFilter(validator))[0];
      if (match) {
        style.value = [match];
        values.splice(values.indexOf(match), 1);
      }
    }
    if (values.length > 0) {
      match = values.filter(_colorFilter(validator))[0];
      if (match) {
        color.value = [match];
        values.splice(values.indexOf(match), 1);
      }
    }
    return components;
  }
  breakUp = {
    animation: animation,
    background: background,
    border: widthStyleColor,
    borderRadius: borderRadius,
    font: font,
    fourValues: fourValues,
    listStyle: listStyle,
    multiplex: multiplex,
    outline: widthStyleColor,
    transition: transition
  };
  return breakUp;
}

var vendorPrefixes;
var hasRequiredVendorPrefixes;
function requireVendorPrefixes() {
  if (hasRequiredVendorPrefixes) return vendorPrefixes;
  hasRequiredVendorPrefixes = 1;
  var VENDOR_PREFIX_PATTERN = /(?:^|\W)(\-\w+\-)/g;
  function unique(value) {
    var prefixes = [];
    var match;
    while ((match = VENDOR_PREFIX_PATTERN.exec(value)) !== null) {
      if (prefixes.indexOf(match[0]) == -1) {
        prefixes.push(match[0]);
      }
    }
    return prefixes;
  }
  function same(value1, value2) {
    return unique(value1).sort().join(',') == unique(value2).sort().join(',');
  }
  vendorPrefixes = {
    unique: unique,
    same: same
  };
  return vendorPrefixes;
}

var understandable_1;
var hasRequiredUnderstandable;
function requireUnderstandable() {
  if (hasRequiredUnderstandable) return understandable_1;
  hasRequiredUnderstandable = 1;
  var sameVendorPrefixes = requireVendorPrefixes().same;
  function understandable(validator, value1, value2, _position, isPaired) {
    if (!sameVendorPrefixes(value1, value2)) {
      return false;
    }
    if (isPaired && validator.isVariable(value1) !== validator.isVariable(value2)) {
      return false;
    }
    return true;
  }
  understandable_1 = understandable;
  return understandable_1;
}

var canOverride;
var hasRequiredCanOverride;
function requireCanOverride() {
  if (hasRequiredCanOverride) return canOverride;
  hasRequiredCanOverride = 1;
  var understandable = requireUnderstandable();
  function animationIterationCount(validator, value1, value2) {
    if (!understandable(validator, value1, value2, 0, true) && !(validator.isAnimationIterationCountKeyword(value2) || validator.isPositiveNumber(value2))) {
      return false;
    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
      return true;
    }
    return validator.isAnimationIterationCountKeyword(value2) || validator.isPositiveNumber(value2);
  }
  function animationName(validator, value1, value2) {
    if (!understandable(validator, value1, value2, 0, true) && !(validator.isAnimationNameKeyword(value2) || validator.isIdentifier(value2))) {
      return false;
    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
      return true;
    }
    return validator.isAnimationNameKeyword(value2) || validator.isIdentifier(value2);
  }
  function areSameFunction(validator, value1, value2) {
    if (!validator.isFunction(value1) || !validator.isFunction(value2)) {
      return false;
    }
    var function1Name = value1.substring(0, value1.indexOf('('));
    var function2Name = value2.substring(0, value2.indexOf('('));
    return function1Name === function2Name;
  }
  function backgroundPosition(validator, value1, value2) {
    if (!understandable(validator, value1, value2, 0, true) && !(validator.isBackgroundPositionKeyword(value2) || validator.isGlobal(value2))) {
      return false;
    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
      return true;
    } else if (validator.isBackgroundPositionKeyword(value2) || validator.isGlobal(value2)) {
      return true;
    }
    return unit(validator, value1, value2);
  }
  function backgroundSize(validator, value1, value2) {
    if (!understandable(validator, value1, value2, 0, true) && !(validator.isBackgroundSizeKeyword(value2) || validator.isGlobal(value2))) {
      return false;
    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
      return true;
    } else if (validator.isBackgroundSizeKeyword(value2) || validator.isGlobal(value2)) {
      return true;
    }
    return unit(validator, value1, value2);
  }
  function color(validator, value1, value2) {
    if (!understandable(validator, value1, value2, 0, true) && !validator.isColor(value2)) {
      return false;
    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
      return true;
    } else if (!validator.colorOpacity && (validator.isRgbColor(value1) || validator.isHslColor(value1))) {
      return false;
    } else if (!validator.colorOpacity && (validator.isRgbColor(value2) || validator.isHslColor(value2))) {
      return false;
    } else if (validator.isColor(value1) && validator.isColor(value2)) {
      return true;
    }
    return sameFunctionOrValue(validator, value1, value2);
  }
  function components(overrideCheckers) {
    return function (validator, value1, value2, position) {
      return overrideCheckers[position](validator, value1, value2);
    };
  }
  function fontFamily(validator, value1, value2) {
    return understandable(validator, value1, value2, 0, true);
  }
  function image(validator, value1, value2) {
    if (!understandable(validator, value1, value2, 0, true) && !validator.isImage(value2)) {
      return false;
    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
      return true;
    } else if (validator.isImage(value2)) {
      return true;
    } else if (validator.isImage(value1)) {
      return false;
    }
    return sameFunctionOrValue(validator, value1, value2);
  }
  function keyword(propertyName) {
    return function (validator, value1, value2) {
      if (!understandable(validator, value1, value2, 0, true) && !validator.isKeyword(propertyName)(value2)) {
        return false;
      } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
        return true;
      }
      return validator.isKeyword(propertyName)(value2);
    };
  }
  function keywordWithGlobal(propertyName) {
    return function (validator, value1, value2) {
      if (!understandable(validator, value1, value2, 0, true) && !(validator.isKeyword(propertyName)(value2) || validator.isGlobal(value2))) {
        return false;
      } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
        return true;
      }
      return validator.isKeyword(propertyName)(value2) || validator.isGlobal(value2);
    };
  }
  function propertyName(validator, value1, value2) {
    if (!understandable(validator, value1, value2, 0, true) && !validator.isIdentifier(value2)) {
      return false;
    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
      return true;
    }
    return validator.isIdentifier(value2);
  }
  function sameFunctionOrValue(validator, value1, value2) {
    return areSameFunction(validator, value1, value2) ? true : value1 === value2;
  }
  function textShadow(validator, value1, value2) {
    if (!understandable(validator, value1, value2, 0, true) && !(validator.isUnit(value2) || validator.isColor(value2) || validator.isGlobal(value2))) {
      return false;
    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
      return true;
    }
    return validator.isUnit(value2) || validator.isColor(value2) || validator.isGlobal(value2);
  }
  function time(validator, value1, value2) {
    if (!understandable(validator, value1, value2, 0, true) && !validator.isTime(value2)) {
      return false;
    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
      return true;
    } else if (validator.isTime(value1) && !validator.isTime(value2)) {
      return false;
    } else if (validator.isTime(value2)) {
      return true;
    } else if (validator.isTime(value1)) {
      return false;
    } else if (validator.isFunction(value1) && !validator.isPrefixed(value1) && validator.isFunction(value2) && !validator.isPrefixed(value2)) {
      return true;
    }
    return sameFunctionOrValue(validator, value1, value2);
  }
  function timingFunction(validator, value1, value2) {
    if (!understandable(validator, value1, value2, 0, true) && !(validator.isTimingFunction(value2) || validator.isGlobal(value2))) {
      return false;
    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
      return true;
    }
    return validator.isTimingFunction(value2) || validator.isGlobal(value2);
  }
  function unit(validator, value1, value2) {
    if (!understandable(validator, value1, value2, 0, true) && !validator.isUnit(value2)) {
      return false;
    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
      return true;
    } else if (validator.isUnit(value1) && !validator.isUnit(value2)) {
      return false;
    } else if (validator.isUnit(value2)) {
      return true;
    } else if (validator.isUnit(value1)) {
      return false;
    } else if (validator.isFunction(value1) && !validator.isPrefixed(value1) && validator.isFunction(value2) && !validator.isPrefixed(value2)) {
      return true;
    }
    return sameFunctionOrValue(validator, value1, value2);
  }
  function unitOrKeywordWithGlobal(propertyName) {
    var byKeyword = keywordWithGlobal(propertyName);
    return function (validator, value1, value2) {
      return unit(validator, value1, value2) || byKeyword(validator, value1, value2);
    };
  }
  function unitOrNumber(validator, value1, value2) {
    if (!understandable(validator, value1, value2, 0, true) && !(validator.isUnit(value2) || validator.isNumber(value2))) {
      return false;
    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
      return true;
    } else if ((validator.isUnit(value1) || validator.isNumber(value1)) && !(validator.isUnit(value2) || validator.isNumber(value2))) {
      return false;
    } else if (validator.isUnit(value2) || validator.isNumber(value2)) {
      return true;
    } else if (validator.isUnit(value1) || validator.isNumber(value1)) {
      return false;
    } else if (validator.isFunction(value1) && !validator.isPrefixed(value1) && validator.isFunction(value2) && !validator.isPrefixed(value2)) {
      return true;
    }
    return sameFunctionOrValue(validator, value1, value2);
  }
  function zIndex(validator, value1, value2) {
    if (!understandable(validator, value1, value2, 0, true) && !validator.isZIndex(value2)) {
      return false;
    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {
      return true;
    }
    return validator.isZIndex(value2);
  }
  canOverride = {
    generic: {
      color: color,
      components: components,
      image: image,
      propertyName: propertyName,
      time: time,
      timingFunction: timingFunction,
      unit: unit,
      unitOrNumber: unitOrNumber
    },
    property: {
      animationDirection: keywordWithGlobal('animation-direction'),
      animationFillMode: keyword('animation-fill-mode'),
      animationIterationCount: animationIterationCount,
      animationName: animationName,
      animationPlayState: keywordWithGlobal('animation-play-state'),
      backgroundAttachment: keyword('background-attachment'),
      backgroundClip: keywordWithGlobal('background-clip'),
      backgroundOrigin: keyword('background-origin'),
      backgroundPosition: backgroundPosition,
      backgroundRepeat: keyword('background-repeat'),
      backgroundSize: backgroundSize,
      bottom: unitOrKeywordWithGlobal('bottom'),
      borderCollapse: keyword('border-collapse'),
      borderStyle: keywordWithGlobal('*-style'),
      clear: keywordWithGlobal('clear'),
      cursor: keywordWithGlobal('cursor'),
      display: keywordWithGlobal('display'),
      float: keywordWithGlobal('float'),
      left: unitOrKeywordWithGlobal('left'),
      fontFamily: fontFamily,
      fontStretch: keywordWithGlobal('font-stretch'),
      fontStyle: keywordWithGlobal('font-style'),
      fontVariant: keywordWithGlobal('font-variant'),
      fontWeight: keywordWithGlobal('font-weight'),
      listStyleType: keywordWithGlobal('list-style-type'),
      listStylePosition: keywordWithGlobal('list-style-position'),
      outlineStyle: keywordWithGlobal('*-style'),
      overflow: keywordWithGlobal('overflow'),
      position: keywordWithGlobal('position'),
      right: unitOrKeywordWithGlobal('right'),
      textAlign: keywordWithGlobal('text-align'),
      textDecoration: keywordWithGlobal('text-decoration'),
      textOverflow: keywordWithGlobal('text-overflow'),
      textShadow: textShadow,
      top: unitOrKeywordWithGlobal('top'),
      transform: sameFunctionOrValue,
      verticalAlign: unitOrKeywordWithGlobal('vertical-align'),
      visibility: keywordWithGlobal('visibility'),
      whiteSpace: keywordWithGlobal('white-space'),
      zIndex: zIndex
    }
  };
  return canOverride;
}

var clone;
var hasRequiredClone;
function requireClone() {
  if (hasRequiredClone) return clone;
  hasRequiredClone = 1;
  var wrapSingle = requireWrapForOptimizing().single;
  var Token = requireToken();
  function deep(property) {
    var cloned = shallow(property);
    for (var i = property.components.length - 1; i >= 0; i--) {
      var component = shallow(property.components[i]);
      component.value = property.components[i].value.slice(0);
      cloned.components.unshift(component);
    }
    cloned.dirty = true;
    cloned.value = property.value.slice(0);
    return cloned;
  }
  function shallow(property) {
    var cloned = wrapSingle([Token.PROPERTY, [Token.PROPERTY_NAME, property.name]]);
    cloned.important = property.important;
    cloned.hack = property.hack;
    cloned.unused = false;
    return cloned;
  }
  clone = {
    deep: deep,
    shallow: shallow
  };
  return clone;
}

var restore;
var hasRequiredRestore;
function requireRestore() {
  if (hasRequiredRestore) return restore;
  hasRequiredRestore = 1;
  var shallowClone = requireClone().shallow;
  var Token = requireToken();
  var Marker = requireMarker();
  function isInheritOnly(values) {
    for (var i = 0, l = values.length; i < l; i++) {
      var value = values[i][1];
      if (value != 'inherit' && value != Marker.COMMA && value != Marker.FORWARD_SLASH) return false;
    }
    return true;
  }
  function background(property, compactable, lastInMultiplex) {
    var components = property.components;
    var restored = [];
    var needsOne, needsBoth;
    function restoreValue(component) {
      Array.prototype.unshift.apply(restored, component.value);
    }
    function isDefaultValue(component) {
      var descriptor = compactable[component.name];
      if (descriptor.doubleValues && descriptor.defaultValue.length == 1) {
        return component.value[0][1] == descriptor.defaultValue[0] && (component.value[1] ? component.value[1][1] == descriptor.defaultValue[0] : true);
      } else if (descriptor.doubleValues && descriptor.defaultValue.length != 1) {
        return component.value[0][1] == descriptor.defaultValue[0] && (component.value[1] ? component.value[1][1] : component.value[0][1]) == descriptor.defaultValue[1];
      } else {
        return component.value[0][1] == descriptor.defaultValue;
      }
    }
    for (var i = components.length - 1; i >= 0; i--) {
      var component = components[i];
      var isDefault = isDefaultValue(component);
      if (component.name == 'background-clip') {
        var originComponent = components[i - 1];
        var isOriginDefault = isDefaultValue(originComponent);
        needsOne = component.value[0][1] == originComponent.value[0][1];
        needsBoth = !needsOne && (isOriginDefault && !isDefault || !isOriginDefault && !isDefault || !isOriginDefault && isDefault && component.value[0][1] != originComponent.value[0][1]);
        if (needsOne) {
          restoreValue(originComponent);
        } else if (needsBoth) {
          restoreValue(component);
          restoreValue(originComponent);
        }
        i--;
      } else if (component.name == 'background-size') {
        var positionComponent = components[i - 1];
        var isPositionDefault = isDefaultValue(positionComponent);
        needsOne = !isPositionDefault && isDefault;
        needsBoth = !needsOne && (isPositionDefault && !isDefault || !isPositionDefault && !isDefault);
        if (needsOne) {
          restoreValue(positionComponent);
        } else if (needsBoth) {
          restoreValue(component);
          restored.unshift([Token.PROPERTY_VALUE, Marker.FORWARD_SLASH]);
          restoreValue(positionComponent);
        } else if (positionComponent.value.length == 1) {
          restoreValue(positionComponent);
        }
        i--;
      } else {
        if (isDefault || compactable[component.name].multiplexLastOnly && !lastInMultiplex) continue;
        restoreValue(component);
      }
    }
    if (restored.length === 0 && property.value.length == 1 && property.value[0][1] == '0') restored.push(property.value[0]);
    if (restored.length === 0) restored.push([Token.PROPERTY_VALUE, compactable[property.name].defaultValue]);
    if (isInheritOnly(restored)) return [restored[0]];
    return restored;
  }
  function borderRadius(property, compactable) {
    if (property.multiplex) {
      var horizontal = shallowClone(property);
      var vertical = shallowClone(property);
      for (var i = 0; i < 4; i++) {
        var component = property.components[i];
        var horizontalComponent = shallowClone(property);
        horizontalComponent.value = [component.value[0]];
        horizontal.components.push(horizontalComponent);
        var verticalComponent = shallowClone(property);
        // FIXME: only shorthand compactor (see breakup#borderRadius) knows that border radius
        // longhands have two values, whereas tokenizer does not care about populating 2nd value
        // if it's missing, hence this fallback
        verticalComponent.value = [component.value[1] || component.value[0]];
        vertical.components.push(verticalComponent);
      }
      var horizontalValues = fourValues(horizontal);
      var verticalValues = fourValues(vertical);
      if (horizontalValues.length == verticalValues.length && horizontalValues[0][1] == verticalValues[0][1] && (horizontalValues.length > 1 ? horizontalValues[1][1] == verticalValues[1][1] : true) && (horizontalValues.length > 2 ? horizontalValues[2][1] == verticalValues[2][1] : true) && (horizontalValues.length > 3 ? horizontalValues[3][1] == verticalValues[3][1] : true)) {
        return horizontalValues;
      } else {
        return horizontalValues.concat([[Token.PROPERTY_VALUE, Marker.FORWARD_SLASH]]).concat(verticalValues);
      }
    } else {
      return fourValues(property);
    }
  }
  function font(property, compactable) {
    var components = property.components;
    var restored = [];
    var component;
    var componentIndex = 0;
    var fontFamilyIndex = 0;
    if (property.value[0][1].indexOf(Marker.INTERNAL) === 0) {
      property.value[0][1] = property.value[0][1].substring(Marker.INTERNAL.length);
      return property.value;
    }

    // first four components are optional
    while (componentIndex < 4) {
      component = components[componentIndex];
      if (component.value[0][1] != compactable[component.name].defaultValue) {
        Array.prototype.push.apply(restored, component.value);
      }
      componentIndex++;
    }

    // then comes font-size
    Array.prototype.push.apply(restored, components[componentIndex].value);
    componentIndex++;

    // then may come line-height
    if (components[componentIndex].value[0][1] != compactable[components[componentIndex].name].defaultValue) {
      Array.prototype.push.apply(restored, [[Token.PROPERTY_VALUE, Marker.FORWARD_SLASH]]);
      Array.prototype.push.apply(restored, components[componentIndex].value);
    }
    componentIndex++;

    // then comes font-family
    while (components[componentIndex].value[fontFamilyIndex]) {
      restored.push(components[componentIndex].value[fontFamilyIndex]);
      if (components[componentIndex].value[fontFamilyIndex + 1]) {
        restored.push([Token.PROPERTY_VALUE, Marker.COMMA]);
      }
      fontFamilyIndex++;
    }
    if (isInheritOnly(restored)) {
      return [restored[0]];
    }
    return restored;
  }
  function fourValues(property) {
    var components = property.components;
    var value1 = components[0].value[0];
    var value2 = components[1].value[0];
    var value3 = components[2].value[0];
    var value4 = components[3].value[0];
    if (value1[1] == value2[1] && value1[1] == value3[1] && value1[1] == value4[1]) {
      return [value1];
    } else if (value1[1] == value3[1] && value2[1] == value4[1]) {
      return [value1, value2];
    } else if (value2[1] == value4[1]) {
      return [value1, value2, value3];
    } else {
      return [value1, value2, value3, value4];
    }
  }
  function multiplex(restoreWith) {
    return function (property, compactable) {
      if (!property.multiplex) return restoreWith(property, compactable, true);
      var multiplexSize = 0;
      var restored = [];
      var componentMultiplexSoFar = {};
      var i, l;

      // At this point we don't know what's the multiplex size, e.g. how many background layers are there
      for (i = 0, l = property.components[0].value.length; i < l; i++) {
        if (property.components[0].value[i][1] == Marker.COMMA) multiplexSize++;
      }
      for (i = 0; i <= multiplexSize; i++) {
        var _property = shallowClone(property);

        // We split multiplex into parts and restore them one by one
        for (var j = 0, m = property.components.length; j < m; j++) {
          var componentToClone = property.components[j];
          var _component = shallowClone(componentToClone);
          _property.components.push(_component);

          // The trick is some properties has more than one value, so we iterate over values looking for
          // a multiplex separator - a comma
          for (var k = componentMultiplexSoFar[_component.name] || 0, n = componentToClone.value.length; k < n; k++) {
            if (componentToClone.value[k][1] == Marker.COMMA) {
              componentMultiplexSoFar[_component.name] = k + 1;
              break;
            }
            _component.value.push(componentToClone.value[k]);
          }
        }

        // No we can restore shorthand value
        var lastInMultiplex = i == multiplexSize;
        var _restored = restoreWith(_property, compactable, lastInMultiplex);
        Array.prototype.push.apply(restored, _restored);
        if (i < multiplexSize) restored.push([Token.PROPERTY_VALUE, Marker.COMMA]);
      }
      return restored;
    };
  }
  function withoutDefaults(property, compactable) {
    var components = property.components;
    var restored = [];
    for (var i = components.length - 1; i >= 0; i--) {
      var component = components[i];
      var descriptor = compactable[component.name];
      if (component.value[0][1] != descriptor.defaultValue || 'keepUnlessDefault' in descriptor && !isDefault(components, compactable, descriptor.keepUnlessDefault)) {
        restored.unshift(component.value[0]);
      }
    }
    if (restored.length === 0) restored.push([Token.PROPERTY_VALUE, compactable[property.name].defaultValue]);
    if (isInheritOnly(restored)) return [restored[0]];
    return restored;
  }
  function isDefault(components, compactable, propertyName) {
    var component;
    var i, l;
    for (i = 0, l = components.length; i < l; i++) {
      component = components[i];
      if (component.name == propertyName && component.value[0][1] == compactable[propertyName].defaultValue) {
        return true;
      }
    }
    return false;
  }
  restore = {
    background: background,
    borderRadius: borderRadius,
    font: font,
    fourValues: fourValues,
    multiplex: multiplex,
    withoutDefaults: withoutDefaults
  };
  return restore;
}

var compactable_1;
var hasRequiredCompactable;
function requireCompactable() {
  if (hasRequiredCompactable) return compactable_1;
  hasRequiredCompactable = 1;
  // Contains the interpretation of CSS properties, as used by the property optimizer

  var breakUp = requireBreakUp();
  var canOverride = requireCanOverride();
  var restore = requireRestore();
  var override = requireOverride();

  // Properties to process
  // Extend this object in order to add support for more properties in the optimizer.
  //
  // Each key in this object represents a CSS property and should be an object.
  // Such an object contains properties that describe how the represented CSS property should be handled.
  // Possible options:
  //
  // * components: array (Only specify for shorthand properties.)
  //   Contains the names of the granular properties this shorthand compacts.
  //
  // * canOverride: function
  //   Returns whether two tokens of this property can be merged with each other.
  //   This property has no meaning for shorthands.
  //
  // * defaultValue: string
  //   Specifies the default value of the property according to the CSS standard.
  //   For shorthand, this is used when every component is set to its default value, therefore it should be the shortest possible default value of all the components.
  //
  // * shortestValue: string
  //   Specifies the shortest possible value the property can possibly have.
  //   (Falls back to defaultValue if unspecified.)
  //
  // * breakUp: function (Only specify for shorthand properties.)
  //   Breaks the shorthand up to its components.
  //
  // * restore: function (Only specify for shorthand properties.)
  //   Puts the shorthand together from its components.
  //
  var compactable = {
    'animation': {
      canOverride: canOverride.generic.components([canOverride.generic.time, canOverride.generic.timingFunction, canOverride.generic.time, canOverride.property.animationIterationCount, canOverride.property.animationDirection, canOverride.property.animationFillMode, canOverride.property.animationPlayState, canOverride.property.animationName]),
      components: ['animation-duration', 'animation-timing-function', 'animation-delay', 'animation-iteration-count', 'animation-direction', 'animation-fill-mode', 'animation-play-state', 'animation-name'],
      breakUp: breakUp.multiplex(breakUp.animation),
      defaultValue: 'none',
      restore: restore.multiplex(restore.withoutDefaults),
      shorthand: true,
      vendorPrefixes: ['-moz-', '-o-', '-webkit-']
    },
    'animation-delay': {
      canOverride: canOverride.generic.time,
      componentOf: ['animation'],
      defaultValue: '0s',
      intoMultiplexMode: 'real',
      vendorPrefixes: ['-moz-', '-o-', '-webkit-']
    },
    'animation-direction': {
      canOverride: canOverride.property.animationDirection,
      componentOf: ['animation'],
      defaultValue: 'normal',
      intoMultiplexMode: 'real',
      vendorPrefixes: ['-moz-', '-o-', '-webkit-']
    },
    'animation-duration': {
      canOverride: canOverride.generic.time,
      componentOf: ['animation'],
      defaultValue: '0s',
      intoMultiplexMode: 'real',
      keepUnlessDefault: 'animation-delay',
      vendorPrefixes: ['-moz-', '-o-', '-webkit-']
    },
    'animation-fill-mode': {
      canOverride: canOverride.property.animationFillMode,
      componentOf: ['animation'],
      defaultValue: 'none',
      intoMultiplexMode: 'real',
      vendorPrefixes: ['-moz-', '-o-', '-webkit-']
    },
    'animation-iteration-count': {
      canOverride: canOverride.property.animationIterationCount,
      componentOf: ['animation'],
      defaultValue: '1',
      intoMultiplexMode: 'real',
      vendorPrefixes: ['-moz-', '-o-', '-webkit-']
    },
    'animation-name': {
      canOverride: canOverride.property.animationName,
      componentOf: ['animation'],
      defaultValue: 'none',
      intoMultiplexMode: 'real',
      vendorPrefixes: ['-moz-', '-o-', '-webkit-']
    },
    'animation-play-state': {
      canOverride: canOverride.property.animationPlayState,
      componentOf: ['animation'],
      defaultValue: 'running',
      intoMultiplexMode: 'real',
      vendorPrefixes: ['-moz-', '-o-', '-webkit-']
    },
    'animation-timing-function': {
      canOverride: canOverride.generic.timingFunction,
      componentOf: ['animation'],
      defaultValue: 'ease',
      intoMultiplexMode: 'real',
      vendorPrefixes: ['-moz-', '-o-', '-webkit-']
    },
    'background': {
      canOverride: canOverride.generic.components([canOverride.generic.image, canOverride.property.backgroundPosition, canOverride.property.backgroundSize, canOverride.property.backgroundRepeat, canOverride.property.backgroundAttachment, canOverride.property.backgroundOrigin, canOverride.property.backgroundClip, canOverride.generic.color]),
      components: ['background-image', 'background-position', 'background-size', 'background-repeat', 'background-attachment', 'background-origin', 'background-clip', 'background-color'],
      breakUp: breakUp.multiplex(breakUp.background),
      defaultValue: '0 0',
      restore: restore.multiplex(restore.background),
      shortestValue: '0',
      shorthand: true
    },
    'background-attachment': {
      canOverride: canOverride.property.backgroundAttachment,
      componentOf: ['background'],
      defaultValue: 'scroll',
      intoMultiplexMode: 'real'
    },
    'background-clip': {
      canOverride: canOverride.property.backgroundClip,
      componentOf: ['background'],
      defaultValue: 'border-box',
      intoMultiplexMode: 'real',
      shortestValue: 'border-box'
    },
    'background-color': {
      canOverride: canOverride.generic.color,
      componentOf: ['background'],
      defaultValue: 'transparent',
      intoMultiplexMode: 'real',
      // otherwise real color will turn into default since color appears in last multiplex only
      multiplexLastOnly: true,
      nonMergeableValue: 'none',
      shortestValue: 'red'
    },
    'background-image': {
      canOverride: canOverride.generic.image,
      componentOf: ['background'],
      defaultValue: 'none',
      intoMultiplexMode: 'default'
    },
    'background-origin': {
      canOverride: canOverride.property.backgroundOrigin,
      componentOf: ['background'],
      defaultValue: 'padding-box',
      intoMultiplexMode: 'real',
      shortestValue: 'border-box'
    },
    'background-position': {
      canOverride: canOverride.property.backgroundPosition,
      componentOf: ['background'],
      defaultValue: ['0', '0'],
      doubleValues: true,
      intoMultiplexMode: 'real',
      shortestValue: '0'
    },
    'background-repeat': {
      canOverride: canOverride.property.backgroundRepeat,
      componentOf: ['background'],
      defaultValue: ['repeat'],
      doubleValues: true,
      intoMultiplexMode: 'real'
    },
    'background-size': {
      canOverride: canOverride.property.backgroundSize,
      componentOf: ['background'],
      defaultValue: ['auto'],
      doubleValues: true,
      intoMultiplexMode: 'real',
      shortestValue: '0 0'
    },
    'bottom': {
      canOverride: canOverride.property.bottom,
      defaultValue: 'auto'
    },
    'border': {
      breakUp: breakUp.border,
      canOverride: canOverride.generic.components([canOverride.generic.unit, canOverride.property.borderStyle, canOverride.generic.color]),
      components: ['border-width', 'border-style', 'border-color'],
      defaultValue: 'none',
      overridesShorthands: ['border-bottom', 'border-left', 'border-right', 'border-top'],
      restore: restore.withoutDefaults,
      shorthand: true,
      shorthandComponents: true
    },
    'border-bottom': {
      breakUp: breakUp.border,
      canOverride: canOverride.generic.components([canOverride.generic.unit, canOverride.property.borderStyle, canOverride.generic.color]),
      components: ['border-bottom-width', 'border-bottom-style', 'border-bottom-color'],
      defaultValue: 'none',
      restore: restore.withoutDefaults,
      shorthand: true
    },
    'border-bottom-color': {
      canOverride: canOverride.generic.color,
      componentOf: ['border-bottom', 'border-color'],
      defaultValue: 'none'
    },
    'border-bottom-left-radius': {
      canOverride: canOverride.generic.unit,
      componentOf: ['border-radius'],
      defaultValue: '0',
      vendorPrefixes: ['-moz-', '-o-']
    },
    'border-bottom-right-radius': {
      canOverride: canOverride.generic.unit,
      componentOf: ['border-radius'],
      defaultValue: '0',
      vendorPrefixes: ['-moz-', '-o-']
    },
    'border-bottom-style': {
      canOverride: canOverride.property.borderStyle,
      componentOf: ['border-bottom', 'border-style'],
      defaultValue: 'none'
    },
    'border-bottom-width': {
      canOverride: canOverride.generic.unit,
      componentOf: ['border-bottom', 'border-width'],
      defaultValue: 'medium',
      oppositeTo: 'border-top-width',
      shortestValue: '0'
    },
    'border-collapse': {
      canOverride: canOverride.property.borderCollapse,
      defaultValue: 'separate'
    },
    'border-color': {
      breakUp: breakUp.fourValues,
      canOverride: canOverride.generic.components([canOverride.generic.color, canOverride.generic.color, canOverride.generic.color, canOverride.generic.color]),
      componentOf: ['border'],
      components: ['border-top-color', 'border-right-color', 'border-bottom-color', 'border-left-color'],
      defaultValue: 'none',
      restore: restore.fourValues,
      shortestValue: 'red',
      shorthand: true
    },
    'border-left': {
      breakUp: breakUp.border,
      canOverride: canOverride.generic.components([canOverride.generic.unit, canOverride.property.borderStyle, canOverride.generic.color]),
      components: ['border-left-width', 'border-left-style', 'border-left-color'],
      defaultValue: 'none',
      restore: restore.withoutDefaults,
      shorthand: true
    },
    'border-left-color': {
      canOverride: canOverride.generic.color,
      componentOf: ['border-color', 'border-left'],
      defaultValue: 'none'
    },
    'border-left-style': {
      canOverride: canOverride.property.borderStyle,
      componentOf: ['border-left', 'border-style'],
      defaultValue: 'none'
    },
    'border-left-width': {
      canOverride: canOverride.generic.unit,
      componentOf: ['border-left', 'border-width'],
      defaultValue: 'medium',
      oppositeTo: 'border-right-width',
      shortestValue: '0'
    },
    'border-radius': {
      breakUp: breakUp.borderRadius,
      canOverride: canOverride.generic.components([canOverride.generic.unit, canOverride.generic.unit, canOverride.generic.unit, canOverride.generic.unit]),
      components: ['border-top-left-radius', 'border-top-right-radius', 'border-bottom-right-radius', 'border-bottom-left-radius'],
      defaultValue: '0',
      restore: restore.borderRadius,
      shorthand: true,
      vendorPrefixes: ['-moz-', '-o-']
    },
    'border-right': {
      breakUp: breakUp.border,
      canOverride: canOverride.generic.components([canOverride.generic.unit, canOverride.property.borderStyle, canOverride.generic.color]),
      components: ['border-right-width', 'border-right-style', 'border-right-color'],
      defaultValue: 'none',
      restore: restore.withoutDefaults,
      shorthand: true
    },
    'border-right-color': {
      canOverride: canOverride.generic.color,
      componentOf: ['border-color', 'border-right'],
      defaultValue: 'none'
    },
    'border-right-style': {
      canOverride: canOverride.property.borderStyle,
      componentOf: ['border-right', 'border-style'],
      defaultValue: 'none'
    },
    'border-right-width': {
      canOverride: canOverride.generic.unit,
      componentOf: ['border-right', 'border-width'],
      defaultValue: 'medium',
      oppositeTo: 'border-left-width',
      shortestValue: '0'
    },
    'border-style': {
      breakUp: breakUp.fourValues,
      canOverride: canOverride.generic.components([canOverride.property.borderStyle, canOverride.property.borderStyle, canOverride.property.borderStyle, canOverride.property.borderStyle]),
      componentOf: ['border'],
      components: ['border-top-style', 'border-right-style', 'border-bottom-style', 'border-left-style'],
      defaultValue: 'none',
      restore: restore.fourValues,
      shorthand: true
    },
    'border-top': {
      breakUp: breakUp.border,
      canOverride: canOverride.generic.components([canOverride.generic.unit, canOverride.property.borderStyle, canOverride.generic.color]),
      components: ['border-top-width', 'border-top-style', 'border-top-color'],
      defaultValue: 'none',
      restore: restore.withoutDefaults,
      shorthand: true
    },
    'border-top-color': {
      canOverride: canOverride.generic.color,
      componentOf: ['border-color', 'border-top'],
      defaultValue: 'none'
    },
    'border-top-left-radius': {
      canOverride: canOverride.generic.unit,
      componentOf: ['border-radius'],
      defaultValue: '0',
      vendorPrefixes: ['-moz-', '-o-']
    },
    'border-top-right-radius': {
      canOverride: canOverride.generic.unit,
      componentOf: ['border-radius'],
      defaultValue: '0',
      vendorPrefixes: ['-moz-', '-o-']
    },
    'border-top-style': {
      canOverride: canOverride.property.borderStyle,
      componentOf: ['border-style', 'border-top'],
      defaultValue: 'none'
    },
    'border-top-width': {
      canOverride: canOverride.generic.unit,
      componentOf: ['border-top', 'border-width'],
      defaultValue: 'medium',
      oppositeTo: 'border-bottom-width',
      shortestValue: '0'
    },
    'border-width': {
      breakUp: breakUp.fourValues,
      canOverride: canOverride.generic.components([canOverride.generic.unit, canOverride.generic.unit, canOverride.generic.unit, canOverride.generic.unit]),
      componentOf: ['border'],
      components: ['border-top-width', 'border-right-width', 'border-bottom-width', 'border-left-width'],
      defaultValue: 'medium',
      restore: restore.fourValues,
      shortestValue: '0',
      shorthand: true
    },
    'clear': {
      canOverride: canOverride.property.clear,
      defaultValue: 'none'
    },
    'color': {
      canOverride: canOverride.generic.color,
      defaultValue: 'transparent',
      shortestValue: 'red'
    },
    'cursor': {
      canOverride: canOverride.property.cursor,
      defaultValue: 'auto'
    },
    'display': {
      canOverride: canOverride.property.display
    },
    'float': {
      canOverride: canOverride.property.float,
      defaultValue: 'none'
    },
    'font': {
      breakUp: breakUp.font,
      canOverride: canOverride.generic.components([canOverride.property.fontStyle, canOverride.property.fontVariant, canOverride.property.fontWeight, canOverride.property.fontStretch, canOverride.generic.unit, canOverride.generic.unit, canOverride.property.fontFamily]),
      components: ['font-style', 'font-variant', 'font-weight', 'font-stretch', 'font-size', 'line-height', 'font-family'],
      restore: restore.font,
      shorthand: true
    },
    'font-family': {
      canOverride: canOverride.property.fontFamily,
      defaultValue: 'user|agent|specific'
    },
    'font-size': {
      canOverride: canOverride.generic.unit,
      defaultValue: 'medium',
      shortestValue: '0'
    },
    'font-stretch': {
      canOverride: canOverride.property.fontStretch,
      defaultValue: 'normal'
    },
    'font-style': {
      canOverride: canOverride.property.fontStyle,
      defaultValue: 'normal'
    },
    'font-variant': {
      canOverride: canOverride.property.fontVariant,
      defaultValue: 'normal'
    },
    'font-weight': {
      canOverride: canOverride.property.fontWeight,
      defaultValue: 'normal',
      shortestValue: '400'
    },
    'height': {
      canOverride: canOverride.generic.unit,
      defaultValue: 'auto',
      shortestValue: '0'
    },
    'left': {
      canOverride: canOverride.property.left,
      defaultValue: 'auto'
    },
    'line-height': {
      canOverride: canOverride.generic.unitOrNumber,
      defaultValue: 'normal',
      shortestValue: '0'
    },
    'list-style': {
      canOverride: canOverride.generic.components([canOverride.property.listStyleType, canOverride.property.listStylePosition, canOverride.property.listStyleImage]),
      components: ['list-style-type', 'list-style-position', 'list-style-image'],
      breakUp: breakUp.listStyle,
      restore: restore.withoutDefaults,
      defaultValue: 'outside',
      // can't use 'disc' because that'd override default 'decimal' for <ol>
      shortestValue: 'none',
      shorthand: true
    },
    'list-style-image': {
      canOverride: canOverride.generic.image,
      componentOf: ['list-style'],
      defaultValue: 'none'
    },
    'list-style-position': {
      canOverride: canOverride.property.listStylePosition,
      componentOf: ['list-style'],
      defaultValue: 'outside',
      shortestValue: 'inside'
    },
    'list-style-type': {
      canOverride: canOverride.property.listStyleType,
      componentOf: ['list-style'],
      // NOTE: we can't tell the real default value here, it's 'disc' for <ul> and 'decimal' for <ol>
      // this is a hack, but it doesn't matter because this value will be either overridden or
      // it will disappear at the final step anyway
      defaultValue: 'decimal|disc',
      shortestValue: 'none'
    },
    'margin': {
      breakUp: breakUp.fourValues,
      canOverride: canOverride.generic.components([canOverride.generic.unit, canOverride.generic.unit, canOverride.generic.unit, canOverride.generic.unit]),
      components: ['margin-top', 'margin-right', 'margin-bottom', 'margin-left'],
      defaultValue: '0',
      restore: restore.fourValues,
      shorthand: true
    },
    'margin-bottom': {
      canOverride: canOverride.generic.unit,
      componentOf: ['margin'],
      defaultValue: '0',
      oppositeTo: 'margin-top'
    },
    'margin-left': {
      canOverride: canOverride.generic.unit,
      componentOf: ['margin'],
      defaultValue: '0',
      oppositeTo: 'margin-right'
    },
    'margin-right': {
      canOverride: canOverride.generic.unit,
      componentOf: ['margin'],
      defaultValue: '0',
      oppositeTo: 'margin-left'
    },
    'margin-top': {
      canOverride: canOverride.generic.unit,
      componentOf: ['margin'],
      defaultValue: '0',
      oppositeTo: 'margin-bottom'
    },
    'outline': {
      canOverride: canOverride.generic.components([canOverride.generic.color, canOverride.property.outlineStyle, canOverride.generic.unit]),
      components: ['outline-color', 'outline-style', 'outline-width'],
      breakUp: breakUp.outline,
      restore: restore.withoutDefaults,
      defaultValue: '0',
      shorthand: true
    },
    'outline-color': {
      canOverride: canOverride.generic.color,
      componentOf: ['outline'],
      defaultValue: 'invert',
      shortestValue: 'red'
    },
    'outline-style': {
      canOverride: canOverride.property.outlineStyle,
      componentOf: ['outline'],
      defaultValue: 'none'
    },
    'outline-width': {
      canOverride: canOverride.generic.unit,
      componentOf: ['outline'],
      defaultValue: 'medium',
      shortestValue: '0'
    },
    'overflow': {
      canOverride: canOverride.property.overflow,
      defaultValue: 'visible'
    },
    'overflow-x': {
      canOverride: canOverride.property.overflow,
      defaultValue: 'visible'
    },
    'overflow-y': {
      canOverride: canOverride.property.overflow,
      defaultValue: 'visible'
    },
    'padding': {
      breakUp: breakUp.fourValues,
      canOverride: canOverride.generic.components([canOverride.generic.unit, canOverride.generic.unit, canOverride.generic.unit, canOverride.generic.unit]),
      components: ['padding-top', 'padding-right', 'padding-bottom', 'padding-left'],
      defaultValue: '0',
      restore: restore.fourValues,
      shorthand: true
    },
    'padding-bottom': {
      canOverride: canOverride.generic.unit,
      componentOf: ['padding'],
      defaultValue: '0',
      oppositeTo: 'padding-top'
    },
    'padding-left': {
      canOverride: canOverride.generic.unit,
      componentOf: ['padding'],
      defaultValue: '0',
      oppositeTo: 'padding-right'
    },
    'padding-right': {
      canOverride: canOverride.generic.unit,
      componentOf: ['padding'],
      defaultValue: '0',
      oppositeTo: 'padding-left'
    },
    'padding-top': {
      canOverride: canOverride.generic.unit,
      componentOf: ['padding'],
      defaultValue: '0',
      oppositeTo: 'padding-bottom'
    },
    'position': {
      canOverride: canOverride.property.position,
      defaultValue: 'static'
    },
    'right': {
      canOverride: canOverride.property.right,
      defaultValue: 'auto'
    },
    'text-align': {
      canOverride: canOverride.property.textAlign,
      // NOTE: we can't tell the real default value here, as it depends on default text direction
      // this is a hack, but it doesn't matter because this value will be either overridden or
      // it will disappear anyway
      defaultValue: 'left|right'
    },
    'text-decoration': {
      canOverride: canOverride.property.textDecoration,
      defaultValue: 'none'
    },
    'text-overflow': {
      canOverride: canOverride.property.textOverflow,
      defaultValue: 'none'
    },
    'text-shadow': {
      canOverride: canOverride.property.textShadow,
      defaultValue: 'none'
    },
    'top': {
      canOverride: canOverride.property.top,
      defaultValue: 'auto'
    },
    'transform': {
      canOverride: canOverride.property.transform,
      vendorPrefixes: ['-moz-', '-ms-', '-webkit-']
    },
    'transition': {
      breakUp: breakUp.multiplex(breakUp.transition),
      canOverride: canOverride.generic.components([canOverride.property.transitionProperty, canOverride.generic.time, canOverride.generic.timingFunction, canOverride.generic.time]),
      components: ['transition-property', 'transition-duration', 'transition-timing-function', 'transition-delay'],
      defaultValue: 'none',
      restore: restore.multiplex(restore.withoutDefaults),
      shorthand: true,
      vendorPrefixes: ['-moz-', '-o-', '-webkit-']
    },
    'transition-delay': {
      canOverride: canOverride.generic.time,
      componentOf: ['transition'],
      defaultValue: '0s',
      intoMultiplexMode: 'real',
      vendorPrefixes: ['-moz-', '-o-', '-webkit-']
    },
    'transition-duration': {
      canOverride: canOverride.generic.time,
      componentOf: ['transition'],
      defaultValue: '0s',
      intoMultiplexMode: 'real',
      vendorPrefixes: ['-moz-', '-o-', '-webkit-']
    },
    'transition-property': {
      canOverride: canOverride.generic.propertyName,
      componentOf: ['transition'],
      defaultValue: 'all',
      intoMultiplexMode: 'placeholder',
      placeholderValue: '_',
      // it's a short value that won't match any property and still be a valid `transition-property`
      vendorPrefixes: ['-moz-', '-o-', '-webkit-']
    },
    'transition-timing-function': {
      canOverride: canOverride.generic.timingFunction,
      componentOf: ['transition'],
      defaultValue: 'ease',
      intoMultiplexMode: 'real',
      vendorPrefixes: ['-moz-', '-o-', '-webkit-']
    },
    'vertical-align': {
      canOverride: canOverride.property.verticalAlign,
      defaultValue: 'baseline'
    },
    'visibility': {
      canOverride: canOverride.property.visibility,
      defaultValue: 'visible'
    },
    'white-space': {
      canOverride: canOverride.property.whiteSpace,
      defaultValue: 'normal'
    },
    'width': {
      canOverride: canOverride.generic.unit,
      defaultValue: 'auto',
      shortestValue: '0'
    },
    'z-index': {
      canOverride: canOverride.property.zIndex,
      defaultValue: 'auto'
    }
  };
  function cloneDescriptor(propertyName, prefix) {
    var clonedDescriptor = override(compactable[propertyName], {});
    if ('componentOf' in clonedDescriptor) {
      clonedDescriptor.componentOf = clonedDescriptor.componentOf.map(function (shorthandName) {
        return prefix + shorthandName;
      });
    }
    if ('components' in clonedDescriptor) {
      clonedDescriptor.components = clonedDescriptor.components.map(function (longhandName) {
        return prefix + longhandName;
      });
    }
    if ('keepUnlessDefault' in clonedDescriptor) {
      clonedDescriptor.keepUnlessDefault = prefix + clonedDescriptor.keepUnlessDefault;
    }
    return clonedDescriptor;
  }

  // generate vendor-prefixed properties
  var vendorPrefixedCompactable = {};
  for (var propertyName in compactable) {
    var descriptor = compactable[propertyName];
    if (!('vendorPrefixes' in descriptor)) {
      continue;
    }
    for (var i = 0; i < descriptor.vendorPrefixes.length; i++) {
      var prefix = descriptor.vendorPrefixes[i];
      var clonedDescriptor = cloneDescriptor(propertyName, prefix);
      delete clonedDescriptor.vendorPrefixes;
      vendorPrefixedCompactable[prefix + propertyName] = clonedDescriptor;
    }
    delete descriptor.vendorPrefixes;
  }
  compactable_1 = override(compactable, vendorPrefixedCompactable);
  return compactable_1;
}

var populateComponents_1;
var hasRequiredPopulateComponents;
function requirePopulateComponents() {
  if (hasRequiredPopulateComponents) return populateComponents_1;
  hasRequiredPopulateComponents = 1;
  var compactable = requireCompactable();
  var InvalidPropertyError = requireInvalidPropertyError();
  function populateComponents(properties, validator, warnings) {
    var component;
    var j, m;
    for (var i = properties.length - 1; i >= 0; i--) {
      var property = properties[i];
      var descriptor = compactable[property.name];
      if (descriptor && descriptor.shorthand) {
        property.shorthand = true;
        property.dirty = true;
        try {
          property.components = descriptor.breakUp(property, compactable, validator);
          if (descriptor.shorthandComponents) {
            for (j = 0, m = property.components.length; j < m; j++) {
              component = property.components[j];
              component.components = compactable[component.name].breakUp(component, compactable, validator);
            }
          }
        } catch (e) {
          if (e instanceof InvalidPropertyError) {
            property.components = []; // this will set property.unused to true below
            warnings.push(e.message);
          } else {
            throw e;
          }
        }
        if (property.components.length > 0) property.multiplex = property.components[0].multiplex;else property.unused = true;
      }
    }
  }
  populateComponents_1 = populateComponents;
  return populateComponents_1;
}

var restoreWithComponents_1;
var hasRequiredRestoreWithComponents;
function requireRestoreWithComponents() {
  if (hasRequiredRestoreWithComponents) return restoreWithComponents_1;
  hasRequiredRestoreWithComponents = 1;
  var compactable = requireCompactable();
  function restoreWithComponents(property) {
    var descriptor = compactable[property.name];
    if (descriptor && descriptor.shorthand) {
      return descriptor.restore(property, compactable);
    } else {
      return property.value;
    }
  }
  restoreWithComponents_1 = restoreWithComponents;
  return restoreWithComponents_1;
}

var mergeIntoShorthands_1;
var hasRequiredMergeIntoShorthands;
function requireMergeIntoShorthands() {
  if (hasRequiredMergeIntoShorthands) return mergeIntoShorthands_1;
  hasRequiredMergeIntoShorthands = 1;
  var everyValuesPair = requireEveryValuesPair();
  var hasInherit = requireHasInherit();
  var populateComponents = requirePopulateComponents();
  var compactable = requireCompactable();
  var deepClone = requireClone().deep;
  var restoreWithComponents = requireRestoreWithComponents();
  var restoreFromOptimizing = requireRestoreFromOptimizing();
  var wrapSingle = requireWrapForOptimizing().single;
  var serializeBody = requireOneTime().body;
  var Token = requireToken();
  function mergeIntoShorthands(properties, validator) {
    var candidates = {};
    var descriptor;
    var componentOf;
    var property;
    var i, l;
    var j, m;

    // there is no shorthand property made up of less than 3 longhands
    if (properties.length < 3) {
      return;
    }
    for (i = 0, l = properties.length; i < l; i++) {
      property = properties[i];
      descriptor = compactable[property.name];
      if (property.unused) {
        continue;
      }
      if (property.hack) {
        continue;
      }
      if (property.block) {
        continue;
      }
      invalidateOrCompact(properties, i, candidates, validator);
      if (descriptor && descriptor.componentOf) {
        for (j = 0, m = descriptor.componentOf.length; j < m; j++) {
          componentOf = descriptor.componentOf[j];
          candidates[componentOf] = candidates[componentOf] || {};
          candidates[componentOf][property.name] = property;
        }
      }
    }
    invalidateOrCompact(properties, i, candidates, validator);
  }
  function invalidateOrCompact(properties, position, candidates, validator) {
    var invalidatedBy = properties[position];
    var shorthandName;
    var shorthandDescriptor;
    var candidateComponents;
    for (shorthandName in candidates) {
      if (undefined !== invalidatedBy && shorthandName == invalidatedBy.name) {
        continue;
      }
      shorthandDescriptor = compactable[shorthandName];
      candidateComponents = candidates[shorthandName];
      if (invalidatedBy && invalidates(candidates, shorthandName, invalidatedBy)) {
        delete candidates[shorthandName];
        continue;
      }
      if (shorthandDescriptor.components.length > Object.keys(candidateComponents).length) {
        continue;
      }
      if (mixedImportance(candidateComponents)) {
        continue;
      }
      if (!overridable(candidateComponents, shorthandName, validator)) {
        continue;
      }
      if (!mergeable(candidateComponents)) {
        continue;
      }
      if (mixedInherit(candidateComponents)) {
        replaceWithInheritBestFit(properties, candidateComponents, shorthandName, validator);
      } else {
        replaceWithShorthand(properties, candidateComponents, shorthandName, validator);
      }
    }
  }
  function invalidates(candidates, shorthandName, invalidatedBy) {
    var shorthandDescriptor = compactable[shorthandName];
    var invalidatedByDescriptor = compactable[invalidatedBy.name];
    var componentName;
    if ('overridesShorthands' in shorthandDescriptor && shorthandDescriptor.overridesShorthands.indexOf(invalidatedBy.name) > -1) {
      return true;
    }
    if (invalidatedByDescriptor && 'componentOf' in invalidatedByDescriptor) {
      for (componentName in candidates[shorthandName]) {
        if (invalidatedByDescriptor.componentOf.indexOf(componentName) > -1) {
          return true;
        }
      }
    }
    return false;
  }
  function mixedImportance(components) {
    var important;
    var componentName;
    for (componentName in components) {
      if (undefined !== important && components[componentName].important != important) {
        return true;
      }
      important = components[componentName].important;
    }
    return false;
  }
  function overridable(components, shorthandName, validator) {
    var descriptor = compactable[shorthandName];
    var newValuePlaceholder = [Token.PROPERTY, [Token.PROPERTY_NAME, shorthandName], [Token.PROPERTY_VALUE, descriptor.defaultValue]];
    var newProperty = wrapSingle(newValuePlaceholder);
    var component;
    var mayOverride;
    var i, l;
    populateComponents([newProperty], validator, []);
    for (i = 0, l = descriptor.components.length; i < l; i++) {
      component = components[descriptor.components[i]];
      mayOverride = compactable[component.name].canOverride;
      if (!everyValuesPair(mayOverride.bind(null, validator), newProperty.components[i], component)) {
        return false;
      }
    }
    return true;
  }
  function mergeable(components) {
    var lastCount = null;
    var currentCount;
    var componentName;
    var component;
    var descriptor;
    var values;
    for (componentName in components) {
      component = components[componentName];
      descriptor = compactable[componentName];
      if (!('restore' in descriptor)) {
        continue;
      }
      restoreFromOptimizing([component.all[component.position]], restoreWithComponents);
      values = descriptor.restore(component, compactable);
      currentCount = values.length;
      if (lastCount !== null && currentCount !== lastCount) {
        return false;
      }
      lastCount = currentCount;
    }
    return true;
  }
  function mixedInherit(components) {
    var componentName;
    var lastValue = null;
    var currentValue;
    for (componentName in components) {
      currentValue = hasInherit(components[componentName]);
      if (lastValue !== null && lastValue !== currentValue) {
        return true;
      }
      lastValue = currentValue;
    }
    return false;
  }
  function replaceWithInheritBestFit(properties, candidateComponents, shorthandName, validator) {
    var viaLonghands = buildSequenceWithInheritLonghands(candidateComponents, shorthandName, validator);
    var viaShorthand = buildSequenceWithInheritShorthand(candidateComponents, shorthandName, validator);
    var longhandTokensSequence = viaLonghands[0];
    var shorthandTokensSequence = viaShorthand[0];
    var isLonghandsShorter = serializeBody(longhandTokensSequence).length < serializeBody(shorthandTokensSequence).length;
    var newTokensSequence = isLonghandsShorter ? longhandTokensSequence : shorthandTokensSequence;
    var newProperty = isLonghandsShorter ? viaLonghands[1] : viaShorthand[1];
    var newComponents = isLonghandsShorter ? viaLonghands[2] : viaShorthand[2];
    var all = candidateComponents[Object.keys(candidateComponents)[0]].all;
    var componentName;
    var oldComponent;
    var newComponent;
    var newToken;
    newProperty.position = all.length;
    newProperty.shorthand = true;
    newProperty.dirty = true;
    newProperty.all = all;
    newProperty.all.push(newTokensSequence[0]);
    properties.push(newProperty);
    for (componentName in candidateComponents) {
      oldComponent = candidateComponents[componentName];
      oldComponent.unused = true;
      if (oldComponent.name in newComponents) {
        newComponent = newComponents[oldComponent.name];
        newToken = findTokenIn(newTokensSequence, componentName);
        newComponent.position = all.length;
        newComponent.all = all;
        newComponent.all.push(newToken);
        properties.push(newComponent);
      }
    }
  }
  function buildSequenceWithInheritLonghands(components, shorthandName, validator) {
    var tokensSequence = [];
    var inheritComponents = {};
    var nonInheritComponents = {};
    var descriptor = compactable[shorthandName];
    var shorthandToken = [Token.PROPERTY, [Token.PROPERTY_NAME, shorthandName], [Token.PROPERTY_VALUE, descriptor.defaultValue]];
    var newProperty = wrapSingle(shorthandToken);
    var component;
    var longhandToken;
    var newComponent;
    var nameMetadata;
    var i, l;
    populateComponents([newProperty], validator, []);
    for (i = 0, l = descriptor.components.length; i < l; i++) {
      component = components[descriptor.components[i]];
      if (hasInherit(component)) {
        longhandToken = component.all[component.position].slice(0, 2);
        Array.prototype.push.apply(longhandToken, component.value);
        tokensSequence.push(longhandToken);
        newComponent = deepClone(component);
        newComponent.value = inferComponentValue(components, newComponent.name);
        newProperty.components[i] = newComponent;
        inheritComponents[component.name] = deepClone(component);
      } else {
        newComponent = deepClone(component);
        newComponent.all = component.all;
        newProperty.components[i] = newComponent;
        nonInheritComponents[component.name] = component;
      }
    }
    nameMetadata = joinMetadata(nonInheritComponents, 1);
    shorthandToken[1].push(nameMetadata);
    restoreFromOptimizing([newProperty], restoreWithComponents);
    shorthandToken = shorthandToken.slice(0, 2);
    Array.prototype.push.apply(shorthandToken, newProperty.value);
    tokensSequence.unshift(shorthandToken);
    return [tokensSequence, newProperty, inheritComponents];
  }
  function inferComponentValue(components, propertyName) {
    var descriptor = compactable[propertyName];
    if ('oppositeTo' in descriptor) {
      return components[descriptor.oppositeTo].value;
    } else {
      return [[Token.PROPERTY_VALUE, descriptor.defaultValue]];
    }
  }
  function joinMetadata(components, at) {
    var metadata = [];
    var component;
    var originalValue;
    var componentMetadata;
    var componentName;
    for (componentName in components) {
      component = components[componentName];
      originalValue = component.all[component.position];
      componentMetadata = originalValue[at][originalValue[at].length - 1];
      Array.prototype.push.apply(metadata, componentMetadata);
    }
    return metadata.sort(metadataSorter);
  }
  function metadataSorter(metadata1, metadata2) {
    var line1 = metadata1[0];
    var line2 = metadata2[0];
    var column1 = metadata1[1];
    var column2 = metadata2[1];
    if (line1 < line2) {
      return -1;
    } else if (line1 === line2) {
      return column1 < column2 ? -1 : 1;
    } else {
      return 1;
    }
  }
  function buildSequenceWithInheritShorthand(components, shorthandName, validator) {
    var tokensSequence = [];
    var inheritComponents = {};
    var nonInheritComponents = {};
    var descriptor = compactable[shorthandName];
    var shorthandToken = [Token.PROPERTY, [Token.PROPERTY_NAME, shorthandName], [Token.PROPERTY_VALUE, 'inherit']];
    var newProperty = wrapSingle(shorthandToken);
    var component;
    var longhandToken;
    var nameMetadata;
    var valueMetadata;
    var i, l;
    populateComponents([newProperty], validator, []);
    for (i = 0, l = descriptor.components.length; i < l; i++) {
      component = components[descriptor.components[i]];
      if (hasInherit(component)) {
        inheritComponents[component.name] = component;
      } else {
        longhandToken = component.all[component.position].slice(0, 2);
        Array.prototype.push.apply(longhandToken, component.value);
        tokensSequence.push(longhandToken);
        nonInheritComponents[component.name] = deepClone(component);
      }
    }
    nameMetadata = joinMetadata(inheritComponents, 1);
    shorthandToken[1].push(nameMetadata);
    valueMetadata = joinMetadata(inheritComponents, 2);
    shorthandToken[2].push(valueMetadata);
    tokensSequence.unshift(shorthandToken);
    return [tokensSequence, newProperty, nonInheritComponents];
  }
  function findTokenIn(tokens, componentName) {
    var i, l;
    for (i = 0, l = tokens.length; i < l; i++) {
      if (tokens[i][1][1] == componentName) {
        return tokens[i];
      }
    }
  }
  function replaceWithShorthand(properties, candidateComponents, shorthandName, validator) {
    var descriptor = compactable[shorthandName];
    var nameMetadata;
    var valueMetadata;
    var newValuePlaceholder = [Token.PROPERTY, [Token.PROPERTY_NAME, shorthandName], [Token.PROPERTY_VALUE, descriptor.defaultValue]];
    var all;
    var newProperty = wrapSingle(newValuePlaceholder);
    newProperty.shorthand = true;
    newProperty.dirty = true;
    populateComponents([newProperty], validator, []);
    for (var i = 0, l = descriptor.components.length; i < l; i++) {
      var component = candidateComponents[descriptor.components[i]];
      newProperty.components[i] = deepClone(component);
      newProperty.important = component.important;
      all = component.all;
    }
    for (var componentName in candidateComponents) {
      candidateComponents[componentName].unused = true;
    }
    nameMetadata = joinMetadata(candidateComponents, 1);
    newValuePlaceholder[1].push(nameMetadata);
    valueMetadata = joinMetadata(candidateComponents, 2);
    newValuePlaceholder[2].push(valueMetadata);
    newProperty.position = all.length;
    newProperty.all = all;
    newProperty.all.push(newValuePlaceholder);
    properties.push(newProperty);
  }
  mergeIntoShorthands_1 = mergeIntoShorthands;
  return mergeIntoShorthands_1;
}

var findComponentIn_1;
var hasRequiredFindComponentIn;
function requireFindComponentIn() {
  if (hasRequiredFindComponentIn) return findComponentIn_1;
  hasRequiredFindComponentIn = 1;
  var compactable = requireCompactable();
  function findComponentIn(shorthand, longhand) {
    var comparator = nameComparator(longhand);
    return findInDirectComponents(shorthand, comparator) || findInSubComponents(shorthand, comparator);
  }
  function nameComparator(to) {
    return function (property) {
      return to.name === property.name;
    };
  }
  function findInDirectComponents(shorthand, comparator) {
    return shorthand.components.filter(comparator)[0];
  }
  function findInSubComponents(shorthand, comparator) {
    var shorthandComponent;
    var longhandMatch;
    var i, l;
    if (!compactable[shorthand.name].shorthandComponents) {
      return;
    }
    for (i = 0, l = shorthand.components.length; i < l; i++) {
      shorthandComponent = shorthand.components[i];
      longhandMatch = findInDirectComponents(shorthandComponent, comparator);
      if (longhandMatch) {
        return longhandMatch;
      }
    }
    return;
  }
  findComponentIn_1 = findComponentIn;
  return findComponentIn_1;
}

var isComponentOf_1;
var hasRequiredIsComponentOf;
function requireIsComponentOf() {
  if (hasRequiredIsComponentOf) return isComponentOf_1;
  hasRequiredIsComponentOf = 1;
  var compactable = requireCompactable();
  function isComponentOf(property1, property2, shallow) {
    return isDirectComponentOf(property1, property2) || !shallow && !!compactable[property1.name].shorthandComponents && isSubComponentOf(property1, property2);
  }
  function isDirectComponentOf(property1, property2) {
    var descriptor = compactable[property1.name];
    return 'components' in descriptor && descriptor.components.indexOf(property2.name) > -1;
  }
  function isSubComponentOf(property1, property2) {
    return property1.components.some(function (component) {
      return isDirectComponentOf(component, property2);
    });
  }
  isComponentOf_1 = isComponentOf;
  return isComponentOf_1;
}

var isMergeableShorthand_1;
var hasRequiredIsMergeableShorthand;
function requireIsMergeableShorthand() {
  if (hasRequiredIsMergeableShorthand) return isMergeableShorthand_1;
  hasRequiredIsMergeableShorthand = 1;
  var Marker = requireMarker();
  function isMergeableShorthand(shorthand) {
    if (shorthand.name != 'font') {
      return true;
    }
    return shorthand.value[0][1].indexOf(Marker.INTERNAL) == -1;
  }
  isMergeableShorthand_1 = isMergeableShorthand;
  return isMergeableShorthand_1;
}

var overridesNonComponentShorthand_1;
var hasRequiredOverridesNonComponentShorthand;
function requireOverridesNonComponentShorthand() {
  if (hasRequiredOverridesNonComponentShorthand) return overridesNonComponentShorthand_1;
  hasRequiredOverridesNonComponentShorthand = 1;
  var compactable = requireCompactable();
  function overridesNonComponentShorthand(property1, property2) {
    return property1.name in compactable && 'overridesShorthands' in compactable[property1.name] && compactable[property1.name].overridesShorthands.indexOf(property2.name) > -1;
  }
  overridesNonComponentShorthand_1 = overridesNonComponentShorthand;
  return overridesNonComponentShorthand_1;
}

var overrideProperties_1;
var hasRequiredOverrideProperties;
function requireOverrideProperties() {
  if (hasRequiredOverrideProperties) return overrideProperties_1;
  hasRequiredOverrideProperties = 1;
  var hasInherit = requireHasInherit();
  var everyValuesPair = requireEveryValuesPair();
  var findComponentIn = requireFindComponentIn();
  var isComponentOf = requireIsComponentOf();
  var isMergeableShorthand = requireIsMergeableShorthand();
  var overridesNonComponentShorthand = requireOverridesNonComponentShorthand();
  var sameVendorPrefixesIn = requireVendorPrefixes().same;
  var compactable = requireCompactable();
  var deepClone = requireClone().deep;
  var restoreWithComponents = requireRestoreWithComponents();
  var shallowClone = requireClone().shallow;
  var restoreFromOptimizing = requireRestoreFromOptimizing();
  var Token = requireToken();
  var Marker = requireMarker();
  var serializeProperty = requireOneTime().property;
  function wouldBreakCompatibility(property, validator) {
    for (var i = 0; i < property.components.length; i++) {
      var component = property.components[i];
      var descriptor = compactable[component.name];
      var canOverride = descriptor && descriptor.canOverride || canOverride.sameValue;
      var _component = shallowClone(component);
      _component.value = [[Token.PROPERTY_VALUE, descriptor.defaultValue]];
      if (!everyValuesPair(canOverride.bind(null, validator), _component, component)) {
        return true;
      }
    }
    return false;
  }
  function overrideIntoMultiplex(property, by) {
    by.unused = true;
    turnIntoMultiplex(by, multiplexSize(property));
    property.value = by.value;
  }
  function overrideByMultiplex(property, by) {
    by.unused = true;
    property.multiplex = true;
    property.value = by.value;
  }
  function overrideSimple(property, by) {
    by.unused = true;
    property.value = by.value;
  }
  function override(property, by) {
    if (by.multiplex) overrideByMultiplex(property, by);else if (property.multiplex) overrideIntoMultiplex(property, by);else overrideSimple(property, by);
  }
  function overrideShorthand(property, by) {
    by.unused = true;
    for (var i = 0, l = property.components.length; i < l; i++) {
      override(property.components[i], by.components[i], property.multiplex);
    }
  }
  function turnIntoMultiplex(property, size) {
    property.multiplex = true;
    if (compactable[property.name].shorthand) {
      turnShorthandValueIntoMultiplex(property, size);
    } else {
      turnLonghandValueIntoMultiplex(property, size);
    }
  }
  function turnShorthandValueIntoMultiplex(property, size) {
    var component;
    var i, l;
    for (i = 0, l = property.components.length; i < l; i++) {
      component = property.components[i];
      if (!component.multiplex) {
        turnLonghandValueIntoMultiplex(component, size);
      }
    }
  }
  function turnLonghandValueIntoMultiplex(property, size) {
    var descriptor = compactable[property.name];
    var withRealValue = descriptor.intoMultiplexMode == 'real';
    var withValue = descriptor.intoMultiplexMode == 'real' ? property.value.slice(0) : descriptor.intoMultiplexMode == 'placeholder' ? descriptor.placeholderValue : descriptor.defaultValue;
    var i = multiplexSize(property);
    var j;
    var m = withValue.length;
    for (; i < size; i++) {
      property.value.push([Token.PROPERTY_VALUE, Marker.COMMA]);
      if (Array.isArray(withValue)) {
        for (j = 0; j < m; j++) {
          property.value.push(withRealValue ? withValue[j] : [Token.PROPERTY_VALUE, withValue[j]]);
        }
      } else {
        property.value.push(withRealValue ? withValue : [Token.PROPERTY_VALUE, withValue]);
      }
    }
  }
  function multiplexSize(component) {
    var size = 0;
    for (var i = 0, l = component.value.length; i < l; i++) {
      if (component.value[i][1] == Marker.COMMA) size++;
    }
    return size + 1;
  }
  function lengthOf(property) {
    var fakeAsArray = [Token.PROPERTY, [Token.PROPERTY_NAME, property.name]].concat(property.value);
    return serializeProperty([fakeAsArray], 0).length;
  }
  function moreSameShorthands(properties, startAt, name) {
    // Since we run the main loop in `compactOverrides` backwards, at this point some
    // properties may not be marked as unused.
    // We should consider reverting the order if possible
    var count = 0;
    for (var i = startAt; i >= 0; i--) {
      if (properties[i].name == name && !properties[i].unused) count++;
      if (count > 1) break;
    }
    return count > 1;
  }
  function overridingFunction(shorthand, validator) {
    for (var i = 0, l = shorthand.components.length; i < l; i++) {
      if (!anyValue(validator.isUrl, shorthand.components[i]) && anyValue(validator.isFunction, shorthand.components[i])) {
        return true;
      }
    }
    return false;
  }
  function anyValue(fn, property) {
    for (var i = 0, l = property.value.length; i < l; i++) {
      if (property.value[i][1] == Marker.COMMA) continue;
      if (fn(property.value[i][1])) return true;
    }
    return false;
  }
  function wouldResultInLongerValue(left, right) {
    if (!left.multiplex && !right.multiplex || left.multiplex && right.multiplex) return false;
    var multiplex = left.multiplex ? left : right;
    var simple = left.multiplex ? right : left;
    var component;
    var multiplexClone = deepClone(multiplex);
    restoreFromOptimizing([multiplexClone], restoreWithComponents);
    var simpleClone = deepClone(simple);
    restoreFromOptimizing([simpleClone], restoreWithComponents);
    var lengthBefore = lengthOf(multiplexClone) + 1 + lengthOf(simpleClone);
    if (left.multiplex) {
      component = findComponentIn(multiplexClone, simpleClone);
      overrideIntoMultiplex(component, simpleClone);
    } else {
      component = findComponentIn(simpleClone, multiplexClone);
      turnIntoMultiplex(simpleClone, multiplexSize(multiplexClone));
      overrideByMultiplex(component, multiplexClone);
    }
    restoreFromOptimizing([simpleClone], restoreWithComponents);
    var lengthAfter = lengthOf(simpleClone);
    return lengthBefore <= lengthAfter;
  }
  function isCompactable(property) {
    return property.name in compactable;
  }
  function noneOverrideHack(left, right) {
    return !left.multiplex && (left.name == 'background' || left.name == 'background-image') && right.multiplex && (right.name == 'background' || right.name == 'background-image') && anyLayerIsNone(right.value);
  }
  function anyLayerIsNone(values) {
    var layers = intoLayers(values);
    for (var i = 0, l = layers.length; i < l; i++) {
      if (layers[i].length == 1 && layers[i][0][1] == 'none') return true;
    }
    return false;
  }
  function intoLayers(values) {
    var layers = [];
    for (var i = 0, layer = [], l = values.length; i < l; i++) {
      var value = values[i];
      if (value[1] == Marker.COMMA) {
        layers.push(layer);
        layer = [];
      } else {
        layer.push(value);
      }
    }
    layers.push(layer);
    return layers;
  }
  function overrideProperties(properties, withMerging, compatibility, validator) {
    var mayOverride, right, left, component;
    var overriddenComponents;
    var overriddenComponent;
    var overridingComponent;
    var overridable;
    var i, j, k;
    propertyLoop: for (i = properties.length - 1; i >= 0; i--) {
      right = properties[i];
      if (!isCompactable(right)) continue;
      if (right.block) continue;
      mayOverride = compactable[right.name].canOverride;
      traverseLoop: for (j = i - 1; j >= 0; j--) {
        left = properties[j];
        if (!isCompactable(left)) continue;
        if (left.block) continue;
        if (left.unused || right.unused) continue;
        if (left.hack && !right.hack && !right.important || !left.hack && !left.important && right.hack) continue;
        if (left.important == right.important && left.hack[0] != right.hack[0]) continue;
        if (left.important == right.important && (left.hack[0] != right.hack[0] || left.hack[1] && left.hack[1] != right.hack[1])) continue;
        if (hasInherit(right)) continue;
        if (noneOverrideHack(left, right)) continue;
        if (right.shorthand && isComponentOf(right, left)) {
          // maybe `left` can be overridden by `right` which is a shorthand?
          if (!right.important && left.important) continue;
          if (!sameVendorPrefixesIn([left], right.components)) continue;
          if (!anyValue(validator.isFunction, left) && overridingFunction(right, validator)) continue;
          if (!isMergeableShorthand(right)) {
            left.unused = true;
            continue;
          }
          component = findComponentIn(right, left);
          mayOverride = compactable[left.name].canOverride;
          if (everyValuesPair(mayOverride.bind(null, validator), left, component)) {
            left.unused = true;
          }
        } else if (right.shorthand && overridesNonComponentShorthand(right, left)) {
          // `right` is a shorthand while `left` can be overriden by it, think `border` and `border-top`
          if (!right.important && left.important) {
            continue;
          }
          if (!sameVendorPrefixesIn([left], right.components)) {
            continue;
          }
          if (!anyValue(validator.isFunction, left) && overridingFunction(right, validator)) {
            continue;
          }
          overriddenComponents = left.shorthand ? left.components : [left];
          for (k = overriddenComponents.length - 1; k >= 0; k--) {
            overriddenComponent = overriddenComponents[k];
            overridingComponent = findComponentIn(right, overriddenComponent);
            mayOverride = compactable[overriddenComponent.name].canOverride;
            if (!everyValuesPair(mayOverride.bind(null, validator), left, overridingComponent)) {
              continue traverseLoop;
            }
          }
          left.unused = true;
        } else if (withMerging && left.shorthand && !right.shorthand && isComponentOf(left, right, true)) {
          // maybe `right` can be pulled into `left` which is a shorthand?
          if (right.important && !left.important) continue;
          if (!right.important && left.important) {
            right.unused = true;
            continue;
          }

          // Pending more clever algorithm in #527
          if (moreSameShorthands(properties, i - 1, left.name)) continue;
          if (overridingFunction(left, validator)) continue;
          if (!isMergeableShorthand(left)) continue;
          component = findComponentIn(left, right);
          if (everyValuesPair(mayOverride.bind(null, validator), component, right)) {
            var disabledBackgroundMerging = !compatibility.properties.backgroundClipMerging && component.name.indexOf('background-clip') > -1 || !compatibility.properties.backgroundOriginMerging && component.name.indexOf('background-origin') > -1 || !compatibility.properties.backgroundSizeMerging && component.name.indexOf('background-size') > -1;
            var nonMergeableValue = compactable[right.name].nonMergeableValue === right.value[0][1];
            if (disabledBackgroundMerging || nonMergeableValue) continue;
            if (!compatibility.properties.merging && wouldBreakCompatibility(left, validator)) continue;
            if (component.value[0][1] != right.value[0][1] && (hasInherit(left) || hasInherit(right))) continue;
            if (wouldResultInLongerValue(left, right)) continue;
            if (!left.multiplex && right.multiplex) turnIntoMultiplex(left, multiplexSize(right));
            override(component, right);
            left.dirty = true;
          }
        } else if (withMerging && left.shorthand && right.shorthand && left.name == right.name) {
          // merge if all components can be merged

          if (!left.multiplex && right.multiplex) continue;
          if (!right.important && left.important) {
            right.unused = true;
            continue propertyLoop;
          }
          if (right.important && !left.important) {
            left.unused = true;
            continue;
          }
          if (!isMergeableShorthand(right)) {
            left.unused = true;
            continue;
          }
          for (k = left.components.length - 1; k >= 0; k--) {
            var leftComponent = left.components[k];
            var rightComponent = right.components[k];
            mayOverride = compactable[leftComponent.name].canOverride;
            if (!everyValuesPair(mayOverride.bind(null, validator), leftComponent, rightComponent)) continue propertyLoop;
          }
          overrideShorthand(left, right);
          left.dirty = true;
        } else if (withMerging && left.shorthand && right.shorthand && isComponentOf(left, right)) {
          // border is a shorthand but any of its components is a shorthand too

          if (!left.important && right.important) continue;
          component = findComponentIn(left, right);
          mayOverride = compactable[right.name].canOverride;
          if (!everyValuesPair(mayOverride.bind(null, validator), component, right)) continue;
          if (left.important && !right.important) {
            right.unused = true;
            continue;
          }
          var rightRestored = compactable[right.name].restore(right, compactable);
          if (rightRestored.length > 1) continue;
          component = findComponentIn(left, right);
          override(component, right);
          right.dirty = true;
        } else if (left.name == right.name) {
          // two non-shorthands should be merged based on understandability
          overridable = true;
          if (right.shorthand) {
            for (k = right.components.length - 1; k >= 0 && overridable; k--) {
              overriddenComponent = left.components[k];
              overridingComponent = right.components[k];
              mayOverride = compactable[overridingComponent.name].canOverride;
              overridable = overridable && everyValuesPair(mayOverride.bind(null, validator), overriddenComponent, overridingComponent);
            }
          } else {
            mayOverride = compactable[right.name].canOverride;
            overridable = everyValuesPair(mayOverride.bind(null, validator), left, right);
          }
          if (left.important && !right.important && overridable) {
            right.unused = true;
            continue;
          }
          if (!left.important && right.important && overridable) {
            left.unused = true;
            continue;
          }
          if (!overridable) {
            continue;
          }
          left.unused = true;
        }
      }
    }
  }
  overrideProperties_1 = overrideProperties;
  return overrideProperties_1;
}

var optimize$1;
var hasRequiredOptimize$1;
function requireOptimize$1() {
  if (hasRequiredOptimize$1) return optimize$1;
  hasRequiredOptimize$1 = 1;
  var mergeIntoShorthands = requireMergeIntoShorthands();
  var overrideProperties = requireOverrideProperties();
  var populateComponents = requirePopulateComponents();
  var restoreWithComponents = requireRestoreWithComponents();
  var wrapForOptimizing = requireWrapForOptimizing().all;
  var removeUnused = requireRemoveUnused();
  var restoreFromOptimizing = requireRestoreFromOptimizing();
  var OptimizationLevel = requireOptimizationLevel().OptimizationLevel;
  function optimizeProperties(properties, withOverriding, withMerging, context) {
    var levelOptions = context.options.level[OptimizationLevel.Two];
    var _properties = wrapForOptimizing(properties, false, levelOptions.skipProperties);
    var _property;
    var i, l;
    populateComponents(_properties, context.validator, context.warnings);
    for (i = 0, l = _properties.length; i < l; i++) {
      _property = _properties[i];
      if (_property.block) {
        optimizeProperties(_property.value[0][1], withOverriding, withMerging, context);
      }
    }
    if (withMerging && levelOptions.mergeIntoShorthands) {
      mergeIntoShorthands(_properties, context.validator);
    }
    if (withOverriding && levelOptions.overrideProperties) {
      overrideProperties(_properties, withMerging, context.options.compatibility, context.validator);
    }
    restoreFromOptimizing(_properties, restoreWithComponents);
    removeUnused(_properties);
  }
  optimize$1 = optimizeProperties;
  return optimize$1;
}

var mergeAdjacent_1;
var hasRequiredMergeAdjacent;
function requireMergeAdjacent() {
  if (hasRequiredMergeAdjacent) return mergeAdjacent_1;
  hasRequiredMergeAdjacent = 1;
  var isMergeable = requireIsMergeable();
  var optimizeProperties = requireOptimize$1();
  var sortSelectors = requireSortSelectors();
  var tidyRules = requireTidyRules();
  var OptimizationLevel = requireOptimizationLevel().OptimizationLevel;
  var serializeBody = requireOneTime().body;
  var serializeRules = requireOneTime().rules;
  var Token = requireToken();
  function mergeAdjacent(tokens, context) {
    var lastToken = [null, [], []];
    var options = context.options;
    var adjacentSpace = options.compatibility.selectors.adjacentSpace;
    var selectorsSortingMethod = options.level[OptimizationLevel.One].selectorsSortingMethod;
    var mergeablePseudoClasses = options.compatibility.selectors.mergeablePseudoClasses;
    var mergeablePseudoElements = options.compatibility.selectors.mergeablePseudoElements;
    var mergeLimit = options.compatibility.selectors.mergeLimit;
    var multiplePseudoMerging = options.compatibility.selectors.multiplePseudoMerging;
    for (var i = 0, l = tokens.length; i < l; i++) {
      var token = tokens[i];
      if (token[0] != Token.RULE) {
        lastToken = [null, [], []];
        continue;
      }
      if (lastToken[0] == Token.RULE && serializeRules(token[1]) == serializeRules(lastToken[1])) {
        Array.prototype.push.apply(lastToken[2], token[2]);
        optimizeProperties(lastToken[2], true, true, context);
        token[2] = [];
      } else if (lastToken[0] == Token.RULE && serializeBody(token[2]) == serializeBody(lastToken[2]) && isMergeable(serializeRules(token[1]), mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging) && isMergeable(serializeRules(lastToken[1]), mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging) && lastToken[1].length < mergeLimit) {
        lastToken[1] = tidyRules(lastToken[1].concat(token[1]), false, adjacentSpace, false, context.warnings);
        lastToken[1] = lastToken.length > 1 ? sortSelectors(lastToken[1], selectorsSortingMethod) : lastToken[1];
        token[2] = [];
      } else {
        lastToken = token;
      }
    }
  }
  mergeAdjacent_1 = mergeAdjacent;
  return mergeAdjacent_1;
}

var rulesOverlap_1;
var hasRequiredRulesOverlap;
function requireRulesOverlap() {
  if (hasRequiredRulesOverlap) return rulesOverlap_1;
  hasRequiredRulesOverlap = 1;
  var MODIFIER_PATTERN = /\-\-.+$/;
  function rulesOverlap(rule1, rule2, bemMode) {
    var scope1;
    var scope2;
    var i, l;
    var j, m;
    for (i = 0, l = rule1.length; i < l; i++) {
      scope1 = rule1[i][1];
      for (j = 0, m = rule2.length; j < m; j++) {
        scope2 = rule2[j][1];
        if (scope1 == scope2) {
          return true;
        }
        if (bemMode && withoutModifiers(scope1) == withoutModifiers(scope2)) {
          return true;
        }
      }
    }
    return false;
  }
  function withoutModifiers(scope) {
    return scope.replace(MODIFIER_PATTERN, '');
  }
  rulesOverlap_1 = rulesOverlap;
  return rulesOverlap_1;
}

var specificity_1;
var hasRequiredSpecificity;
function requireSpecificity() {
  if (hasRequiredSpecificity) return specificity_1;
  hasRequiredSpecificity = 1;
  var Marker = requireMarker();
  var Selector = {
    DOT: '.',
    HASH: '#',
    PSEUDO: ':'
  };
  var LETTER_PATTERN = /[a-zA-Z]/;
  var NOT_PREFIX = ':not(';
  var SEPARATOR_PATTERN = /[\s,\(>~\+]/;
  function specificity(selector) {
    var result = [0, 0, 0];
    var character;
    var isEscaped;
    var isSingleQuoted;
    var isDoubleQuoted;
    var roundBracketLevel = 0;
    var couldIntroduceNewTypeSelector;
    var withinNotPseudoClass = false;
    var wasPseudoClass = false;
    var i, l;
    for (i = 0, l = selector.length; i < l; i++) {
      character = selector[i];
      if (isEscaped) ; else if (character == Marker.SINGLE_QUOTE && !isDoubleQuoted && !isSingleQuoted) {
        isSingleQuoted = true;
      } else if (character == Marker.SINGLE_QUOTE && !isDoubleQuoted && isSingleQuoted) {
        isSingleQuoted = false;
      } else if (character == Marker.DOUBLE_QUOTE && !isDoubleQuoted && !isSingleQuoted) {
        isDoubleQuoted = true;
      } else if (character == Marker.DOUBLE_QUOTE && isDoubleQuoted && !isSingleQuoted) {
        isDoubleQuoted = false;
      } else if (isSingleQuoted || isDoubleQuoted) {
        continue;
      } else if (roundBracketLevel > 0 && !withinNotPseudoClass) ; else if (character == Marker.OPEN_ROUND_BRACKET) {
        roundBracketLevel++;
      } else if (character == Marker.CLOSE_ROUND_BRACKET && roundBracketLevel == 1) {
        roundBracketLevel--;
        withinNotPseudoClass = false;
      } else if (character == Marker.CLOSE_ROUND_BRACKET) {
        roundBracketLevel--;
      } else if (character == Selector.HASH) {
        result[0]++;
      } else if (character == Selector.DOT || character == Marker.OPEN_SQUARE_BRACKET) {
        result[1]++;
      } else if (character == Selector.PSEUDO && !wasPseudoClass && !isNotPseudoClass(selector, i)) {
        result[1]++;
        withinNotPseudoClass = false;
      } else if (character == Selector.PSEUDO) {
        withinNotPseudoClass = true;
      } else if ((i === 0 || couldIntroduceNewTypeSelector) && LETTER_PATTERN.test(character)) {
        result[2]++;
      }
      isEscaped = character == Marker.BACK_SLASH;
      wasPseudoClass = character == Selector.PSEUDO;
      couldIntroduceNewTypeSelector = !isEscaped && SEPARATOR_PATTERN.test(character);
    }
    return result;
  }
  function isNotPseudoClass(selector, index) {
    return selector.indexOf(NOT_PREFIX, index) === index;
  }
  specificity_1 = specificity;
  return specificity_1;
}

var specificitiesOverlap_1;
var hasRequiredSpecificitiesOverlap;
function requireSpecificitiesOverlap() {
  if (hasRequiredSpecificitiesOverlap) return specificitiesOverlap_1;
  hasRequiredSpecificitiesOverlap = 1;
  var specificity = requireSpecificity();
  function specificitiesOverlap(selector1, selector2, cache) {
    var specificity1;
    var specificity2;
    var i, l;
    var j, m;
    for (i = 0, l = selector1.length; i < l; i++) {
      specificity1 = findSpecificity(selector1[i][1], cache);
      for (j = 0, m = selector2.length; j < m; j++) {
        specificity2 = findSpecificity(selector2[j][1], cache);
        if (specificity1[0] === specificity2[0] && specificity1[1] === specificity2[1] && specificity1[2] === specificity2[2]) {
          return true;
        }
      }
    }
    return false;
  }
  function findSpecificity(selector, cache) {
    var value;
    if (!(selector in cache)) {
      cache[selector] = value = specificity(selector);
    }
    return value || cache[selector];
  }
  specificitiesOverlap_1 = specificitiesOverlap;
  return specificitiesOverlap_1;
}

var reorderable;
var hasRequiredReorderable;
function requireReorderable() {
  if (hasRequiredReorderable) return reorderable;
  hasRequiredReorderable = 1;
  // TODO: it'd be great to merge it with the other canReorder functionality

  var rulesOverlap = requireRulesOverlap();
  var specificitiesOverlap = requireSpecificitiesOverlap();
  var FLEX_PROPERTIES = /align\-items|box\-align|box\-pack|flex|justify/;
  var BORDER_PROPERTIES = /^border\-(top|right|bottom|left|color|style|width|radius)/;
  function canReorder(left, right, cache) {
    for (var i = right.length - 1; i >= 0; i--) {
      for (var j = left.length - 1; j >= 0; j--) {
        if (!canReorderSingle(left[j], right[i], cache)) return false;
      }
    }
    return true;
  }
  function canReorderSingle(left, right, cache) {
    var leftName = left[0];
    var leftValue = left[1];
    var leftNameRoot = left[2];
    var leftSelector = left[5];
    var leftInSpecificSelector = left[6];
    var rightName = right[0];
    var rightValue = right[1];
    var rightNameRoot = right[2];
    var rightSelector = right[5];
    var rightInSpecificSelector = right[6];
    if (leftName == 'font' && rightName == 'line-height' || rightName == 'font' && leftName == 'line-height') return false;
    if (FLEX_PROPERTIES.test(leftName) && FLEX_PROPERTIES.test(rightName)) return false;
    if (leftNameRoot == rightNameRoot && unprefixed(leftName) == unprefixed(rightName) && vendorPrefixed(leftName) ^ vendorPrefixed(rightName)) return false;
    if (leftNameRoot == 'border' && BORDER_PROPERTIES.test(rightNameRoot) && (leftName == 'border' || leftName == rightNameRoot || leftValue != rightValue && sameBorderComponent(leftName, rightName))) return false;
    if (rightNameRoot == 'border' && BORDER_PROPERTIES.test(leftNameRoot) && (rightName == 'border' || rightName == leftNameRoot || leftValue != rightValue && sameBorderComponent(leftName, rightName))) return false;
    if (leftNameRoot == 'border' && rightNameRoot == 'border' && leftName != rightName && (isSideBorder(leftName) && isStyleBorder(rightName) || isStyleBorder(leftName) && isSideBorder(rightName))) return false;
    if (leftNameRoot != rightNameRoot) return true;
    if (leftName == rightName && leftNameRoot == rightNameRoot && (leftValue == rightValue || withDifferentVendorPrefix(leftValue, rightValue))) return true;
    if (leftName != rightName && leftNameRoot == rightNameRoot && leftName != leftNameRoot && rightName != rightNameRoot) return true;
    if (leftName != rightName && leftNameRoot == rightNameRoot && leftValue == rightValue) return true;
    if (rightInSpecificSelector && leftInSpecificSelector && !inheritable(leftNameRoot) && !inheritable(rightNameRoot) && !rulesOverlap(rightSelector, leftSelector, false)) return true;
    if (!specificitiesOverlap(leftSelector, rightSelector, cache)) return true;
    return false;
  }
  function vendorPrefixed(name) {
    return /^\-(?:moz|webkit|ms|o)\-/.test(name);
  }
  function unprefixed(name) {
    return name.replace(/^\-(?:moz|webkit|ms|o)\-/, '');
  }
  function sameBorderComponent(name1, name2) {
    return name1.split('-').pop() == name2.split('-').pop();
  }
  function isSideBorder(name) {
    return name == 'border-top' || name == 'border-right' || name == 'border-bottom' || name == 'border-left';
  }
  function isStyleBorder(name) {
    return name == 'border-color' || name == 'border-style' || name == 'border-width';
  }
  function withDifferentVendorPrefix(value1, value2) {
    return vendorPrefixed(value1) && vendorPrefixed(value2) && value1.split('-')[1] != value2.split('-')[2];
  }
  function inheritable(name) {
    // According to http://www.w3.org/TR/CSS21/propidx.html
    // Others will be catched by other, preceeding rules
    return name == 'font' || name == 'line-height' || name == 'list-style';
  }
  reorderable = {
    canReorder: canReorder,
    canReorderSingle: canReorderSingle
  };
  return reorderable;
}

var extractProperties_1;
var hasRequiredExtractProperties;
function requireExtractProperties() {
  if (hasRequiredExtractProperties) return extractProperties_1;
  hasRequiredExtractProperties = 1;
  // This extractor is used in level 2 optimizations
  // IMPORTANT: Mind Token class and this code is not related!
  // Properties will be tokenized in one step, see #429

  var Token = requireToken();
  var serializeRules = requireOneTime().rules;
  var serializeValue = requireOneTime().value;
  function extractProperties(token) {
    var properties = [];
    var inSpecificSelector;
    var property;
    var name;
    var value;
    var i, l;
    if (token[0] == Token.RULE) {
      inSpecificSelector = !/[\.\+>~]/.test(serializeRules(token[1]));
      for (i = 0, l = token[2].length; i < l; i++) {
        property = token[2][i];
        if (property[0] != Token.PROPERTY) continue;
        name = property[1][1];
        if (name.length === 0) continue;
        if (name.indexOf('--') === 0) continue;
        value = serializeValue(property, i);
        properties.push([name, value, findNameRoot(name), token[2][i], name + ':' + value, token[1], inSpecificSelector]);
      }
    } else if (token[0] == Token.NESTED_BLOCK) {
      for (i = 0, l = token[2].length; i < l; i++) {
        properties = properties.concat(extractProperties(token[2][i]));
      }
    }
    return properties;
  }
  function findNameRoot(name) {
    if (name == 'list-style') return name;
    if (name.indexOf('-radius') > 0) return 'border-radius';
    if (name == 'border-collapse' || name == 'border-spacing' || name == 'border-image') return name;
    if (name.indexOf('border-') === 0 && /^border\-\w+\-\w+$/.test(name)) return name.match(/border\-\w+/)[0];
    if (name.indexOf('border-') === 0 && /^border\-\w+$/.test(name)) return 'border';
    if (name.indexOf('text-') === 0) return name;
    if (name == '-chrome-') return name;
    return name.replace(/^\-\w+\-/, '').match(/([a-zA-Z]+)/)[0].toLowerCase();
  }
  extractProperties_1 = extractProperties;
  return extractProperties_1;
}

var mergeMediaQueries_1;
var hasRequiredMergeMediaQueries;
function requireMergeMediaQueries() {
  if (hasRequiredMergeMediaQueries) return mergeMediaQueries_1;
  hasRequiredMergeMediaQueries = 1;
  var canReorder = requireReorderable().canReorder;
  var canReorderSingle = requireReorderable().canReorderSingle;
  var extractProperties = requireExtractProperties();
  var rulesOverlap = requireRulesOverlap();
  var serializeRules = requireOneTime().rules;
  var OptimizationLevel = requireOptimizationLevel().OptimizationLevel;
  var Token = requireToken();
  function mergeMediaQueries(tokens, context) {
    var mergeSemantically = context.options.level[OptimizationLevel.Two].mergeSemantically;
    var specificityCache = context.cache.specificity;
    var candidates = {};
    var reduced = [];
    for (var i = tokens.length - 1; i >= 0; i--) {
      var token = tokens[i];
      if (token[0] != Token.NESTED_BLOCK) {
        continue;
      }
      var key = serializeRules(token[1]);
      var candidate = candidates[key];
      if (!candidate) {
        candidate = [];
        candidates[key] = candidate;
      }
      candidate.push(i);
    }
    for (var name in candidates) {
      var positions = candidates[name];
      positionLoop: for (var j = positions.length - 1; j > 0; j--) {
        var positionOne = positions[j];
        var tokenOne = tokens[positionOne];
        var positionTwo = positions[j - 1];
        var tokenTwo = tokens[positionTwo];
        directionLoop: for (var direction = 1; direction >= -1; direction -= 2) {
          var topToBottom = direction == 1;
          var from = topToBottom ? positionOne + 1 : positionTwo - 1;
          var to = topToBottom ? positionTwo : positionOne;
          var delta = topToBottom ? 1 : -1;
          var source = topToBottom ? tokenOne : tokenTwo;
          var target = topToBottom ? tokenTwo : tokenOne;
          var movedProperties = extractProperties(source);
          while (from != to) {
            var traversedProperties = extractProperties(tokens[from]);
            from += delta;
            if (mergeSemantically && allSameRulePropertiesCanBeReordered(movedProperties, traversedProperties, specificityCache)) {
              continue;
            }
            if (!canReorder(movedProperties, traversedProperties, specificityCache)) continue directionLoop;
          }
          target[2] = topToBottom ? source[2].concat(target[2]) : target[2].concat(source[2]);
          source[2] = [];
          reduced.push(target);
          continue positionLoop;
        }
      }
    }
    return reduced;
  }
  function allSameRulePropertiesCanBeReordered(movedProperties, traversedProperties, specificityCache) {
    var movedProperty;
    var movedRule;
    var traversedProperty;
    var traversedRule;
    var i, l;
    var j, m;
    for (i = 0, l = movedProperties.length; i < l; i++) {
      movedProperty = movedProperties[i];
      movedRule = movedProperty[5];
      for (j = 0, m = traversedProperties.length; j < m; j++) {
        traversedProperty = traversedProperties[j];
        traversedRule = traversedProperty[5];
        if (rulesOverlap(movedRule, traversedRule, true) && !canReorderSingle(movedProperty, traversedProperty, specificityCache)) {
          return false;
        }
      }
    }
    return true;
  }
  mergeMediaQueries_1 = mergeMediaQueries;
  return mergeMediaQueries_1;
}

var mergeNonAdjacentByBody_1;
var hasRequiredMergeNonAdjacentByBody;
function requireMergeNonAdjacentByBody() {
  if (hasRequiredMergeNonAdjacentByBody) return mergeNonAdjacentByBody_1;
  hasRequiredMergeNonAdjacentByBody = 1;
  var isMergeable = requireIsMergeable();
  var sortSelectors = requireSortSelectors();
  var tidyRules = requireTidyRules();
  var OptimizationLevel = requireOptimizationLevel().OptimizationLevel;
  var serializeBody = requireOneTime().body;
  var serializeRules = requireOneTime().rules;
  var Token = requireToken();
  function unsafeSelector(value) {
    return /\.|\*| :/.test(value);
  }
  function isBemElement(token) {
    var asString = serializeRules(token[1]);
    return asString.indexOf('__') > -1 || asString.indexOf('--') > -1;
  }
  function withoutModifier(selector) {
    return selector.replace(/--[^ ,>\+~:]+/g, '');
  }
  function removeAnyUnsafeElements(left, candidates) {
    var leftSelector = withoutModifier(serializeRules(left[1]));
    for (var body in candidates) {
      var right = candidates[body];
      var rightSelector = withoutModifier(serializeRules(right[1]));
      if (rightSelector.indexOf(leftSelector) > -1 || leftSelector.indexOf(rightSelector) > -1) delete candidates[body];
    }
  }
  function mergeNonAdjacentByBody(tokens, context) {
    var options = context.options;
    var mergeSemantically = options.level[OptimizationLevel.Two].mergeSemantically;
    var adjacentSpace = options.compatibility.selectors.adjacentSpace;
    var selectorsSortingMethod = options.level[OptimizationLevel.One].selectorsSortingMethod;
    var mergeablePseudoClasses = options.compatibility.selectors.mergeablePseudoClasses;
    var mergeablePseudoElements = options.compatibility.selectors.mergeablePseudoElements;
    var multiplePseudoMerging = options.compatibility.selectors.multiplePseudoMerging;
    var candidates = {};
    for (var i = tokens.length - 1; i >= 0; i--) {
      var token = tokens[i];
      if (token[0] != Token.RULE) continue;
      if (token[2].length > 0 && !mergeSemantically && unsafeSelector(serializeRules(token[1]))) candidates = {};
      if (token[2].length > 0 && mergeSemantically && isBemElement(token)) removeAnyUnsafeElements(token, candidates);
      var candidateBody = serializeBody(token[2]);
      var oldToken = candidates[candidateBody];
      if (oldToken && isMergeable(serializeRules(token[1]), mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging) && isMergeable(serializeRules(oldToken[1]), mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging)) {
        if (token[2].length > 0) {
          token[1] = tidyRules(oldToken[1].concat(token[1]), false, adjacentSpace, false, context.warnings);
          token[1] = token[1].length > 1 ? sortSelectors(token[1], selectorsSortingMethod) : token[1];
        } else {
          token[1] = oldToken[1].concat(token[1]);
        }
        oldToken[2] = [];
        candidates[candidateBody] = null;
      }
      candidates[serializeBody(token[2])] = token;
    }
  }
  mergeNonAdjacentByBody_1 = mergeNonAdjacentByBody;
  return mergeNonAdjacentByBody_1;
}

var mergeNonAdjacentBySelector_1;
var hasRequiredMergeNonAdjacentBySelector;
function requireMergeNonAdjacentBySelector() {
  if (hasRequiredMergeNonAdjacentBySelector) return mergeNonAdjacentBySelector_1;
  hasRequiredMergeNonAdjacentBySelector = 1;
  var canReorder = requireReorderable().canReorder;
  var extractProperties = requireExtractProperties();
  var optimizeProperties = requireOptimize$1();
  var serializeRules = requireOneTime().rules;
  var Token = requireToken();
  function mergeNonAdjacentBySelector(tokens, context) {
    var specificityCache = context.cache.specificity;
    var allSelectors = {};
    var repeatedSelectors = [];
    var i;
    for (i = tokens.length - 1; i >= 0; i--) {
      if (tokens[i][0] != Token.RULE) continue;
      if (tokens[i][2].length === 0) continue;
      var selector = serializeRules(tokens[i][1]);
      allSelectors[selector] = [i].concat(allSelectors[selector] || []);
      if (allSelectors[selector].length == 2) repeatedSelectors.push(selector);
    }
    for (i = repeatedSelectors.length - 1; i >= 0; i--) {
      var positions = allSelectors[repeatedSelectors[i]];
      selectorIterator: for (var j = positions.length - 1; j > 0; j--) {
        var positionOne = positions[j - 1];
        var tokenOne = tokens[positionOne];
        var positionTwo = positions[j];
        var tokenTwo = tokens[positionTwo];
        directionIterator: for (var direction = 1; direction >= -1; direction -= 2) {
          var topToBottom = direction == 1;
          var from = topToBottom ? positionOne + 1 : positionTwo - 1;
          var to = topToBottom ? positionTwo : positionOne;
          var delta = topToBottom ? 1 : -1;
          var moved = topToBottom ? tokenOne : tokenTwo;
          var target = topToBottom ? tokenTwo : tokenOne;
          var movedProperties = extractProperties(moved);
          while (from != to) {
            var traversedProperties = extractProperties(tokens[from]);
            from += delta;

            // traversed then moved as we move selectors towards the start
            var reorderable = topToBottom ? canReorder(movedProperties, traversedProperties, specificityCache) : canReorder(traversedProperties, movedProperties, specificityCache);
            if (!reorderable && !topToBottom) continue selectorIterator;
            if (!reorderable && topToBottom) continue directionIterator;
          }
          if (topToBottom) {
            Array.prototype.push.apply(moved[2], target[2]);
            target[2] = moved[2];
          } else {
            Array.prototype.push.apply(target[2], moved[2]);
          }
          optimizeProperties(target[2], true, true, context);
          moved[2] = [];
        }
      }
    }
  }
  mergeNonAdjacentBySelector_1 = mergeNonAdjacentBySelector;
  return mergeNonAdjacentBySelector_1;
}

var cloneArray_1;
var hasRequiredCloneArray;
function requireCloneArray() {
  if (hasRequiredCloneArray) return cloneArray_1;
  hasRequiredCloneArray = 1;
  function cloneArray(array) {
    var cloned = array.slice(0);
    for (var i = 0, l = cloned.length; i < l; i++) {
      if (Array.isArray(cloned[i])) cloned[i] = cloneArray(cloned[i]);
    }
    return cloned;
  }
  cloneArray_1 = cloneArray;
  return cloneArray_1;
}

var reduceNonAdjacent_1;
var hasRequiredReduceNonAdjacent;
function requireReduceNonAdjacent() {
  if (hasRequiredReduceNonAdjacent) return reduceNonAdjacent_1;
  hasRequiredReduceNonAdjacent = 1;
  var isMergeable = requireIsMergeable();
  var optimizeProperties = requireOptimize$1();
  var cloneArray = requireCloneArray();
  var Token = requireToken();
  var serializeBody = requireOneTime().body;
  var serializeRules = requireOneTime().rules;
  function reduceNonAdjacent(tokens, context) {
    var options = context.options;
    var mergeablePseudoClasses = options.compatibility.selectors.mergeablePseudoClasses;
    var mergeablePseudoElements = options.compatibility.selectors.mergeablePseudoElements;
    var multiplePseudoMerging = options.compatibility.selectors.multiplePseudoMerging;
    var candidates = {};
    var repeated = [];
    for (var i = tokens.length - 1; i >= 0; i--) {
      var token = tokens[i];
      if (token[0] != Token.RULE) {
        continue;
      } else if (token[2].length === 0) {
        continue;
      }
      var selectorAsString = serializeRules(token[1]);
      var isComplexAndNotSpecial = token[1].length > 1 && isMergeable(selectorAsString, mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging);
      var wrappedSelectors = wrappedSelectorsFrom(token[1]);
      var selectors = isComplexAndNotSpecial ? [selectorAsString].concat(wrappedSelectors) : [selectorAsString];
      for (var j = 0, m = selectors.length; j < m; j++) {
        var selector = selectors[j];
        if (!candidates[selector]) candidates[selector] = [];else repeated.push(selector);
        candidates[selector].push({
          where: i,
          list: wrappedSelectors,
          isPartial: isComplexAndNotSpecial && j > 0,
          isComplex: isComplexAndNotSpecial && j === 0
        });
      }
    }
    reduceSimpleNonAdjacentCases(tokens, repeated, candidates, options, context);
    reduceComplexNonAdjacentCases(tokens, candidates, options, context);
  }
  function wrappedSelectorsFrom(list) {
    var wrapped = [];
    for (var i = 0; i < list.length; i++) {
      wrapped.push([list[i][1]]);
    }
    return wrapped;
  }
  function reduceSimpleNonAdjacentCases(tokens, repeated, candidates, options, context) {
    function filterOut(idx, bodies) {
      return data[idx].isPartial && bodies.length === 0;
    }
    function reduceBody(token, newBody, processedCount, tokenIdx) {
      if (!data[processedCount - tokenIdx - 1].isPartial) token[2] = newBody;
    }
    for (var i = 0, l = repeated.length; i < l; i++) {
      var selector = repeated[i];
      var data = candidates[selector];
      reduceSelector(tokens, data, {
        filterOut: filterOut,
        callback: reduceBody
      }, options, context);
    }
  }
  function reduceComplexNonAdjacentCases(tokens, candidates, options, context) {
    var mergeablePseudoClasses = options.compatibility.selectors.mergeablePseudoClasses;
    var mergeablePseudoElements = options.compatibility.selectors.mergeablePseudoElements;
    var multiplePseudoMerging = options.compatibility.selectors.multiplePseudoMerging;
    var localContext = {};
    function filterOut(idx) {
      return localContext.data[idx].where < localContext.intoPosition;
    }
    function collectReducedBodies(token, newBody, processedCount, tokenIdx) {
      if (tokenIdx === 0) localContext.reducedBodies.push(newBody);
    }
    allSelectors: for (var complexSelector in candidates) {
      var into = candidates[complexSelector];
      if (!into[0].isComplex) continue;
      var intoPosition = into[into.length - 1].where;
      var intoToken = tokens[intoPosition];
      var reducedBodies = [];
      var selectors = isMergeable(complexSelector, mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging) ? into[0].list : [complexSelector];
      localContext.intoPosition = intoPosition;
      localContext.reducedBodies = reducedBodies;
      for (var j = 0, m = selectors.length; j < m; j++) {
        var selector = selectors[j];
        var data = candidates[selector];
        if (data.length < 2) continue allSelectors;
        localContext.data = data;
        reduceSelector(tokens, data, {
          filterOut: filterOut,
          callback: collectReducedBodies
        }, options, context);
        if (serializeBody(reducedBodies[reducedBodies.length - 1]) != serializeBody(reducedBodies[0])) continue allSelectors;
      }
      intoToken[2] = reducedBodies[0];
    }
  }
  function reduceSelector(tokens, data, context, options, outerContext) {
    var bodies = [];
    var bodiesAsList = [];
    var processedTokens = [];
    for (var j = data.length - 1; j >= 0; j--) {
      if (context.filterOut(j, bodies)) continue;
      var where = data[j].where;
      var token = tokens[where];
      var clonedBody = cloneArray(token[2]);
      bodies = bodies.concat(clonedBody);
      bodiesAsList.push(clonedBody);
      processedTokens.push(where);
    }
    optimizeProperties(bodies, true, false, outerContext);
    var processedCount = processedTokens.length;
    var propertyIdx = bodies.length - 1;
    var tokenIdx = processedCount - 1;
    while (tokenIdx >= 0) {
      if ((tokenIdx === 0 || bodies[propertyIdx] && bodiesAsList[tokenIdx].indexOf(bodies[propertyIdx]) > -1) && propertyIdx > -1) {
        propertyIdx--;
        continue;
      }
      var newBody = bodies.splice(propertyIdx + 1);
      context.callback(tokens[processedTokens[tokenIdx]], newBody, processedCount, tokenIdx);
      tokenIdx--;
    }
  }
  reduceNonAdjacent_1 = reduceNonAdjacent;
  return reduceNonAdjacent_1;
}

var removeDuplicateFontAtRules_1;
var hasRequiredRemoveDuplicateFontAtRules;
function requireRemoveDuplicateFontAtRules() {
  if (hasRequiredRemoveDuplicateFontAtRules) return removeDuplicateFontAtRules_1;
  hasRequiredRemoveDuplicateFontAtRules = 1;
  var Token = requireToken();
  var serializeAll = requireOneTime().all;
  var FONT_FACE_SCOPE = '@font-face';
  function removeDuplicateFontAtRules(tokens) {
    var fontAtRules = [];
    var token;
    var key;
    var i, l;
    for (i = 0, l = tokens.length; i < l; i++) {
      token = tokens[i];
      if (token[0] != Token.AT_RULE_BLOCK && token[1][0][1] != FONT_FACE_SCOPE) {
        continue;
      }
      key = serializeAll([token]);
      if (fontAtRules.indexOf(key) > -1) {
        token[2] = [];
      } else {
        fontAtRules.push(key);
      }
    }
  }
  removeDuplicateFontAtRules_1 = removeDuplicateFontAtRules;
  return removeDuplicateFontAtRules_1;
}

var removeDuplicateMediaQueries_1;
var hasRequiredRemoveDuplicateMediaQueries;
function requireRemoveDuplicateMediaQueries() {
  if (hasRequiredRemoveDuplicateMediaQueries) return removeDuplicateMediaQueries_1;
  hasRequiredRemoveDuplicateMediaQueries = 1;
  var Token = requireToken();
  var serializeAll = requireOneTime().all;
  var serializeRules = requireOneTime().rules;
  function removeDuplicateMediaQueries(tokens) {
    var candidates = {};
    var candidate;
    var token;
    var key;
    var i, l;
    for (i = 0, l = tokens.length; i < l; i++) {
      token = tokens[i];
      if (token[0] != Token.NESTED_BLOCK) {
        continue;
      }
      key = serializeRules(token[1]) + '%' + serializeAll(token[2]);
      candidate = candidates[key];
      if (candidate) {
        candidate[2] = [];
      }
      candidates[key] = token;
    }
  }
  removeDuplicateMediaQueries_1 = removeDuplicateMediaQueries;
  return removeDuplicateMediaQueries_1;
}

var removeDuplicates_1;
var hasRequiredRemoveDuplicates;
function requireRemoveDuplicates() {
  if (hasRequiredRemoveDuplicates) return removeDuplicates_1;
  hasRequiredRemoveDuplicates = 1;
  var Token = requireToken();
  var serializeBody = requireOneTime().body;
  var serializeRules = requireOneTime().rules;
  function removeDuplicates(tokens) {
    var matched = {};
    var moreThanOnce = [];
    var id, token;
    var body, bodies;
    for (var i = 0, l = tokens.length; i < l; i++) {
      token = tokens[i];
      if (token[0] != Token.RULE) continue;
      id = serializeRules(token[1]);
      if (matched[id] && matched[id].length == 1) moreThanOnce.push(id);else matched[id] = matched[id] || [];
      matched[id].push(i);
    }
    for (i = 0, l = moreThanOnce.length; i < l; i++) {
      id = moreThanOnce[i];
      bodies = [];
      for (var j = matched[id].length - 1; j >= 0; j--) {
        token = tokens[matched[id][j]];
        body = serializeBody(token[2]);
        if (bodies.indexOf(body) > -1) token[2] = [];else bodies.push(body);
      }
    }
  }
  removeDuplicates_1 = removeDuplicates;
  return removeDuplicates_1;
}

var removeUnusedAtRules_1;
var hasRequiredRemoveUnusedAtRules;
function requireRemoveUnusedAtRules() {
  if (hasRequiredRemoveUnusedAtRules) return removeUnusedAtRules_1;
  hasRequiredRemoveUnusedAtRules = 1;
  var populateComponents = requirePopulateComponents();
  var wrapForOptimizing = requireWrapForOptimizing().single;
  var restoreFromOptimizing = requireRestoreFromOptimizing();
  var Token = requireToken();
  var animationNameRegex = /^(\-moz\-|\-o\-|\-webkit\-)?animation-name$/;
  var animationRegex = /^(\-moz\-|\-o\-|\-webkit\-)?animation$/;
  var keyframeRegex = /^@(\-moz\-|\-o\-|\-webkit\-)?keyframes /;
  var importantRegex = /\s{0,31}!important$/;
  var optionalMatchingQuotesRegex = /^(['"]?)(.*)\1$/;
  function normalize(value) {
    return value.replace(optionalMatchingQuotesRegex, '$2').replace(importantRegex, '');
  }
  function removeUnusedAtRules(tokens, context) {
    removeUnusedAtRule(tokens, matchCounterStyle, markCounterStylesAsUsed, context);
    removeUnusedAtRule(tokens, matchFontFace, markFontFacesAsUsed, context);
    removeUnusedAtRule(tokens, matchKeyframe, markKeyframesAsUsed, context);
    removeUnusedAtRule(tokens, matchNamespace, markNamespacesAsUsed, context);
  }
  function removeUnusedAtRule(tokens, matchCallback, markCallback, context) {
    var atRules = {};
    var atRule;
    var atRuleTokens;
    var atRuleToken;
    var zeroAt;
    var i, l;
    for (i = 0, l = tokens.length; i < l; i++) {
      matchCallback(tokens[i], atRules);
    }
    if (Object.keys(atRules).length === 0) {
      return;
    }
    markUsedAtRules(tokens, markCallback, atRules, context);
    for (atRule in atRules) {
      atRuleTokens = atRules[atRule];
      for (i = 0, l = atRuleTokens.length; i < l; i++) {
        atRuleToken = atRuleTokens[i];
        zeroAt = atRuleToken[0] == Token.AT_RULE ? 1 : 2;
        atRuleToken[zeroAt] = [];
      }
    }
  }
  function markUsedAtRules(tokens, markCallback, atRules, context) {
    var boundMarkCallback = markCallback(atRules);
    var i, l;
    for (i = 0, l = tokens.length; i < l; i++) {
      switch (tokens[i][0]) {
        case Token.RULE:
          boundMarkCallback(tokens[i], context);
          break;
        case Token.NESTED_BLOCK:
          markUsedAtRules(tokens[i][2], markCallback, atRules, context);
      }
    }
  }
  function matchCounterStyle(token, atRules) {
    var match;
    if (token[0] == Token.AT_RULE_BLOCK && token[1][0][1].indexOf('@counter-style') === 0) {
      match = token[1][0][1].split(' ')[1];
      atRules[match] = atRules[match] || [];
      atRules[match].push(token);
    }
  }
  function markCounterStylesAsUsed(atRules) {
    return function (token, context) {
      var property;
      var wrappedProperty;
      var i, l;
      for (i = 0, l = token[2].length; i < l; i++) {
        property = token[2][i];
        if (property[1][1] == 'list-style') {
          wrappedProperty = wrapForOptimizing(property);
          populateComponents([wrappedProperty], context.validator, context.warnings);
          if (wrappedProperty.components[0].value[0][1] in atRules) {
            delete atRules[property[2][1]];
          }
          restoreFromOptimizing([wrappedProperty]);
        }
        if (property[1][1] == 'list-style-type' && property[2][1] in atRules) {
          delete atRules[property[2][1]];
        }
      }
    };
  }
  function matchFontFace(token, atRules) {
    var property;
    var match;
    var i, l;
    if (token[0] == Token.AT_RULE_BLOCK && token[1][0][1] == '@font-face') {
      for (i = 0, l = token[2].length; i < l; i++) {
        property = token[2][i];
        if (property[1][1] == 'font-family') {
          match = normalize(property[2][1].toLowerCase());
          atRules[match] = atRules[match] || [];
          atRules[match].push(token);
          break;
        }
      }
    }
  }
  function markFontFacesAsUsed(atRules) {
    return function (token, context) {
      var property;
      var wrappedProperty;
      var component;
      var normalizedMatch;
      var i, l;
      var j, m;
      for (i = 0, l = token[2].length; i < l; i++) {
        property = token[2][i];
        if (property[1][1] == 'font') {
          wrappedProperty = wrapForOptimizing(property);
          populateComponents([wrappedProperty], context.validator, context.warnings);
          component = wrappedProperty.components[6];
          for (j = 0, m = component.value.length; j < m; j++) {
            normalizedMatch = normalize(component.value[j][1].toLowerCase());
            if (normalizedMatch in atRules) {
              delete atRules[normalizedMatch];
            }
          }
          restoreFromOptimizing([wrappedProperty]);
        }
        if (property[1][1] == 'font-family') {
          for (j = 2, m = property.length; j < m; j++) {
            normalizedMatch = normalize(property[j][1].toLowerCase());
            if (normalizedMatch in atRules) {
              delete atRules[normalizedMatch];
            }
          }
        }
      }
    };
  }
  function matchKeyframe(token, atRules) {
    var match;
    if (token[0] == Token.NESTED_BLOCK && keyframeRegex.test(token[1][0][1])) {
      match = token[1][0][1].split(' ')[1];
      atRules[match] = atRules[match] || [];
      atRules[match].push(token);
    }
  }
  function markKeyframesAsUsed(atRules) {
    return function (token, context) {
      var property;
      var wrappedProperty;
      var component;
      var i, l;
      var j, m;
      for (i = 0, l = token[2].length; i < l; i++) {
        property = token[2][i];
        if (animationRegex.test(property[1][1])) {
          wrappedProperty = wrapForOptimizing(property);
          populateComponents([wrappedProperty], context.validator, context.warnings);
          component = wrappedProperty.components[7];
          for (j = 0, m = component.value.length; j < m; j++) {
            if (component.value[j][1] in atRules) {
              delete atRules[component.value[j][1]];
            }
          }
          restoreFromOptimizing([wrappedProperty]);
        }
        if (animationNameRegex.test(property[1][1])) {
          for (j = 2, m = property.length; j < m; j++) {
            if (property[j][1] in atRules) {
              delete atRules[property[j][1]];
            }
          }
        }
      }
    };
  }
  function matchNamespace(token, atRules) {
    var match;
    if (token[0] == Token.AT_RULE && token[1].indexOf('@namespace') === 0) {
      match = token[1].split(' ')[1];
      atRules[match] = atRules[match] || [];
      atRules[match].push(token);
    }
  }
  function markNamespacesAsUsed(atRules) {
    var namespaceRegex = new RegExp(Object.keys(atRules).join('\\\||') + '\\\|', 'g');
    return function (token) {
      var match;
      var scope;
      var normalizedMatch;
      var i, l;
      var j, m;
      for (i = 0, l = token[1].length; i < l; i++) {
        scope = token[1][i];
        match = scope[1].match(namespaceRegex);
        for (j = 0, m = match.length; j < m; j++) {
          normalizedMatch = match[j].substring(0, match[j].length - 1);
          if (normalizedMatch in atRules) {
            delete atRules[normalizedMatch];
          }
        }
      }
    };
  }
  removeUnusedAtRules_1 = removeUnusedAtRules;
  return removeUnusedAtRules_1;
}

var tidyRuleDuplicates_1;
var hasRequiredTidyRuleDuplicates;
function requireTidyRuleDuplicates() {
  if (hasRequiredTidyRuleDuplicates) return tidyRuleDuplicates_1;
  hasRequiredTidyRuleDuplicates = 1;
  function ruleSorter(s1, s2) {
    return s1[1] > s2[1] ? 1 : -1;
  }
  function tidyRuleDuplicates(rules) {
    var list = [];
    var repeated = [];
    for (var i = 0, l = rules.length; i < l; i++) {
      var rule = rules[i];
      if (repeated.indexOf(rule[1]) == -1) {
        repeated.push(rule[1]);
        list.push(rule);
      }
    }
    return list.sort(ruleSorter);
  }
  tidyRuleDuplicates_1 = tidyRuleDuplicates;
  return tidyRuleDuplicates_1;
}

var restructure_1;
var hasRequiredRestructure;
function requireRestructure() {
  if (hasRequiredRestructure) return restructure_1;
  hasRequiredRestructure = 1;
  var canReorderSingle = requireReorderable().canReorderSingle;
  var extractProperties = requireExtractProperties();
  var isMergeable = requireIsMergeable();
  var tidyRuleDuplicates = requireTidyRuleDuplicates();
  var Token = requireToken();
  var cloneArray = requireCloneArray();
  var serializeBody = requireOneTime().body;
  var serializeRules = requireOneTime().rules;
  function naturalSorter(a, b) {
    return a > b ? 1 : -1;
  }
  function cloneAndMergeSelectors(propertyA, propertyB) {
    var cloned = cloneArray(propertyA);
    cloned[5] = cloned[5].concat(propertyB[5]);
    return cloned;
  }
  function restructure(tokens, context) {
    var options = context.options;
    var mergeablePseudoClasses = options.compatibility.selectors.mergeablePseudoClasses;
    var mergeablePseudoElements = options.compatibility.selectors.mergeablePseudoElements;
    var mergeLimit = options.compatibility.selectors.mergeLimit;
    var multiplePseudoMerging = options.compatibility.selectors.multiplePseudoMerging;
    var specificityCache = context.cache.specificity;
    var movableTokens = {};
    var movedProperties = [];
    var multiPropertyMoveCache = {};
    var movedToBeDropped = [];
    var maxCombinationsLevel = 2;
    var ID_JOIN_CHARACTER = '%';
    function sendToMultiPropertyMoveCache(position, movedProperty, allFits) {
      for (var i = allFits.length - 1; i >= 0; i--) {
        var fit = allFits[i][0];
        var id = addToCache(movedProperty, fit);
        if (multiPropertyMoveCache[id].length > 1 && processMultiPropertyMove(position, multiPropertyMoveCache[id])) {
          removeAllMatchingFromCache(id);
          break;
        }
      }
    }
    function addToCache(movedProperty, fit) {
      var id = cacheId(fit);
      multiPropertyMoveCache[id] = multiPropertyMoveCache[id] || [];
      multiPropertyMoveCache[id].push([movedProperty, fit]);
      return id;
    }
    function removeAllMatchingFromCache(matchId) {
      var matchSelectors = matchId.split(ID_JOIN_CHARACTER);
      var forRemoval = [];
      var i;
      for (var id in multiPropertyMoveCache) {
        var selectors = id.split(ID_JOIN_CHARACTER);
        for (i = selectors.length - 1; i >= 0; i--) {
          if (matchSelectors.indexOf(selectors[i]) > -1) {
            forRemoval.push(id);
            break;
          }
        }
      }
      for (i = forRemoval.length - 1; i >= 0; i--) {
        delete multiPropertyMoveCache[forRemoval[i]];
      }
    }
    function cacheId(cachedTokens) {
      var id = [];
      for (var i = 0, l = cachedTokens.length; i < l; i++) {
        id.push(serializeRules(cachedTokens[i][1]));
      }
      return id.join(ID_JOIN_CHARACTER);
    }
    function tokensToMerge(sourceTokens) {
      var uniqueTokensWithBody = [];
      var mergeableTokens = [];
      for (var i = sourceTokens.length - 1; i >= 0; i--) {
        if (!isMergeable(serializeRules(sourceTokens[i][1]), mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging)) {
          continue;
        }
        mergeableTokens.unshift(sourceTokens[i]);
        if (sourceTokens[i][2].length > 0 && uniqueTokensWithBody.indexOf(sourceTokens[i]) == -1) uniqueTokensWithBody.push(sourceTokens[i]);
      }
      return uniqueTokensWithBody.length > 1 ? mergeableTokens : [];
    }
    function shortenIfPossible(position, movedProperty) {
      var name = movedProperty[0];
      var value = movedProperty[1];
      var key = movedProperty[4];
      var valueSize = name.length + value.length + 1;
      var allSelectors = [];
      var qualifiedTokens = [];
      var mergeableTokens = tokensToMerge(movableTokens[key]);
      if (mergeableTokens.length < 2) return;
      var allFits = findAllFits(mergeableTokens, valueSize, 1);
      var bestFit = allFits[0];
      if (bestFit[1] > 0) return sendToMultiPropertyMoveCache(position, movedProperty, allFits);
      for (var i = bestFit[0].length - 1; i >= 0; i--) {
        allSelectors = bestFit[0][i][1].concat(allSelectors);
        qualifiedTokens.unshift(bestFit[0][i]);
      }
      allSelectors = tidyRuleDuplicates(allSelectors);
      dropAsNewTokenAt(position, [movedProperty], allSelectors, qualifiedTokens);
    }
    function fitSorter(fit1, fit2) {
      return fit1[1] > fit2[1] ? 1 : fit1[1] == fit2[1] ? 0 : -1;
    }
    function findAllFits(mergeableTokens, propertySize, propertiesCount) {
      var combinations = allCombinations(mergeableTokens, propertySize, propertiesCount, maxCombinationsLevel - 1);
      return combinations.sort(fitSorter);
    }
    function allCombinations(tokensVariant, propertySize, propertiesCount, level) {
      var differenceVariants = [[tokensVariant, sizeDifference(tokensVariant, propertySize, propertiesCount)]];
      if (tokensVariant.length > 2 && level > 0) {
        for (var i = tokensVariant.length - 1; i >= 0; i--) {
          var subVariant = Array.prototype.slice.call(tokensVariant, 0);
          subVariant.splice(i, 1);
          differenceVariants = differenceVariants.concat(allCombinations(subVariant, propertySize, propertiesCount, level - 1));
        }
      }
      return differenceVariants;
    }
    function sizeDifference(tokensVariant, propertySize, propertiesCount) {
      var allSelectorsSize = 0;
      for (var i = tokensVariant.length - 1; i >= 0; i--) {
        allSelectorsSize += tokensVariant[i][2].length > propertiesCount ? serializeRules(tokensVariant[i][1]).length : -1;
      }
      return allSelectorsSize - (tokensVariant.length - 1) * propertySize + 1;
    }
    function dropAsNewTokenAt(position, properties, allSelectors, mergeableTokens) {
      var i, j, k, m;
      var allProperties = [];
      for (i = mergeableTokens.length - 1; i >= 0; i--) {
        var mergeableToken = mergeableTokens[i];
        for (j = mergeableToken[2].length - 1; j >= 0; j--) {
          var mergeableProperty = mergeableToken[2][j];
          for (k = 0, m = properties.length; k < m; k++) {
            var property = properties[k];
            var mergeablePropertyName = mergeableProperty[1][1];
            var propertyName = property[0];
            var propertyBody = property[4];
            if (mergeablePropertyName == propertyName && serializeBody([mergeableProperty]) == propertyBody) {
              mergeableToken[2].splice(j, 1);
              break;
            }
          }
        }
      }
      for (i = properties.length - 1; i >= 0; i--) {
        allProperties.unshift(properties[i][3]);
      }
      var newToken = [Token.RULE, allSelectors, allProperties];
      tokens.splice(position, 0, newToken);
    }
    function dropPropertiesAt(position, movedProperty) {
      var key = movedProperty[4];
      var toMove = movableTokens[key];
      if (toMove && toMove.length > 1) {
        if (!shortenMultiMovesIfPossible(position, movedProperty)) shortenIfPossible(position, movedProperty);
      }
    }
    function shortenMultiMovesIfPossible(position, movedProperty) {
      var candidates = [];
      var propertiesAndMergableTokens = [];
      var key = movedProperty[4];
      var j, k;
      var mergeableTokens = tokensToMerge(movableTokens[key]);
      if (mergeableTokens.length < 2) return;
      movableLoop: for (var value in movableTokens) {
        var tokensList = movableTokens[value];
        for (j = mergeableTokens.length - 1; j >= 0; j--) {
          if (tokensList.indexOf(mergeableTokens[j]) == -1) continue movableLoop;
        }
        candidates.push(value);
      }
      if (candidates.length < 2) return false;
      for (j = candidates.length - 1; j >= 0; j--) {
        for (k = movedProperties.length - 1; k >= 0; k--) {
          if (movedProperties[k][4] == candidates[j]) {
            propertiesAndMergableTokens.unshift([movedProperties[k], mergeableTokens]);
            break;
          }
        }
      }
      return processMultiPropertyMove(position, propertiesAndMergableTokens);
    }
    function processMultiPropertyMove(position, propertiesAndMergableTokens) {
      var valueSize = 0;
      var properties = [];
      var property;
      for (var i = propertiesAndMergableTokens.length - 1; i >= 0; i--) {
        property = propertiesAndMergableTokens[i][0];
        var fullValue = property[4];
        valueSize += fullValue.length + (i > 0 ? 1 : 0);
        properties.push(property);
      }
      var mergeableTokens = propertiesAndMergableTokens[0][1];
      var bestFit = findAllFits(mergeableTokens, valueSize, properties.length)[0];
      if (bestFit[1] > 0) return false;
      var allSelectors = [];
      var qualifiedTokens = [];
      for (i = bestFit[0].length - 1; i >= 0; i--) {
        allSelectors = bestFit[0][i][1].concat(allSelectors);
        qualifiedTokens.unshift(bestFit[0][i]);
      }
      allSelectors = tidyRuleDuplicates(allSelectors);
      dropAsNewTokenAt(position, properties, allSelectors, qualifiedTokens);
      for (i = properties.length - 1; i >= 0; i--) {
        property = properties[i];
        var index = movedProperties.indexOf(property);
        delete movableTokens[property[4]];
        if (index > -1 && movedToBeDropped.indexOf(index) == -1) movedToBeDropped.push(index);
      }
      return true;
    }
    function boundToAnotherPropertyInCurrrentToken(property, movedProperty, token) {
      var propertyName = property[0];
      var movedPropertyName = movedProperty[0];
      if (propertyName != movedPropertyName) return false;
      var key = movedProperty[4];
      var toMove = movableTokens[key];
      return toMove && toMove.indexOf(token) > -1;
    }
    for (var i = tokens.length - 1; i >= 0; i--) {
      var token = tokens[i];
      var isRule;
      var j, k, m;
      var samePropertyAt;
      if (token[0] == Token.RULE) {
        isRule = true;
      } else if (token[0] == Token.NESTED_BLOCK) {
        isRule = false;
      } else {
        continue;
      }

      // We cache movedProperties.length as it may change in the loop
      var movedCount = movedProperties.length;
      var properties = extractProperties(token);
      movedToBeDropped = [];
      var unmovableInCurrentToken = [];
      for (j = properties.length - 1; j >= 0; j--) {
        for (k = j - 1; k >= 0; k--) {
          if (!canReorderSingle(properties[j], properties[k], specificityCache)) {
            unmovableInCurrentToken.push(j);
            break;
          }
        }
      }
      for (j = properties.length - 1; j >= 0; j--) {
        var property = properties[j];
        var movedSameProperty = false;
        for (k = 0; k < movedCount; k++) {
          var movedProperty = movedProperties[k];
          if (movedToBeDropped.indexOf(k) == -1 && (!canReorderSingle(property, movedProperty, specificityCache) && !boundToAnotherPropertyInCurrrentToken(property, movedProperty, token) || movableTokens[movedProperty[4]] && movableTokens[movedProperty[4]].length === mergeLimit)) {
            dropPropertiesAt(i + 1, movedProperty);
            if (movedToBeDropped.indexOf(k) == -1) {
              movedToBeDropped.push(k);
              delete movableTokens[movedProperty[4]];
            }
          }
          if (!movedSameProperty) {
            movedSameProperty = property[0] == movedProperty[0] && property[1] == movedProperty[1];
            if (movedSameProperty) {
              samePropertyAt = k;
            }
          }
        }
        if (!isRule || unmovableInCurrentToken.indexOf(j) > -1) continue;
        var key = property[4];
        if (movedSameProperty && movedProperties[samePropertyAt][5].length + property[5].length > mergeLimit) {
          dropPropertiesAt(i + 1, movedProperties[samePropertyAt]);
          movedProperties.splice(samePropertyAt, 1);
          movableTokens[key] = [token];
          movedSameProperty = false;
        } else {
          movableTokens[key] = movableTokens[key] || [];
          movableTokens[key].push(token);
        }
        if (movedSameProperty) {
          movedProperties[samePropertyAt] = cloneAndMergeSelectors(movedProperties[samePropertyAt], property);
        } else {
          movedProperties.push(property);
        }
      }
      movedToBeDropped = movedToBeDropped.sort(naturalSorter);
      for (j = 0, m = movedToBeDropped.length; j < m; j++) {
        var dropAt = movedToBeDropped[j] - j;
        movedProperties.splice(dropAt, 1);
      }
    }
    var position = tokens[0] && tokens[0][0] == Token.AT_RULE && tokens[0][1].indexOf('@charset') === 0 ? 1 : 0;
    for (; position < tokens.length - 1; position++) {
      var isImportRule = tokens[position][0] === Token.AT_RULE && tokens[position][1].indexOf('@import') === 0;
      var isComment = tokens[position][0] === Token.COMMENT;
      if (!(isImportRule || isComment)) break;
    }
    for (i = 0; i < movedProperties.length; i++) {
      dropPropertiesAt(position, movedProperties[i]);
    }
  }
  restructure_1 = restructure;
  return restructure_1;
}

var optimize;
var hasRequiredOptimize;
function requireOptimize() {
  if (hasRequiredOptimize) return optimize;
  hasRequiredOptimize = 1;
  var mergeAdjacent = requireMergeAdjacent();
  var mergeMediaQueries = requireMergeMediaQueries();
  var mergeNonAdjacentByBody = requireMergeNonAdjacentByBody();
  var mergeNonAdjacentBySelector = requireMergeNonAdjacentBySelector();
  var reduceNonAdjacent = requireReduceNonAdjacent();
  var removeDuplicateFontAtRules = requireRemoveDuplicateFontAtRules();
  var removeDuplicateMediaQueries = requireRemoveDuplicateMediaQueries();
  var removeDuplicates = requireRemoveDuplicates();
  var removeUnusedAtRules = requireRemoveUnusedAtRules();
  var restructure = requireRestructure();
  var optimizeProperties = requireOptimize$1();
  var OptimizationLevel = requireOptimizationLevel().OptimizationLevel;
  var Token = requireToken();
  function removeEmpty(tokens) {
    for (var i = 0, l = tokens.length; i < l; i++) {
      var token = tokens[i];
      var isEmpty = false;
      switch (token[0]) {
        case Token.RULE:
          isEmpty = token[1].length === 0 || token[2].length === 0;
          break;
        case Token.NESTED_BLOCK:
          removeEmpty(token[2]);
          isEmpty = token[2].length === 0;
          break;
        case Token.AT_RULE:
          isEmpty = token[1].length === 0;
          break;
        case Token.AT_RULE_BLOCK:
          isEmpty = token[2].length === 0;
      }
      if (isEmpty) {
        tokens.splice(i, 1);
        i--;
        l--;
      }
    }
  }
  function recursivelyOptimizeBlocks(tokens, context) {
    for (var i = 0, l = tokens.length; i < l; i++) {
      var token = tokens[i];
      if (token[0] == Token.NESTED_BLOCK) {
        var isKeyframes = /@(-moz-|-o-|-webkit-)?keyframes/.test(token[1][0][1]);
        level2Optimize(token[2], context, !isKeyframes);
      }
    }
  }
  function recursivelyOptimizeProperties(tokens, context) {
    for (var i = 0, l = tokens.length; i < l; i++) {
      var token = tokens[i];
      switch (token[0]) {
        case Token.RULE:
          optimizeProperties(token[2], true, true, context);
          break;
        case Token.NESTED_BLOCK:
          recursivelyOptimizeProperties(token[2], context);
      }
    }
  }
  function level2Optimize(tokens, context, withRestructuring) {
    var levelOptions = context.options.level[OptimizationLevel.Two];
    var reduced;
    var i;
    recursivelyOptimizeBlocks(tokens, context);
    recursivelyOptimizeProperties(tokens, context);
    if (levelOptions.removeDuplicateRules) {
      removeDuplicates(tokens, context);
    }
    if (levelOptions.mergeAdjacentRules) {
      mergeAdjacent(tokens, context);
    }
    if (levelOptions.reduceNonAdjacentRules) {
      reduceNonAdjacent(tokens, context);
    }
    if (levelOptions.mergeNonAdjacentRules && levelOptions.mergeNonAdjacentRules != 'body') {
      mergeNonAdjacentBySelector(tokens, context);
    }
    if (levelOptions.mergeNonAdjacentRules && levelOptions.mergeNonAdjacentRules != 'selector') {
      mergeNonAdjacentByBody(tokens, context);
    }
    if (levelOptions.restructureRules && levelOptions.mergeAdjacentRules && withRestructuring) {
      restructure(tokens, context);
      mergeAdjacent(tokens, context);
    }
    if (levelOptions.restructureRules && !levelOptions.mergeAdjacentRules && withRestructuring) {
      restructure(tokens, context);
    }
    if (levelOptions.removeDuplicateFontRules) {
      removeDuplicateFontAtRules(tokens, context);
    }
    if (levelOptions.removeDuplicateMediaBlocks) {
      removeDuplicateMediaQueries(tokens, context);
    }
    if (levelOptions.removeUnusedAtRules) {
      removeUnusedAtRules(tokens, context);
    }
    if (levelOptions.mergeMedia) {
      reduced = mergeMediaQueries(tokens, context);
      for (i = reduced.length - 1; i >= 0; i--) {
        level2Optimize(reduced[i][2], context, false);
      }
    }
    if (levelOptions.removeEmpty) {
      removeEmpty(tokens);
    }
    return tokens;
  }
  optimize = level2Optimize;
  return optimize;
}

var validator_1;
var hasRequiredValidator;
function requireValidator() {
  if (hasRequiredValidator) return validator_1;
  hasRequiredValidator = 1;
  var functionNoVendorRegexStr = '[A-Z]+(\\-|[A-Z]|[0-9])+\\(.*?\\)';
  var functionVendorRegexStr = '\\-(\\-|[A-Z]|[0-9])+\\(.*?\\)';
  var variableRegexStr = 'var\\(\\-\\-[^\\)]+\\)';
  var functionAnyRegexStr = '(' + variableRegexStr + '|' + functionNoVendorRegexStr + '|' + functionVendorRegexStr + ')';
  var calcRegex = new RegExp('^(\\-moz\\-|\\-webkit\\-)?calc\\([^\\)]+\\)$', 'i');
  var decimalRegex = /[0-9]/;
  var functionAnyRegex = new RegExp('^' + functionAnyRegexStr + '$', 'i');
  var hslColorRegex = /^hsl\(\s{0,31}[\-\.]?\d+\s{0,31},\s{0,31}\.?\d+%\s{0,31},\s{0,31}\.?\d+%\s{0,31}\)|hsla\(\s{0,31}[\-\.]?\d+\s{0,31},\s{0,31}\.?\d+%\s{0,31},\s{0,31}\.?\d+%\s{0,31},\s{0,31}\.?\d+\s{0,31}\)$/i;
  var identifierRegex = /^(\-[a-z0-9_][a-z0-9\-_]*|[a-z][a-z0-9\-_]*)$/i;
  var namedEntityRegex = /^[a-z]+$/i;
  var prefixRegex = /^-([a-z0-9]|-)*$/i;
  var rgbColorRegex = /^rgb\(\s{0,31}[\d]{1,3}\s{0,31},\s{0,31}[\d]{1,3}\s{0,31},\s{0,31}[\d]{1,3}\s{0,31}\)|rgba\(\s{0,31}[\d]{1,3}\s{0,31},\s{0,31}[\d]{1,3}\s{0,31},\s{0,31}[\d]{1,3}\s{0,31},\s{0,31}[\.\d]+\s{0,31}\)$/i;
  var timingFunctionRegex = /^(cubic\-bezier|steps)\([^\)]+\)$/;
  var validTimeUnits = ['ms', 's'];
  var urlRegex = /^url\([\s\S]+\)$/i;
  var variableRegex = new RegExp('^' + variableRegexStr + '$', 'i');
  var eightValueColorRegex = /^#[0-9a-f]{8}$/i;
  var fourValueColorRegex = /^#[0-9a-f]{4}$/i;
  var sixValueColorRegex = /^#[0-9a-f]{6}$/i;
  var threeValueColorRegex = /^#[0-9a-f]{3}$/i;
  var DECIMAL_DOT = '.';
  var MINUS_SIGN = '-';
  var PLUS_SIGN = '+';
  var Keywords = {
    '^': ['inherit', 'initial', 'unset'],
    '*-style': ['auto', 'dashed', 'dotted', 'double', 'groove', 'hidden', 'inset', 'none', 'outset', 'ridge', 'solid'],
    '*-timing-function': ['ease', 'ease-in', 'ease-in-out', 'ease-out', 'linear', 'step-end', 'step-start'],
    'animation-direction': ['alternate', 'alternate-reverse', 'normal', 'reverse'],
    'animation-fill-mode': ['backwards', 'both', 'forwards', 'none'],
    'animation-iteration-count': ['infinite'],
    'animation-name': ['none'],
    'animation-play-state': ['paused', 'running'],
    'background-attachment': ['fixed', 'inherit', 'local', 'scroll'],
    'background-clip': ['border-box', 'content-box', 'inherit', 'padding-box', 'text'],
    'background-origin': ['border-box', 'content-box', 'inherit', 'padding-box'],
    'background-position': ['bottom', 'center', 'left', 'right', 'top'],
    'background-repeat': ['no-repeat', 'inherit', 'repeat', 'repeat-x', 'repeat-y', 'round', 'space'],
    'background-size': ['auto', 'cover', 'contain'],
    'border-collapse': ['collapse', 'inherit', 'separate'],
    'bottom': ['auto'],
    'clear': ['both', 'left', 'none', 'right'],
    'color': ['transparent'],
    'cursor': ['all-scroll', 'auto', 'col-resize', 'crosshair', 'default', 'e-resize', 'help', 'move', 'n-resize', 'ne-resize', 'no-drop', 'not-allowed', 'nw-resize', 'pointer', 'progress', 'row-resize', 's-resize', 'se-resize', 'sw-resize', 'text', 'vertical-text', 'w-resize', 'wait'],
    'display': ['block', 'inline', 'inline-block', 'inline-table', 'list-item', 'none', 'table', 'table-caption', 'table-cell', 'table-column', 'table-column-group', 'table-footer-group', 'table-header-group', 'table-row', 'table-row-group'],
    'float': ['left', 'none', 'right'],
    'left': ['auto'],
    'font': ['caption', 'icon', 'menu', 'message-box', 'small-caption', 'status-bar', 'unset'],
    'font-size': ['large', 'larger', 'medium', 'small', 'smaller', 'x-large', 'x-small', 'xx-large', 'xx-small'],
    'font-stretch': ['condensed', 'expanded', 'extra-condensed', 'extra-expanded', 'normal', 'semi-condensed', 'semi-expanded', 'ultra-condensed', 'ultra-expanded'],
    'font-style': ['italic', 'normal', 'oblique'],
    'font-variant': ['normal', 'small-caps'],
    'font-weight': ['100', '200', '300', '400', '500', '600', '700', '800', '900', 'bold', 'bolder', 'lighter', 'normal'],
    'line-height': ['normal'],
    'list-style-position': ['inside', 'outside'],
    'list-style-type': ['armenian', 'circle', 'decimal', 'decimal-leading-zero', 'disc', 'decimal|disc',
    // this is the default value of list-style-type, see comment in compactable.js
    'georgian', 'lower-alpha', 'lower-greek', 'lower-latin', 'lower-roman', 'none', 'square', 'upper-alpha', 'upper-latin', 'upper-roman'],
    'overflow': ['auto', 'hidden', 'scroll', 'visible'],
    'position': ['absolute', 'fixed', 'relative', 'static'],
    'right': ['auto'],
    'text-align': ['center', 'justify', 'left', 'left|right',
    // this is the default value of list-style-type, see comment in compactable.js
    'right'],
    'text-decoration': ['line-through', 'none', 'overline', 'underline'],
    'text-overflow': ['clip', 'ellipsis'],
    'top': ['auto'],
    'vertical-align': ['baseline', 'bottom', 'middle', 'sub', 'super', 'text-bottom', 'text-top', 'top'],
    'visibility': ['collapse', 'hidden', 'visible'],
    'white-space': ['normal', 'nowrap', 'pre'],
    'width': ['inherit', 'initial', 'medium', 'thick', 'thin']
  };
  var Units = ['%', 'ch', 'cm', 'em', 'ex', 'in', 'mm', 'pc', 'pt', 'px', 'rem', 'vh', 'vm', 'vmax', 'vmin', 'vw'];
  function isColor(value) {
    return value != 'auto' && (isKeyword('color')(value) || isHexColor(value) || isColorFunction(value) || isNamedEntity(value));
  }
  function isColorFunction(value) {
    return isRgbColor(value) || isHslColor(value);
  }
  function isDynamicUnit(value) {
    return calcRegex.test(value);
  }
  function isFunction(value) {
    return functionAnyRegex.test(value);
  }
  function isHexColor(value) {
    return threeValueColorRegex.test(value) || fourValueColorRegex.test(value) || sixValueColorRegex.test(value) || eightValueColorRegex.test(value);
  }
  function isHslColor(value) {
    return hslColorRegex.test(value);
  }
  function isIdentifier(value) {
    return identifierRegex.test(value);
  }
  function isImage(value) {
    return value == 'none' || value == 'inherit' || isUrl(value);
  }
  function isKeyword(propertyName) {
    return function (value) {
      return Keywords[propertyName].indexOf(value) > -1;
    };
  }
  function isNamedEntity(value) {
    return namedEntityRegex.test(value);
  }
  function isNumber(value) {
    return scanForNumber(value) == value.length;
  }
  function isRgbColor(value) {
    return rgbColorRegex.test(value);
  }
  function isPrefixed(value) {
    return prefixRegex.test(value);
  }
  function isPositiveNumber(value) {
    return isNumber(value) && parseFloat(value) >= 0;
  }
  function isVariable(value) {
    return variableRegex.test(value);
  }
  function isTime(value) {
    var numberUpTo = scanForNumber(value);
    return numberUpTo == value.length && parseInt(value) === 0 || numberUpTo > -1 && validTimeUnits.indexOf(value.slice(numberUpTo + 1)) > -1;
  }
  function isTimingFunction() {
    var isTimingFunctionKeyword = isKeyword('*-timing-function');
    return function (value) {
      return isTimingFunctionKeyword(value) || timingFunctionRegex.test(value);
    };
  }
  function isUnit(validUnits, value) {
    var numberUpTo = scanForNumber(value);
    return numberUpTo == value.length && parseInt(value) === 0 || numberUpTo > -1 && validUnits.indexOf(value.slice(numberUpTo + 1)) > -1 || value == 'auto' || value == 'inherit';
  }
  function isUrl(value) {
    return urlRegex.test(value);
  }
  function isZIndex(value) {
    return value == 'auto' || isNumber(value) || isKeyword('^')(value);
  }
  function scanForNumber(value) {
    var hasDot = false;
    var hasSign = false;
    var character;
    var i, l;
    for (i = 0, l = value.length; i < l; i++) {
      character = value[i];
      if (i === 0 && (character == PLUS_SIGN || character == MINUS_SIGN)) {
        hasSign = true;
      } else if (i > 0 && hasSign && (character == PLUS_SIGN || character == MINUS_SIGN)) {
        return i - 1;
      } else if (character == DECIMAL_DOT && !hasDot) {
        hasDot = true;
      } else if (character == DECIMAL_DOT && hasDot) {
        return i - 1;
      } else if (decimalRegex.test(character)) {
        continue;
      } else {
        return i - 1;
      }
    }
    return i;
  }
  function validator(compatibility) {
    var validUnits = Units.slice(0).filter(function (value) {
      return !(value in compatibility.units) || compatibility.units[value] === true;
    });
    return {
      colorOpacity: compatibility.colors.opacity,
      isAnimationDirectionKeyword: isKeyword('animation-direction'),
      isAnimationFillModeKeyword: isKeyword('animation-fill-mode'),
      isAnimationIterationCountKeyword: isKeyword('animation-iteration-count'),
      isAnimationNameKeyword: isKeyword('animation-name'),
      isAnimationPlayStateKeyword: isKeyword('animation-play-state'),
      isTimingFunction: isTimingFunction(),
      isBackgroundAttachmentKeyword: isKeyword('background-attachment'),
      isBackgroundClipKeyword: isKeyword('background-clip'),
      isBackgroundOriginKeyword: isKeyword('background-origin'),
      isBackgroundPositionKeyword: isKeyword('background-position'),
      isBackgroundRepeatKeyword: isKeyword('background-repeat'),
      isBackgroundSizeKeyword: isKeyword('background-size'),
      isColor: isColor,
      isColorFunction: isColorFunction,
      isDynamicUnit: isDynamicUnit,
      isFontKeyword: isKeyword('font'),
      isFontSizeKeyword: isKeyword('font-size'),
      isFontStretchKeyword: isKeyword('font-stretch'),
      isFontStyleKeyword: isKeyword('font-style'),
      isFontVariantKeyword: isKeyword('font-variant'),
      isFontWeightKeyword: isKeyword('font-weight'),
      isFunction: isFunction,
      isGlobal: isKeyword('^'),
      isHslColor: isHslColor,
      isIdentifier: isIdentifier,
      isImage: isImage,
      isKeyword: isKeyword,
      isLineHeightKeyword: isKeyword('line-height'),
      isListStylePositionKeyword: isKeyword('list-style-position'),
      isListStyleTypeKeyword: isKeyword('list-style-type'),
      isNumber: isNumber,
      isPrefixed: isPrefixed,
      isPositiveNumber: isPositiveNumber,
      isRgbColor: isRgbColor,
      isStyleKeyword: isKeyword('*-style'),
      isTime: isTime,
      isUnit: isUnit.bind(null, validUnits),
      isUrl: isUrl,
      isVariable: isVariable,
      isWidth: isKeyword('width'),
      isZIndex: isZIndex
    };
  }
  validator_1 = validator;
  return validator_1;
}

var compatibility;
var hasRequiredCompatibility;
function requireCompatibility() {
  if (hasRequiredCompatibility) return compatibility;
  hasRequiredCompatibility = 1;
  var DEFAULTS = {
    '*': {
      colors: {
        opacity: true // rgba / hsla
      },
      properties: {
        backgroundClipMerging: true,
        // background-clip to shorthand
        backgroundOriginMerging: true,
        // background-origin to shorthand
        backgroundSizeMerging: true,
        // background-size to shorthand
        colors: true,
        // any kind of color transformations, like `#ff00ff` to `#f0f` or `#fff` into `red`
        ieBangHack: false,
        // !ie suffix hacks on IE<8
        ieFilters: false,
        // whether to preserve `filter` and `-ms-filter` properties
        iePrefixHack: false,
        // underscore / asterisk prefix hacks on IE
        ieSuffixHack: false,
        // \9 suffix hacks on IE6-9
        merging: true,
        // merging properties into one
        shorterLengthUnits: false,
        // optimize pixel units into `pt`, `pc` or `in` units
        spaceAfterClosingBrace: true,
        // 'url() no-repeat' to 'url()no-repeat'
        urlQuotes: false,
        // whether to wrap content of `url()` into quotes or not
        zeroUnits: true // 0[unit] -> 0
      },
      selectors: {
        adjacentSpace: false,
        // div+ nav Android stock browser hack
        ie7Hack: false,
        // *+html hack
        mergeablePseudoClasses: [':active', ':after', ':before', ':empty', ':checked', ':disabled', ':empty', ':enabled', ':first-child', ':first-letter', ':first-line', ':first-of-type', ':focus', ':hover', ':lang', ':last-child', ':last-of-type', ':link', ':not', ':nth-child', ':nth-last-child', ':nth-last-of-type', ':nth-of-type', ':only-child', ':only-of-type', ':root', ':target', ':visited'],
        // selectors with these pseudo-classes can be merged as these are universally supported
        mergeablePseudoElements: ['::after', '::before', '::first-letter', '::first-line'],
        // selectors with these pseudo-elements can be merged as these are universally supported
        mergeLimit: 8191,
        // number of rules that can be safely merged together
        multiplePseudoMerging: true
      },
      units: {
        ch: true,
        in: true,
        pc: true,
        pt: true,
        rem: true,
        vh: true,
        vm: true,
        // vm is vmin on IE9+ see https://developer.mozilla.org/en-US/docs/Web/CSS/length
        vmax: true,
        vmin: true,
        vw: true
      }
    }
  };
  DEFAULTS.ie11 = DEFAULTS['*'];
  DEFAULTS.ie10 = DEFAULTS['*'];
  DEFAULTS.ie9 = merge(DEFAULTS['*'], {
    properties: {
      ieFilters: true,
      ieSuffixHack: true
    }
  });
  DEFAULTS.ie8 = merge(DEFAULTS.ie9, {
    colors: {
      opacity: false
    },
    properties: {
      backgroundClipMerging: false,
      backgroundOriginMerging: false,
      backgroundSizeMerging: false,
      iePrefixHack: true,
      merging: false
    },
    selectors: {
      mergeablePseudoClasses: [':after', ':before', ':first-child', ':first-letter', ':focus', ':hover', ':visited'],
      mergeablePseudoElements: []
    },
    units: {
      ch: false,
      rem: false,
      vh: false,
      vm: false,
      vmax: false,
      vmin: false,
      vw: false
    }
  });
  DEFAULTS.ie7 = merge(DEFAULTS.ie8, {
    properties: {
      ieBangHack: true
    },
    selectors: {
      ie7Hack: true,
      mergeablePseudoClasses: [':first-child', ':first-letter', ':hover', ':visited']
    }
  });
  function compatibilityFrom(source) {
    return merge(DEFAULTS['*'], calculateSource(source));
  }
  function merge(source, target) {
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        var value = source[key];
        if (Object.prototype.hasOwnProperty.call(target, key) && typeof value === 'object' && !Array.isArray(value)) {
          target[key] = merge(value, target[key] || {});
        } else {
          target[key] = key in target ? target[key] : value;
        }
      }
    }
    return target;
  }
  function calculateSource(source) {
    if (typeof source == 'object') return source;
    if (!/[,\+\-]/.test(source)) return DEFAULTS[source] || DEFAULTS['*'];
    var parts = source.split(',');
    var template = parts[0] in DEFAULTS ? DEFAULTS[parts.shift()] : DEFAULTS['*'];
    source = {};
    parts.forEach(function (part) {
      var isAdd = part[0] == '+';
      var key = part.substring(1).split('.');
      var group = key[0];
      var option = key[1];
      source[group] = source[group] || {};
      source[group][option] = isAdd;
    });
    return merge(template, source);
  }
  compatibility = compatibilityFrom;
  return compatibility;
}

var isHttpResource_1;
var hasRequiredIsHttpResource;
function requireIsHttpResource() {
  if (hasRequiredIsHttpResource) return isHttpResource_1;
  hasRequiredIsHttpResource = 1;
  var HTTP_RESOURCE_PATTERN = /^http:\/\//;
  function isHttpResource(uri) {
    return HTTP_RESOURCE_PATTERN.test(uri);
  }
  isHttpResource_1 = isHttpResource;
  return isHttpResource_1;
}

var isHttpsResource_1;
var hasRequiredIsHttpsResource;
function requireIsHttpsResource() {
  if (hasRequiredIsHttpsResource) return isHttpsResource_1;
  hasRequiredIsHttpsResource = 1;
  var HTTPS_RESOURCE_PATTERN = /^https:\/\//;
  function isHttpsResource(uri) {
    return HTTPS_RESOURCE_PATTERN.test(uri);
  }
  isHttpsResource_1 = isHttpsResource;
  return isHttpsResource_1;
}

var loadRemoteResource_1;
var hasRequiredLoadRemoteResource;
function requireLoadRemoteResource() {
  if (hasRequiredLoadRemoteResource) return loadRemoteResource_1;
  hasRequiredLoadRemoteResource = 1;
  var http = require$$0$7;
  var https = require$$1$3;
  var url = require$$1$2;
  var isHttpResource = requireIsHttpResource();
  var isHttpsResource = requireIsHttpsResource();
  var override = requireOverride();
  var HTTP_PROTOCOL = 'http:';
  function loadRemoteResource(uri, inlineRequest, inlineTimeout, callback) {
    var proxyProtocol = inlineRequest.protocol || inlineRequest.hostname;
    var errorHandled = false;
    var requestOptions;
    var fetch;
    requestOptions = override(url.parse(uri), inlineRequest || {});
    if (inlineRequest.hostname !== undefined) {
      // overwrite as we always expect a http proxy currently
      requestOptions.protocol = inlineRequest.protocol || HTTP_PROTOCOL;
      requestOptions.path = requestOptions.href;
    }
    fetch = proxyProtocol && !isHttpsResource(proxyProtocol) || isHttpResource(uri) ? http.get : https.get;
    fetch(requestOptions, function (res) {
      var chunks = [];
      var movedUri;
      if (errorHandled) {
        return;
      }
      if (res.statusCode < 200 || res.statusCode > 399) {
        return callback(res.statusCode, null);
      } else if (res.statusCode > 299) {
        movedUri = url.resolve(uri, res.headers.location);
        return loadRemoteResource(movedUri, inlineRequest, inlineTimeout, callback);
      }
      res.on('data', function (chunk) {
        chunks.push(chunk.toString());
      });
      res.on('end', function () {
        var body = chunks.join('');
        callback(null, body);
      });
    }).on('error', function (res) {
      if (errorHandled) {
        return;
      }
      errorHandled = true;
      callback(res.message, null);
    }).on('timeout', function () {
      if (errorHandled) {
        return;
      }
      errorHandled = true;
      callback('timeout', null);
    }).setTimeout(inlineTimeout);
  }
  loadRemoteResource_1 = loadRemoteResource;
  return loadRemoteResource_1;
}

var fetch;
var hasRequiredFetch;
function requireFetch() {
  if (hasRequiredFetch) return fetch;
  hasRequiredFetch = 1;
  var loadRemoteResource = requireLoadRemoteResource();
  function fetchFrom(callback) {
    return callback || loadRemoteResource;
  }
  fetch = fetchFrom;
  return fetch;
}

var inline;
var hasRequiredInline;
function requireInline() {
  if (hasRequiredInline) return inline;
  hasRequiredInline = 1;
  function inlineOptionsFrom(rules) {
    if (Array.isArray(rules)) {
      return rules;
    }
    if (rules === false) {
      return ['none'];
    }
    return undefined === rules ? ['local'] : rules.split(',');
  }
  inline = inlineOptionsFrom;
  return inline;
}

var inlineRequest;
var hasRequiredInlineRequest;
function requireInlineRequest() {
  if (hasRequiredInlineRequest) return inlineRequest;
  hasRequiredInlineRequest = 1;
  var url = require$$1$2;
  var override = requireOverride();
  function inlineRequestFrom(option) {
    return override(/* jshint camelcase: false */
    proxyOptionsFrom(process.env.HTTP_PROXY || process.env.http_proxy), option || {});
  }
  function proxyOptionsFrom(httpProxy) {
    return httpProxy ? {
      hostname: url.parse(httpProxy).hostname,
      port: parseInt(url.parse(httpProxy).port)
    } : {};
  }
  inlineRequest = inlineRequestFrom;
  return inlineRequest;
}

var inlineTimeout;
var hasRequiredInlineTimeout;
function requireInlineTimeout() {
  if (hasRequiredInlineTimeout) return inlineTimeout;
  hasRequiredInlineTimeout = 1;
  var DEFAULT_TIMEOUT = 5000;
  function inlineTimeoutFrom(option) {
    return option || DEFAULT_TIMEOUT;
  }
  inlineTimeout = inlineTimeoutFrom;
  return inlineTimeout;
}

var rebase;
var hasRequiredRebase$1;
function requireRebase$1() {
  if (hasRequiredRebase$1) return rebase;
  hasRequiredRebase$1 = 1;
  function rebaseFrom(rebaseOption) {
    return undefined === rebaseOption ? true : !!rebaseOption;
  }
  rebase = rebaseFrom;
  return rebase;
}

var rebaseTo;
var hasRequiredRebaseTo;
function requireRebaseTo() {
  if (hasRequiredRebaseTo) return rebaseTo;
  hasRequiredRebaseTo = 1;
  var path = require$$1$1;
  function rebaseToFrom(option) {
    return option ? path.resolve(option) : process.cwd();
  }
  rebaseTo = rebaseToFrom;
  return rebaseTo;
}

var sourceMap = {};

var sourceMapGenerator = {};

var base64Vlq = {};

var base64 = {};

/* -*- Mode: js; js-indent-level: 2; -*- */
var hasRequiredBase64;
function requireBase64() {
  if (hasRequiredBase64) return base64;
  hasRequiredBase64 = 1;
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

  /**
   * Encode an integer in the range of 0 to 63 to a single base 64 digit.
   */
  base64.encode = function (number) {
    if (0 <= number && number < intToCharMap.length) {
      return intToCharMap[number];
    }
    throw new TypeError("Must be between 0 and 63: " + number);
  };

  /**
   * Decode a single base 64 character code digit to an integer. Returns -1 on
   * failure.
   */
  base64.decode = function (charCode) {
    var bigA = 65; // 'A'
    var bigZ = 90; // 'Z'

    var littleA = 97; // 'a'
    var littleZ = 122; // 'z'

    var zero = 48; // '0'
    var nine = 57; // '9'

    var plus = 43; // '+'
    var slash = 47; // '/'

    var littleOffset = 26;
    var numberOffset = 52;

    // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
    if (bigA <= charCode && charCode <= bigZ) {
      return charCode - bigA;
    }

    // 26 - 51: abcdefghijklmnopqrstuvwxyz
    if (littleA <= charCode && charCode <= littleZ) {
      return charCode - littleA + littleOffset;
    }

    // 52 - 61: 0123456789
    if (zero <= charCode && charCode <= nine) {
      return charCode - zero + numberOffset;
    }

    // 62: +
    if (charCode == plus) {
      return 62;
    }

    // 63: /
    if (charCode == slash) {
      return 63;
    }

    // Invalid base64 digit.
    return -1;
  };
  return base64;
}

/* -*- Mode: js; js-indent-level: 2; -*- */
var hasRequiredBase64Vlq;
function requireBase64Vlq() {
  if (hasRequiredBase64Vlq) return base64Vlq;
  hasRequiredBase64Vlq = 1;
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   *
   * Based on the Base 64 VLQ implementation in Closure Compiler:
   * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
   *
   * Copyright 2011 The Closure Compiler Authors. All rights reserved.
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   *  * Redistributions of source code must retain the above copyright
   *    notice, this list of conditions and the following disclaimer.
   *  * Redistributions in binary form must reproduce the above
   *    copyright notice, this list of conditions and the following
   *    disclaimer in the documentation and/or other materials provided
   *    with the distribution.
   *  * Neither the name of Google Inc. nor the names of its
   *    contributors may be used to endorse or promote products derived
   *    from this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */

  var base64 = requireBase64();

  // A single base 64 digit can contain 6 bits of data. For the base 64 variable
  // length quantities we use in the source map spec, the first bit is the sign,
  // the next four bits are the actual value, and the 6th bit is the
  // continuation bit. The continuation bit tells us whether there are more
  // digits in this value following this digit.
  //
  //   Continuation
  //   |    Sign
  //   |    |
  //   V    V
  //   101011

  var VLQ_BASE_SHIFT = 5;

  // binary: 100000
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

  // binary: 011111
  var VLQ_BASE_MASK = VLQ_BASE - 1;

  // binary: 100000
  var VLQ_CONTINUATION_BIT = VLQ_BASE;

  /**
   * Converts from a two-complement value to a value where the sign bit is
   * placed in the least significant bit.  For example, as decimals:
   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
   */
  function toVLQSigned(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
  }

  /**
   * Converts to a two-complement value from a value where the sign bit is
   * placed in the least significant bit.  For example, as decimals:
   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
   */
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative ? -shifted : shifted;
  }

  /**
   * Returns the base 64 VLQ encoded value.
   */
  base64Vlq.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;
    var vlq = toVLQSigned(aValue);
    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        // There are still more digits in this value, so we must make sure the
        // continuation bit is marked.
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
    } while (vlq > 0);
    return encoded;
  };

  /**
   * Decodes the next base 64 VLQ value from the given string and returns the
   * value and the rest of the string via the out parameter.
   */
  base64Vlq.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;
    do {
      if (aIndex >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }
      digit = base64.decode(aStr.charCodeAt(aIndex++));
      if (digit === -1) {
        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
      }
      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);
    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
  };
  return base64Vlq;
}

var util = {};

/* -*- Mode: js; js-indent-level: 2; -*- */
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  (function (exports) {
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */

    /**
     * This is a helper function for getting values from parameter/options
     * objects.
     *
     * @param args The object we are extracting values from
     * @param name The name of the property we are getting.
     * @param defaultValue An optional value to return if the property is missing
     * from the object. If this is not specified and the property is missing, an
     * error will be thrown.
     */
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);
      if (!match) {
        return null;
      }
      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      };
    }
    exports.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url = '';
      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ':';
      }
      url += '//';
      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + '@';
      }
      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }
      return url;
    }
    exports.urlGenerate = urlGenerate;

    /**
     * Normalizes a path, or the path portion of a URL:
     *
     * - Replaces consecutive slashes with one slash.
     * - Removes unnecessary '.' parts.
     * - Removes unnecessary '<dir>/..' parts.
     *
     * Based on code in the Node.js 'path' core module.
     *
     * @param aPath The path or url to normalize.
     */
    function normalize(aPath) {
      var path = aPath;
      var url = urlParse(aPath);
      if (url) {
        if (!url.path) {
          return aPath;
        }
        path = url.path;
      }
      var isAbsolute = exports.isAbsolute(path);
      var parts = path.split(/\/+/);
      for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
        part = parts[i];
        if (part === '.') {
          parts.splice(i, 1);
        } else if (part === '..') {
          up++;
        } else if (up > 0) {
          if (part === '') {
            // The first part is blank if the path is absolute. Trying to go
            // above the root is a no-op. Therefore we can remove all '..' parts
            // directly after the root.
            parts.splice(i + 1, up);
            up = 0;
          } else {
            parts.splice(i, 2);
            up--;
          }
        }
      }
      path = parts.join('/');
      if (path === '') {
        path = isAbsolute ? '/' : '.';
      }
      if (url) {
        url.path = path;
        return urlGenerate(url);
      }
      return path;
    }
    exports.normalize = normalize;

    /**
     * Joins two paths/URLs.
     *
     * @param aRoot The root path or URL.
     * @param aPath The path or URL to be joined with the root.
     *
     * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
     *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
     *   first.
     * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
     *   is updated with the result and aRoot is returned. Otherwise the result
     *   is returned.
     *   - If aPath is absolute, the result is aPath.
     *   - Otherwise the two paths are joined with a slash.
     * - Joining for example 'http://' and 'www.example.com' is also supported.
     */
    function join(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || '/';
      }

      // `join(foo, '//www.example.org')`
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }

      // `join('http://', 'www.example.com')`
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports.join = join;
    exports.isAbsolute = function (aPath) {
      return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
    };

    /**
     * Make a path relative to a URL or another path.
     *
     * @param aRoot The root path or URL.
     * @param aPath The path or URL to be made relative to aRoot.
     */
    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, '');

      // It is possible for the path to be above the root. In this case, simply
      // checking whether the root is a prefix of the path won't work. Instead, we
      // need to remove components from the root one by one, until either we find
      // a prefix that fits, or we run out of components to remove.
      var level = 0;
      while (aPath.indexOf(aRoot + '/') !== 0) {
        var index = aRoot.lastIndexOf("/");
        if (index < 0) {
          return aPath;
        }

        // If the only part of the root that is left is the scheme (i.e. http://,
        // file:///, etc.), one or more slashes (/), or simply nothing at all, we
        // have exhausted all components, so the path is not relative to the root.
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }

      // Make sure we add a "../" for each component we removed from the root.
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports.relative = relative;
    var supportsNullProto = function () {
      var obj = Object.create(null);
      return !('__proto__' in obj);
    }();
    function identity(s) {
      return s;
    }

    /**
     * Because behavior goes wacky when you set `__proto__` on objects, we
     * have to prefix all the strings in our set with an arbitrary character.
     *
     * See https://github.com/mozilla/source-map/pull/31 and
     * https://github.com/mozilla/source-map/issues/30
     *
     * @param String aStr
     */
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return '$' + aStr;
      }
      return aStr;
    }
    exports.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s) {
      if (!s) {
        return false;
      }
      var length = s.length;
      if (length < 9 /* "__proto__".length */) {
        return false;
      }
      if (s.charCodeAt(length - 1) !== 95 /* '_' */ || s.charCodeAt(length - 2) !== 95 /* '_' */ || s.charCodeAt(length - 3) !== 111 /* 'o' */ || s.charCodeAt(length - 4) !== 116 /* 't' */ || s.charCodeAt(length - 5) !== 111 /* 'o' */ || s.charCodeAt(length - 6) !== 114 /* 'r' */ || s.charCodeAt(length - 7) !== 112 /* 'p' */ || s.charCodeAt(length - 8) !== 95 /* '_' */ || s.charCodeAt(length - 9) !== 95 /* '_' */) {
        return false;
      }
      for (var i = length - 10; i >= 0; i--) {
        if (s.charCodeAt(i) !== 36 /* '$' */) {
          return false;
        }
      }
      return true;
    }

    /**
     * Comparator between two mappings where the original positions are compared.
     *
     * Optionally pass in `true` as `onlyCompareGenerated` to consider two
     * mappings with the same original source/line/column, but different generated
     * line and column the same. Useful when searching for a mapping with a
     * stubbed out mapping.
     */
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByOriginalPositions = compareByOriginalPositions;

    /**
     * Comparator between two mappings with deflated source and name indices where
     * the generated positions are compared.
     *
     * Optionally pass in `true` as `onlyCompareGenerated` to consider two
     * mappings with the same generated line and column, but different
     * source/name/original line and column the same. Useful when searching for a
     * mapping with a stubbed out mapping.
     */
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 === null) {
        return 1; // aStr2 !== null
      }
      if (aStr2 === null) {
        return -1; // aStr1 !== null
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }

    /**
     * Comparator between two mappings with inflated source and name strings where
     * the generated positions are compared.
     */
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

    /**
     * Strip any JSON XSSI avoidance prefix from the string (as documented
     * in the source maps specification), and then parse the string as
     * JSON.
     */
    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
    }
    exports.parseSourceMapInput = parseSourceMapInput;

    /**
     * Compute the URL of a source given the the source root, the source's
     * URL, and the source map's URL.
     */
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      sourceURL = sourceURL || '';
      if (sourceRoot) {
        // This follows what Chrome does.
        if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
          sourceRoot += '/';
        }
        // The spec says:
        //   Line 4: An optional source root, useful for relocating source
        //   files on a server or removing repeated values in the
        //   sources entry.  This value is prepended to the individual
        //   entries in the source field.
        sourceURL = sourceRoot + sourceURL;
      }

      // Historically, SourceMapConsumer did not take the sourceMapURL as
      // a parameter.  This mode is still somewhat supported, which is why
      // this code block is conditional.  However, it's preferable to pass
      // the source map URL to SourceMapConsumer, so that this function
      // can implement the source URL resolution algorithm as outlined in
      // the spec.  This block is basically the equivalent of:
      //    new URL(sourceURL, sourceMapURL).toString()
      // ... except it avoids using URL, which wasn't available in the
      // older releases of node still supported by this library.
      //
      // The spec says:
      //   If the sources are not absolute URLs after prepending of the
      //   sourceRoot, the sources are resolved relative to the
      //   SourceMap (like resolving script src in a html document).
      if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
          throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
          // Strip the last path component, but keep the "/".
          var index = parsed.path.lastIndexOf('/');
          if (index >= 0) {
            parsed.path = parsed.path.substring(0, index + 1);
          }
        }
        sourceURL = join(urlGenerate(parsed), sourceURL);
      }
      return normalize(sourceURL);
    }
    exports.computeSourceURL = computeSourceURL;
  })(util);
  return util;
}

var arraySet = {};

/* -*- Mode: js; js-indent-level: 2; -*- */
var hasRequiredArraySet;
function requireArraySet() {
  if (hasRequiredArraySet) return arraySet;
  hasRequiredArraySet = 1;
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var util = requireUtil();
  var has = Object.prototype.hasOwnProperty;
  var hasNativeMap = typeof Map !== "undefined";

  /**
   * A data structure which is a combination of an array and a set. Adding a new
   * member is O(1), testing for membership is O(1), and finding the index of an
   * element is O(1). Removing elements from the set is not supported. Only
   * strings are supported for membership.
   */
  function ArraySet() {
    this._array = [];
    this._set = hasNativeMap ? new Map() : Object.create(null);
  }

  /**
   * Static method for creating ArraySet instances from an existing array.
   */
  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet();
    for (var i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }
    return set;
  };

  /**
   * Return how many unique items are in this ArraySet. If duplicates have been
   * added, than those do not count towards the size.
   *
   * @returns Number
   */
  ArraySet.prototype.size = function ArraySet_size() {
    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  };

  /**
   * Add the given string to this set.
   *
   * @param String aStr
   */
  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
    var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      if (hasNativeMap) {
        this._set.set(aStr, idx);
      } else {
        this._set[sStr] = idx;
      }
    }
  };

  /**
   * Is the given string a member of this set?
   *
   * @param String aStr
   */
  ArraySet.prototype.has = function ArraySet_has(aStr) {
    if (hasNativeMap) {
      return this._set.has(aStr);
    } else {
      var sStr = util.toSetString(aStr);
      return has.call(this._set, sStr);
    }
  };

  /**
   * What is the index of the given string in the array?
   *
   * @param String aStr
   */
  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (hasNativeMap) {
      var idx = this._set.get(aStr);
      if (idx >= 0) {
        return idx;
      }
    } else {
      var sStr = util.toSetString(aStr);
      if (has.call(this._set, sStr)) {
        return this._set[sStr];
      }
    }
    throw new Error('"' + aStr + '" is not in the set.');
  };

  /**
   * What is the element at the given index?
   *
   * @param Number aIdx
   */
  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error('No element indexed by ' + aIdx);
  };

  /**
   * Returns the array representation of this set (which has the proper indices
   * indicated by indexOf). Note that this is a copy of the internal array used
   * for storing the members so that no one can mess with internal state.
   */
  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };
  arraySet.ArraySet = ArraySet;
  return arraySet;
}

var mappingList = {};

/* -*- Mode: js; js-indent-level: 2; -*- */
var hasRequiredMappingList;
function requireMappingList() {
  if (hasRequiredMappingList) return mappingList;
  hasRequiredMappingList = 1;
  /*
   * Copyright 2014 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var util = requireUtil();

  /**
   * Determine whether mappingB is after mappingA with respect to generated
   * position.
   */
  function generatedPositionAfter(mappingA, mappingB) {
    // Optimized for most common case
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
  }

  /**
   * A data structure to provide a sorted view of accumulated mappings in a
   * performance conscious manner. It trades a neglibable overhead in general
   * case for a large speedup in case of mappings being added in order.
   */
  function MappingList() {
    this._array = [];
    this._sorted = true;
    // Serves as infimum
    this._last = {
      generatedLine: -1,
      generatedColumn: 0
    };
  }

  /**
   * Iterate through internal items. This method takes the same arguments that
   * `Array.prototype.forEach` takes.
   *
   * NOTE: The order of the mappings is NOT guaranteed.
   */
  MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

  /**
   * Add the given source mapping.
   *
   * @param Object aMapping
   */
  MappingList.prototype.add = function MappingList_add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;
      this._array.push(aMapping);
    } else {
      this._sorted = false;
      this._array.push(aMapping);
    }
  };

  /**
   * Returns the flat, sorted array of mappings. The mappings are sorted by
   * generated position.
   *
   * WARNING: This method returns internal data without copying, for
   * performance. The return value must NOT be mutated, and should be treated as
   * an immutable borrow. If you want to take ownership, you must make your own
   * copy.
   */
  MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util.compareByGeneratedPositionsInflated);
      this._sorted = true;
    }
    return this._array;
  };
  mappingList.MappingList = MappingList;
  return mappingList;
}

/* -*- Mode: js; js-indent-level: 2; -*- */
var hasRequiredSourceMapGenerator;
function requireSourceMapGenerator() {
  if (hasRequiredSourceMapGenerator) return sourceMapGenerator;
  hasRequiredSourceMapGenerator = 1;
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var base64VLQ = requireBase64Vlq();
  var util = requireUtil();
  var ArraySet = requireArraySet().ArraySet;
  var MappingList = requireMappingList().MappingList;

  /**
   * An instance of the SourceMapGenerator represents a source map which is
   * being built incrementally. You may pass an object with the following
   * properties:
   *
   *   - file: The filename of the generated source.
   *   - sourceRoot: A root for all relative URLs in this source map.
   */
  function SourceMapGenerator(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util.getArg(aArgs, 'file', null);
    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
    this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = new MappingList();
    this._sourcesContents = null;
  }
  SourceMapGenerator.prototype._version = 3;

  /**
   * Creates a new SourceMapGenerator based on a SourceMapConsumer
   *
   * @param aSourceMapConsumer The SourceMap.
   */
  SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };
      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }
        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };
        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }
      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util.relative(sourceRoot, sourceFile);
      }
      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

  /**
   * Add a single mapping from original source line and column to the generated
   * source's line and column for this source map being created. The mapping
   * object should have the following properties:
   *
   *   - generated: An object with the generated line and column positions.
   *   - original: An object with the original line and column positions.
   *   - source: The original source file (relative to the sourceRoot).
   *   - name: An optional original token name for this mapping.
   */
  SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);
    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }
    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }
    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }
    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

  /**
   * Set the source content for a source file.
   */
  SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }
    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

  /**
   * Applies the mappings of a sub-source-map for a specific source file to the
   * source map being generated. Each mapping to the supplied source file is
   * rewritten using the supplied source map. Note: The resolution for the
   * resulting mappings is the minimium of this map and the supplied map.
   *
   * @param aSourceMapConsumer The source map to be applied.
   * @param aSourceFile Optional. The filename of the source file.
   *        If omitted, SourceMapConsumer's file property will be used.
   * @param aSourceMapPath Optional. The dirname of the path to the source map
   *        to be applied. If relative, it is relative to the SourceMapConsumer.
   *        This parameter is needed when the two source maps aren't in the same
   *        directory, and the source map to be applied contains relative source
   *        paths. If so, those relative source paths need to be rewritten
   *        relative to the SourceMapGenerator.
   */
  SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\'s "file" property. Both were omitted.');
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source);
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }
      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }
      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }
    }, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util.join(aSourceMapPath, sourceFile);
        }
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

  /**
   * A mapping can have one of the three levels of data:
   *
   *   1. Just the generated position.
   *   2. The Generated position, original position, and original source.
   *   3. Generated and original position, original source, as well as a name
   *      token.
   *
   * To maintain consistency, we validate that any new mapping being added falls
   * in to one of these categories.
   */
  SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
    // When aOriginal is truthy but has empty values for .line and .column,
    // it is most likely a programmer error. In this case we throw a very
    // specific error message to try to guide them the right way.
    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
      throw new Error('original.line and original.column are not numbers -- you probably meant to omit ' + 'the original mapping entirely and only map the generated position. If so, pass ' + 'null for the original mapping instead of an object with empty or null values.');
    }
    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
      // Case 1.
      return;
    } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
      // Cases 2 and 3.
      return;
    } else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };

  /**
   * Serialize the accumulated mappings in to the stream of base 64 VLQs
   * specified by the source map format.
   */
  SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;
    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = '';
      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      } else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }
      }
      next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;
      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;
        next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;
        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }
      result += next;
    }
    return result;
  };
  SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
    }, this);
  };

  /**
   * Externalize the source map.
   */
  SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }
    return map;
  };

  /**
   * Render the source map being generated to a string.
   */
  SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };
  sourceMapGenerator.SourceMapGenerator = SourceMapGenerator;
  return sourceMapGenerator;
}

var sourceMapConsumer = {};

var binarySearch = {};

/* -*- Mode: js; js-indent-level: 2; -*- */
var hasRequiredBinarySearch;
function requireBinarySearch() {
  if (hasRequiredBinarySearch) return binarySearch;
  hasRequiredBinarySearch = 1;
  (function (exports) {
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */

    exports.GREATEST_LOWER_BOUND = 1;
    exports.LEAST_UPPER_BOUND = 2;

    /**
     * Recursive implementation of binary search.
     *
     * @param aLow Indices here and lower do not contain the needle.
     * @param aHigh Indices here and higher do not contain the needle.
     * @param aNeedle The element being searched for.
     * @param aHaystack The non-empty array being searched.
     * @param aCompare Function which takes two elements and returns -1, 0, or 1.
     * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
     *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
     *     closest element that is smaller than or greater than the one we are
     *     searching for, respectively, if the exact element cannot be found.
     */
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      // This function terminates when one of the following is true:
      //
      //   1. We find the exact element we are looking for.
      //
      //   2. We did not find the exact element, but we can return the index of
      //      the next-closest element.
      //
      //   3. We did not find the exact element, and there is no next-closest
      //      element than the one we are searching for, so we return -1.
      var mid = Math.floor((aHigh - aLow) / 2) + aLow;
      var cmp = aCompare(aNeedle, aHaystack[mid], true);
      if (cmp === 0) {
        // Found the element we are looking for.
        return mid;
      } else if (cmp > 0) {
        // Our needle is greater than aHaystack[mid].
        if (aHigh - mid > 1) {
          // The element is in the upper half.
          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }

        // The exact needle element was not found in this haystack. Determine if
        // we are in termination case (3) or (2) and return the appropriate thing.
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        } else {
          return mid;
        }
      } else {
        // Our needle is less than aHaystack[mid].
        if (mid - aLow > 1) {
          // The element is in the lower half.
          return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
        }

        // we are in termination case (3) or (2) and return the appropriate thing.
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return mid;
        } else {
          return aLow < 0 ? -1 : aLow;
        }
      }
    }

    /**
     * This is an implementation of binary search which will always try and return
     * the index of the closest element if there is no exact hit. This is because
     * mappings between original and generated line/col pairs are single points,
     * and there is an implicit region between each of them, so a miss just means
     * that you aren't on the very start of a region.
     *
     * @param aNeedle The element you are looking for.
     * @param aHaystack The array that is being searched.
     * @param aCompare A function which takes the needle and an element in the
     *     array and returns -1, 0, or 1 depending on whether the needle is less
     *     than, equal to, or greater than the element, respectively.
     * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
     *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
     *     closest element that is smaller than or greater than the one we are
     *     searching for, respectively, if the exact element cannot be found.
     *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
     */
    exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }
      var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);
      if (index < 0) {
        return -1;
      }

      // We have found either the exact element, or the next-closest element than
      // the one we are searching for. However, there may be more than one such
      // element. Make sure we always return the smallest of these.
      while (index - 1 >= 0) {
        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
          break;
        }
        --index;
      }
      return index;
    };
  })(binarySearch);
  return binarySearch;
}

var quickSort = {};

/* -*- Mode: js; js-indent-level: 2; -*- */
var hasRequiredQuickSort;
function requireQuickSort() {
  if (hasRequiredQuickSort) return quickSort;
  hasRequiredQuickSort = 1;
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  // It turns out that some (most?) JavaScript engines don't self-host
  // `Array.prototype.sort`. This makes sense because C++ will likely remain
  // faster than JS when doing raw CPU-intensive sorting. However, when using a
  // custom comparator function, calling back and forth between the VM's C++ and
  // JIT'd JS is rather slow *and* loses JIT type information, resulting in
  // worse generated code for the comparator function than would be optimal. In
  // fact, when sorting with a comparator, these costs outweigh the benefits of
  // sorting in C++. By using our own JS-implemented Quick Sort (below), we get
  // a ~3500ms mean speed-up in `bench/bench.html`.

  /**
   * Swap the elements indexed by `x` and `y` in the array `ary`.
   *
   * @param {Array} ary
   *        The array.
   * @param {Number} x
   *        The index of the first item.
   * @param {Number} y
   *        The index of the second item.
   */
  function swap(ary, x, y) {
    var temp = ary[x];
    ary[x] = ary[y];
    ary[y] = temp;
  }

  /**
   * Returns a random integer within the range `low .. high` inclusive.
   *
   * @param {Number} low
   *        The lower bound on the range.
   * @param {Number} high
   *        The upper bound on the range.
   */
  function randomIntInRange(low, high) {
    return Math.round(low + Math.random() * (high - low));
  }

  /**
   * The Quick Sort algorithm.
   *
   * @param {Array} ary
   *        An array to sort.
   * @param {function} comparator
   *        Function to use to compare two items.
   * @param {Number} p
   *        Start index of the array
   * @param {Number} r
   *        End index of the array
   */
  function doQuickSort(ary, comparator, p, r) {
    // If our lower bound is less than our upper bound, we (1) partition the
    // array into two pieces and (2) recurse on each half. If it is not, this is
    // the empty array and our base case.

    if (p < r) {
      // (1) Partitioning.
      //
      // The partitioning chooses a pivot between `p` and `r` and moves all
      // elements that are less than or equal to the pivot to the before it, and
      // all the elements that are greater than it after it. The effect is that
      // once partition is done, the pivot is in the exact place it will be when
      // the array is put in sorted order, and it will not need to be moved
      // again. This runs in O(n) time.

      // Always choose a random pivot so that an input array which is reverse
      // sorted does not cause O(n^2) running time.
      var pivotIndex = randomIntInRange(p, r);
      var i = p - 1;
      swap(ary, pivotIndex, r);
      var pivot = ary[r];

      // Immediately after `j` is incremented in this loop, the following hold
      // true:
      //
      //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
      //
      //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
      for (var j = p; j < r; j++) {
        if (comparator(ary[j], pivot) <= 0) {
          i += 1;
          swap(ary, i, j);
        }
      }
      swap(ary, i + 1, j);
      var q = i + 1;

      // (2) Recurse on each half.

      doQuickSort(ary, comparator, p, q - 1);
      doQuickSort(ary, comparator, q + 1, r);
    }
  }

  /**
   * Sort the given array in-place with the given comparator function.
   *
   * @param {Array} ary
   *        An array to sort.
   * @param {function} comparator
   *        Function to use to compare two items.
   */
  quickSort.quickSort = function (ary, comparator) {
    doQuickSort(ary, comparator, 0, ary.length - 1);
  };
  return quickSort;
}

/* -*- Mode: js; js-indent-level: 2; -*- */
var hasRequiredSourceMapConsumer;
function requireSourceMapConsumer() {
  if (hasRequiredSourceMapConsumer) return sourceMapConsumer;
  hasRequiredSourceMapConsumer = 1;
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var util = requireUtil();
  var binarySearch = requireBinarySearch();
  var ArraySet = requireArraySet().ArraySet;
  var base64VLQ = requireBase64Vlq();
  var quickSort = requireQuickSort().quickSort;
  function SourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
  }
  SourceMapConsumer.fromSourceMap = function (aSourceMap, aSourceMapURL) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
  };

  /**
   * The version of the source mapping spec that we are consuming.
   */
  SourceMapConsumer.prototype._version = 3;

  // `__generatedMappings` and `__originalMappings` are arrays that hold the
  // parsed mapping coordinates from the source map's "mappings" attribute. They
  // are lazily instantiated, accessed via the `_generatedMappings` and
  // `_originalMappings` getters respectively, and we only parse the mappings
  // and create these arrays once queried for a source location. We jump through
  // these hoops because there can be many thousands of mappings, and parsing
  // them is expensive, so we only want to do it if we must.
  //
  // Each object in the arrays is of the form:
  //
  //     {
  //       generatedLine: The line number in the generated code,
  //       generatedColumn: The column number in the generated code,
  //       source: The path to the original source file that generated this
  //               chunk of code,
  //       originalLine: The line number in the original source that
  //                     corresponds to this chunk of generated code,
  //       originalColumn: The column number in the original source that
  //                       corresponds to this chunk of generated code,
  //       name: The name of the original symbol which generated this chunk of
  //             code.
  //     }
  //
  // All properties except for `generatedLine` and `generatedColumn` can be
  // `null`.
  //
  // `_generatedMappings` is ordered by the generated positions.
  //
  // `_originalMappings` is ordered by the original positions.

  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
    configurable: true,
    enumerable: true,
    get: function () {
      if (!this.__generatedMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }
      return this.__generatedMappings;
    }
  });
  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
    configurable: true,
    enumerable: true,
    get: function () {
      if (!this.__originalMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }
      return this.__originalMappings;
    }
  });
  SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };
  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;
  SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
  SourceMapConsumer.LEAST_UPPER_BOUND = 2;

  /**
   * Iterate over each mapping between an original source/line/column and a
   * generated line/column in this source map.
   *
   * @param Function aCallback
   *        The function that is called with each mapping.
   * @param Object aContext
   *        Optional. If specified, this object will be the value of `this` every
   *        time that `aCallback` is called.
   * @param aOrder
   *        Either `SourceMapConsumer.GENERATED_ORDER` or
   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
   *        iterate over the mappings sorted by the generated file's line/column
   *        order or the original's source/line/column order, respectively. Defaults to
   *        `SourceMapConsumer.GENERATED_ORDER`.
   */
  SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
    var mappings;
    switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
    }
    var sourceRoot = this.sourceRoot;
    mappings.map(function (mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
      return {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };

  /**
   * Returns all generated line and column information for the original source,
   * line, and column provided. If no column is provided, returns all mappings
   * corresponding to a either the line we are searching for or the next
   * closest line that has any mappings. Otherwise, returns all mappings
   * corresponding to the given line and either the column we are searching for
   * or the next closest column that has any offsets.
   *
   * The only argument is an object with the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.  The line number is 1-based.
   *   - column: Optional. the column number in the original source.
   *    The column number is 0-based.
   *
   * and an array of objects is returned, each with the following properties:
   *
   *   - line: The line number in the generated source, or null.  The
   *    line number is 1-based.
   *   - column: The column number in the generated source, or null.
   *    The column number is 0-based.
   */
  SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, 'line');

    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.
    var needle = {
      source: util.getArg(aArgs, 'source'),
      originalLine: line,
      originalColumn: util.getArg(aArgs, 'column', 0)
    };
    needle.source = this._findSourceIndex(needle.source);
    if (needle.source < 0) {
      return [];
    }
    var mappings = [];
    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];
      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we found. Since
        // mappings are sorted, this is guaranteed to find all mappings for
        // the line we found.
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });
          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we were searching for.
        // Since mappings are sorted, this is guaranteed to find all mappings for
        // the line we are searching for.
        while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });
          mapping = this._originalMappings[++index];
        }
      }
    }
    return mappings;
  };
  sourceMapConsumer.SourceMapConsumer = SourceMapConsumer;

  /**
   * A BasicSourceMapConsumer instance represents a parsed source map which we can
   * query for information about the original file positions by giving it a file
   * position in the generated source.
   *
   * The first parameter is the raw source map (either as a JSON string, or
   * already parsed to an object). According to the spec, source maps have the
   * following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - sources: An array of URLs to the original source files.
   *   - names: An array of identifiers which can be referrenced by individual mappings.
   *   - sourceRoot: Optional. The URL root from which all sources are relative.
   *   - sourcesContent: Optional. An array of contents of the original source files.
   *   - mappings: A string of base64 VLQs which contain the actual mappings.
   *   - file: Optional. The generated file this source map is associated with.
   *
   * Here is an example source map, taken from the source map spec[0]:
   *
   *     {
   *       version : 3,
   *       file: "out.js",
   *       sourceRoot : "",
   *       sources: ["foo.js", "bar.js"],
   *       names: ["src", "maps", "are", "fun"],
   *       mappings: "AA,AB;;ABCDE;"
   *     }
   *
   * The second parameter, if given, is a string whose value is the URL
   * at which the source map was found.  This URL is used to compute the
   * sources array.
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
   */
  function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    var version = util.getArg(sourceMap, 'version');
    var sources = util.getArg(sourceMap, 'sources');
    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
    // requires the array) to play nice here.
    var names = util.getArg(sourceMap, 'names', []);
    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
    var mappings = util.getArg(sourceMap, 'mappings');
    var file = util.getArg(sourceMap, 'file', null);

    // Once again, Sass deviates from the spec and supplies the version as a
    // string rather than a number, so we use loose equality checking here.
    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }
    if (sourceRoot) {
      sourceRoot = util.normalize(sourceRoot);
    }
    sources = sources.map(String)
    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    .map(util.normalize)
    // Always ensure that absolute sources are internally stored relative to
    // the source root, if the source root is absolute. Not doing this would
    // be particularly problematic when the source root is a prefix of the
    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
    .map(function (source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
    });

    // Pass `true` below to allow duplicate names and sources. While source maps
    // are intended to be compressed and deduplicated, the TypeScript compiler
    // sometimes generates source maps with duplicates in them. See Github issue
    // #72 and bugzil.la/889492.
    this._names = ArraySet.fromArray(names.map(String), true);
    this._sources = ArraySet.fromArray(sources, true);
    this._absoluteSources = this._sources.toArray().map(function (s) {
      return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
    });
    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this._sourceMapURL = aSourceMapURL;
    this.file = file;
  }
  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

  /**
   * Utility function to find the index of a source.  Returns -1 if not
   * found.
   */
  BasicSourceMapConsumer.prototype._findSourceIndex = function (aSource) {
    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }
    if (this._sources.has(relativeSource)) {
      return this._sources.indexOf(relativeSource);
    }

    // Maybe aSource is an absolute URL as returned by |sources|.  In
    // this case we can't simply undo the transform.
    var i;
    for (i = 0; i < this._absoluteSources.length; ++i) {
      if (this._absoluteSources[i] == aSource) {
        return i;
      }
    }
    return -1;
  };

  /**
   * Create a BasicSourceMapConsumer from a SourceMapGenerator.
   *
   * @param SourceMapGenerator aSourceMap
   *        The source map that will be consumed.
   * @param String aSourceMapURL
   *        The URL at which the source map can be found (optional)
   * @returns BasicSourceMapConsumer
   */
  BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);
    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
    smc.file = aSourceMap._file;
    smc._sourceMapURL = aSourceMapURL;
    smc._absoluteSources = smc._sources.toArray().map(function (s) {
      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
    });

    // Because we are modifying the entries (by converting string sources and
    // names to indices into the sources and names ArraySets), we have to make
    // a copy of the entry or else bad things happen. Shared mutable state
    // strikes again! See github issue #191.

    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];
    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping();
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;
      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;
        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }
        destOriginalMappings.push(destMapping);
      }
      destGeneratedMappings.push(destMapping);
    }
    quickSort(smc.__originalMappings, util.compareByOriginalPositions);
    return smc;
  };

  /**
   * The version of the source mapping spec that we are consuming.
   */
  BasicSourceMapConsumer.prototype._version = 3;

  /**
   * The list of original sources.
   */
  Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
    get: function () {
      return this._absoluteSources.slice();
    }
  });

  /**
   * Provide the JIT with a nice shape / hidden class.
   */
  function Mapping() {
    this.generatedLine = 0;
    this.generatedColumn = 0;
    this.source = null;
    this.originalLine = null;
    this.originalColumn = null;
    this.name = null;
  }

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;
    while (index < length) {
      if (aStr.charAt(index) === ';') {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      } else if (aStr.charAt(index) === ',') {
        index++;
      } else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;

        // Because each offset is encoded relative to the previous one,
        // many segments often have the same encoding. We can exploit this
        // fact by caching the parsed variable length fields of each segment,
        // allowing us to avoid a second parse if we encounter the same
        // segment again.
        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);
        segment = cachedSegments[str];
        if (segment) {
          index += str.length;
        } else {
          segment = [];
          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }
          if (segment.length === 2) {
            throw new Error('Found a source, but no line and column');
          }
          if (segment.length === 3) {
            throw new Error('Found a source and line, but no column');
          }
          cachedSegments[str] = segment;
        }

        // Generated column.
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;
        if (segment.length > 1) {
          // Original source.
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];

          // Original line.
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          // Lines are stored 0-based
          mapping.originalLine += 1;

          // Original column.
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;
          if (segment.length > 4) {
            // Original name.
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }
        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === 'number') {
          originalMappings.push(mapping);
        }
      }
    }
    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;
    quickSort(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };

  /**
   * Find the mapping that best matches the hypothetical "needle" mapping that
   * we are searching for in the given "haystack" of mappings.
   */
  BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.

    if (aNeedle[aLineName] <= 0) {
      throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);
    }
    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };

  /**
   * Compute the last column for each generated mapping. The last column is
   * inclusive.
   */
  BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];

      // Mappings do not contain a field for the last generated columnt. We
      // can come up with an optimistic estimate, however, by assuming that
      // mappings are contiguous (i.e. given two consecutive mappings, the
      // first mapping ends where the second one starts).
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];
        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }

      // The last mapping for each line spans the entire line.
      mapping.lastGeneratedColumn = Infinity;
    }
  };

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.  The line number
   *     is 1-based.
   *   - column: The column number in the generated source.  The column
   *     number is 0-based.
   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.  The
   *     line number is 1-based.
   *   - column: The column number in the original source, or null.  The
   *     column number is 0-based.
   *   - name: The original identifier, or null.
   */
  BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };
    var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));
    if (index >= 0) {
      var mapping = this._generatedMappings[index];
      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, 'source', null);
        if (source !== null) {
          source = this._sources.at(source);
          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
        }
        var name = util.getArg(mapping, 'name', null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: name
        };
      }
    }
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };

  /**
   * Return true if we have the source content for every source in the source
   * map, false otherwise.
   */
  BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function (sc) {
      return sc == null;
    });
  };

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * available.
   */
  BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }
    var index = this._findSourceIndex(aSource);
    if (index >= 0) {
      return this.sourcesContent[index];
    }
    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }
    var url;
    if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
      // many users. We can help them out when they expect file:// URIs to
      // behave like it would if they were running a local HTTP server. See
      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
      if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
      }
      if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
      }
    }

    // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.
    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
    }
  };

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.  The line number
   *     is 1-based.
   *   - column: The column number in the original source.  The column
   *     number is 0-based.
   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.  The
   *     line number is 1-based.
   *   - column: The column number in the generated source, or null.
   *     The column number is 0-based.
   */
  BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, 'source');
    source = this._findSourceIndex(source);
    if (source < 0) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }
    var needle = {
      source: source,
      originalLine: util.getArg(aArgs, 'line'),
      originalColumn: util.getArg(aArgs, 'column')
    };
    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));
    if (index >= 0) {
      var mapping = this._originalMappings[index];
      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }
    }
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };
  sourceMapConsumer.BasicSourceMapConsumer = BasicSourceMapConsumer;

  /**
   * An IndexedSourceMapConsumer instance represents a parsed source map which
   * we can query for information. It differs from BasicSourceMapConsumer in
   * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
   * input.
   *
   * The first parameter is a raw source map (either as a JSON string, or already
   * parsed to an object). According to the spec for indexed source maps, they
   * have the following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - file: Optional. The generated file this source map is associated with.
   *   - sections: A list of section definitions.
   *
   * Each value under the "sections" field has two fields:
   *   - offset: The offset into the original specified at which this section
   *       begins to apply, defined as an object with a "line" and "column"
   *       field.
   *   - map: A source map definition. This source map could also be indexed,
   *       but doesn't have to be.
   *
   * Instead of the "map" field, it's also possible to have a "url" field
   * specifying a URL to retrieve a source map from, but that's currently
   * unsupported.
   *
   * Here's an example source map, taken from the source map spec[0], but
   * modified to omit a section which uses the "url" field.
   *
   *  {
   *    version : 3,
   *    file: "app.js",
   *    sections: [{
   *      offset: {line:100, column:10},
   *      map: {
   *        version : 3,
   *        file: "section.js",
   *        sources: ["foo.js", "bar.js"],
   *        names: ["src", "maps", "are", "fun"],
   *        mappings: "AAAA,E;;ABCDE;"
   *      }
   *    }],
   *  }
   *
   * The second parameter, if given, is a string whose value is the URL
   * at which the source map was found.  This URL is used to compute the
   * sources array.
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
   */
  function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    var version = util.getArg(sourceMap, 'version');
    var sections = util.getArg(sourceMap, 'sections');
    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }
    this._sources = new ArraySet();
    this._names = new ArraySet();
    var lastOffset = {
      line: -1,
      column: 0
    };
    this._sections = sections.map(function (s) {
      if (s.url) {
        // The url field will require support for asynchronicity.
        // See https://github.com/mozilla/source-map/issues/16
        throw new Error('Support for url field in sections not implemented.');
      }
      var offset = util.getArg(s, 'offset');
      var offsetLine = util.getArg(offset, 'line');
      var offsetColumn = util.getArg(offset, 'column');
      if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
        throw new Error('Section offsets must be ordered and non-overlapping.');
      }
      lastOffset = offset;
      return {
        generatedOffset: {
          // The offset fields are 0-based, but we use 1-based indices when
          // encoding/decoding from VLQ.
          generatedLine: offsetLine + 1,
          generatedColumn: offsetColumn + 1
        },
        consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
      };
    });
  }
  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

  /**
   * The version of the source mapping spec that we are consuming.
   */
  IndexedSourceMapConsumer.prototype._version = 3;

  /**
   * The list of original sources.
   */
  Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
    get: function () {
      var sources = [];
      for (var i = 0; i < this._sections.length; i++) {
        for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
          sources.push(this._sections[i].consumer.sources[j]);
        }
      }
      return sources;
    }
  });

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.  The line number
   *     is 1-based.
   *   - column: The column number in the generated source.  The column
   *     number is 0-based.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.  The
   *     line number is 1-based.
   *   - column: The column number in the original source, or null.  The
   *     column number is 0-based.
   *   - name: The original identifier, or null.
   */
  IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    // Find the section containing the generated position we're trying to map
    // to an original position.
    var sectionIndex = binarySearch.search(needle, this._sections, function (needle, section) {
      var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
      if (cmp) {
        return cmp;
      }
      return needle.generatedColumn - section.generatedOffset.generatedColumn;
    });
    var section = this._sections[sectionIndex];
    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }
    return section.consumer.originalPositionFor({
      line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
      bias: aArgs.bias
    });
  };

  /**
   * Return true if we have the source content for every source in the source
   * map, false otherwise.
   */
  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function (s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * available.
   */
  IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.  The line number
   *     is 1-based.
   *   - column: The column number in the original source.  The column
   *     number is 0-based.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.  The
   *     line number is 1-based. 
   *   - column: The column number in the generated source, or null.
   *     The column number is 0-based.
   */
  IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      // Only consider this section if the requested source is in the list of
      // sources of the consumer.
      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
        };
        return ret;
      }
    }
    return {
      line: null,
      column: null
    };
  };

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];
        var source = section.consumer._sources.at(mapping.source);
        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
        this._sources.add(source);
        source = this._sources.indexOf(source);
        var name = null;
        if (mapping.name) {
          name = section.consumer._names.at(mapping.name);
          this._names.add(name);
          name = this._names.indexOf(name);
        }

        // The mappings coming from the consumer for the section have
        // generated positions relative to the start of the section, so we
        // need to offset them to be relative to the start of the concatenated
        // generated file.
        var adjustedMapping = {
          source: source,
          generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name
        };
        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === 'number') {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }
    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };
  sourceMapConsumer.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
  return sourceMapConsumer;
}

var sourceNode = {};

/* -*- Mode: js; js-indent-level: 2; -*- */
var hasRequiredSourceNode;
function requireSourceNode() {
  if (hasRequiredSourceNode) return sourceNode;
  hasRequiredSourceNode = 1;
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var SourceMapGenerator = requireSourceMapGenerator().SourceMapGenerator;
  var util = requireUtil();

  // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
  // operating systems these days (capturing the result).
  var REGEX_NEWLINE = /(\r?\n)/;

  // Newline character code for charCodeAt() comparisons
  var NEWLINE_CODE = 10;

  // Private symbol for identifying `SourceNode`s when multiple versions of
  // the source-map library are loaded. This MUST NOT CHANGE across
  // versions!
  var isSourceNode = "$$$isSourceNode$$$";

  /**
   * SourceNodes provide a way to abstract over interpolating/concatenating
   * snippets of generated JavaScript source code while maintaining the line and
   * column information associated with the original source code.
   *
   * @param aLine The original line number.
   * @param aColumn The original column number.
   * @param aSource The original source's filename.
   * @param aChunks Optional. An array of strings which are snippets of
   *        generated JS, or other SourceNodes.
   * @param aName The original identifier.
   */
  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null) this.add(aChunks);
  }

  /**
   * Creates a SourceNode from generated code and a SourceMapConsumer.
   *
   * @param aGeneratedCode The generated code
   * @param aSourceMapConsumer The SourceMap for the generated code
   * @param aRelativePath Optional. The path that relative sources in the
   *        SourceMapConsumer should be relative to.
   */
  SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    var node = new SourceNode();

    // All even indices of this array are one line of the generated code,
    // while all odd indices are the newlines between two adjacent lines
    // (since `REGEX_NEWLINE` captures its match).
    // Processed fragments are accessed by calling `shiftNextLine`.
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;
    var shiftNextLine = function () {
      var lineContents = getNextLine();
      // The last line of a file might not have a newline.
      var newLine = getNextLine() || "";
      return lineContents + newLine;
      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;
      }
    };

    // We need to remember the position of "remainingLines"
    var lastGeneratedLine = 1,
      lastGeneratedColumn = 0;

    // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.
    var lastMapping = null;
    aSourceMapConsumer.eachMapping(function (mapping) {
      if (lastMapping !== null) {
        // We add the code from "lastMapping" to "mapping":
        // First check if there is a new line in between.
        if (lastGeneratedLine < mapping.generatedLine) {
          // Associate first line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
          // The remaining code is added without mapping
        } else {
          // There is no new line in between.
          // Associate the code between "lastGeneratedColumn" and
          // "mapping.generatedColumn" with "lastMapping"
          var nextLine = remainingLines[remainingLinesIndex] || '';
          var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          // No more remaining code, continue
          lastMapping = mapping;
          return;
        }
      }
      // We add the generated code until the first mapping
      // to the SourceNode without any mapping.
      // Each line is added as separate string.
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex] || '';
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    // We have processed all mappings.
    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        // Associate the remaining code in the current line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      // and add the remaining lines without any mapping
      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }

    // Copy sourcesContent into SourceNode
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });
    return node;
    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
        node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
      }
    }
  };

  /**
   * Add a chunk of generated JS to this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function (chunk) {
        this.add(chunk);
      }, this);
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    } else {
      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }
    return this;
  };

  /**
   * Add a chunk of generated JS to the beginning of this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length - 1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    } else {
      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }
    return this;
  };

  /**
   * Walk over the tree of JS snippets in this node and its children. The
   * walking function is called once for each snippet of JS and is passed that
   * snippet and the its original associated source's line/column location.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for (var i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];
      if (chunk[isSourceNode]) {
        chunk.walk(aFn);
      } else {
        if (chunk !== '') {
          aFn(chunk, {
            source: this.source,
            line: this.line,
            column: this.column,
            name: this.name
          });
        }
      }
    }
  };

  /**
   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
   * each of `this.children`.
   *
   * @param aSep The separator.
   */
  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i = 0; i < len - 1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
    }
    return this;
  };

  /**
   * Call String.prototype.replace on the very right-most source snippet. Useful
   * for trimming whitespace from the end of a source node, etc.
   *
   * @param aPattern The pattern to replace.
   * @param aReplacement The thing to replace the pattern with.
   */
  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild[isSourceNode]) {
      lastChild.replaceRight(aPattern, aReplacement);
    } else if (typeof lastChild === 'string') {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    } else {
      this.children.push(''.replace(aPattern, aReplacement));
    }
    return this;
  };

  /**
   * Set the source content for a source file. This will be added to the SourceMapGenerator
   * in the sourcesContent field.
   *
   * @param aSourceFile The filename of the source file
   * @param aSourceContent The content of the source file
   */
  SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };

  /**
   * Walk over the tree of SourceNodes. The walking function is called for each
   * source file content and is passed the filename and source content.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }
    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };

  /**
   * Return the string representation of this source node. Walks over the tree
   * and concatenates all the various snippets together to one string.
   */
  SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function (chunk) {
      str += chunk;
    });
    return str;
  };

  /**
   * Returns the string representation of this source node along with a source
   * map.
   */
  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map = new SourceMapGenerator(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function (chunk, original) {
      generated.code += chunk;
      if (original.source !== null && original.line !== null && original.column !== null) {
        if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }
      for (var idx = 0, length = chunk.length; idx < length; idx++) {
        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
          generated.line++;
          generated.column = 0;
          // Mappings end at eol
          if (idx + 1 === length) {
            lastOriginalSource = null;
            sourceMappingActive = false;
          } else if (sourceMappingActive) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
        } else {
          generated.column++;
        }
      }
    });
    this.walkSourceContents(function (sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });
    return {
      code: generated.code,
      map: map
    };
  };
  sourceNode.SourceNode = SourceNode;
  return sourceNode;
}

/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
var hasRequiredSourceMap;
function requireSourceMap() {
  if (hasRequiredSourceMap) return sourceMap;
  hasRequiredSourceMap = 1;
  sourceMap.SourceMapGenerator = requireSourceMapGenerator().SourceMapGenerator;
  sourceMap.SourceMapConsumer = requireSourceMapConsumer().SourceMapConsumer;
  sourceMap.SourceNode = requireSourceNode().SourceNode;
  return sourceMap;
}

var inputSourceMapTracker_1;
var hasRequiredInputSourceMapTracker;
function requireInputSourceMapTracker() {
  if (hasRequiredInputSourceMapTracker) return inputSourceMapTracker_1;
  hasRequiredInputSourceMapTracker = 1;
  var SourceMapConsumer = requireSourceMap().SourceMapConsumer;
  function inputSourceMapTracker() {
    var maps = {};
    return {
      all: all.bind(null, maps),
      isTracking: isTracking.bind(null, maps),
      originalPositionFor: originalPositionFor.bind(null, maps),
      track: track.bind(null, maps)
    };
  }
  function all(maps) {
    return maps;
  }
  function isTracking(maps, source) {
    return source in maps;
  }
  function originalPositionFor(maps, metadata, range, selectorFallbacks) {
    var line = metadata[0];
    var column = metadata[1];
    var source = metadata[2];
    var position = {
      line: line,
      column: column + range
    };
    var originalPosition;
    while (!originalPosition && position.column > column) {
      position.column--;
      originalPosition = maps[source].originalPositionFor(position);
    }
    if (!originalPosition || originalPosition.column < 0) {
      return metadata;
    }
    if (originalPosition.line === null && line > 1 && selectorFallbacks > 0) {
      return originalPositionFor(maps, [line - 1, column, source], range, selectorFallbacks - 1);
    }
    return originalPosition.line !== null ? toMetadata(originalPosition) : metadata;
  }
  function toMetadata(asHash) {
    return [asHash.line, asHash.column, asHash.source];
  }
  function track(maps, source, data) {
    maps[source] = new SourceMapConsumer(data);
  }
  inputSourceMapTracker_1 = inputSourceMapTracker;
  return inputSourceMapTracker_1;
}

var isRemoteResource_1;
var hasRequiredIsRemoteResource;
function requireIsRemoteResource() {
  if (hasRequiredIsRemoteResource) return isRemoteResource_1;
  hasRequiredIsRemoteResource = 1;
  var REMOTE_RESOURCE_PATTERN = /^(\w+:\/\/|\/\/)/;
  function isRemoteResource(uri) {
    return REMOTE_RESOURCE_PATTERN.test(uri);
  }
  isRemoteResource_1 = isRemoteResource;
  return isRemoteResource_1;
}

var hasProtocol_1;
var hasRequiredHasProtocol;
function requireHasProtocol() {
  if (hasRequiredHasProtocol) return hasProtocol_1;
  hasRequiredHasProtocol = 1;
  var NO_PROTOCOL_RESOURCE_PATTERN = /^\/\//;
  function hasProtocol(uri) {
    return !NO_PROTOCOL_RESOURCE_PATTERN.test(uri);
  }
  hasProtocol_1 = hasProtocol;
  return hasProtocol_1;
}

var isAllowedResource_1;
var hasRequiredIsAllowedResource;
function requireIsAllowedResource() {
  if (hasRequiredIsAllowedResource) return isAllowedResource_1;
  hasRequiredIsAllowedResource = 1;
  var path = require$$1$1;
  var url = require$$1$2;
  var isRemoteResource = requireIsRemoteResource();
  var hasProtocol = requireHasProtocol();
  var HTTP_PROTOCOL = 'http:';
  function isAllowedResource(uri, isRemote, rules) {
    var match;
    var absoluteUri;
    var allowed = isRemote ? false : true;
    var rule;
    var isNegated;
    var normalizedRule;
    var i;
    if (rules.length === 0) {
      return false;
    }
    if (isRemote && !hasProtocol(uri)) {
      uri = HTTP_PROTOCOL + uri;
    }
    match = isRemote ? url.parse(uri).host : uri;
    absoluteUri = isRemote ? uri : path.resolve(uri);
    for (i = 0; i < rules.length; i++) {
      rule = rules[i];
      isNegated = rule[0] == '!';
      normalizedRule = rule.substring(1);
      if (isNegated && isRemote && isRemoteRule(normalizedRule)) {
        allowed = allowed && !isAllowedResource(uri, true, [normalizedRule]);
      } else if (isNegated && !isRemote && !isRemoteRule(normalizedRule)) {
        allowed = allowed && !isAllowedResource(uri, false, [normalizedRule]);
      } else if (isNegated) {
        allowed = allowed && true;
      } else if (rule == 'all') {
        allowed = true;
      } else if (isRemote && rule == 'local') {
        allowed = allowed || false;
      } else if (isRemote && rule == 'remote') {
        allowed = true;
      } else if (!isRemote && rule == 'remote') {
        allowed = false;
      } else if (!isRemote && rule == 'local') {
        allowed = true;
      } else if (rule === match) {
        allowed = true;
      } else if (rule === uri) {
        allowed = true;
      } else if (isRemote && absoluteUri.indexOf(rule) === 0) {
        allowed = true;
      } else if (!isRemote && absoluteUri.indexOf(path.resolve(rule)) === 0) {
        allowed = true;
      } else if (isRemote != isRemoteRule(normalizedRule)) {
        allowed = allowed && true;
      } else {
        allowed = false;
      }
    }
    return allowed;
  }
  function isRemoteRule(rule) {
    return isRemoteResource(rule) || url.parse(HTTP_PROTOCOL + '//' + rule).host == rule;
  }
  isAllowedResource_1 = isAllowedResource;
  return isAllowedResource_1;
}

var matchDataUri_1;
var hasRequiredMatchDataUri;
function requireMatchDataUri() {
  if (hasRequiredMatchDataUri) return matchDataUri_1;
  hasRequiredMatchDataUri = 1;
  var DATA_URI_PATTERN = /^data:(\S*?)?(;charset=[^;]+)?(;[^,]+?)?,(.+)/;
  function matchDataUri(uri) {
    return DATA_URI_PATTERN.exec(uri);
  }
  matchDataUri_1 = matchDataUri;
  return matchDataUri_1;
}

var rebaseLocalMap_1;
var hasRequiredRebaseLocalMap;
function requireRebaseLocalMap() {
  if (hasRequiredRebaseLocalMap) return rebaseLocalMap_1;
  hasRequiredRebaseLocalMap = 1;
  var path = require$$1$1;
  function rebaseLocalMap(sourceMap, sourceUri, rebaseTo) {
    var currentPath = path.resolve('');
    var absoluteUri = path.resolve(currentPath, sourceUri);
    var absoluteUriDirectory = path.dirname(absoluteUri);
    sourceMap.sources = sourceMap.sources.map(function (source) {
      return path.relative(rebaseTo, path.resolve(absoluteUriDirectory, source));
    });
    return sourceMap;
  }
  rebaseLocalMap_1 = rebaseLocalMap;
  return rebaseLocalMap_1;
}

var rebaseRemoteMap_1;
var hasRequiredRebaseRemoteMap;
function requireRebaseRemoteMap() {
  if (hasRequiredRebaseRemoteMap) return rebaseRemoteMap_1;
  hasRequiredRebaseRemoteMap = 1;
  var path = require$$1$1;
  var url = require$$1$2;
  function rebaseRemoteMap(sourceMap, sourceUri) {
    var sourceDirectory = path.dirname(sourceUri);
    sourceMap.sources = sourceMap.sources.map(function (source) {
      return url.resolve(sourceDirectory, source);
    });
    return sourceMap;
  }
  rebaseRemoteMap_1 = rebaseRemoteMap;
  return rebaseRemoteMap_1;
}

var isDataUriResource_1;
var hasRequiredIsDataUriResource;
function requireIsDataUriResource() {
  if (hasRequiredIsDataUriResource) return isDataUriResource_1;
  hasRequiredIsDataUriResource = 1;
  var DATA_URI_PATTERN = /^data:(\S*?)?(;charset=[^;]+)?(;[^,]+?)?,(.+)/;
  function isDataUriResource(uri) {
    return DATA_URI_PATTERN.test(uri);
  }
  isDataUriResource_1 = isDataUriResource;
  return isDataUriResource_1;
}

var applySourceMaps_1;
var hasRequiredApplySourceMaps;
function requireApplySourceMaps() {
  if (hasRequiredApplySourceMaps) return applySourceMaps_1;
  hasRequiredApplySourceMaps = 1;
  var fs = require$$0$5;
  var path = require$$1$1;
  var isAllowedResource = requireIsAllowedResource();
  var matchDataUri = requireMatchDataUri();
  var rebaseLocalMap = requireRebaseLocalMap();
  var rebaseRemoteMap = requireRebaseRemoteMap();
  var Token = requireToken();
  var hasProtocol = requireHasProtocol();
  var isDataUriResource = requireIsDataUriResource();
  var isRemoteResource = requireIsRemoteResource();
  var MAP_MARKER_PATTERN = /^\/\*# sourceMappingURL=(\S+) \*\/$/;
  function applySourceMaps(tokens, context, callback) {
    var applyContext = {
      callback: callback,
      fetch: context.options.fetch,
      index: 0,
      inline: context.options.inline,
      inlineRequest: context.options.inlineRequest,
      inlineTimeout: context.options.inlineTimeout,
      inputSourceMapTracker: context.inputSourceMapTracker,
      localOnly: context.localOnly,
      processedTokens: [],
      rebaseTo: context.options.rebaseTo,
      sourceTokens: tokens,
      warnings: context.warnings
    };
    return context.options.sourceMap && tokens.length > 0 ? doApplySourceMaps(applyContext) : callback(tokens);
  }
  function doApplySourceMaps(applyContext) {
    var singleSourceTokens = [];
    var lastSource = findTokenSource(applyContext.sourceTokens[0]);
    var source;
    var token;
    var l;
    for (l = applyContext.sourceTokens.length; applyContext.index < l; applyContext.index++) {
      token = applyContext.sourceTokens[applyContext.index];
      source = findTokenSource(token);
      if (source != lastSource) {
        singleSourceTokens = [];
        lastSource = source;
      }
      singleSourceTokens.push(token);
      applyContext.processedTokens.push(token);
      if (token[0] == Token.COMMENT && MAP_MARKER_PATTERN.test(token[1])) {
        return fetchAndApplySourceMap(token[1], source, singleSourceTokens, applyContext);
      }
    }
    return applyContext.callback(applyContext.processedTokens);
  }
  function findTokenSource(token) {
    var scope;
    var metadata;
    if (token[0] == Token.AT_RULE || token[0] == Token.COMMENT) {
      metadata = token[2][0];
    } else {
      scope = token[1][0];
      metadata = scope[2][0];
    }
    return metadata[2];
  }
  function fetchAndApplySourceMap(sourceMapComment, source, singleSourceTokens, applyContext) {
    return extractInputSourceMapFrom(sourceMapComment, applyContext, function (inputSourceMap) {
      if (inputSourceMap) {
        applyContext.inputSourceMapTracker.track(source, inputSourceMap);
        applySourceMapRecursively(singleSourceTokens, applyContext.inputSourceMapTracker);
      }
      applyContext.index++;
      return doApplySourceMaps(applyContext);
    });
  }
  function extractInputSourceMapFrom(sourceMapComment, applyContext, whenSourceMapReady) {
    var uri = MAP_MARKER_PATTERN.exec(sourceMapComment)[1];
    var absoluteUri;
    var sourceMap;
    var rebasedMap;
    if (isDataUriResource(uri)) {
      sourceMap = extractInputSourceMapFromDataUri(uri);
      return whenSourceMapReady(sourceMap);
    } else if (isRemoteResource(uri)) {
      return loadInputSourceMapFromRemoteUri(uri, applyContext, function (sourceMap) {
        var parsedMap;
        if (sourceMap) {
          parsedMap = JSON.parse(sourceMap);
          rebasedMap = rebaseRemoteMap(parsedMap, uri);
          whenSourceMapReady(rebasedMap);
        } else {
          whenSourceMapReady(null);
        }
      });
    } else {
      // at this point `uri` is already rebased, see lib/reader/rebase.js#rebaseSourceMapComment
      // it is rebased to be consistent with rebasing other URIs
      // however here we need to resolve it back to read it from disk
      absoluteUri = path.resolve(applyContext.rebaseTo, uri);
      sourceMap = loadInputSourceMapFromLocalUri(absoluteUri, applyContext);
      if (sourceMap) {
        rebasedMap = rebaseLocalMap(sourceMap, absoluteUri, applyContext.rebaseTo);
        return whenSourceMapReady(rebasedMap);
      } else {
        return whenSourceMapReady(null);
      }
    }
  }
  function extractInputSourceMapFromDataUri(uri) {
    var dataUriMatch = matchDataUri(uri);
    var charset = dataUriMatch[2] ? dataUriMatch[2].split(/[=;]/)[2] : 'us-ascii';
    var encoding = dataUriMatch[3] ? dataUriMatch[3].split(';')[1] : 'utf8';
    var data = encoding == 'utf8' ? commonjsGlobal.unescape(dataUriMatch[4]) : dataUriMatch[4];
    var buffer = new Buffer(data, encoding);
    buffer.charset = charset;
    return JSON.parse(buffer.toString());
  }
  function loadInputSourceMapFromRemoteUri(uri, applyContext, whenLoaded) {
    var isAllowed = isAllowedResource(uri, true, applyContext.inline);
    var isRuntimeResource = !hasProtocol(uri);
    if (applyContext.localOnly) {
      applyContext.warnings.push('Cannot fetch remote resource from "' + uri + '" as no callback given.');
      return whenLoaded(null);
    } else if (isRuntimeResource) {
      applyContext.warnings.push('Cannot fetch "' + uri + '" as no protocol given.');
      return whenLoaded(null);
    } else if (!isAllowed) {
      applyContext.warnings.push('Cannot fetch "' + uri + '" as resource is not allowed.');
      return whenLoaded(null);
    }
    applyContext.fetch(uri, applyContext.inlineRequest, applyContext.inlineTimeout, function (error, body) {
      if (error) {
        applyContext.warnings.push('Missing source map at "' + uri + '" - ' + error);
        return whenLoaded(null);
      }
      whenLoaded(body);
    });
  }
  function loadInputSourceMapFromLocalUri(uri, applyContext) {
    var isAllowed = isAllowedResource(uri, false, applyContext.inline);
    var sourceMap;
    if (!fs.existsSync(uri) || !fs.statSync(uri).isFile()) {
      applyContext.warnings.push('Ignoring local source map at "' + uri + '" as resource is missing.');
      return null;
    } else if (!isAllowed) {
      applyContext.warnings.push('Cannot fetch "' + uri + '" as resource is not allowed.');
      return null;
    }
    sourceMap = fs.readFileSync(uri, 'utf-8');
    return JSON.parse(sourceMap);
  }
  function applySourceMapRecursively(tokens, inputSourceMapTracker) {
    var token;
    var i, l;
    for (i = 0, l = tokens.length; i < l; i++) {
      token = tokens[i];
      switch (token[0]) {
        case Token.AT_RULE:
          applySourceMapTo(token, inputSourceMapTracker);
          break;
        case Token.AT_RULE_BLOCK:
          applySourceMapRecursively(token[1], inputSourceMapTracker);
          applySourceMapRecursively(token[2], inputSourceMapTracker);
          break;
        case Token.AT_RULE_BLOCK_SCOPE:
          applySourceMapTo(token, inputSourceMapTracker);
          break;
        case Token.NESTED_BLOCK:
          applySourceMapRecursively(token[1], inputSourceMapTracker);
          applySourceMapRecursively(token[2], inputSourceMapTracker);
          break;
        case Token.NESTED_BLOCK_SCOPE:
          applySourceMapTo(token, inputSourceMapTracker);
          break;
        case Token.COMMENT:
          applySourceMapTo(token, inputSourceMapTracker);
          break;
        case Token.PROPERTY:
          applySourceMapRecursively(token, inputSourceMapTracker);
          break;
        case Token.PROPERTY_BLOCK:
          applySourceMapRecursively(token[1], inputSourceMapTracker);
          break;
        case Token.PROPERTY_NAME:
          applySourceMapTo(token, inputSourceMapTracker);
          break;
        case Token.PROPERTY_VALUE:
          applySourceMapTo(token, inputSourceMapTracker);
          break;
        case Token.RULE:
          applySourceMapRecursively(token[1], inputSourceMapTracker);
          applySourceMapRecursively(token[2], inputSourceMapTracker);
          break;
        case Token.RULE_SCOPE:
          applySourceMapTo(token, inputSourceMapTracker);
      }
    }
    return tokens;
  }
  function applySourceMapTo(token, inputSourceMapTracker) {
    var value = token[1];
    var metadata = token[2];
    var newMetadata = [];
    var i, l;
    for (i = 0, l = metadata.length; i < l; i++) {
      newMetadata.push(inputSourceMapTracker.originalPositionFor(metadata[i], value.length));
    }
    token[2] = newMetadata;
  }
  applySourceMaps_1 = applySourceMaps;
  return applySourceMaps_1;
}

var extractImportUrlAndMedia_1;
var hasRequiredExtractImportUrlAndMedia;
function requireExtractImportUrlAndMedia() {
  if (hasRequiredExtractImportUrlAndMedia) return extractImportUrlAndMedia_1;
  hasRequiredExtractImportUrlAndMedia = 1;
  var split = requireSplit();
  var BRACE_PREFIX = /^\(/;
  var BRACE_SUFFIX = /\)$/;
  var IMPORT_PREFIX_PATTERN = /^@import/i;
  var QUOTE_PREFIX_PATTERN = /['"]\s*/;
  var QUOTE_SUFFIX_PATTERN = /\s*['"]/;
  var URL_PREFIX_PATTERN = /^url\(\s*/i;
  var URL_SUFFIX_PATTERN = /\s*\)/i;
  function extractImportUrlAndMedia(atRuleValue) {
    var uri;
    var mediaQuery;
    var stripped;
    var parts;
    stripped = atRuleValue.replace(IMPORT_PREFIX_PATTERN, '').trim().replace(URL_PREFIX_PATTERN, '(').replace(URL_SUFFIX_PATTERN, ')').replace(QUOTE_PREFIX_PATTERN, '').replace(QUOTE_SUFFIX_PATTERN, '');
    parts = split(stripped, ' ');
    uri = parts[0].replace(BRACE_PREFIX, '').replace(BRACE_SUFFIX, '');
    mediaQuery = parts.slice(1).join(' ');
    return [uri, mediaQuery];
  }
  extractImportUrlAndMedia_1 = extractImportUrlAndMedia;
  return extractImportUrlAndMedia_1;
}

var loadOriginalSources_1;
var hasRequiredLoadOriginalSources;
function requireLoadOriginalSources() {
  if (hasRequiredLoadOriginalSources) return loadOriginalSources_1;
  hasRequiredLoadOriginalSources = 1;
  var fs = require$$0$5;
  var path = require$$1$1;
  var isAllowedResource = requireIsAllowedResource();
  var hasProtocol = requireHasProtocol();
  var isRemoteResource = requireIsRemoteResource();
  function loadOriginalSources(context, callback) {
    var loadContext = {
      callback: callback,
      fetch: context.options.fetch,
      index: 0,
      inline: context.options.inline,
      inlineRequest: context.options.inlineRequest,
      inlineTimeout: context.options.inlineTimeout,
      localOnly: context.localOnly,
      rebaseTo: context.options.rebaseTo,
      sourcesContent: context.sourcesContent,
      uriToSource: uriToSourceMapping(context.inputSourceMapTracker.all()),
      warnings: context.warnings
    };
    return context.options.sourceMap && context.options.sourceMapInlineSources ? doLoadOriginalSources(loadContext) : callback();
  }
  function uriToSourceMapping(allSourceMapConsumers) {
    var mapping = {};
    var consumer;
    var uri;
    var source;
    var i, l;
    for (source in allSourceMapConsumers) {
      consumer = allSourceMapConsumers[source];
      for (i = 0, l = consumer.sources.length; i < l; i++) {
        uri = consumer.sources[i];
        source = consumer.sourceContentFor(uri, true);
        mapping[uri] = source;
      }
    }
    return mapping;
  }
  function doLoadOriginalSources(loadContext) {
    var uris = Object.keys(loadContext.uriToSource);
    var uri;
    var source;
    var total;
    for (total = uris.length; loadContext.index < total; loadContext.index++) {
      uri = uris[loadContext.index];
      source = loadContext.uriToSource[uri];
      if (source) {
        loadContext.sourcesContent[uri] = source;
      } else {
        return loadOriginalSource(uri, loadContext);
      }
    }
    return loadContext.callback();
  }
  function loadOriginalSource(uri, loadContext) {
    var content;
    if (isRemoteResource(uri)) {
      return loadOriginalSourceFromRemoteUri(uri, loadContext, function (content) {
        loadContext.index++;
        loadContext.sourcesContent[uri] = content;
        return doLoadOriginalSources(loadContext);
      });
    } else {
      content = loadOriginalSourceFromLocalUri(uri, loadContext);
      loadContext.index++;
      loadContext.sourcesContent[uri] = content;
      return doLoadOriginalSources(loadContext);
    }
  }
  function loadOriginalSourceFromRemoteUri(uri, loadContext, whenLoaded) {
    var isAllowed = isAllowedResource(uri, true, loadContext.inline);
    var isRuntimeResource = !hasProtocol(uri);
    if (loadContext.localOnly) {
      loadContext.warnings.push('Cannot fetch remote resource from "' + uri + '" as no callback given.');
      return whenLoaded(null);
    } else if (isRuntimeResource) {
      loadContext.warnings.push('Cannot fetch "' + uri + '" as no protocol given.');
      return whenLoaded(null);
    } else if (!isAllowed) {
      loadContext.warnings.push('Cannot fetch "' + uri + '" as resource is not allowed.');
      return whenLoaded(null);
    }
    loadContext.fetch(uri, loadContext.inlineRequest, loadContext.inlineTimeout, function (error, content) {
      if (error) {
        loadContext.warnings.push('Missing original source at "' + uri + '" - ' + error);
      }
      whenLoaded(content);
    });
  }
  function loadOriginalSourceFromLocalUri(relativeUri, loadContext) {
    var isAllowed = isAllowedResource(relativeUri, false, loadContext.inline);
    var absoluteUri = path.resolve(loadContext.rebaseTo, relativeUri);
    if (!fs.existsSync(absoluteUri) || !fs.statSync(absoluteUri).isFile()) {
      loadContext.warnings.push('Ignoring local source map at "' + absoluteUri + '" as resource is missing.');
      return null;
    } else if (!isAllowed) {
      loadContext.warnings.push('Cannot fetch "' + absoluteUri + '" as resource is not allowed.');
      return null;
    }
    return fs.readFileSync(absoluteUri, 'utf8');
  }
  loadOriginalSources_1 = loadOriginalSources;
  return loadOriginalSources_1;
}

var normalizePath_1;
var hasRequiredNormalizePath;
function requireNormalizePath() {
  if (hasRequiredNormalizePath) return normalizePath_1;
  hasRequiredNormalizePath = 1;
  var UNIX_SEPARATOR = '/';
  var WINDOWS_SEPARATOR_PATTERN = /\\/g;
  function normalizePath(path) {
    return path.replace(WINDOWS_SEPARATOR_PATTERN, UNIX_SEPARATOR);
  }
  normalizePath_1 = normalizePath;
  return normalizePath_1;
}

var restoreImport_1;
var hasRequiredRestoreImport;
function requireRestoreImport() {
  if (hasRequiredRestoreImport) return restoreImport_1;
  hasRequiredRestoreImport = 1;
  function restoreImport(uri, mediaQuery) {
    return ('@import ' + uri + ' ' + mediaQuery).trim();
  }
  restoreImport_1 = restoreImport;
  return restoreImport_1;
}

var rewriteUrl_1;
var hasRequiredRewriteUrl;
function requireRewriteUrl() {
  if (hasRequiredRewriteUrl) return rewriteUrl_1;
  hasRequiredRewriteUrl = 1;
  var path = require$$1$1;
  var url = require$$1$2;
  var DOUBLE_QUOTE = '"';
  var SINGLE_QUOTE = '\'';
  var URL_PREFIX = 'url(';
  var URL_SUFFIX = ')';
  var QUOTE_PREFIX_PATTERN = /^["']/;
  var QUOTE_SUFFIX_PATTERN = /["']$/;
  var ROUND_BRACKETS_PATTERN = /[\(\)]/;
  var URL_PREFIX_PATTERN = /^url\(/i;
  var URL_SUFFIX_PATTERN = /\)$/;
  var WHITESPACE_PATTERN = /\s/;
  var isWindows = process.platform == 'win32';
  function rebase(uri, rebaseConfig) {
    if (!rebaseConfig) {
      return uri;
    }
    if (isAbsolute(uri) && !isRemote(rebaseConfig.toBase)) {
      return uri;
    }
    if (isRemote(uri) || isSVGMarker(uri) || isInternal(uri)) {
      return uri;
    }
    if (isData(uri)) {
      return '\'' + uri + '\'';
    }
    if (isRemote(rebaseConfig.toBase)) {
      return url.resolve(rebaseConfig.toBase, uri);
    }
    return rebaseConfig.absolute ? normalize(absolute(uri, rebaseConfig)) : normalize(relative(uri, rebaseConfig));
  }
  function isAbsolute(uri) {
    return path.isAbsolute(uri);
  }
  function isSVGMarker(uri) {
    return uri[0] == '#';
  }
  function isInternal(uri) {
    return /^\w+:\w+/.test(uri);
  }
  function isRemote(uri) {
    return /^[^:]+?:\/\//.test(uri) || uri.indexOf('//') === 0;
  }
  function isData(uri) {
    return uri.indexOf('data:') === 0;
  }
  function absolute(uri, rebaseConfig) {
    return path.resolve(path.join(rebaseConfig.fromBase || '', uri)).replace(rebaseConfig.toBase, '');
  }
  function relative(uri, rebaseConfig) {
    return path.relative(rebaseConfig.toBase, path.join(rebaseConfig.fromBase || '', uri));
  }
  function normalize(uri) {
    return isWindows ? uri.replace(/\\/g, '/') : uri;
  }
  function quoteFor(unquotedUrl) {
    if (unquotedUrl.indexOf(SINGLE_QUOTE) > -1) {
      return DOUBLE_QUOTE;
    } else if (unquotedUrl.indexOf(DOUBLE_QUOTE) > -1) {
      return SINGLE_QUOTE;
    } else if (hasWhitespace(unquotedUrl) || hasRoundBrackets(unquotedUrl)) {
      return SINGLE_QUOTE;
    } else {
      return '';
    }
  }
  function hasWhitespace(url) {
    return WHITESPACE_PATTERN.test(url);
  }
  function hasRoundBrackets(url) {
    return ROUND_BRACKETS_PATTERN.test(url);
  }
  function rewriteUrl(originalUrl, rebaseConfig, pathOnly) {
    var strippedUrl = originalUrl.replace(URL_PREFIX_PATTERN, '').replace(URL_SUFFIX_PATTERN, '').trim();
    var unquotedUrl = strippedUrl.replace(QUOTE_PREFIX_PATTERN, '').replace(QUOTE_SUFFIX_PATTERN, '').trim();
    var quote = strippedUrl[0] == SINGLE_QUOTE || strippedUrl[0] == DOUBLE_QUOTE ? strippedUrl[0] : quoteFor(unquotedUrl);
    return pathOnly ? rebase(unquotedUrl, rebaseConfig) : URL_PREFIX + quote + rebase(unquotedUrl, rebaseConfig) + quote + URL_SUFFIX;
  }
  rewriteUrl_1 = rewriteUrl;
  return rewriteUrl_1;
}

var isImport_1;
var hasRequiredIsImport;
function requireIsImport() {
  if (hasRequiredIsImport) return isImport_1;
  hasRequiredIsImport = 1;
  var IMPORT_PREFIX_PATTERN = /^@import/i;
  function isImport(value) {
    return IMPORT_PREFIX_PATTERN.test(value);
  }
  isImport_1 = isImport;
  return isImport_1;
}

var rebase_1;
var hasRequiredRebase;
function requireRebase() {
  if (hasRequiredRebase) return rebase_1;
  hasRequiredRebase = 1;
  var extractImportUrlAndMedia = requireExtractImportUrlAndMedia();
  var restoreImport = requireRestoreImport();
  var rewriteUrl = requireRewriteUrl();
  var Token = requireToken();
  var isImport = requireIsImport();
  var SOURCE_MAP_COMMENT_PATTERN = /^\/\*# sourceMappingURL=(\S+) \*\/$/;
  function rebase(tokens, rebaseAll, validator, rebaseConfig) {
    return rebaseAll ? rebaseEverything(tokens, validator, rebaseConfig) : rebaseAtRules(tokens, validator, rebaseConfig);
  }
  function rebaseEverything(tokens, validator, rebaseConfig) {
    var token;
    var i, l;
    for (i = 0, l = tokens.length; i < l; i++) {
      token = tokens[i];
      switch (token[0]) {
        case Token.AT_RULE:
          rebaseAtRule(token, validator, rebaseConfig);
          break;
        case Token.AT_RULE_BLOCK:
          rebaseProperties(token[2], validator, rebaseConfig);
          break;
        case Token.COMMENT:
          rebaseSourceMapComment(token, rebaseConfig);
          break;
        case Token.NESTED_BLOCK:
          rebaseEverything(token[2], validator, rebaseConfig);
          break;
        case Token.RULE:
          rebaseProperties(token[2], validator, rebaseConfig);
          break;
      }
    }
    return tokens;
  }
  function rebaseAtRules(tokens, validator, rebaseConfig) {
    var token;
    var i, l;
    for (i = 0, l = tokens.length; i < l; i++) {
      token = tokens[i];
      switch (token[0]) {
        case Token.AT_RULE:
          rebaseAtRule(token, validator, rebaseConfig);
          break;
      }
    }
    return tokens;
  }
  function rebaseAtRule(token, validator, rebaseConfig) {
    if (!isImport(token[1])) {
      return;
    }
    var uriAndMediaQuery = extractImportUrlAndMedia(token[1]);
    var newUrl = rewriteUrl(uriAndMediaQuery[0], rebaseConfig);
    var mediaQuery = uriAndMediaQuery[1];
    token[1] = restoreImport(newUrl, mediaQuery);
  }
  function rebaseSourceMapComment(token, rebaseConfig) {
    var matches = SOURCE_MAP_COMMENT_PATTERN.exec(token[1]);
    if (matches && matches[1].indexOf('data:') === -1) {
      token[1] = token[1].replace(matches[1], rewriteUrl(matches[1], rebaseConfig, true));
    }
  }
  function rebaseProperties(properties, validator, rebaseConfig) {
    var property;
    var value;
    var i, l;
    var j, m;
    for (i = 0, l = properties.length; i < l; i++) {
      property = properties[i];
      for (j = 2 /* 0 is Token.PROPERTY, 1 is name */, m = property.length; j < m; j++) {
        value = property[j][1];
        if (validator.isUrl(value)) {
          property[j][1] = rewriteUrl(value, rebaseConfig);
        }
      }
    }
  }
  rebase_1 = rebase;
  return rebase_1;
}

var tokenize_1;
var hasRequiredTokenize;
function requireTokenize() {
  if (hasRequiredTokenize) return tokenize_1;
  hasRequiredTokenize = 1;
  var Marker = requireMarker();
  var Token = requireToken();
  var formatPosition = requireFormatPosition();
  var Level = {
    BLOCK: 'block',
    COMMENT: 'comment',
    DOUBLE_QUOTE: 'double-quote',
    RULE: 'rule',
    SINGLE_QUOTE: 'single-quote'
  };
  var AT_RULES = ['@charset', '@import'];
  var BLOCK_RULES = ['@-moz-document', '@document', '@-moz-keyframes', '@-ms-keyframes', '@-o-keyframes', '@-webkit-keyframes', '@keyframes', '@media', '@supports'];
  var IGNORE_END_COMMENT_PATTERN = /\/\* clean\-css ignore:end \*\/$/;
  var IGNORE_START_COMMENT_PATTERN = /^\/\* clean\-css ignore:start \*\//;
  var PAGE_MARGIN_BOXES = ['@bottom-center', '@bottom-left', '@bottom-left-corner', '@bottom-right', '@bottom-right-corner', '@left-bottom', '@left-middle', '@left-top', '@right-bottom', '@right-middle', '@right-top', '@top-center', '@top-left', '@top-left-corner', '@top-right', '@top-right-corner'];
  var EXTRA_PAGE_BOXES = ['@footnote', '@footnotes', '@left', '@page-float-bottom', '@page-float-top', '@right'];
  var REPEAT_PATTERN = /^\[\s{0,31}\d+\s{0,31}\]$/;
  var RULE_WORD_SEPARATOR_PATTERN = /[\s\(]/;
  var TAIL_BROKEN_VALUE_PATTERN = /[\s|\}]*$/;
  function tokenize(source, externalContext) {
    var internalContext = {
      level: Level.BLOCK,
      position: {
        source: externalContext.source || undefined,
        line: 1,
        column: 0,
        index: 0
      }
    };
    return intoTokens(source, externalContext, internalContext, false);
  }
  function intoTokens(source, externalContext, internalContext, isNested) {
    var allTokens = [];
    var newTokens = allTokens;
    var lastToken;
    var ruleToken;
    var ruleTokens = [];
    var propertyToken;
    var metadata;
    var metadatas = [];
    var level = internalContext.level;
    var levels = [];
    var buffer = [];
    var buffers = [];
    var serializedBuffer;
    var serializedBufferPart;
    var roundBracketLevel = 0;
    var isQuoted;
    var isSpace;
    var isNewLineNix;
    var isNewLineWin;
    var isCarriageReturn;
    var isCommentStart;
    var wasCommentStart = false;
    var isCommentEnd;
    var wasCommentEnd = false;
    var isCommentEndMarker;
    var isEscaped;
    var wasEscaped = false;
    var isRaw = false;
    var seekingValue = false;
    var seekingPropertyBlockClosing = false;
    var position = internalContext.position;
    var lastCommentStartAt;
    for (; position.index < source.length; position.index++) {
      var character = source[position.index];
      isQuoted = level == Level.SINGLE_QUOTE || level == Level.DOUBLE_QUOTE;
      isSpace = character == Marker.SPACE || character == Marker.TAB;
      isNewLineNix = character == Marker.NEW_LINE_NIX;
      isNewLineWin = character == Marker.NEW_LINE_NIX && source[position.index - 1] == Marker.CARRIAGE_RETURN;
      isCarriageReturn = character == Marker.CARRIAGE_RETURN && source[position.index + 1] && source[position.index + 1] != Marker.NEW_LINE_NIX;
      isCommentStart = !wasCommentEnd && level != Level.COMMENT && !isQuoted && character == Marker.ASTERISK && source[position.index - 1] == Marker.FORWARD_SLASH;
      isCommentEndMarker = !wasCommentStart && !isQuoted && character == Marker.FORWARD_SLASH && source[position.index - 1] == Marker.ASTERISK;
      isCommentEnd = level == Level.COMMENT && isCommentEndMarker;
      roundBracketLevel = Math.max(roundBracketLevel, 0);
      metadata = buffer.length === 0 ? [position.line, position.column, position.source] : metadata;
      if (isEscaped) {
        // previous character was a backslash
        buffer.push(character);
      } else if (!isCommentEnd && level == Level.COMMENT) {
        buffer.push(character);
      } else if (!isCommentStart && !isCommentEnd && isRaw) {
        buffer.push(character);
      } else if (isCommentStart && (level == Level.BLOCK || level == Level.RULE) && buffer.length > 1) {
        // comment start within block preceded by some content, e.g. div/*<--
        metadatas.push(metadata);
        buffer.push(character);
        buffers.push(buffer.slice(0, buffer.length - 2));
        buffer = buffer.slice(buffer.length - 2);
        metadata = [position.line, position.column - 1, position.source];
        levels.push(level);
        level = Level.COMMENT;
      } else if (isCommentStart) {
        // comment start, e.g. /*<--
        levels.push(level);
        level = Level.COMMENT;
        buffer.push(character);
      } else if (isCommentEnd && isIgnoreStartComment(buffer)) {
        // ignore:start comment end, e.g. /* clean-css ignore:start */<--
        serializedBuffer = buffer.join('').trim() + character;
        lastToken = [Token.COMMENT, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]];
        newTokens.push(lastToken);
        isRaw = true;
        metadata = metadatas.pop() || null;
        buffer = buffers.pop() || [];
      } else if (isCommentEnd && isIgnoreEndComment(buffer)) {
        // ignore:start comment end, e.g. /* clean-css ignore:end */<--
        serializedBuffer = buffer.join('') + character;
        lastCommentStartAt = serializedBuffer.lastIndexOf(Marker.FORWARD_SLASH + Marker.ASTERISK);
        serializedBufferPart = serializedBuffer.substring(0, lastCommentStartAt);
        lastToken = [Token.RAW, serializedBufferPart, [originalMetadata(metadata, serializedBufferPart, externalContext)]];
        newTokens.push(lastToken);
        serializedBufferPart = serializedBuffer.substring(lastCommentStartAt);
        metadata = [position.line, position.column - serializedBufferPart.length + 1, position.source];
        lastToken = [Token.COMMENT, serializedBufferPart, [originalMetadata(metadata, serializedBufferPart, externalContext)]];
        newTokens.push(lastToken);
        isRaw = false;
        level = levels.pop();
        metadata = metadatas.pop() || null;
        buffer = buffers.pop() || [];
      } else if (isCommentEnd) {
        // comment end, e.g. /* comment */<--
        serializedBuffer = buffer.join('').trim() + character;
        lastToken = [Token.COMMENT, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]];
        newTokens.push(lastToken);
        level = levels.pop();
        metadata = metadatas.pop() || null;
        buffer = buffers.pop() || [];
      } else if (isCommentEndMarker && source[position.index + 1] != Marker.ASTERISK) {
        externalContext.warnings.push('Unexpected \'*/\' at ' + formatPosition([position.line, position.column, position.source]) + '.');
        buffer = [];
      } else if (character == Marker.SINGLE_QUOTE && !isQuoted) {
        // single quotation start, e.g. a[href^='https<--
        levels.push(level);
        level = Level.SINGLE_QUOTE;
        buffer.push(character);
      } else if (character == Marker.SINGLE_QUOTE && level == Level.SINGLE_QUOTE) {
        // single quotation end, e.g. a[href^='https'<--
        level = levels.pop();
        buffer.push(character);
      } else if (character == Marker.DOUBLE_QUOTE && !isQuoted) {
        // double quotation start, e.g. a[href^="<--
        levels.push(level);
        level = Level.DOUBLE_QUOTE;
        buffer.push(character);
      } else if (character == Marker.DOUBLE_QUOTE && level == Level.DOUBLE_QUOTE) {
        // double quotation end, e.g. a[href^="https"<--
        level = levels.pop();
        buffer.push(character);
      } else if (!isCommentStart && !isCommentEnd && character != Marker.CLOSE_ROUND_BRACKET && character != Marker.OPEN_ROUND_BRACKET && level != Level.COMMENT && !isQuoted && roundBracketLevel > 0) {
        // character inside any function, e.g. hsla(.<--
        buffer.push(character);
      } else if (character == Marker.OPEN_ROUND_BRACKET && !isQuoted && level != Level.COMMENT && !seekingValue) {
        // round open bracket, e.g. @import url(<--
        buffer.push(character);
        roundBracketLevel++;
      } else if (character == Marker.CLOSE_ROUND_BRACKET && !isQuoted && level != Level.COMMENT && !seekingValue) {
        // round open bracket, e.g. @import url(test.css)<--
        buffer.push(character);
        roundBracketLevel--;
      } else if (character == Marker.SEMICOLON && level == Level.BLOCK && buffer[0] == Marker.AT) {
        // semicolon ending rule at block level, e.g. @import '...';<--
        serializedBuffer = buffer.join('').trim();
        allTokens.push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        buffer = [];
      } else if (character == Marker.COMMA && level == Level.BLOCK && ruleToken) {
        // comma separator at block level, e.g. a,div,<--
        serializedBuffer = buffer.join('').trim();
        ruleToken[1].push([tokenScopeFrom(ruleToken[0]), serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext, ruleToken[1].length)]]);
        buffer = [];
      } else if (character == Marker.COMMA && level == Level.BLOCK && tokenTypeFrom(buffer) == Token.AT_RULE) {
        // comma separator at block level, e.g. @import url(...) screen,<--
        // keep iterating as end semicolon will create the token
        buffer.push(character);
      } else if (character == Marker.COMMA && level == Level.BLOCK) {
        // comma separator at block level, e.g. a,<--
        ruleToken = [tokenTypeFrom(buffer), [], []];
        serializedBuffer = buffer.join('').trim();
        ruleToken[1].push([tokenScopeFrom(ruleToken[0]), serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext, 0)]]);
        buffer = [];
      } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.BLOCK && ruleToken && ruleToken[0] == Token.NESTED_BLOCK) {
        // open brace opening at-rule at block level, e.g. @media{<--
        serializedBuffer = buffer.join('').trim();
        ruleToken[1].push([Token.NESTED_BLOCK_SCOPE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        allTokens.push(ruleToken);
        levels.push(level);
        position.column++;
        position.index++;
        buffer = [];
        ruleToken[2] = intoTokens(source, externalContext, internalContext, true);
        ruleToken = null;
      } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.BLOCK && tokenTypeFrom(buffer) == Token.NESTED_BLOCK) {
        // open brace opening at-rule at block level, e.g. @media{<--
        serializedBuffer = buffer.join('').trim();
        ruleToken = ruleToken || [Token.NESTED_BLOCK, [], []];
        ruleToken[1].push([Token.NESTED_BLOCK_SCOPE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        allTokens.push(ruleToken);
        levels.push(level);
        position.column++;
        position.index++;
        buffer = [];
        ruleToken[2] = intoTokens(source, externalContext, internalContext, true);
        ruleToken = null;
      } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.BLOCK) {
        // open brace opening rule at block level, e.g. div{<--
        serializedBuffer = buffer.join('').trim();
        ruleToken = ruleToken || [tokenTypeFrom(buffer), [], []];
        ruleToken[1].push([tokenScopeFrom(ruleToken[0]), serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext, ruleToken[1].length)]]);
        newTokens = ruleToken[2];
        allTokens.push(ruleToken);
        levels.push(level);
        level = Level.RULE;
        buffer = [];
      } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.RULE && seekingValue) {
        // open brace opening rule at rule level, e.g. div{--variable:{<--
        ruleTokens.push(ruleToken);
        ruleToken = [Token.PROPERTY_BLOCK, []];
        propertyToken.push(ruleToken);
        newTokens = ruleToken[1];
        levels.push(level);
        level = Level.RULE;
        seekingValue = false;
      } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.RULE && isPageMarginBox(buffer)) {
        // open brace opening page-margin box at rule level, e.g. @page{@top-center{<--
        serializedBuffer = buffer.join('').trim();
        ruleTokens.push(ruleToken);
        ruleToken = [Token.AT_RULE_BLOCK, [], []];
        ruleToken[1].push([Token.AT_RULE_BLOCK_SCOPE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        newTokens.push(ruleToken);
        newTokens = ruleToken[2];
        levels.push(level);
        level = Level.RULE;
        buffer = [];
      } else if (character == Marker.COLON && level == Level.RULE && !seekingValue) {
        // colon at rule level, e.g. a{color:<--
        serializedBuffer = buffer.join('').trim();
        propertyToken = [Token.PROPERTY, [Token.PROPERTY_NAME, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]];
        newTokens.push(propertyToken);
        seekingValue = true;
        buffer = [];
      } else if (character == Marker.SEMICOLON && level == Level.RULE && propertyToken && ruleTokens.length > 0 && buffer.length > 0 && buffer[0] == Marker.AT) {
        // semicolon at rule level for at-rule, e.g. a{--color:{@apply(--other-color);<--
        serializedBuffer = buffer.join('').trim();
        ruleToken[1].push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        buffer = [];
      } else if (character == Marker.SEMICOLON && level == Level.RULE && propertyToken && buffer.length > 0) {
        // semicolon at rule level, e.g. a{color:red;<--
        serializedBuffer = buffer.join('').trim();
        propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        propertyToken = null;
        seekingValue = false;
        buffer = [];
      } else if (character == Marker.SEMICOLON && level == Level.RULE && propertyToken && buffer.length === 0) {
        // semicolon after bracketed value at rule level, e.g. a{color:rgb(...);<--
        propertyToken = null;
        seekingValue = false;
      } else if (character == Marker.SEMICOLON && level == Level.RULE && buffer.length > 0 && buffer[0] == Marker.AT) {
        // semicolon for at-rule at rule level, e.g. a{@apply(--variable);<--
        serializedBuffer = buffer.join('');
        newTokens.push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        seekingValue = false;
        buffer = [];
      } else if (character == Marker.SEMICOLON && level == Level.RULE && seekingPropertyBlockClosing) {
        // close brace after a property block at rule level, e.g. a{--custom:{color:red;};<--
        seekingPropertyBlockClosing = false;
        buffer = [];
      } else if (character == Marker.SEMICOLON && level == Level.RULE && buffer.length === 0) ; else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && propertyToken && seekingValue && buffer.length > 0 && ruleTokens.length > 0) {
        // close brace at rule level, e.g. a{--color:{color:red}<--
        serializedBuffer = buffer.join('');
        propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        propertyToken = null;
        ruleToken = ruleTokens.pop();
        newTokens = ruleToken[2];
        level = levels.pop();
        seekingValue = false;
        buffer = [];
      } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && propertyToken && buffer.length > 0 && buffer[0] == Marker.AT && ruleTokens.length > 0) {
        // close brace at rule level for at-rule, e.g. a{--color:{@apply(--other-color)}<--
        serializedBuffer = buffer.join('');
        ruleToken[1].push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        propertyToken = null;
        ruleToken = ruleTokens.pop();
        newTokens = ruleToken[2];
        level = levels.pop();
        seekingValue = false;
        buffer = [];
      } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && propertyToken && ruleTokens.length > 0) {
        // close brace at rule level after space, e.g. a{--color:{color:red }<--
        propertyToken = null;
        ruleToken = ruleTokens.pop();
        newTokens = ruleToken[2];
        level = levels.pop();
        seekingValue = false;
      } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && propertyToken && buffer.length > 0) {
        // close brace at rule level, e.g. a{color:red}<--
        serializedBuffer = buffer.join('');
        propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        propertyToken = null;
        ruleToken = ruleTokens.pop();
        newTokens = allTokens;
        level = levels.pop();
        seekingValue = false;
        buffer = [];
      } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && buffer.length > 0 && buffer[0] == Marker.AT) {
        // close brace after at-rule at rule level, e.g. a{@apply(--variable)}<--
        propertyToken = null;
        ruleToken = null;
        serializedBuffer = buffer.join('').trim();
        newTokens.push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        newTokens = allTokens;
        level = levels.pop();
        seekingValue = false;
        buffer = [];
      } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && levels[levels.length - 1] == Level.RULE) {
        // close brace after a property block at rule level, e.g. a{--custom:{color:red;}<--
        propertyToken = null;
        ruleToken = ruleTokens.pop();
        newTokens = ruleToken[2];
        level = levels.pop();
        seekingValue = false;
        seekingPropertyBlockClosing = true;
        buffer = [];
      } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE) {
        // close brace after a rule, e.g. a{color:red;}<--
        propertyToken = null;
        ruleToken = null;
        newTokens = allTokens;
        level = levels.pop();
        seekingValue = false;
      } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.BLOCK && !isNested && position.index <= source.length - 1) {
        // stray close brace at block level, e.g. a{color:red}color:blue}<--
        externalContext.warnings.push('Unexpected \'}\' at ' + formatPosition([position.line, position.column, position.source]) + '.');
        buffer.push(character);
      } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.BLOCK) {
        // close brace at block level, e.g. @media screen {...}<--
        break;
      } else if (character == Marker.OPEN_ROUND_BRACKET && level == Level.RULE && seekingValue) {
        // round open bracket, e.g. a{color:hsla(<--
        buffer.push(character);
        roundBracketLevel++;
      } else if (character == Marker.CLOSE_ROUND_BRACKET && level == Level.RULE && seekingValue && roundBracketLevel == 1) {
        // round close bracket, e.g. a{color:hsla(0,0%,0%)<--
        buffer.push(character);
        serializedBuffer = buffer.join('').trim();
        propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        roundBracketLevel--;
        buffer = [];
      } else if (character == Marker.CLOSE_ROUND_BRACKET && level == Level.RULE && seekingValue) {
        // round close bracket within other brackets, e.g. a{width:calc((10rem / 2)<--
        buffer.push(character);
        roundBracketLevel--;
      } else if (character == Marker.FORWARD_SLASH && source[position.index + 1] != Marker.ASTERISK && level == Level.RULE && seekingValue && buffer.length > 0) {
        // forward slash within a property, e.g. a{background:url(image.png) 0 0/<--
        serializedBuffer = buffer.join('').trim();
        propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        propertyToken.push([Token.PROPERTY_VALUE, character, [[position.line, position.column, position.source]]]);
        buffer = [];
      } else if (character == Marker.FORWARD_SLASH && source[position.index + 1] != Marker.ASTERISK && level == Level.RULE && seekingValue) {
        // forward slash within a property after space, e.g. a{background:url(image.png) 0 0 /<--
        propertyToken.push([Token.PROPERTY_VALUE, character, [[position.line, position.column, position.source]]]);
        buffer = [];
      } else if (character == Marker.COMMA && level == Level.RULE && seekingValue && buffer.length > 0) {
        // comma within a property, e.g. a{background:url(image.png),<--
        serializedBuffer = buffer.join('').trim();
        propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        propertyToken.push([Token.PROPERTY_VALUE, character, [[position.line, position.column, position.source]]]);
        buffer = [];
      } else if (character == Marker.COMMA && level == Level.RULE && seekingValue) {
        // comma within a property after space, e.g. a{background:url(image.png) ,<--
        propertyToken.push([Token.PROPERTY_VALUE, character, [[position.line, position.column, position.source]]]);
        buffer = [];
      } else if (character == Marker.CLOSE_SQUARE_BRACKET && propertyToken && propertyToken.length > 1 && buffer.length > 0 && isRepeatToken(buffer)) {
        buffer.push(character);
        serializedBuffer = buffer.join('').trim();
        propertyToken[propertyToken.length - 1][1] += serializedBuffer;
        buffer = [];
      } else if ((isSpace || isNewLineNix && !isNewLineWin) && level == Level.RULE && seekingValue && propertyToken && buffer.length > 0) {
        // space or *nix newline within property, e.g. a{margin:0 <--
        serializedBuffer = buffer.join('').trim();
        propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        buffer = [];
      } else if (isNewLineWin && level == Level.RULE && seekingValue && propertyToken && buffer.length > 1) {
        // win newline within property, e.g. a{margin:0\r\n<--
        serializedBuffer = buffer.join('').trim();
        propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
        buffer = [];
      } else if (isNewLineWin && level == Level.RULE && seekingValue) {
        // win newline
        buffer = [];
      } else if (buffer.length == 1 && isNewLineWin) {
        // ignore windows newline which is composed of two characters
        buffer.pop();
      } else if (buffer.length > 0 || !isSpace && !isNewLineNix && !isNewLineWin && !isCarriageReturn) {
        // any character
        buffer.push(character);
      }
      wasEscaped = isEscaped;
      isEscaped = !wasEscaped && character == Marker.BACK_SLASH;
      wasCommentStart = isCommentStart;
      wasCommentEnd = isCommentEnd;
      position.line = isNewLineWin || isNewLineNix || isCarriageReturn ? position.line + 1 : position.line;
      position.column = isNewLineWin || isNewLineNix || isCarriageReturn ? 0 : position.column + 1;
    }
    if (seekingValue) {
      externalContext.warnings.push('Missing \'}\' at ' + formatPosition([position.line, position.column, position.source]) + '.');
    }
    if (seekingValue && buffer.length > 0) {
      serializedBuffer = buffer.join('').replace(TAIL_BROKEN_VALUE_PATTERN, '');
      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);
      buffer = [];
    }
    if (buffer.length > 0) {
      externalContext.warnings.push('Invalid character(s) \'' + buffer.join('') + '\' at ' + formatPosition(metadata) + '. Ignoring.');
    }
    return allTokens;
  }
  function isIgnoreStartComment(buffer) {
    return IGNORE_START_COMMENT_PATTERN.test(buffer.join('') + Marker.FORWARD_SLASH);
  }
  function isIgnoreEndComment(buffer) {
    return IGNORE_END_COMMENT_PATTERN.test(buffer.join('') + Marker.FORWARD_SLASH);
  }
  function originalMetadata(metadata, value, externalContext, selectorFallbacks) {
    var source = metadata[2];
    return externalContext.inputSourceMapTracker.isTracking(source) ? externalContext.inputSourceMapTracker.originalPositionFor(metadata, value.length, selectorFallbacks) : metadata;
  }
  function tokenTypeFrom(buffer) {
    var isAtRule = buffer[0] == Marker.AT || buffer[0] == Marker.UNDERSCORE;
    var ruleWord = buffer.join('').split(RULE_WORD_SEPARATOR_PATTERN)[0];
    if (isAtRule && BLOCK_RULES.indexOf(ruleWord) > -1) {
      return Token.NESTED_BLOCK;
    } else if (isAtRule && AT_RULES.indexOf(ruleWord) > -1) {
      return Token.AT_RULE;
    } else if (isAtRule) {
      return Token.AT_RULE_BLOCK;
    } else {
      return Token.RULE;
    }
  }
  function tokenScopeFrom(tokenType) {
    if (tokenType == Token.RULE) {
      return Token.RULE_SCOPE;
    } else if (tokenType == Token.NESTED_BLOCK) {
      return Token.NESTED_BLOCK_SCOPE;
    } else if (tokenType == Token.AT_RULE_BLOCK) {
      return Token.AT_RULE_BLOCK_SCOPE;
    }
  }
  function isPageMarginBox(buffer) {
    var serializedBuffer = buffer.join('').trim();
    return PAGE_MARGIN_BOXES.indexOf(serializedBuffer) > -1 || EXTRA_PAGE_BOXES.indexOf(serializedBuffer) > -1;
  }
  function isRepeatToken(buffer) {
    return REPEAT_PATTERN.test(buffer.join('') + Marker.CLOSE_SQUARE_BRACKET);
  }
  tokenize_1 = tokenize;
  return tokenize_1;
}

var readSources_1;
var hasRequiredReadSources;
function requireReadSources() {
  if (hasRequiredReadSources) return readSources_1;
  hasRequiredReadSources = 1;
  var fs = require$$0$5;
  var path = require$$1$1;
  var applySourceMaps = requireApplySourceMaps();
  var extractImportUrlAndMedia = requireExtractImportUrlAndMedia();
  var isAllowedResource = requireIsAllowedResource();
  var loadOriginalSources = requireLoadOriginalSources();
  var normalizePath = requireNormalizePath();
  var rebase = requireRebase();
  var rebaseLocalMap = requireRebaseLocalMap();
  var rebaseRemoteMap = requireRebaseRemoteMap();
  var restoreImport = requireRestoreImport();
  var tokenize = requireTokenize();
  var Token = requireToken();
  var Marker = requireMarker();
  var hasProtocol = requireHasProtocol();
  var isImport = requireIsImport();
  var isRemoteResource = requireIsRemoteResource();
  var UNKNOWN_URI = 'uri:unknown';
  function readSources(input, context, callback) {
    return doReadSources(input, context, function (tokens) {
      return applySourceMaps(tokens, context, function () {
        return loadOriginalSources(context, function () {
          return callback(tokens);
        });
      });
    });
  }
  function doReadSources(input, context, callback) {
    if (typeof input == 'string') {
      return fromString(input, context, callback);
    } else if (Buffer.isBuffer(input)) {
      return fromString(input.toString(), context, callback);
    } else if (Array.isArray(input)) {
      return fromArray(input, context, callback);
    } else if (typeof input == 'object') {
      return fromHash(input, context, callback);
    }
  }
  function fromString(input, context, callback) {
    context.source = undefined;
    context.sourcesContent[undefined] = input;
    context.stats.originalSize += input.length;
    return fromStyles(input, context, {
      inline: context.options.inline
    }, callback);
  }
  function fromArray(input, context, callback) {
    var inputAsImports = input.reduce(function (accumulator, uriOrHash) {
      if (typeof uriOrHash === 'string') {
        return addStringSource(uriOrHash, accumulator);
      } else {
        return addHashSource(uriOrHash, context, accumulator);
      }
    }, []);
    return fromStyles(inputAsImports.join(''), context, {
      inline: ['all']
    }, callback);
  }
  function fromHash(input, context, callback) {
    var inputAsImports = addHashSource(input, context, []);
    return fromStyles(inputAsImports.join(''), context, {
      inline: ['all']
    }, callback);
  }
  function addStringSource(input, imports) {
    imports.push(restoreAsImport(normalizeUri(input)));
    return imports;
  }
  function addHashSource(input, context, imports) {
    var uri;
    var normalizedUri;
    var source;
    for (uri in input) {
      source = input[uri];
      normalizedUri = normalizeUri(uri);
      imports.push(restoreAsImport(normalizedUri));
      context.sourcesContent[normalizedUri] = source.styles;
      if (source.sourceMap) {
        trackSourceMap(source.sourceMap, normalizedUri, context);
      }
    }
    return imports;
  }
  function normalizeUri(uri) {
    var currentPath = path.resolve('');
    var absoluteUri;
    var relativeToCurrentPath;
    var normalizedUri;
    if (isRemoteResource(uri)) {
      return uri;
    }
    absoluteUri = path.isAbsolute(uri) ? uri : path.resolve(uri);
    relativeToCurrentPath = path.relative(currentPath, absoluteUri);
    normalizedUri = normalizePath(relativeToCurrentPath);
    return normalizedUri;
  }
  function trackSourceMap(sourceMap, uri, context) {
    var parsedMap = typeof sourceMap == 'string' ? JSON.parse(sourceMap) : sourceMap;
    var rebasedMap = isRemoteResource(uri) ? rebaseRemoteMap(parsedMap, uri) : rebaseLocalMap(parsedMap, uri || UNKNOWN_URI, context.options.rebaseTo);
    context.inputSourceMapTracker.track(uri, rebasedMap);
  }
  function restoreAsImport(uri) {
    return restoreImport('url(' + uri + ')', '') + Marker.SEMICOLON;
  }
  function fromStyles(styles, context, parentInlinerContext, callback) {
    var tokens;
    var rebaseConfig = {};
    if (!context.source) {
      rebaseConfig.fromBase = path.resolve('');
      rebaseConfig.toBase = context.options.rebaseTo;
    } else if (isRemoteResource(context.source)) {
      rebaseConfig.fromBase = context.source;
      rebaseConfig.toBase = context.source;
    } else if (path.isAbsolute(context.source)) {
      rebaseConfig.fromBase = path.dirname(context.source);
      rebaseConfig.toBase = context.options.rebaseTo;
    } else {
      rebaseConfig.fromBase = path.dirname(path.resolve(context.source));
      rebaseConfig.toBase = context.options.rebaseTo;
    }
    tokens = tokenize(styles, context);
    tokens = rebase(tokens, context.options.rebase, context.validator, rebaseConfig);
    return allowsAnyImports(parentInlinerContext.inline) ? inline(tokens, context, parentInlinerContext, callback) : callback(tokens);
  }
  function allowsAnyImports(inline) {
    return !(inline.length == 1 && inline[0] == 'none');
  }
  function inline(tokens, externalContext, parentInlinerContext, callback) {
    var inlinerContext = {
      afterContent: false,
      callback: callback,
      errors: externalContext.errors,
      externalContext: externalContext,
      fetch: externalContext.options.fetch,
      inlinedStylesheets: parentInlinerContext.inlinedStylesheets || externalContext.inlinedStylesheets,
      inline: parentInlinerContext.inline,
      inlineRequest: externalContext.options.inlineRequest,
      inlineTimeout: externalContext.options.inlineTimeout,
      isRemote: parentInlinerContext.isRemote || false,
      localOnly: externalContext.localOnly,
      outputTokens: [],
      rebaseTo: externalContext.options.rebaseTo,
      sourceTokens: tokens,
      warnings: externalContext.warnings
    };
    return doInlineImports(inlinerContext);
  }
  function doInlineImports(inlinerContext) {
    var token;
    var i, l;
    for (i = 0, l = inlinerContext.sourceTokens.length; i < l; i++) {
      token = inlinerContext.sourceTokens[i];
      if (token[0] == Token.AT_RULE && isImport(token[1])) {
        inlinerContext.sourceTokens.splice(0, i);
        return inlineStylesheet(token, inlinerContext);
      } else if (token[0] == Token.AT_RULE || token[0] == Token.COMMENT) {
        inlinerContext.outputTokens.push(token);
      } else {
        inlinerContext.outputTokens.push(token);
        inlinerContext.afterContent = true;
      }
    }
    inlinerContext.sourceTokens = [];
    return inlinerContext.callback(inlinerContext.outputTokens);
  }
  function inlineStylesheet(token, inlinerContext) {
    var uriAndMediaQuery = extractImportUrlAndMedia(token[1]);
    var uri = uriAndMediaQuery[0];
    var mediaQuery = uriAndMediaQuery[1];
    var metadata = token[2];
    return isRemoteResource(uri) ? inlineRemoteStylesheet(uri, mediaQuery, metadata, inlinerContext) : inlineLocalStylesheet(uri, mediaQuery, metadata, inlinerContext);
  }
  function inlineRemoteStylesheet(uri, mediaQuery, metadata, inlinerContext) {
    var isAllowed = isAllowedResource(uri, true, inlinerContext.inline);
    var originalUri = uri;
    var isLoaded = uri in inlinerContext.externalContext.sourcesContent;
    var isRuntimeResource = !hasProtocol(uri);
    if (inlinerContext.inlinedStylesheets.indexOf(uri) > -1) {
      inlinerContext.warnings.push('Ignoring remote @import of "' + uri + '" as it has already been imported.');
      inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
      return doInlineImports(inlinerContext);
    } else if (inlinerContext.localOnly && inlinerContext.afterContent) {
      inlinerContext.warnings.push('Ignoring remote @import of "' + uri + '" as no callback given and after other content.');
      inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
      return doInlineImports(inlinerContext);
    } else if (isRuntimeResource) {
      inlinerContext.warnings.push('Skipping remote @import of "' + uri + '" as no protocol given.');
      inlinerContext.outputTokens = inlinerContext.outputTokens.concat(inlinerContext.sourceTokens.slice(0, 1));
      inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
      return doInlineImports(inlinerContext);
    } else if (inlinerContext.localOnly && !isLoaded) {
      inlinerContext.warnings.push('Skipping remote @import of "' + uri + '" as no callback given.');
      inlinerContext.outputTokens = inlinerContext.outputTokens.concat(inlinerContext.sourceTokens.slice(0, 1));
      inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
      return doInlineImports(inlinerContext);
    } else if (!isAllowed && inlinerContext.afterContent) {
      inlinerContext.warnings.push('Ignoring remote @import of "' + uri + '" as resource is not allowed and after other content.');
      inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
      return doInlineImports(inlinerContext);
    } else if (!isAllowed) {
      inlinerContext.warnings.push('Skipping remote @import of "' + uri + '" as resource is not allowed.');
      inlinerContext.outputTokens = inlinerContext.outputTokens.concat(inlinerContext.sourceTokens.slice(0, 1));
      inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
      return doInlineImports(inlinerContext);
    }
    inlinerContext.inlinedStylesheets.push(uri);
    function whenLoaded(error, importedStyles) {
      if (error) {
        inlinerContext.errors.push('Broken @import declaration of "' + uri + '" - ' + error);
        return process.nextTick(function () {
          inlinerContext.outputTokens = inlinerContext.outputTokens.concat(inlinerContext.sourceTokens.slice(0, 1));
          inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
          doInlineImports(inlinerContext);
        });
      }
      inlinerContext.inline = inlinerContext.externalContext.options.inline;
      inlinerContext.isRemote = true;
      inlinerContext.externalContext.source = originalUri;
      inlinerContext.externalContext.sourcesContent[uri] = importedStyles;
      inlinerContext.externalContext.stats.originalSize += importedStyles.length;
      return fromStyles(importedStyles, inlinerContext.externalContext, inlinerContext, function (importedTokens) {
        importedTokens = wrapInMedia(importedTokens, mediaQuery, metadata);
        inlinerContext.outputTokens = inlinerContext.outputTokens.concat(importedTokens);
        inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
        return doInlineImports(inlinerContext);
      });
    }
    return isLoaded ? whenLoaded(null, inlinerContext.externalContext.sourcesContent[uri]) : inlinerContext.fetch(uri, inlinerContext.inlineRequest, inlinerContext.inlineTimeout, whenLoaded);
  }
  function inlineLocalStylesheet(uri, mediaQuery, metadata, inlinerContext) {
    var currentPath = path.resolve('');
    var absoluteUri = path.isAbsolute(uri) ? path.resolve(currentPath, uri[0] == '/' ? uri.substring(1) : uri) : path.resolve(inlinerContext.rebaseTo, uri);
    var relativeToCurrentPath = path.relative(currentPath, absoluteUri);
    var importedStyles;
    var isAllowed = isAllowedResource(uri, false, inlinerContext.inline);
    var normalizedPath = normalizePath(relativeToCurrentPath);
    var isLoaded = normalizedPath in inlinerContext.externalContext.sourcesContent;
    if (inlinerContext.inlinedStylesheets.indexOf(absoluteUri) > -1) {
      inlinerContext.warnings.push('Ignoring local @import of "' + uri + '" as it has already been imported.');
    } else if (!isLoaded && (!fs.existsSync(absoluteUri) || !fs.statSync(absoluteUri).isFile())) {
      inlinerContext.errors.push('Ignoring local @import of "' + uri + '" as resource is missing.');
    } else if (!isAllowed && inlinerContext.afterContent) {
      inlinerContext.warnings.push('Ignoring local @import of "' + uri + '" as resource is not allowed and after other content.');
    } else if (inlinerContext.afterContent) {
      inlinerContext.warnings.push('Ignoring local @import of "' + uri + '" as after other content.');
    } else if (!isAllowed) {
      inlinerContext.warnings.push('Skipping local @import of "' + uri + '" as resource is not allowed.');
      inlinerContext.outputTokens = inlinerContext.outputTokens.concat(inlinerContext.sourceTokens.slice(0, 1));
    } else {
      importedStyles = isLoaded ? inlinerContext.externalContext.sourcesContent[normalizedPath] : fs.readFileSync(absoluteUri, 'utf-8');
      inlinerContext.inlinedStylesheets.push(absoluteUri);
      inlinerContext.inline = inlinerContext.externalContext.options.inline;
      inlinerContext.externalContext.source = normalizedPath;
      inlinerContext.externalContext.sourcesContent[normalizedPath] = importedStyles;
      inlinerContext.externalContext.stats.originalSize += importedStyles.length;
      return fromStyles(importedStyles, inlinerContext.externalContext, inlinerContext, function (importedTokens) {
        importedTokens = wrapInMedia(importedTokens, mediaQuery, metadata);
        inlinerContext.outputTokens = inlinerContext.outputTokens.concat(importedTokens);
        inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
        return doInlineImports(inlinerContext);
      });
    }
    inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);
    return doInlineImports(inlinerContext);
  }
  function wrapInMedia(tokens, mediaQuery, metadata) {
    if (mediaQuery) {
      return [[Token.NESTED_BLOCK, [[Token.NESTED_BLOCK_SCOPE, '@media ' + mediaQuery, metadata]], tokens]];
    } else {
      return tokens;
    }
  }
  readSources_1 = readSources;
  return readSources_1;
}

var simple;
var hasRequiredSimple;
function requireSimple() {
  if (hasRequiredSimple) return simple;
  hasRequiredSimple = 1;
  var all = requireHelpers().all;
  function store(serializeContext, token) {
    var value = typeof token == 'string' ? token : token[1];
    var wrap = serializeContext.wrap;
    wrap(serializeContext, value);
    track(serializeContext, value);
    serializeContext.output.push(value);
  }
  function wrap(serializeContext, value) {
    if (serializeContext.column + value.length > serializeContext.format.wrapAt) {
      track(serializeContext, serializeContext.format.breakWith);
      serializeContext.output.push(serializeContext.format.breakWith);
    }
  }
  function track(serializeContext, value) {
    var parts = value.split('\n');
    serializeContext.line += parts.length - 1;
    serializeContext.column = parts.length > 1 ? 0 : serializeContext.column + parts.pop().length;
  }
  function serializeStyles(tokens, context) {
    var serializeContext = {
      column: 0,
      format: context.options.format,
      indentBy: 0,
      indentWith: '',
      line: 1,
      output: [],
      spaceAfterClosingBrace: context.options.compatibility.properties.spaceAfterClosingBrace,
      store: store,
      wrap: context.options.format.wrapAt ? wrap : function () {/* noop */}
    };
    all(serializeContext, tokens);
    return {
      styles: serializeContext.output.join('')
    };
  }
  simple = serializeStyles;
  return simple;
}

var sourceMaps;
var hasRequiredSourceMaps;
function requireSourceMaps() {
  if (hasRequiredSourceMaps) return sourceMaps;
  hasRequiredSourceMaps = 1;
  var SourceMapGenerator = requireSourceMap().SourceMapGenerator;
  var all = requireHelpers().all;
  var isRemoteResource = requireIsRemoteResource();
  var isWindows = process.platform == 'win32';
  var NIX_SEPARATOR_PATTERN = /\//g;
  var UNKNOWN_SOURCE = '$stdin';
  var WINDOWS_SEPARATOR = '\\';
  function store(serializeContext, element) {
    var fromString = typeof element == 'string';
    var value = fromString ? element : element[1];
    var mappings = fromString ? null : element[2];
    var wrap = serializeContext.wrap;
    wrap(serializeContext, value);
    track(serializeContext, value, mappings);
    serializeContext.output.push(value);
  }
  function wrap(serializeContext, value) {
    if (serializeContext.column + value.length > serializeContext.format.wrapAt) {
      track(serializeContext, serializeContext.format.breakWith, false);
      serializeContext.output.push(serializeContext.format.breakWith);
    }
  }
  function track(serializeContext, value, mappings) {
    var parts = value.split('\n');
    if (mappings) {
      trackAllMappings(serializeContext, mappings);
    }
    serializeContext.line += parts.length - 1;
    serializeContext.column = parts.length > 1 ? 0 : serializeContext.column + parts.pop().length;
  }
  function trackAllMappings(serializeContext, mappings) {
    for (var i = 0, l = mappings.length; i < l; i++) {
      trackMapping(serializeContext, mappings[i]);
    }
  }
  function trackMapping(serializeContext, mapping) {
    var line = mapping[0];
    var column = mapping[1];
    var originalSource = mapping[2];
    var source = originalSource;
    var storedSource = source || UNKNOWN_SOURCE;
    if (isWindows && source && !isRemoteResource(source)) {
      storedSource = source.replace(NIX_SEPARATOR_PATTERN, WINDOWS_SEPARATOR);
    }
    serializeContext.outputMap.addMapping({
      generated: {
        line: serializeContext.line,
        column: serializeContext.column
      },
      source: storedSource,
      original: {
        line: line,
        column: column
      }
    });
    if (serializeContext.inlineSources && originalSource in serializeContext.sourcesContent) {
      serializeContext.outputMap.setSourceContent(storedSource, serializeContext.sourcesContent[originalSource]);
    }
  }
  function serializeStylesAndSourceMap(tokens, context) {
    var serializeContext = {
      column: 0,
      format: context.options.format,
      indentBy: 0,
      indentWith: '',
      inlineSources: context.options.sourceMapInlineSources,
      line: 1,
      output: [],
      outputMap: new SourceMapGenerator(),
      sourcesContent: context.sourcesContent,
      spaceAfterClosingBrace: context.options.compatibility.properties.spaceAfterClosingBrace,
      store: store,
      wrap: context.options.format.wrapAt ? wrap : function () {/* noop */}
    };
    all(serializeContext, tokens);
    return {
      sourceMap: serializeContext.outputMap,
      styles: serializeContext.output.join('')
    };
  }
  sourceMaps = serializeStylesAndSourceMap;
  return sourceMaps;
}

/**
 * Clean-css - https://github.com/jakubpawlowicz/clean-css
 * Released under the terms of MIT license
 *
 * Copyright (C) 2017 JakubPawlowicz.com
 */
var hasRequiredClean;
function requireClean() {
  if (hasRequiredClean) return clean.exports;
  hasRequiredClean = 1;
  var level0Optimize = requireOptimize$3();
  var level1Optimize = requireOptimize$2();
  var level2Optimize = requireOptimize();
  var validator = requireValidator();
  var compatibilityFrom = requireCompatibility();
  var fetchFrom = requireFetch();
  var formatFrom = requireFormat$1().formatFrom;
  var inlineFrom = requireInline();
  var inlineRequestFrom = requireInlineRequest();
  var inlineTimeoutFrom = requireInlineTimeout();
  var OptimizationLevel = requireOptimizationLevel().OptimizationLevel;
  var optimizationLevelFrom = requireOptimizationLevel().optimizationLevelFrom;
  var rebaseFrom = requireRebase$1();
  var rebaseToFrom = requireRebaseTo();
  var inputSourceMapTracker = requireInputSourceMapTracker();
  var readSources = requireReadSources();
  var serializeStyles = requireSimple();
  var serializeStylesAndSourceMap = requireSourceMaps();
  var CleanCSS = clean.exports = function CleanCSS(options) {
    options = options || {};
    this.options = {
      compatibility: compatibilityFrom(options.compatibility),
      fetch: fetchFrom(options.fetch),
      format: formatFrom(options.format),
      inline: inlineFrom(options.inline),
      inlineRequest: inlineRequestFrom(options.inlineRequest),
      inlineTimeout: inlineTimeoutFrom(options.inlineTimeout),
      level: optimizationLevelFrom(options.level),
      rebase: rebaseFrom(options.rebase),
      rebaseTo: rebaseToFrom(options.rebaseTo),
      returnPromise: !!options.returnPromise,
      sourceMap: !!options.sourceMap,
      sourceMapInlineSources: !!options.sourceMapInlineSources
    };
  };

  // for compatibility with optimize-css-assets-webpack-plugin
  CleanCSS.process = function (input, opts) {
    var cleanCss;
    var optsTo = opts.to;
    delete opts.to;
    cleanCss = new CleanCSS(Object.assign({
      returnPromise: true,
      rebaseTo: optsTo
    }, opts));
    return cleanCss.minify(input).then(function (output) {
      return {
        css: output.styles
      };
    });
  };
  CleanCSS.prototype.minify = function (input, maybeSourceMap, maybeCallback) {
    var options = this.options;
    if (options.returnPromise) {
      return new Promise(function (resolve, reject) {
        minify(input, options, maybeSourceMap, function (errors, output) {
          return errors ? reject(errors) : resolve(output);
        });
      });
    } else {
      return minify(input, options, maybeSourceMap, maybeCallback);
    }
  };
  function minify(input, options, maybeSourceMap, maybeCallback) {
    var sourceMap = typeof maybeSourceMap != 'function' ? maybeSourceMap : null;
    var callback = typeof maybeCallback == 'function' ? maybeCallback : typeof maybeSourceMap == 'function' ? maybeSourceMap : null;
    var context = {
      stats: {
        efficiency: 0,
        minifiedSize: 0,
        originalSize: 0,
        startedAt: Date.now(),
        timeSpent: 0
      },
      cache: {
        specificity: {}
      },
      errors: [],
      inlinedStylesheets: [],
      inputSourceMapTracker: inputSourceMapTracker(),
      localOnly: !callback,
      options: options,
      source: null,
      sourcesContent: {},
      validator: validator(options.compatibility),
      warnings: []
    };
    if (sourceMap) {
      context.inputSourceMapTracker.track(undefined, sourceMap);
    }
    return runner(context.localOnly)(function () {
      return readSources(input, context, function (tokens) {
        var serialize = context.options.sourceMap ? serializeStylesAndSourceMap : serializeStyles;
        var optimizedTokens = optimize(tokens, context);
        var optimizedStyles = serialize(optimizedTokens, context);
        var output = withMetadata(optimizedStyles, context);
        return callback ? callback(context.errors.length > 0 ? context.errors : null, output) : output;
      });
    });
  }
  function runner(localOnly) {
    // to always execute code asynchronously when a callback is given
    // more at blog.izs.me/post/59142742143/designing-apis-for-asynchrony
    return localOnly ? function (callback) {
      return callback();
    } : process.nextTick;
  }
  function optimize(tokens, context) {
    var optimized;
    optimized = level0Optimize(tokens, context);
    optimized = OptimizationLevel.One in context.options.level ? level1Optimize(tokens, context) : tokens;
    optimized = OptimizationLevel.Two in context.options.level ? level2Optimize(tokens, context, true) : optimized;
    return optimized;
  }
  function withMetadata(output, context) {
    output.stats = calculateStatsFrom(output.styles, context);
    output.errors = context.errors;
    output.inlinedStylesheets = context.inlinedStylesheets;
    output.warnings = context.warnings;
    return output;
  }
  function calculateStatsFrom(styles, context) {
    var finishedAt = Date.now();
    var timeSpent = finishedAt - context.stats.startedAt;
    delete context.stats.startedAt;
    context.stats.timeSpent = timeSpent;
    context.stats.efficiency = 1 - styles.length / context.stats.originalSize;
    context.stats.minifiedSize = styles.length;
    return context.stats;
  }
  return clean.exports;
}

var cleanCss;
var hasRequiredCleanCss;
function requireCleanCss() {
  if (hasRequiredCleanCss) return cleanCss;
  hasRequiredCleanCss = 1;
  cleanCss = requireClean();
  return cleanCss;
}

var he$1 = {exports: {}};

/*! https://mths.be/he v1.2.0 by @mathias | MIT license */
var he = he$1.exports;
var hasRequiredHe;
function requireHe() {
  if (hasRequiredHe) return he$1.exports;
  hasRequiredHe = 1;
  (function (module, exports) {
    (function (root) {
      // Detect free variables `exports`.
      var freeExports = exports;

      // Detect free variable `module`.
      var freeModule = module && module.exports == freeExports && module;

      // Detect free variable `global`, from Node.js or Browserified code,
      // and use it as `root`.
      var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
        root = freeGlobal;
      }

      /*--------------------------------------------------------------------------*/

      // All astral symbols.
      var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
      // All ASCII symbols (not just printable ASCII) except those listed in the
      // first column of the overrides table.
      // https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides
      var regexAsciiWhitelist = /[\x01-\x7F]/g;
      // All BMP symbols that are not ASCII newlines, printable ASCII symbols, or
      // code points listed in the first column of the overrides table on
      // https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides.
      var regexBmpWhitelist = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;
      var regexEncodeNonAscii = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g;
      var encodeMap = {
        '\xAD': 'shy',
        '\u200C': 'zwnj',
        '\u200D': 'zwj',
        '\u200E': 'lrm',
        '\u2063': 'ic',
        '\u2062': 'it',
        '\u2061': 'af',
        '\u200F': 'rlm',
        '\u200B': 'ZeroWidthSpace',
        '\u2060': 'NoBreak',
        '\u0311': 'DownBreve',
        '\u20DB': 'tdot',
        '\u20DC': 'DotDot',
        '\t': 'Tab',
        '\n': 'NewLine',
        '\u2008': 'puncsp',
        '\u205F': 'MediumSpace',
        '\u2009': 'thinsp',
        '\u200A': 'hairsp',
        '\u2004': 'emsp13',
        '\u2002': 'ensp',
        '\u2005': 'emsp14',
        '\u2003': 'emsp',
        '\u2007': 'numsp',
        '\xA0': 'nbsp',
        '\u205F\u200A': 'ThickSpace',
        '\u203E': 'oline',
        '_': 'lowbar',
        '\u2010': 'dash',
        '\u2013': 'ndash',
        '\u2014': 'mdash',
        '\u2015': 'horbar',
        ',': 'comma',
        ';': 'semi',
        '\u204F': 'bsemi',
        ':': 'colon',
        '\u2A74': 'Colone',
        '!': 'excl',
        '\xA1': 'iexcl',
        '?': 'quest',
        '\xBF': 'iquest',
        '.': 'period',
        '\u2025': 'nldr',
        '\u2026': 'mldr',
        '\xB7': 'middot',
        '\'': 'apos',
        '\u2018': 'lsquo',
        '\u2019': 'rsquo',
        '\u201A': 'sbquo',
        '\u2039': 'lsaquo',
        '\u203A': 'rsaquo',
        '"': 'quot',
        '\u201C': 'ldquo',
        '\u201D': 'rdquo',
        '\u201E': 'bdquo',
        '\xAB': 'laquo',
        '\xBB': 'raquo',
        '(': 'lpar',
        ')': 'rpar',
        '[': 'lsqb',
        ']': 'rsqb',
        '{': 'lcub',
        '}': 'rcub',
        '\u2308': 'lceil',
        '\u2309': 'rceil',
        '\u230A': 'lfloor',
        '\u230B': 'rfloor',
        '\u2985': 'lopar',
        '\u2986': 'ropar',
        '\u298B': 'lbrke',
        '\u298C': 'rbrke',
        '\u298D': 'lbrkslu',
        '\u298E': 'rbrksld',
        '\u298F': 'lbrksld',
        '\u2990': 'rbrkslu',
        '\u2991': 'langd',
        '\u2992': 'rangd',
        '\u2993': 'lparlt',
        '\u2994': 'rpargt',
        '\u2995': 'gtlPar',
        '\u2996': 'ltrPar',
        '\u27E6': 'lobrk',
        '\u27E7': 'robrk',
        '\u27E8': 'lang',
        '\u27E9': 'rang',
        '\u27EA': 'Lang',
        '\u27EB': 'Rang',
        '\u27EC': 'loang',
        '\u27ED': 'roang',
        '\u2772': 'lbbrk',
        '\u2773': 'rbbrk',
        '\u2016': 'Vert',
        '\xA7': 'sect',
        '\xB6': 'para',
        '@': 'commat',
        '*': 'ast',
        '/': 'sol',
        'undefined': null,
        '&': 'amp',
        '#': 'num',
        '%': 'percnt',
        '\u2030': 'permil',
        '\u2031': 'pertenk',
        '\u2020': 'dagger',
        '\u2021': 'Dagger',
        '\u2022': 'bull',
        '\u2043': 'hybull',
        '\u2032': 'prime',
        '\u2033': 'Prime',
        '\u2034': 'tprime',
        '\u2057': 'qprime',
        '\u2035': 'bprime',
        '\u2041': 'caret',
        '`': 'grave',
        '\xB4': 'acute',
        '\u02DC': 'tilde',
        '^': 'Hat',
        '\xAF': 'macr',
        '\u02D8': 'breve',
        '\u02D9': 'dot',
        '\xA8': 'die',
        '\u02DA': 'ring',
        '\u02DD': 'dblac',
        '\xB8': 'cedil',
        '\u02DB': 'ogon',
        '\u02C6': 'circ',
        '\u02C7': 'caron',
        '\xB0': 'deg',
        '\xA9': 'copy',
        '\xAE': 'reg',
        '\u2117': 'copysr',
        '\u2118': 'wp',
        '\u211E': 'rx',
        '\u2127': 'mho',
        '\u2129': 'iiota',
        '\u2190': 'larr',
        '\u219A': 'nlarr',
        '\u2192': 'rarr',
        '\u219B': 'nrarr',
        '\u2191': 'uarr',
        '\u2193': 'darr',
        '\u2194': 'harr',
        '\u21AE': 'nharr',
        '\u2195': 'varr',
        '\u2196': 'nwarr',
        '\u2197': 'nearr',
        '\u2198': 'searr',
        '\u2199': 'swarr',
        '\u219D': 'rarrw',
        '\u219D\u0338': 'nrarrw',
        '\u219E': 'Larr',
        '\u219F': 'Uarr',
        '\u21A0': 'Rarr',
        '\u21A1': 'Darr',
        '\u21A2': 'larrtl',
        '\u21A3': 'rarrtl',
        '\u21A4': 'mapstoleft',
        '\u21A5': 'mapstoup',
        '\u21A6': 'map',
        '\u21A7': 'mapstodown',
        '\u21A9': 'larrhk',
        '\u21AA': 'rarrhk',
        '\u21AB': 'larrlp',
        '\u21AC': 'rarrlp',
        '\u21AD': 'harrw',
        '\u21B0': 'lsh',
        '\u21B1': 'rsh',
        '\u21B2': 'ldsh',
        '\u21B3': 'rdsh',
        '\u21B5': 'crarr',
        '\u21B6': 'cularr',
        '\u21B7': 'curarr',
        '\u21BA': 'olarr',
        '\u21BB': 'orarr',
        '\u21BC': 'lharu',
        '\u21BD': 'lhard',
        '\u21BE': 'uharr',
        '\u21BF': 'uharl',
        '\u21C0': 'rharu',
        '\u21C1': 'rhard',
        '\u21C2': 'dharr',
        '\u21C3': 'dharl',
        '\u21C4': 'rlarr',
        '\u21C5': 'udarr',
        '\u21C6': 'lrarr',
        '\u21C7': 'llarr',
        '\u21C8': 'uuarr',
        '\u21C9': 'rrarr',
        '\u21CA': 'ddarr',
        '\u21CB': 'lrhar',
        '\u21CC': 'rlhar',
        '\u21D0': 'lArr',
        '\u21CD': 'nlArr',
        '\u21D1': 'uArr',
        '\u21D2': 'rArr',
        '\u21CF': 'nrArr',
        '\u21D3': 'dArr',
        '\u21D4': 'iff',
        '\u21CE': 'nhArr',
        '\u21D5': 'vArr',
        '\u21D6': 'nwArr',
        '\u21D7': 'neArr',
        '\u21D8': 'seArr',
        '\u21D9': 'swArr',
        '\u21DA': 'lAarr',
        '\u21DB': 'rAarr',
        '\u21DD': 'zigrarr',
        '\u21E4': 'larrb',
        '\u21E5': 'rarrb',
        '\u21F5': 'duarr',
        '\u21FD': 'loarr',
        '\u21FE': 'roarr',
        '\u21FF': 'hoarr',
        '\u2200': 'forall',
        '\u2201': 'comp',
        '\u2202': 'part',
        '\u2202\u0338': 'npart',
        '\u2203': 'exist',
        '\u2204': 'nexist',
        '\u2205': 'empty',
        '\u2207': 'Del',
        '\u2208': 'in',
        '\u2209': 'notin',
        '\u220B': 'ni',
        '\u220C': 'notni',
        '\u03F6': 'bepsi',
        '\u220F': 'prod',
        '\u2210': 'coprod',
        '\u2211': 'sum',
        '+': 'plus',
        '\xB1': 'pm',
        '\xF7': 'div',
        '\xD7': 'times',
        '<': 'lt',
        '\u226E': 'nlt',
        '<\u20D2': 'nvlt',
        '=': 'equals',
        '\u2260': 'ne',
        '=\u20E5': 'bne',
        '\u2A75': 'Equal',
        '>': 'gt',
        '\u226F': 'ngt',
        '>\u20D2': 'nvgt',
        '\xAC': 'not',
        '|': 'vert',
        '\xA6': 'brvbar',
        '\u2212': 'minus',
        '\u2213': 'mp',
        '\u2214': 'plusdo',
        '\u2044': 'frasl',
        '\u2216': 'setmn',
        '\u2217': 'lowast',
        '\u2218': 'compfn',
        '\u221A': 'Sqrt',
        '\u221D': 'prop',
        '\u221E': 'infin',
        '\u221F': 'angrt',
        '\u2220': 'ang',
        '\u2220\u20D2': 'nang',
        '\u2221': 'angmsd',
        '\u2222': 'angsph',
        '\u2223': 'mid',
        '\u2224': 'nmid',
        '\u2225': 'par',
        '\u2226': 'npar',
        '\u2227': 'and',
        '\u2228': 'or',
        '\u2229': 'cap',
        '\u2229\uFE00': 'caps',
        '\u222A': 'cup',
        '\u222A\uFE00': 'cups',
        '\u222B': 'int',
        '\u222C': 'Int',
        '\u222D': 'tint',
        '\u2A0C': 'qint',
        '\u222E': 'oint',
        '\u222F': 'Conint',
        '\u2230': 'Cconint',
        '\u2231': 'cwint',
        '\u2232': 'cwconint',
        '\u2233': 'awconint',
        '\u2234': 'there4',
        '\u2235': 'becaus',
        '\u2236': 'ratio',
        '\u2237': 'Colon',
        '\u2238': 'minusd',
        '\u223A': 'mDDot',
        '\u223B': 'homtht',
        '\u223C': 'sim',
        '\u2241': 'nsim',
        '\u223C\u20D2': 'nvsim',
        '\u223D': 'bsim',
        '\u223D\u0331': 'race',
        '\u223E': 'ac',
        '\u223E\u0333': 'acE',
        '\u223F': 'acd',
        '\u2240': 'wr',
        '\u2242': 'esim',
        '\u2242\u0338': 'nesim',
        '\u2243': 'sime',
        '\u2244': 'nsime',
        '\u2245': 'cong',
        '\u2247': 'ncong',
        '\u2246': 'simne',
        '\u2248': 'ap',
        '\u2249': 'nap',
        '\u224A': 'ape',
        '\u224B': 'apid',
        '\u224B\u0338': 'napid',
        '\u224C': 'bcong',
        '\u224D': 'CupCap',
        '\u226D': 'NotCupCap',
        '\u224D\u20D2': 'nvap',
        '\u224E': 'bump',
        '\u224E\u0338': 'nbump',
        '\u224F': 'bumpe',
        '\u224F\u0338': 'nbumpe',
        '\u2250': 'doteq',
        '\u2250\u0338': 'nedot',
        '\u2251': 'eDot',
        '\u2252': 'efDot',
        '\u2253': 'erDot',
        '\u2254': 'colone',
        '\u2255': 'ecolon',
        '\u2256': 'ecir',
        '\u2257': 'cire',
        '\u2259': 'wedgeq',
        '\u225A': 'veeeq',
        '\u225C': 'trie',
        '\u225F': 'equest',
        '\u2261': 'equiv',
        '\u2262': 'nequiv',
        '\u2261\u20E5': 'bnequiv',
        '\u2264': 'le',
        '\u2270': 'nle',
        '\u2264\u20D2': 'nvle',
        '\u2265': 'ge',
        '\u2271': 'nge',
        '\u2265\u20D2': 'nvge',
        '\u2266': 'lE',
        '\u2266\u0338': 'nlE',
        '\u2267': 'gE',
        '\u2267\u0338': 'ngE',
        '\u2268\uFE00': 'lvnE',
        '\u2268': 'lnE',
        '\u2269': 'gnE',
        '\u2269\uFE00': 'gvnE',
        '\u226A': 'll',
        '\u226A\u0338': 'nLtv',
        '\u226A\u20D2': 'nLt',
        '\u226B': 'gg',
        '\u226B\u0338': 'nGtv',
        '\u226B\u20D2': 'nGt',
        '\u226C': 'twixt',
        '\u2272': 'lsim',
        '\u2274': 'nlsim',
        '\u2273': 'gsim',
        '\u2275': 'ngsim',
        '\u2276': 'lg',
        '\u2278': 'ntlg',
        '\u2277': 'gl',
        '\u2279': 'ntgl',
        '\u227A': 'pr',
        '\u2280': 'npr',
        '\u227B': 'sc',
        '\u2281': 'nsc',
        '\u227C': 'prcue',
        '\u22E0': 'nprcue',
        '\u227D': 'sccue',
        '\u22E1': 'nsccue',
        '\u227E': 'prsim',
        '\u227F': 'scsim',
        '\u227F\u0338': 'NotSucceedsTilde',
        '\u2282': 'sub',
        '\u2284': 'nsub',
        '\u2282\u20D2': 'vnsub',
        '\u2283': 'sup',
        '\u2285': 'nsup',
        '\u2283\u20D2': 'vnsup',
        '\u2286': 'sube',
        '\u2288': 'nsube',
        '\u2287': 'supe',
        '\u2289': 'nsupe',
        '\u228A\uFE00': 'vsubne',
        '\u228A': 'subne',
        '\u228B\uFE00': 'vsupne',
        '\u228B': 'supne',
        '\u228D': 'cupdot',
        '\u228E': 'uplus',
        '\u228F': 'sqsub',
        '\u228F\u0338': 'NotSquareSubset',
        '\u2290': 'sqsup',
        '\u2290\u0338': 'NotSquareSuperset',
        '\u2291': 'sqsube',
        '\u22E2': 'nsqsube',
        '\u2292': 'sqsupe',
        '\u22E3': 'nsqsupe',
        '\u2293': 'sqcap',
        '\u2293\uFE00': 'sqcaps',
        '\u2294': 'sqcup',
        '\u2294\uFE00': 'sqcups',
        '\u2295': 'oplus',
        '\u2296': 'ominus',
        '\u2297': 'otimes',
        '\u2298': 'osol',
        '\u2299': 'odot',
        '\u229A': 'ocir',
        '\u229B': 'oast',
        '\u229D': 'odash',
        '\u229E': 'plusb',
        '\u229F': 'minusb',
        '\u22A0': 'timesb',
        '\u22A1': 'sdotb',
        '\u22A2': 'vdash',
        '\u22AC': 'nvdash',
        '\u22A3': 'dashv',
        '\u22A4': 'top',
        '\u22A5': 'bot',
        '\u22A7': 'models',
        '\u22A8': 'vDash',
        '\u22AD': 'nvDash',
        '\u22A9': 'Vdash',
        '\u22AE': 'nVdash',
        '\u22AA': 'Vvdash',
        '\u22AB': 'VDash',
        '\u22AF': 'nVDash',
        '\u22B0': 'prurel',
        '\u22B2': 'vltri',
        '\u22EA': 'nltri',
        '\u22B3': 'vrtri',
        '\u22EB': 'nrtri',
        '\u22B4': 'ltrie',
        '\u22EC': 'nltrie',
        '\u22B4\u20D2': 'nvltrie',
        '\u22B5': 'rtrie',
        '\u22ED': 'nrtrie',
        '\u22B5\u20D2': 'nvrtrie',
        '\u22B6': 'origof',
        '\u22B7': 'imof',
        '\u22B8': 'mumap',
        '\u22B9': 'hercon',
        '\u22BA': 'intcal',
        '\u22BB': 'veebar',
        '\u22BD': 'barvee',
        '\u22BE': 'angrtvb',
        '\u22BF': 'lrtri',
        '\u22C0': 'Wedge',
        '\u22C1': 'Vee',
        '\u22C2': 'xcap',
        '\u22C3': 'xcup',
        '\u22C4': 'diam',
        '\u22C5': 'sdot',
        '\u22C6': 'Star',
        '\u22C7': 'divonx',
        '\u22C8': 'bowtie',
        '\u22C9': 'ltimes',
        '\u22CA': 'rtimes',
        '\u22CB': 'lthree',
        '\u22CC': 'rthree',
        '\u22CD': 'bsime',
        '\u22CE': 'cuvee',
        '\u22CF': 'cuwed',
        '\u22D0': 'Sub',
        '\u22D1': 'Sup',
        '\u22D2': 'Cap',
        '\u22D3': 'Cup',
        '\u22D4': 'fork',
        '\u22D5': 'epar',
        '\u22D6': 'ltdot',
        '\u22D7': 'gtdot',
        '\u22D8': 'Ll',
        '\u22D8\u0338': 'nLl',
        '\u22D9': 'Gg',
        '\u22D9\u0338': 'nGg',
        '\u22DA\uFE00': 'lesg',
        '\u22DA': 'leg',
        '\u22DB': 'gel',
        '\u22DB\uFE00': 'gesl',
        '\u22DE': 'cuepr',
        '\u22DF': 'cuesc',
        '\u22E6': 'lnsim',
        '\u22E7': 'gnsim',
        '\u22E8': 'prnsim',
        '\u22E9': 'scnsim',
        '\u22EE': 'vellip',
        '\u22EF': 'ctdot',
        '\u22F0': 'utdot',
        '\u22F1': 'dtdot',
        '\u22F2': 'disin',
        '\u22F3': 'isinsv',
        '\u22F4': 'isins',
        '\u22F5': 'isindot',
        '\u22F5\u0338': 'notindot',
        '\u22F6': 'notinvc',
        '\u22F7': 'notinvb',
        '\u22F9': 'isinE',
        '\u22F9\u0338': 'notinE',
        '\u22FA': 'nisd',
        '\u22FB': 'xnis',
        '\u22FC': 'nis',
        '\u22FD': 'notnivc',
        '\u22FE': 'notnivb',
        '\u2305': 'barwed',
        '\u2306': 'Barwed',
        '\u230C': 'drcrop',
        '\u230D': 'dlcrop',
        '\u230E': 'urcrop',
        '\u230F': 'ulcrop',
        '\u2310': 'bnot',
        '\u2312': 'profline',
        '\u2313': 'profsurf',
        '\u2315': 'telrec',
        '\u2316': 'target',
        '\u231C': 'ulcorn',
        '\u231D': 'urcorn',
        '\u231E': 'dlcorn',
        '\u231F': 'drcorn',
        '\u2322': 'frown',
        '\u2323': 'smile',
        '\u232D': 'cylcty',
        '\u232E': 'profalar',
        '\u2336': 'topbot',
        '\u233D': 'ovbar',
        '\u233F': 'solbar',
        '\u237C': 'angzarr',
        '\u23B0': 'lmoust',
        '\u23B1': 'rmoust',
        '\u23B4': 'tbrk',
        '\u23B5': 'bbrk',
        '\u23B6': 'bbrktbrk',
        '\u23DC': 'OverParenthesis',
        '\u23DD': 'UnderParenthesis',
        '\u23DE': 'OverBrace',
        '\u23DF': 'UnderBrace',
        '\u23E2': 'trpezium',
        '\u23E7': 'elinters',
        '\u2423': 'blank',
        '\u2500': 'boxh',
        '\u2502': 'boxv',
        '\u250C': 'boxdr',
        '\u2510': 'boxdl',
        '\u2514': 'boxur',
        '\u2518': 'boxul',
        '\u251C': 'boxvr',
        '\u2524': 'boxvl',
        '\u252C': 'boxhd',
        '\u2534': 'boxhu',
        '\u253C': 'boxvh',
        '\u2550': 'boxH',
        '\u2551': 'boxV',
        '\u2552': 'boxdR',
        '\u2553': 'boxDr',
        '\u2554': 'boxDR',
        '\u2555': 'boxdL',
        '\u2556': 'boxDl',
        '\u2557': 'boxDL',
        '\u2558': 'boxuR',
        '\u2559': 'boxUr',
        '\u255A': 'boxUR',
        '\u255B': 'boxuL',
        '\u255C': 'boxUl',
        '\u255D': 'boxUL',
        '\u255E': 'boxvR',
        '\u255F': 'boxVr',
        '\u2560': 'boxVR',
        '\u2561': 'boxvL',
        '\u2562': 'boxVl',
        '\u2563': 'boxVL',
        '\u2564': 'boxHd',
        '\u2565': 'boxhD',
        '\u2566': 'boxHD',
        '\u2567': 'boxHu',
        '\u2568': 'boxhU',
        '\u2569': 'boxHU',
        '\u256A': 'boxvH',
        '\u256B': 'boxVh',
        '\u256C': 'boxVH',
        '\u2580': 'uhblk',
        '\u2584': 'lhblk',
        '\u2588': 'block',
        '\u2591': 'blk14',
        '\u2592': 'blk12',
        '\u2593': 'blk34',
        '\u25A1': 'squ',
        '\u25AA': 'squf',
        '\u25AB': 'EmptyVerySmallSquare',
        '\u25AD': 'rect',
        '\u25AE': 'marker',
        '\u25B1': 'fltns',
        '\u25B3': 'xutri',
        '\u25B4': 'utrif',
        '\u25B5': 'utri',
        '\u25B8': 'rtrif',
        '\u25B9': 'rtri',
        '\u25BD': 'xdtri',
        '\u25BE': 'dtrif',
        '\u25BF': 'dtri',
        '\u25C2': 'ltrif',
        '\u25C3': 'ltri',
        '\u25CA': 'loz',
        '\u25CB': 'cir',
        '\u25EC': 'tridot',
        '\u25EF': 'xcirc',
        '\u25F8': 'ultri',
        '\u25F9': 'urtri',
        '\u25FA': 'lltri',
        '\u25FB': 'EmptySmallSquare',
        '\u25FC': 'FilledSmallSquare',
        '\u2605': 'starf',
        '\u2606': 'star',
        '\u260E': 'phone',
        '\u2640': 'female',
        '\u2642': 'male',
        '\u2660': 'spades',
        '\u2663': 'clubs',
        '\u2665': 'hearts',
        '\u2666': 'diams',
        '\u266A': 'sung',
        '\u2713': 'check',
        '\u2717': 'cross',
        '\u2720': 'malt',
        '\u2736': 'sext',
        '\u2758': 'VerticalSeparator',
        '\u27C8': 'bsolhsub',
        '\u27C9': 'suphsol',
        '\u27F5': 'xlarr',
        '\u27F6': 'xrarr',
        '\u27F7': 'xharr',
        '\u27F8': 'xlArr',
        '\u27F9': 'xrArr',
        '\u27FA': 'xhArr',
        '\u27FC': 'xmap',
        '\u27FF': 'dzigrarr',
        '\u2902': 'nvlArr',
        '\u2903': 'nvrArr',
        '\u2904': 'nvHarr',
        '\u2905': 'Map',
        '\u290C': 'lbarr',
        '\u290D': 'rbarr',
        '\u290E': 'lBarr',
        '\u290F': 'rBarr',
        '\u2910': 'RBarr',
        '\u2911': 'DDotrahd',
        '\u2912': 'UpArrowBar',
        '\u2913': 'DownArrowBar',
        '\u2916': 'Rarrtl',
        '\u2919': 'latail',
        '\u291A': 'ratail',
        '\u291B': 'lAtail',
        '\u291C': 'rAtail',
        '\u291D': 'larrfs',
        '\u291E': 'rarrfs',
        '\u291F': 'larrbfs',
        '\u2920': 'rarrbfs',
        '\u2923': 'nwarhk',
        '\u2924': 'nearhk',
        '\u2925': 'searhk',
        '\u2926': 'swarhk',
        '\u2927': 'nwnear',
        '\u2928': 'toea',
        '\u2929': 'tosa',
        '\u292A': 'swnwar',
        '\u2933': 'rarrc',
        '\u2933\u0338': 'nrarrc',
        '\u2935': 'cudarrr',
        '\u2936': 'ldca',
        '\u2937': 'rdca',
        '\u2938': 'cudarrl',
        '\u2939': 'larrpl',
        '\u293C': 'curarrm',
        '\u293D': 'cularrp',
        '\u2945': 'rarrpl',
        '\u2948': 'harrcir',
        '\u2949': 'Uarrocir',
        '\u294A': 'lurdshar',
        '\u294B': 'ldrushar',
        '\u294E': 'LeftRightVector',
        '\u294F': 'RightUpDownVector',
        '\u2950': 'DownLeftRightVector',
        '\u2951': 'LeftUpDownVector',
        '\u2952': 'LeftVectorBar',
        '\u2953': 'RightVectorBar',
        '\u2954': 'RightUpVectorBar',
        '\u2955': 'RightDownVectorBar',
        '\u2956': 'DownLeftVectorBar',
        '\u2957': 'DownRightVectorBar',
        '\u2958': 'LeftUpVectorBar',
        '\u2959': 'LeftDownVectorBar',
        '\u295A': 'LeftTeeVector',
        '\u295B': 'RightTeeVector',
        '\u295C': 'RightUpTeeVector',
        '\u295D': 'RightDownTeeVector',
        '\u295E': 'DownLeftTeeVector',
        '\u295F': 'DownRightTeeVector',
        '\u2960': 'LeftUpTeeVector',
        '\u2961': 'LeftDownTeeVector',
        '\u2962': 'lHar',
        '\u2963': 'uHar',
        '\u2964': 'rHar',
        '\u2965': 'dHar',
        '\u2966': 'luruhar',
        '\u2967': 'ldrdhar',
        '\u2968': 'ruluhar',
        '\u2969': 'rdldhar',
        '\u296A': 'lharul',
        '\u296B': 'llhard',
        '\u296C': 'rharul',
        '\u296D': 'lrhard',
        '\u296E': 'udhar',
        '\u296F': 'duhar',
        '\u2970': 'RoundImplies',
        '\u2971': 'erarr',
        '\u2972': 'simrarr',
        '\u2973': 'larrsim',
        '\u2974': 'rarrsim',
        '\u2975': 'rarrap',
        '\u2976': 'ltlarr',
        '\u2978': 'gtrarr',
        '\u2979': 'subrarr',
        '\u297B': 'suplarr',
        '\u297C': 'lfisht',
        '\u297D': 'rfisht',
        '\u297E': 'ufisht',
        '\u297F': 'dfisht',
        '\u299A': 'vzigzag',
        '\u299C': 'vangrt',
        '\u299D': 'angrtvbd',
        '\u29A4': 'ange',
        '\u29A5': 'range',
        '\u29A6': 'dwangle',
        '\u29A7': 'uwangle',
        '\u29A8': 'angmsdaa',
        '\u29A9': 'angmsdab',
        '\u29AA': 'angmsdac',
        '\u29AB': 'angmsdad',
        '\u29AC': 'angmsdae',
        '\u29AD': 'angmsdaf',
        '\u29AE': 'angmsdag',
        '\u29AF': 'angmsdah',
        '\u29B0': 'bemptyv',
        '\u29B1': 'demptyv',
        '\u29B2': 'cemptyv',
        '\u29B3': 'raemptyv',
        '\u29B4': 'laemptyv',
        '\u29B5': 'ohbar',
        '\u29B6': 'omid',
        '\u29B7': 'opar',
        '\u29B9': 'operp',
        '\u29BB': 'olcross',
        '\u29BC': 'odsold',
        '\u29BE': 'olcir',
        '\u29BF': 'ofcir',
        '\u29C0': 'olt',
        '\u29C1': 'ogt',
        '\u29C2': 'cirscir',
        '\u29C3': 'cirE',
        '\u29C4': 'solb',
        '\u29C5': 'bsolb',
        '\u29C9': 'boxbox',
        '\u29CD': 'trisb',
        '\u29CE': 'rtriltri',
        '\u29CF': 'LeftTriangleBar',
        '\u29CF\u0338': 'NotLeftTriangleBar',
        '\u29D0': 'RightTriangleBar',
        '\u29D0\u0338': 'NotRightTriangleBar',
        '\u29DC': 'iinfin',
        '\u29DD': 'infintie',
        '\u29DE': 'nvinfin',
        '\u29E3': 'eparsl',
        '\u29E4': 'smeparsl',
        '\u29E5': 'eqvparsl',
        '\u29EB': 'lozf',
        '\u29F4': 'RuleDelayed',
        '\u29F6': 'dsol',
        '\u2A00': 'xodot',
        '\u2A01': 'xoplus',
        '\u2A02': 'xotime',
        '\u2A04': 'xuplus',
        '\u2A06': 'xsqcup',
        '\u2A0D': 'fpartint',
        '\u2A10': 'cirfnint',
        '\u2A11': 'awint',
        '\u2A12': 'rppolint',
        '\u2A13': 'scpolint',
        '\u2A14': 'npolint',
        '\u2A15': 'pointint',
        '\u2A16': 'quatint',
        '\u2A17': 'intlarhk',
        '\u2A22': 'pluscir',
        '\u2A23': 'plusacir',
        '\u2A24': 'simplus',
        '\u2A25': 'plusdu',
        '\u2A26': 'plussim',
        '\u2A27': 'plustwo',
        '\u2A29': 'mcomma',
        '\u2A2A': 'minusdu',
        '\u2A2D': 'loplus',
        '\u2A2E': 'roplus',
        '\u2A2F': 'Cross',
        '\u2A30': 'timesd',
        '\u2A31': 'timesbar',
        '\u2A33': 'smashp',
        '\u2A34': 'lotimes',
        '\u2A35': 'rotimes',
        '\u2A36': 'otimesas',
        '\u2A37': 'Otimes',
        '\u2A38': 'odiv',
        '\u2A39': 'triplus',
        '\u2A3A': 'triminus',
        '\u2A3B': 'tritime',
        '\u2A3C': 'iprod',
        '\u2A3F': 'amalg',
        '\u2A40': 'capdot',
        '\u2A42': 'ncup',
        '\u2A43': 'ncap',
        '\u2A44': 'capand',
        '\u2A45': 'cupor',
        '\u2A46': 'cupcap',
        '\u2A47': 'capcup',
        '\u2A48': 'cupbrcap',
        '\u2A49': 'capbrcup',
        '\u2A4A': 'cupcup',
        '\u2A4B': 'capcap',
        '\u2A4C': 'ccups',
        '\u2A4D': 'ccaps',
        '\u2A50': 'ccupssm',
        '\u2A53': 'And',
        '\u2A54': 'Or',
        '\u2A55': 'andand',
        '\u2A56': 'oror',
        '\u2A57': 'orslope',
        '\u2A58': 'andslope',
        '\u2A5A': 'andv',
        '\u2A5B': 'orv',
        '\u2A5C': 'andd',
        '\u2A5D': 'ord',
        '\u2A5F': 'wedbar',
        '\u2A66': 'sdote',
        '\u2A6A': 'simdot',
        '\u2A6D': 'congdot',
        '\u2A6D\u0338': 'ncongdot',
        '\u2A6E': 'easter',
        '\u2A6F': 'apacir',
        '\u2A70': 'apE',
        '\u2A70\u0338': 'napE',
        '\u2A71': 'eplus',
        '\u2A72': 'pluse',
        '\u2A73': 'Esim',
        '\u2A77': 'eDDot',
        '\u2A78': 'equivDD',
        '\u2A79': 'ltcir',
        '\u2A7A': 'gtcir',
        '\u2A7B': 'ltquest',
        '\u2A7C': 'gtquest',
        '\u2A7D': 'les',
        '\u2A7D\u0338': 'nles',
        '\u2A7E': 'ges',
        '\u2A7E\u0338': 'nges',
        '\u2A7F': 'lesdot',
        '\u2A80': 'gesdot',
        '\u2A81': 'lesdoto',
        '\u2A82': 'gesdoto',
        '\u2A83': 'lesdotor',
        '\u2A84': 'gesdotol',
        '\u2A85': 'lap',
        '\u2A86': 'gap',
        '\u2A87': 'lne',
        '\u2A88': 'gne',
        '\u2A89': 'lnap',
        '\u2A8A': 'gnap',
        '\u2A8B': 'lEg',
        '\u2A8C': 'gEl',
        '\u2A8D': 'lsime',
        '\u2A8E': 'gsime',
        '\u2A8F': 'lsimg',
        '\u2A90': 'gsiml',
        '\u2A91': 'lgE',
        '\u2A92': 'glE',
        '\u2A93': 'lesges',
        '\u2A94': 'gesles',
        '\u2A95': 'els',
        '\u2A96': 'egs',
        '\u2A97': 'elsdot',
        '\u2A98': 'egsdot',
        '\u2A99': 'el',
        '\u2A9A': 'eg',
        '\u2A9D': 'siml',
        '\u2A9E': 'simg',
        '\u2A9F': 'simlE',
        '\u2AA0': 'simgE',
        '\u2AA1': 'LessLess',
        '\u2AA1\u0338': 'NotNestedLessLess',
        '\u2AA2': 'GreaterGreater',
        '\u2AA2\u0338': 'NotNestedGreaterGreater',
        '\u2AA4': 'glj',
        '\u2AA5': 'gla',
        '\u2AA6': 'ltcc',
        '\u2AA7': 'gtcc',
        '\u2AA8': 'lescc',
        '\u2AA9': 'gescc',
        '\u2AAA': 'smt',
        '\u2AAB': 'lat',
        '\u2AAC': 'smte',
        '\u2AAC\uFE00': 'smtes',
        '\u2AAD': 'late',
        '\u2AAD\uFE00': 'lates',
        '\u2AAE': 'bumpE',
        '\u2AAF': 'pre',
        '\u2AAF\u0338': 'npre',
        '\u2AB0': 'sce',
        '\u2AB0\u0338': 'nsce',
        '\u2AB3': 'prE',
        '\u2AB4': 'scE',
        '\u2AB5': 'prnE',
        '\u2AB6': 'scnE',
        '\u2AB7': 'prap',
        '\u2AB8': 'scap',
        '\u2AB9': 'prnap',
        '\u2ABA': 'scnap',
        '\u2ABB': 'Pr',
        '\u2ABC': 'Sc',
        '\u2ABD': 'subdot',
        '\u2ABE': 'supdot',
        '\u2ABF': 'subplus',
        '\u2AC0': 'supplus',
        '\u2AC1': 'submult',
        '\u2AC2': 'supmult',
        '\u2AC3': 'subedot',
        '\u2AC4': 'supedot',
        '\u2AC5': 'subE',
        '\u2AC5\u0338': 'nsubE',
        '\u2AC6': 'supE',
        '\u2AC6\u0338': 'nsupE',
        '\u2AC7': 'subsim',
        '\u2AC8': 'supsim',
        '\u2ACB\uFE00': 'vsubnE',
        '\u2ACB': 'subnE',
        '\u2ACC\uFE00': 'vsupnE',
        '\u2ACC': 'supnE',
        '\u2ACF': 'csub',
        '\u2AD0': 'csup',
        '\u2AD1': 'csube',
        '\u2AD2': 'csupe',
        '\u2AD3': 'subsup',
        '\u2AD4': 'supsub',
        '\u2AD5': 'subsub',
        '\u2AD6': 'supsup',
        '\u2AD7': 'suphsub',
        '\u2AD8': 'supdsub',
        '\u2AD9': 'forkv',
        '\u2ADA': 'topfork',
        '\u2ADB': 'mlcp',
        '\u2AE4': 'Dashv',
        '\u2AE6': 'Vdashl',
        '\u2AE7': 'Barv',
        '\u2AE8': 'vBar',
        '\u2AE9': 'vBarv',
        '\u2AEB': 'Vbar',
        '\u2AEC': 'Not',
        '\u2AED': 'bNot',
        '\u2AEE': 'rnmid',
        '\u2AEF': 'cirmid',
        '\u2AF0': 'midcir',
        '\u2AF1': 'topcir',
        '\u2AF2': 'nhpar',
        '\u2AF3': 'parsim',
        '\u2AFD': 'parsl',
        '\u2AFD\u20E5': 'nparsl',
        '\u266D': 'flat',
        '\u266E': 'natur',
        '\u266F': 'sharp',
        '\xA4': 'curren',
        '\xA2': 'cent',
        '$': 'dollar',
        '\xA3': 'pound',
        '\xA5': 'yen',
        '\u20AC': 'euro',
        '\xB9': 'sup1',
        '\xBD': 'half',
        '\u2153': 'frac13',
        '\xBC': 'frac14',
        '\u2155': 'frac15',
        '\u2159': 'frac16',
        '\u215B': 'frac18',
        '\xB2': 'sup2',
        '\u2154': 'frac23',
        '\u2156': 'frac25',
        '\xB3': 'sup3',
        '\xBE': 'frac34',
        '\u2157': 'frac35',
        '\u215C': 'frac38',
        '\u2158': 'frac45',
        '\u215A': 'frac56',
        '\u215D': 'frac58',
        '\u215E': 'frac78',
        '\uD835\uDCB6': 'ascr',
        '\uD835\uDD52': 'aopf',
        '\uD835\uDD1E': 'afr',
        '\uD835\uDD38': 'Aopf',
        '\uD835\uDD04': 'Afr',
        '\uD835\uDC9C': 'Ascr',
        '\xAA': 'ordf',
        '\xE1': 'aacute',
        '\xC1': 'Aacute',
        '\xE0': 'agrave',
        '\xC0': 'Agrave',
        '\u0103': 'abreve',
        '\u0102': 'Abreve',
        '\xE2': 'acirc',
        '\xC2': 'Acirc',
        '\xE5': 'aring',
        '\xC5': 'angst',
        '\xE4': 'auml',
        '\xC4': 'Auml',
        '\xE3': 'atilde',
        '\xC3': 'Atilde',
        '\u0105': 'aogon',
        '\u0104': 'Aogon',
        '\u0101': 'amacr',
        '\u0100': 'Amacr',
        '\xE6': 'aelig',
        '\xC6': 'AElig',
        '\uD835\uDCB7': 'bscr',
        '\uD835\uDD53': 'bopf',
        '\uD835\uDD1F': 'bfr',
        '\uD835\uDD39': 'Bopf',
        '\u212C': 'Bscr',
        '\uD835\uDD05': 'Bfr',
        '\uD835\uDD20': 'cfr',
        '\uD835\uDCB8': 'cscr',
        '\uD835\uDD54': 'copf',
        '\u212D': 'Cfr',
        '\uD835\uDC9E': 'Cscr',
        '\u2102': 'Copf',
        '\u0107': 'cacute',
        '\u0106': 'Cacute',
        '\u0109': 'ccirc',
        '\u0108': 'Ccirc',
        '\u010D': 'ccaron',
        '\u010C': 'Ccaron',
        '\u010B': 'cdot',
        '\u010A': 'Cdot',
        '\xE7': 'ccedil',
        '\xC7': 'Ccedil',
        '\u2105': 'incare',
        '\uD835\uDD21': 'dfr',
        '\u2146': 'dd',
        '\uD835\uDD55': 'dopf',
        '\uD835\uDCB9': 'dscr',
        '\uD835\uDC9F': 'Dscr',
        '\uD835\uDD07': 'Dfr',
        '\u2145': 'DD',
        '\uD835\uDD3B': 'Dopf',
        '\u010F': 'dcaron',
        '\u010E': 'Dcaron',
        '\u0111': 'dstrok',
        '\u0110': 'Dstrok',
        '\xF0': 'eth',
        '\xD0': 'ETH',
        '\u2147': 'ee',
        '\u212F': 'escr',
        '\uD835\uDD22': 'efr',
        '\uD835\uDD56': 'eopf',
        '\u2130': 'Escr',
        '\uD835\uDD08': 'Efr',
        '\uD835\uDD3C': 'Eopf',
        '\xE9': 'eacute',
        '\xC9': 'Eacute',
        '\xE8': 'egrave',
        '\xC8': 'Egrave',
        '\xEA': 'ecirc',
        '\xCA': 'Ecirc',
        '\u011B': 'ecaron',
        '\u011A': 'Ecaron',
        '\xEB': 'euml',
        '\xCB': 'Euml',
        '\u0117': 'edot',
        '\u0116': 'Edot',
        '\u0119': 'eogon',
        '\u0118': 'Eogon',
        '\u0113': 'emacr',
        '\u0112': 'Emacr',
        '\uD835\uDD23': 'ffr',
        '\uD835\uDD57': 'fopf',
        '\uD835\uDCBB': 'fscr',
        '\uD835\uDD09': 'Ffr',
        '\uD835\uDD3D': 'Fopf',
        '\u2131': 'Fscr',
        '\uFB00': 'fflig',
        '\uFB03': 'ffilig',
        '\uFB04': 'ffllig',
        '\uFB01': 'filig',
        'fj': 'fjlig',
        '\uFB02': 'fllig',
        '\u0192': 'fnof',
        '\u210A': 'gscr',
        '\uD835\uDD58': 'gopf',
        '\uD835\uDD24': 'gfr',
        '\uD835\uDCA2': 'Gscr',
        '\uD835\uDD3E': 'Gopf',
        '\uD835\uDD0A': 'Gfr',
        '\u01F5': 'gacute',
        '\u011F': 'gbreve',
        '\u011E': 'Gbreve',
        '\u011D': 'gcirc',
        '\u011C': 'Gcirc',
        '\u0121': 'gdot',
        '\u0120': 'Gdot',
        '\u0122': 'Gcedil',
        '\uD835\uDD25': 'hfr',
        '\u210E': 'planckh',
        '\uD835\uDCBD': 'hscr',
        '\uD835\uDD59': 'hopf',
        '\u210B': 'Hscr',
        '\u210C': 'Hfr',
        '\u210D': 'Hopf',
        '\u0125': 'hcirc',
        '\u0124': 'Hcirc',
        '\u210F': 'hbar',
        '\u0127': 'hstrok',
        '\u0126': 'Hstrok',
        '\uD835\uDD5A': 'iopf',
        '\uD835\uDD26': 'ifr',
        '\uD835\uDCBE': 'iscr',
        '\u2148': 'ii',
        '\uD835\uDD40': 'Iopf',
        '\u2110': 'Iscr',
        '\u2111': 'Im',
        '\xED': 'iacute',
        '\xCD': 'Iacute',
        '\xEC': 'igrave',
        '\xCC': 'Igrave',
        '\xEE': 'icirc',
        '\xCE': 'Icirc',
        '\xEF': 'iuml',
        '\xCF': 'Iuml',
        '\u0129': 'itilde',
        '\u0128': 'Itilde',
        '\u0130': 'Idot',
        '\u012F': 'iogon',
        '\u012E': 'Iogon',
        '\u012B': 'imacr',
        '\u012A': 'Imacr',
        '\u0133': 'ijlig',
        '\u0132': 'IJlig',
        '\u0131': 'imath',
        '\uD835\uDCBF': 'jscr',
        '\uD835\uDD5B': 'jopf',
        '\uD835\uDD27': 'jfr',
        '\uD835\uDCA5': 'Jscr',
        '\uD835\uDD0D': 'Jfr',
        '\uD835\uDD41': 'Jopf',
        '\u0135': 'jcirc',
        '\u0134': 'Jcirc',
        '\u0237': 'jmath',
        '\uD835\uDD5C': 'kopf',
        '\uD835\uDCC0': 'kscr',
        '\uD835\uDD28': 'kfr',
        '\uD835\uDCA6': 'Kscr',
        '\uD835\uDD42': 'Kopf',
        '\uD835\uDD0E': 'Kfr',
        '\u0137': 'kcedil',
        '\u0136': 'Kcedil',
        '\uD835\uDD29': 'lfr',
        '\uD835\uDCC1': 'lscr',
        '\u2113': 'ell',
        '\uD835\uDD5D': 'lopf',
        '\u2112': 'Lscr',
        '\uD835\uDD0F': 'Lfr',
        '\uD835\uDD43': 'Lopf',
        '\u013A': 'lacute',
        '\u0139': 'Lacute',
        '\u013E': 'lcaron',
        '\u013D': 'Lcaron',
        '\u013C': 'lcedil',
        '\u013B': 'Lcedil',
        '\u0142': 'lstrok',
        '\u0141': 'Lstrok',
        '\u0140': 'lmidot',
        '\u013F': 'Lmidot',
        '\uD835\uDD2A': 'mfr',
        '\uD835\uDD5E': 'mopf',
        '\uD835\uDCC2': 'mscr',
        '\uD835\uDD10': 'Mfr',
        '\uD835\uDD44': 'Mopf',
        '\u2133': 'Mscr',
        '\uD835\uDD2B': 'nfr',
        '\uD835\uDD5F': 'nopf',
        '\uD835\uDCC3': 'nscr',
        '\u2115': 'Nopf',
        '\uD835\uDCA9': 'Nscr',
        '\uD835\uDD11': 'Nfr',
        '\u0144': 'nacute',
        '\u0143': 'Nacute',
        '\u0148': 'ncaron',
        '\u0147': 'Ncaron',
        '\xF1': 'ntilde',
        '\xD1': 'Ntilde',
        '\u0146': 'ncedil',
        '\u0145': 'Ncedil',
        '\u2116': 'numero',
        '\u014B': 'eng',
        '\u014A': 'ENG',
        '\uD835\uDD60': 'oopf',
        '\uD835\uDD2C': 'ofr',
        '\u2134': 'oscr',
        '\uD835\uDCAA': 'Oscr',
        '\uD835\uDD12': 'Ofr',
        '\uD835\uDD46': 'Oopf',
        '\xBA': 'ordm',
        '\xF3': 'oacute',
        '\xD3': 'Oacute',
        '\xF2': 'ograve',
        '\xD2': 'Ograve',
        '\xF4': 'ocirc',
        '\xD4': 'Ocirc',
        '\xF6': 'ouml',
        '\xD6': 'Ouml',
        '\u0151': 'odblac',
        '\u0150': 'Odblac',
        '\xF5': 'otilde',
        '\xD5': 'Otilde',
        '\xF8': 'oslash',
        '\xD8': 'Oslash',
        '\u014D': 'omacr',
        '\u014C': 'Omacr',
        '\u0153': 'oelig',
        '\u0152': 'OElig',
        '\uD835\uDD2D': 'pfr',
        '\uD835\uDCC5': 'pscr',
        '\uD835\uDD61': 'popf',
        '\u2119': 'Popf',
        '\uD835\uDD13': 'Pfr',
        '\uD835\uDCAB': 'Pscr',
        '\uD835\uDD62': 'qopf',
        '\uD835\uDD2E': 'qfr',
        '\uD835\uDCC6': 'qscr',
        '\uD835\uDCAC': 'Qscr',
        '\uD835\uDD14': 'Qfr',
        '\u211A': 'Qopf',
        '\u0138': 'kgreen',
        '\uD835\uDD2F': 'rfr',
        '\uD835\uDD63': 'ropf',
        '\uD835\uDCC7': 'rscr',
        '\u211B': 'Rscr',
        '\u211C': 'Re',
        '\u211D': 'Ropf',
        '\u0155': 'racute',
        '\u0154': 'Racute',
        '\u0159': 'rcaron',
        '\u0158': 'Rcaron',
        '\u0157': 'rcedil',
        '\u0156': 'Rcedil',
        '\uD835\uDD64': 'sopf',
        '\uD835\uDCC8': 'sscr',
        '\uD835\uDD30': 'sfr',
        '\uD835\uDD4A': 'Sopf',
        '\uD835\uDD16': 'Sfr',
        '\uD835\uDCAE': 'Sscr',
        '\u24C8': 'oS',
        '\u015B': 'sacute',
        '\u015A': 'Sacute',
        '\u015D': 'scirc',
        '\u015C': 'Scirc',
        '\u0161': 'scaron',
        '\u0160': 'Scaron',
        '\u015F': 'scedil',
        '\u015E': 'Scedil',
        '\xDF': 'szlig',
        '\uD835\uDD31': 'tfr',
        '\uD835\uDCC9': 'tscr',
        '\uD835\uDD65': 'topf',
        '\uD835\uDCAF': 'Tscr',
        '\uD835\uDD17': 'Tfr',
        '\uD835\uDD4B': 'Topf',
        '\u0165': 'tcaron',
        '\u0164': 'Tcaron',
        '\u0163': 'tcedil',
        '\u0162': 'Tcedil',
        '\u2122': 'trade',
        '\u0167': 'tstrok',
        '\u0166': 'Tstrok',
        '\uD835\uDCCA': 'uscr',
        '\uD835\uDD66': 'uopf',
        '\uD835\uDD32': 'ufr',
        '\uD835\uDD4C': 'Uopf',
        '\uD835\uDD18': 'Ufr',
        '\uD835\uDCB0': 'Uscr',
        '\xFA': 'uacute',
        '\xDA': 'Uacute',
        '\xF9': 'ugrave',
        '\xD9': 'Ugrave',
        '\u016D': 'ubreve',
        '\u016C': 'Ubreve',
        '\xFB': 'ucirc',
        '\xDB': 'Ucirc',
        '\u016F': 'uring',
        '\u016E': 'Uring',
        '\xFC': 'uuml',
        '\xDC': 'Uuml',
        '\u0171': 'udblac',
        '\u0170': 'Udblac',
        '\u0169': 'utilde',
        '\u0168': 'Utilde',
        '\u0173': 'uogon',
        '\u0172': 'Uogon',
        '\u016B': 'umacr',
        '\u016A': 'Umacr',
        '\uD835\uDD33': 'vfr',
        '\uD835\uDD67': 'vopf',
        '\uD835\uDCCB': 'vscr',
        '\uD835\uDD19': 'Vfr',
        '\uD835\uDD4D': 'Vopf',
        '\uD835\uDCB1': 'Vscr',
        '\uD835\uDD68': 'wopf',
        '\uD835\uDCCC': 'wscr',
        '\uD835\uDD34': 'wfr',
        '\uD835\uDCB2': 'Wscr',
        '\uD835\uDD4E': 'Wopf',
        '\uD835\uDD1A': 'Wfr',
        '\u0175': 'wcirc',
        '\u0174': 'Wcirc',
        '\uD835\uDD35': 'xfr',
        '\uD835\uDCCD': 'xscr',
        '\uD835\uDD69': 'xopf',
        '\uD835\uDD4F': 'Xopf',
        '\uD835\uDD1B': 'Xfr',
        '\uD835\uDCB3': 'Xscr',
        '\uD835\uDD36': 'yfr',
        '\uD835\uDCCE': 'yscr',
        '\uD835\uDD6A': 'yopf',
        '\uD835\uDCB4': 'Yscr',
        '\uD835\uDD1C': 'Yfr',
        '\uD835\uDD50': 'Yopf',
        '\xFD': 'yacute',
        '\xDD': 'Yacute',
        '\u0177': 'ycirc',
        '\u0176': 'Ycirc',
        '\xFF': 'yuml',
        '\u0178': 'Yuml',
        '\uD835\uDCCF': 'zscr',
        '\uD835\uDD37': 'zfr',
        '\uD835\uDD6B': 'zopf',
        '\u2128': 'Zfr',
        '\u2124': 'Zopf',
        '\uD835\uDCB5': 'Zscr',
        '\u017A': 'zacute',
        '\u0179': 'Zacute',
        '\u017E': 'zcaron',
        '\u017D': 'Zcaron',
        '\u017C': 'zdot',
        '\u017B': 'Zdot',
        '\u01B5': 'imped',
        '\xFE': 'thorn',
        '\xDE': 'THORN',
        '\u0149': 'napos',
        '\u03B1': 'alpha',
        '\u0391': 'Alpha',
        '\u03B2': 'beta',
        '\u0392': 'Beta',
        '\u03B3': 'gamma',
        '\u0393': 'Gamma',
        '\u03B4': 'delta',
        '\u0394': 'Delta',
        '\u03B5': 'epsi',
        '\u03F5': 'epsiv',
        '\u0395': 'Epsilon',
        '\u03DD': 'gammad',
        '\u03DC': 'Gammad',
        '\u03B6': 'zeta',
        '\u0396': 'Zeta',
        '\u03B7': 'eta',
        '\u0397': 'Eta',
        '\u03B8': 'theta',
        '\u03D1': 'thetav',
        '\u0398': 'Theta',
        '\u03B9': 'iota',
        '\u0399': 'Iota',
        '\u03BA': 'kappa',
        '\u03F0': 'kappav',
        '\u039A': 'Kappa',
        '\u03BB': 'lambda',
        '\u039B': 'Lambda',
        '\u03BC': 'mu',
        '\xB5': 'micro',
        '\u039C': 'Mu',
        '\u03BD': 'nu',
        '\u039D': 'Nu',
        '\u03BE': 'xi',
        '\u039E': 'Xi',
        '\u03BF': 'omicron',
        '\u039F': 'Omicron',
        '\u03C0': 'pi',
        '\u03D6': 'piv',
        '\u03A0': 'Pi',
        '\u03C1': 'rho',
        '\u03F1': 'rhov',
        '\u03A1': 'Rho',
        '\u03C3': 'sigma',
        '\u03A3': 'Sigma',
        '\u03C2': 'sigmaf',
        '\u03C4': 'tau',
        '\u03A4': 'Tau',
        '\u03C5': 'upsi',
        '\u03A5': 'Upsilon',
        '\u03D2': 'Upsi',
        '\u03C6': 'phi',
        '\u03D5': 'phiv',
        '\u03A6': 'Phi',
        '\u03C7': 'chi',
        '\u03A7': 'Chi',
        '\u03C8': 'psi',
        '\u03A8': 'Psi',
        '\u03C9': 'omega',
        '\u03A9': 'ohm',
        '\u0430': 'acy',
        '\u0410': 'Acy',
        '\u0431': 'bcy',
        '\u0411': 'Bcy',
        '\u0432': 'vcy',
        '\u0412': 'Vcy',
        '\u0433': 'gcy',
        '\u0413': 'Gcy',
        '\u0453': 'gjcy',
        '\u0403': 'GJcy',
        '\u0434': 'dcy',
        '\u0414': 'Dcy',
        '\u0452': 'djcy',
        '\u0402': 'DJcy',
        '\u0435': 'iecy',
        '\u0415': 'IEcy',
        '\u0451': 'iocy',
        '\u0401': 'IOcy',
        '\u0454': 'jukcy',
        '\u0404': 'Jukcy',
        '\u0436': 'zhcy',
        '\u0416': 'ZHcy',
        '\u0437': 'zcy',
        '\u0417': 'Zcy',
        '\u0455': 'dscy',
        '\u0405': 'DScy',
        '\u0438': 'icy',
        '\u0418': 'Icy',
        '\u0456': 'iukcy',
        '\u0406': 'Iukcy',
        '\u0457': 'yicy',
        '\u0407': 'YIcy',
        '\u0439': 'jcy',
        '\u0419': 'Jcy',
        '\u0458': 'jsercy',
        '\u0408': 'Jsercy',
        '\u043A': 'kcy',
        '\u041A': 'Kcy',
        '\u045C': 'kjcy',
        '\u040C': 'KJcy',
        '\u043B': 'lcy',
        '\u041B': 'Lcy',
        '\u0459': 'ljcy',
        '\u0409': 'LJcy',
        '\u043C': 'mcy',
        '\u041C': 'Mcy',
        '\u043D': 'ncy',
        '\u041D': 'Ncy',
        '\u045A': 'njcy',
        '\u040A': 'NJcy',
        '\u043E': 'ocy',
        '\u041E': 'Ocy',
        '\u043F': 'pcy',
        '\u041F': 'Pcy',
        '\u0440': 'rcy',
        '\u0420': 'Rcy',
        '\u0441': 'scy',
        '\u0421': 'Scy',
        '\u0442': 'tcy',
        '\u0422': 'Tcy',
        '\u045B': 'tshcy',
        '\u040B': 'TSHcy',
        '\u0443': 'ucy',
        '\u0423': 'Ucy',
        '\u045E': 'ubrcy',
        '\u040E': 'Ubrcy',
        '\u0444': 'fcy',
        '\u0424': 'Fcy',
        '\u0445': 'khcy',
        '\u0425': 'KHcy',
        '\u0446': 'tscy',
        '\u0426': 'TScy',
        '\u0447': 'chcy',
        '\u0427': 'CHcy',
        '\u045F': 'dzcy',
        '\u040F': 'DZcy',
        '\u0448': 'shcy',
        '\u0428': 'SHcy',
        '\u0449': 'shchcy',
        '\u0429': 'SHCHcy',
        '\u044A': 'hardcy',
        '\u042A': 'HARDcy',
        '\u044B': 'ycy',
        '\u042B': 'Ycy',
        '\u044C': 'softcy',
        '\u042C': 'SOFTcy',
        '\u044D': 'ecy',
        '\u042D': 'Ecy',
        '\u044E': 'yucy',
        '\u042E': 'YUcy',
        '\u044F': 'yacy',
        '\u042F': 'YAcy',
        '\u2135': 'aleph',
        '\u2136': 'beth',
        '\u2137': 'gimel',
        '\u2138': 'daleth'
      };
      var regexEscape = /["&'<>`]/g;
      var escapeMap = {
        '"': '&quot;',
        '&': '&amp;',
        '\'': '&#x27;',
        '<': '&lt;',
        // See https://mathiasbynens.be/notes/ambiguous-ampersands: in HTML, the
        // following is not strictly necessary unless its part of a tag or an
        // unquoted attribute value. Were only escaping it to support those
        // situations, and for XML support.
        '>': '&gt;',
        // In Internet Explorer  8, the backtick character can be used
        // to break out of (un)quoted attribute values or HTML comments.
        // See http://html5sec.org/#102, http://html5sec.org/#108, and
        // http://html5sec.org/#133.
        '`': '&#x60;'
      };
      var regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;
      var regexInvalidRawCodePoint = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
      var regexDecode = /&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g;
      var decodeMap = {
        'aacute': '\xE1',
        'Aacute': '\xC1',
        'abreve': '\u0103',
        'Abreve': '\u0102',
        'ac': '\u223E',
        'acd': '\u223F',
        'acE': '\u223E\u0333',
        'acirc': '\xE2',
        'Acirc': '\xC2',
        'acute': '\xB4',
        'acy': '\u0430',
        'Acy': '\u0410',
        'aelig': '\xE6',
        'AElig': '\xC6',
        'af': '\u2061',
        'afr': '\uD835\uDD1E',
        'Afr': '\uD835\uDD04',
        'agrave': '\xE0',
        'Agrave': '\xC0',
        'alefsym': '\u2135',
        'aleph': '\u2135',
        'alpha': '\u03B1',
        'Alpha': '\u0391',
        'amacr': '\u0101',
        'Amacr': '\u0100',
        'amalg': '\u2A3F',
        'amp': '&',
        'AMP': '&',
        'and': '\u2227',
        'And': '\u2A53',
        'andand': '\u2A55',
        'andd': '\u2A5C',
        'andslope': '\u2A58',
        'andv': '\u2A5A',
        'ang': '\u2220',
        'ange': '\u29A4',
        'angle': '\u2220',
        'angmsd': '\u2221',
        'angmsdaa': '\u29A8',
        'angmsdab': '\u29A9',
        'angmsdac': '\u29AA',
        'angmsdad': '\u29AB',
        'angmsdae': '\u29AC',
        'angmsdaf': '\u29AD',
        'angmsdag': '\u29AE',
        'angmsdah': '\u29AF',
        'angrt': '\u221F',
        'angrtvb': '\u22BE',
        'angrtvbd': '\u299D',
        'angsph': '\u2222',
        'angst': '\xC5',
        'angzarr': '\u237C',
        'aogon': '\u0105',
        'Aogon': '\u0104',
        'aopf': '\uD835\uDD52',
        'Aopf': '\uD835\uDD38',
        'ap': '\u2248',
        'apacir': '\u2A6F',
        'ape': '\u224A',
        'apE': '\u2A70',
        'apid': '\u224B',
        'apos': '\'',
        'ApplyFunction': '\u2061',
        'approx': '\u2248',
        'approxeq': '\u224A',
        'aring': '\xE5',
        'Aring': '\xC5',
        'ascr': '\uD835\uDCB6',
        'Ascr': '\uD835\uDC9C',
        'Assign': '\u2254',
        'ast': '*',
        'asymp': '\u2248',
        'asympeq': '\u224D',
        'atilde': '\xE3',
        'Atilde': '\xC3',
        'auml': '\xE4',
        'Auml': '\xC4',
        'awconint': '\u2233',
        'awint': '\u2A11',
        'backcong': '\u224C',
        'backepsilon': '\u03F6',
        'backprime': '\u2035',
        'backsim': '\u223D',
        'backsimeq': '\u22CD',
        'Backslash': '\u2216',
        'Barv': '\u2AE7',
        'barvee': '\u22BD',
        'barwed': '\u2305',
        'Barwed': '\u2306',
        'barwedge': '\u2305',
        'bbrk': '\u23B5',
        'bbrktbrk': '\u23B6',
        'bcong': '\u224C',
        'bcy': '\u0431',
        'Bcy': '\u0411',
        'bdquo': '\u201E',
        'becaus': '\u2235',
        'because': '\u2235',
        'Because': '\u2235',
        'bemptyv': '\u29B0',
        'bepsi': '\u03F6',
        'bernou': '\u212C',
        'Bernoullis': '\u212C',
        'beta': '\u03B2',
        'Beta': '\u0392',
        'beth': '\u2136',
        'between': '\u226C',
        'bfr': '\uD835\uDD1F',
        'Bfr': '\uD835\uDD05',
        'bigcap': '\u22C2',
        'bigcirc': '\u25EF',
        'bigcup': '\u22C3',
        'bigodot': '\u2A00',
        'bigoplus': '\u2A01',
        'bigotimes': '\u2A02',
        'bigsqcup': '\u2A06',
        'bigstar': '\u2605',
        'bigtriangledown': '\u25BD',
        'bigtriangleup': '\u25B3',
        'biguplus': '\u2A04',
        'bigvee': '\u22C1',
        'bigwedge': '\u22C0',
        'bkarow': '\u290D',
        'blacklozenge': '\u29EB',
        'blacksquare': '\u25AA',
        'blacktriangle': '\u25B4',
        'blacktriangledown': '\u25BE',
        'blacktriangleleft': '\u25C2',
        'blacktriangleright': '\u25B8',
        'blank': '\u2423',
        'blk12': '\u2592',
        'blk14': '\u2591',
        'blk34': '\u2593',
        'block': '\u2588',
        'bne': '=\u20E5',
        'bnequiv': '\u2261\u20E5',
        'bnot': '\u2310',
        'bNot': '\u2AED',
        'bopf': '\uD835\uDD53',
        'Bopf': '\uD835\uDD39',
        'bot': '\u22A5',
        'bottom': '\u22A5',
        'bowtie': '\u22C8',
        'boxbox': '\u29C9',
        'boxdl': '\u2510',
        'boxdL': '\u2555',
        'boxDl': '\u2556',
        'boxDL': '\u2557',
        'boxdr': '\u250C',
        'boxdR': '\u2552',
        'boxDr': '\u2553',
        'boxDR': '\u2554',
        'boxh': '\u2500',
        'boxH': '\u2550',
        'boxhd': '\u252C',
        'boxhD': '\u2565',
        'boxHd': '\u2564',
        'boxHD': '\u2566',
        'boxhu': '\u2534',
        'boxhU': '\u2568',
        'boxHu': '\u2567',
        'boxHU': '\u2569',
        'boxminus': '\u229F',
        'boxplus': '\u229E',
        'boxtimes': '\u22A0',
        'boxul': '\u2518',
        'boxuL': '\u255B',
        'boxUl': '\u255C',
        'boxUL': '\u255D',
        'boxur': '\u2514',
        'boxuR': '\u2558',
        'boxUr': '\u2559',
        'boxUR': '\u255A',
        'boxv': '\u2502',
        'boxV': '\u2551',
        'boxvh': '\u253C',
        'boxvH': '\u256A',
        'boxVh': '\u256B',
        'boxVH': '\u256C',
        'boxvl': '\u2524',
        'boxvL': '\u2561',
        'boxVl': '\u2562',
        'boxVL': '\u2563',
        'boxvr': '\u251C',
        'boxvR': '\u255E',
        'boxVr': '\u255F',
        'boxVR': '\u2560',
        'bprime': '\u2035',
        'breve': '\u02D8',
        'Breve': '\u02D8',
        'brvbar': '\xA6',
        'bscr': '\uD835\uDCB7',
        'Bscr': '\u212C',
        'bsemi': '\u204F',
        'bsim': '\u223D',
        'bsime': '\u22CD',
        'bsol': '\\',
        'bsolb': '\u29C5',
        'bsolhsub': '\u27C8',
        'bull': '\u2022',
        'bullet': '\u2022',
        'bump': '\u224E',
        'bumpe': '\u224F',
        'bumpE': '\u2AAE',
        'bumpeq': '\u224F',
        'Bumpeq': '\u224E',
        'cacute': '\u0107',
        'Cacute': '\u0106',
        'cap': '\u2229',
        'Cap': '\u22D2',
        'capand': '\u2A44',
        'capbrcup': '\u2A49',
        'capcap': '\u2A4B',
        'capcup': '\u2A47',
        'capdot': '\u2A40',
        'CapitalDifferentialD': '\u2145',
        'caps': '\u2229\uFE00',
        'caret': '\u2041',
        'caron': '\u02C7',
        'Cayleys': '\u212D',
        'ccaps': '\u2A4D',
        'ccaron': '\u010D',
        'Ccaron': '\u010C',
        'ccedil': '\xE7',
        'Ccedil': '\xC7',
        'ccirc': '\u0109',
        'Ccirc': '\u0108',
        'Cconint': '\u2230',
        'ccups': '\u2A4C',
        'ccupssm': '\u2A50',
        'cdot': '\u010B',
        'Cdot': '\u010A',
        'cedil': '\xB8',
        'Cedilla': '\xB8',
        'cemptyv': '\u29B2',
        'cent': '\xA2',
        'centerdot': '\xB7',
        'CenterDot': '\xB7',
        'cfr': '\uD835\uDD20',
        'Cfr': '\u212D',
        'chcy': '\u0447',
        'CHcy': '\u0427',
        'check': '\u2713',
        'checkmark': '\u2713',
        'chi': '\u03C7',
        'Chi': '\u03A7',
        'cir': '\u25CB',
        'circ': '\u02C6',
        'circeq': '\u2257',
        'circlearrowleft': '\u21BA',
        'circlearrowright': '\u21BB',
        'circledast': '\u229B',
        'circledcirc': '\u229A',
        'circleddash': '\u229D',
        'CircleDot': '\u2299',
        'circledR': '\xAE',
        'circledS': '\u24C8',
        'CircleMinus': '\u2296',
        'CirclePlus': '\u2295',
        'CircleTimes': '\u2297',
        'cire': '\u2257',
        'cirE': '\u29C3',
        'cirfnint': '\u2A10',
        'cirmid': '\u2AEF',
        'cirscir': '\u29C2',
        'ClockwiseContourIntegral': '\u2232',
        'CloseCurlyDoubleQuote': '\u201D',
        'CloseCurlyQuote': '\u2019',
        'clubs': '\u2663',
        'clubsuit': '\u2663',
        'colon': ':',
        'Colon': '\u2237',
        'colone': '\u2254',
        'Colone': '\u2A74',
        'coloneq': '\u2254',
        'comma': ',',
        'commat': '@',
        'comp': '\u2201',
        'compfn': '\u2218',
        'complement': '\u2201',
        'complexes': '\u2102',
        'cong': '\u2245',
        'congdot': '\u2A6D',
        'Congruent': '\u2261',
        'conint': '\u222E',
        'Conint': '\u222F',
        'ContourIntegral': '\u222E',
        'copf': '\uD835\uDD54',
        'Copf': '\u2102',
        'coprod': '\u2210',
        'Coproduct': '\u2210',
        'copy': '\xA9',
        'COPY': '\xA9',
        'copysr': '\u2117',
        'CounterClockwiseContourIntegral': '\u2233',
        'crarr': '\u21B5',
        'cross': '\u2717',
        'Cross': '\u2A2F',
        'cscr': '\uD835\uDCB8',
        'Cscr': '\uD835\uDC9E',
        'csub': '\u2ACF',
        'csube': '\u2AD1',
        'csup': '\u2AD0',
        'csupe': '\u2AD2',
        'ctdot': '\u22EF',
        'cudarrl': '\u2938',
        'cudarrr': '\u2935',
        'cuepr': '\u22DE',
        'cuesc': '\u22DF',
        'cularr': '\u21B6',
        'cularrp': '\u293D',
        'cup': '\u222A',
        'Cup': '\u22D3',
        'cupbrcap': '\u2A48',
        'cupcap': '\u2A46',
        'CupCap': '\u224D',
        'cupcup': '\u2A4A',
        'cupdot': '\u228D',
        'cupor': '\u2A45',
        'cups': '\u222A\uFE00',
        'curarr': '\u21B7',
        'curarrm': '\u293C',
        'curlyeqprec': '\u22DE',
        'curlyeqsucc': '\u22DF',
        'curlyvee': '\u22CE',
        'curlywedge': '\u22CF',
        'curren': '\xA4',
        'curvearrowleft': '\u21B6',
        'curvearrowright': '\u21B7',
        'cuvee': '\u22CE',
        'cuwed': '\u22CF',
        'cwconint': '\u2232',
        'cwint': '\u2231',
        'cylcty': '\u232D',
        'dagger': '\u2020',
        'Dagger': '\u2021',
        'daleth': '\u2138',
        'darr': '\u2193',
        'dArr': '\u21D3',
        'Darr': '\u21A1',
        'dash': '\u2010',
        'dashv': '\u22A3',
        'Dashv': '\u2AE4',
        'dbkarow': '\u290F',
        'dblac': '\u02DD',
        'dcaron': '\u010F',
        'Dcaron': '\u010E',
        'dcy': '\u0434',
        'Dcy': '\u0414',
        'dd': '\u2146',
        'DD': '\u2145',
        'ddagger': '\u2021',
        'ddarr': '\u21CA',
        'DDotrahd': '\u2911',
        'ddotseq': '\u2A77',
        'deg': '\xB0',
        'Del': '\u2207',
        'delta': '\u03B4',
        'Delta': '\u0394',
        'demptyv': '\u29B1',
        'dfisht': '\u297F',
        'dfr': '\uD835\uDD21',
        'Dfr': '\uD835\uDD07',
        'dHar': '\u2965',
        'dharl': '\u21C3',
        'dharr': '\u21C2',
        'DiacriticalAcute': '\xB4',
        'DiacriticalDot': '\u02D9',
        'DiacriticalDoubleAcute': '\u02DD',
        'DiacriticalGrave': '`',
        'DiacriticalTilde': '\u02DC',
        'diam': '\u22C4',
        'diamond': '\u22C4',
        'Diamond': '\u22C4',
        'diamondsuit': '\u2666',
        'diams': '\u2666',
        'die': '\xA8',
        'DifferentialD': '\u2146',
        'digamma': '\u03DD',
        'disin': '\u22F2',
        'div': '\xF7',
        'divide': '\xF7',
        'divideontimes': '\u22C7',
        'divonx': '\u22C7',
        'djcy': '\u0452',
        'DJcy': '\u0402',
        'dlcorn': '\u231E',
        'dlcrop': '\u230D',
        'dollar': '$',
        'dopf': '\uD835\uDD55',
        'Dopf': '\uD835\uDD3B',
        'dot': '\u02D9',
        'Dot': '\xA8',
        'DotDot': '\u20DC',
        'doteq': '\u2250',
        'doteqdot': '\u2251',
        'DotEqual': '\u2250',
        'dotminus': '\u2238',
        'dotplus': '\u2214',
        'dotsquare': '\u22A1',
        'doublebarwedge': '\u2306',
        'DoubleContourIntegral': '\u222F',
        'DoubleDot': '\xA8',
        'DoubleDownArrow': '\u21D3',
        'DoubleLeftArrow': '\u21D0',
        'DoubleLeftRightArrow': '\u21D4',
        'DoubleLeftTee': '\u2AE4',
        'DoubleLongLeftArrow': '\u27F8',
        'DoubleLongLeftRightArrow': '\u27FA',
        'DoubleLongRightArrow': '\u27F9',
        'DoubleRightArrow': '\u21D2',
        'DoubleRightTee': '\u22A8',
        'DoubleUpArrow': '\u21D1',
        'DoubleUpDownArrow': '\u21D5',
        'DoubleVerticalBar': '\u2225',
        'downarrow': '\u2193',
        'Downarrow': '\u21D3',
        'DownArrow': '\u2193',
        'DownArrowBar': '\u2913',
        'DownArrowUpArrow': '\u21F5',
        'DownBreve': '\u0311',
        'downdownarrows': '\u21CA',
        'downharpoonleft': '\u21C3',
        'downharpoonright': '\u21C2',
        'DownLeftRightVector': '\u2950',
        'DownLeftTeeVector': '\u295E',
        'DownLeftVector': '\u21BD',
        'DownLeftVectorBar': '\u2956',
        'DownRightTeeVector': '\u295F',
        'DownRightVector': '\u21C1',
        'DownRightVectorBar': '\u2957',
        'DownTee': '\u22A4',
        'DownTeeArrow': '\u21A7',
        'drbkarow': '\u2910',
        'drcorn': '\u231F',
        'drcrop': '\u230C',
        'dscr': '\uD835\uDCB9',
        'Dscr': '\uD835\uDC9F',
        'dscy': '\u0455',
        'DScy': '\u0405',
        'dsol': '\u29F6',
        'dstrok': '\u0111',
        'Dstrok': '\u0110',
        'dtdot': '\u22F1',
        'dtri': '\u25BF',
        'dtrif': '\u25BE',
        'duarr': '\u21F5',
        'duhar': '\u296F',
        'dwangle': '\u29A6',
        'dzcy': '\u045F',
        'DZcy': '\u040F',
        'dzigrarr': '\u27FF',
        'eacute': '\xE9',
        'Eacute': '\xC9',
        'easter': '\u2A6E',
        'ecaron': '\u011B',
        'Ecaron': '\u011A',
        'ecir': '\u2256',
        'ecirc': '\xEA',
        'Ecirc': '\xCA',
        'ecolon': '\u2255',
        'ecy': '\u044D',
        'Ecy': '\u042D',
        'eDDot': '\u2A77',
        'edot': '\u0117',
        'eDot': '\u2251',
        'Edot': '\u0116',
        'ee': '\u2147',
        'efDot': '\u2252',
        'efr': '\uD835\uDD22',
        'Efr': '\uD835\uDD08',
        'eg': '\u2A9A',
        'egrave': '\xE8',
        'Egrave': '\xC8',
        'egs': '\u2A96',
        'egsdot': '\u2A98',
        'el': '\u2A99',
        'Element': '\u2208',
        'elinters': '\u23E7',
        'ell': '\u2113',
        'els': '\u2A95',
        'elsdot': '\u2A97',
        'emacr': '\u0113',
        'Emacr': '\u0112',
        'empty': '\u2205',
        'emptyset': '\u2205',
        'EmptySmallSquare': '\u25FB',
        'emptyv': '\u2205',
        'EmptyVerySmallSquare': '\u25AB',
        'emsp': '\u2003',
        'emsp13': '\u2004',
        'emsp14': '\u2005',
        'eng': '\u014B',
        'ENG': '\u014A',
        'ensp': '\u2002',
        'eogon': '\u0119',
        'Eogon': '\u0118',
        'eopf': '\uD835\uDD56',
        'Eopf': '\uD835\uDD3C',
        'epar': '\u22D5',
        'eparsl': '\u29E3',
        'eplus': '\u2A71',
        'epsi': '\u03B5',
        'epsilon': '\u03B5',
        'Epsilon': '\u0395',
        'epsiv': '\u03F5',
        'eqcirc': '\u2256',
        'eqcolon': '\u2255',
        'eqsim': '\u2242',
        'eqslantgtr': '\u2A96',
        'eqslantless': '\u2A95',
        'Equal': '\u2A75',
        'equals': '=',
        'EqualTilde': '\u2242',
        'equest': '\u225F',
        'Equilibrium': '\u21CC',
        'equiv': '\u2261',
        'equivDD': '\u2A78',
        'eqvparsl': '\u29E5',
        'erarr': '\u2971',
        'erDot': '\u2253',
        'escr': '\u212F',
        'Escr': '\u2130',
        'esdot': '\u2250',
        'esim': '\u2242',
        'Esim': '\u2A73',
        'eta': '\u03B7',
        'Eta': '\u0397',
        'eth': '\xF0',
        'ETH': '\xD0',
        'euml': '\xEB',
        'Euml': '\xCB',
        'euro': '\u20AC',
        'excl': '!',
        'exist': '\u2203',
        'Exists': '\u2203',
        'expectation': '\u2130',
        'exponentiale': '\u2147',
        'ExponentialE': '\u2147',
        'fallingdotseq': '\u2252',
        'fcy': '\u0444',
        'Fcy': '\u0424',
        'female': '\u2640',
        'ffilig': '\uFB03',
        'fflig': '\uFB00',
        'ffllig': '\uFB04',
        'ffr': '\uD835\uDD23',
        'Ffr': '\uD835\uDD09',
        'filig': '\uFB01',
        'FilledSmallSquare': '\u25FC',
        'FilledVerySmallSquare': '\u25AA',
        'fjlig': 'fj',
        'flat': '\u266D',
        'fllig': '\uFB02',
        'fltns': '\u25B1',
        'fnof': '\u0192',
        'fopf': '\uD835\uDD57',
        'Fopf': '\uD835\uDD3D',
        'forall': '\u2200',
        'ForAll': '\u2200',
        'fork': '\u22D4',
        'forkv': '\u2AD9',
        'Fouriertrf': '\u2131',
        'fpartint': '\u2A0D',
        'frac12': '\xBD',
        'frac13': '\u2153',
        'frac14': '\xBC',
        'frac15': '\u2155',
        'frac16': '\u2159',
        'frac18': '\u215B',
        'frac23': '\u2154',
        'frac25': '\u2156',
        'frac34': '\xBE',
        'frac35': '\u2157',
        'frac38': '\u215C',
        'frac45': '\u2158',
        'frac56': '\u215A',
        'frac58': '\u215D',
        'frac78': '\u215E',
        'frasl': '\u2044',
        'frown': '\u2322',
        'fscr': '\uD835\uDCBB',
        'Fscr': '\u2131',
        'gacute': '\u01F5',
        'gamma': '\u03B3',
        'Gamma': '\u0393',
        'gammad': '\u03DD',
        'Gammad': '\u03DC',
        'gap': '\u2A86',
        'gbreve': '\u011F',
        'Gbreve': '\u011E',
        'Gcedil': '\u0122',
        'gcirc': '\u011D',
        'Gcirc': '\u011C',
        'gcy': '\u0433',
        'Gcy': '\u0413',
        'gdot': '\u0121',
        'Gdot': '\u0120',
        'ge': '\u2265',
        'gE': '\u2267',
        'gel': '\u22DB',
        'gEl': '\u2A8C',
        'geq': '\u2265',
        'geqq': '\u2267',
        'geqslant': '\u2A7E',
        'ges': '\u2A7E',
        'gescc': '\u2AA9',
        'gesdot': '\u2A80',
        'gesdoto': '\u2A82',
        'gesdotol': '\u2A84',
        'gesl': '\u22DB\uFE00',
        'gesles': '\u2A94',
        'gfr': '\uD835\uDD24',
        'Gfr': '\uD835\uDD0A',
        'gg': '\u226B',
        'Gg': '\u22D9',
        'ggg': '\u22D9',
        'gimel': '\u2137',
        'gjcy': '\u0453',
        'GJcy': '\u0403',
        'gl': '\u2277',
        'gla': '\u2AA5',
        'glE': '\u2A92',
        'glj': '\u2AA4',
        'gnap': '\u2A8A',
        'gnapprox': '\u2A8A',
        'gne': '\u2A88',
        'gnE': '\u2269',
        'gneq': '\u2A88',
        'gneqq': '\u2269',
        'gnsim': '\u22E7',
        'gopf': '\uD835\uDD58',
        'Gopf': '\uD835\uDD3E',
        'grave': '`',
        'GreaterEqual': '\u2265',
        'GreaterEqualLess': '\u22DB',
        'GreaterFullEqual': '\u2267',
        'GreaterGreater': '\u2AA2',
        'GreaterLess': '\u2277',
        'GreaterSlantEqual': '\u2A7E',
        'GreaterTilde': '\u2273',
        'gscr': '\u210A',
        'Gscr': '\uD835\uDCA2',
        'gsim': '\u2273',
        'gsime': '\u2A8E',
        'gsiml': '\u2A90',
        'gt': '>',
        'Gt': '\u226B',
        'GT': '>',
        'gtcc': '\u2AA7',
        'gtcir': '\u2A7A',
        'gtdot': '\u22D7',
        'gtlPar': '\u2995',
        'gtquest': '\u2A7C',
        'gtrapprox': '\u2A86',
        'gtrarr': '\u2978',
        'gtrdot': '\u22D7',
        'gtreqless': '\u22DB',
        'gtreqqless': '\u2A8C',
        'gtrless': '\u2277',
        'gtrsim': '\u2273',
        'gvertneqq': '\u2269\uFE00',
        'gvnE': '\u2269\uFE00',
        'Hacek': '\u02C7',
        'hairsp': '\u200A',
        'half': '\xBD',
        'hamilt': '\u210B',
        'hardcy': '\u044A',
        'HARDcy': '\u042A',
        'harr': '\u2194',
        'hArr': '\u21D4',
        'harrcir': '\u2948',
        'harrw': '\u21AD',
        'Hat': '^',
        'hbar': '\u210F',
        'hcirc': '\u0125',
        'Hcirc': '\u0124',
        'hearts': '\u2665',
        'heartsuit': '\u2665',
        'hellip': '\u2026',
        'hercon': '\u22B9',
        'hfr': '\uD835\uDD25',
        'Hfr': '\u210C',
        'HilbertSpace': '\u210B',
        'hksearow': '\u2925',
        'hkswarow': '\u2926',
        'hoarr': '\u21FF',
        'homtht': '\u223B',
        'hookleftarrow': '\u21A9',
        'hookrightarrow': '\u21AA',
        'hopf': '\uD835\uDD59',
        'Hopf': '\u210D',
        'horbar': '\u2015',
        'HorizontalLine': '\u2500',
        'hscr': '\uD835\uDCBD',
        'Hscr': '\u210B',
        'hslash': '\u210F',
        'hstrok': '\u0127',
        'Hstrok': '\u0126',
        'HumpDownHump': '\u224E',
        'HumpEqual': '\u224F',
        'hybull': '\u2043',
        'hyphen': '\u2010',
        'iacute': '\xED',
        'Iacute': '\xCD',
        'ic': '\u2063',
        'icirc': '\xEE',
        'Icirc': '\xCE',
        'icy': '\u0438',
        'Icy': '\u0418',
        'Idot': '\u0130',
        'iecy': '\u0435',
        'IEcy': '\u0415',
        'iexcl': '\xA1',
        'iff': '\u21D4',
        'ifr': '\uD835\uDD26',
        'Ifr': '\u2111',
        'igrave': '\xEC',
        'Igrave': '\xCC',
        'ii': '\u2148',
        'iiiint': '\u2A0C',
        'iiint': '\u222D',
        'iinfin': '\u29DC',
        'iiota': '\u2129',
        'ijlig': '\u0133',
        'IJlig': '\u0132',
        'Im': '\u2111',
        'imacr': '\u012B',
        'Imacr': '\u012A',
        'image': '\u2111',
        'ImaginaryI': '\u2148',
        'imagline': '\u2110',
        'imagpart': '\u2111',
        'imath': '\u0131',
        'imof': '\u22B7',
        'imped': '\u01B5',
        'Implies': '\u21D2',
        'in': '\u2208',
        'incare': '\u2105',
        'infin': '\u221E',
        'infintie': '\u29DD',
        'inodot': '\u0131',
        'int': '\u222B',
        'Int': '\u222C',
        'intcal': '\u22BA',
        'integers': '\u2124',
        'Integral': '\u222B',
        'intercal': '\u22BA',
        'Intersection': '\u22C2',
        'intlarhk': '\u2A17',
        'intprod': '\u2A3C',
        'InvisibleComma': '\u2063',
        'InvisibleTimes': '\u2062',
        'iocy': '\u0451',
        'IOcy': '\u0401',
        'iogon': '\u012F',
        'Iogon': '\u012E',
        'iopf': '\uD835\uDD5A',
        'Iopf': '\uD835\uDD40',
        'iota': '\u03B9',
        'Iota': '\u0399',
        'iprod': '\u2A3C',
        'iquest': '\xBF',
        'iscr': '\uD835\uDCBE',
        'Iscr': '\u2110',
        'isin': '\u2208',
        'isindot': '\u22F5',
        'isinE': '\u22F9',
        'isins': '\u22F4',
        'isinsv': '\u22F3',
        'isinv': '\u2208',
        'it': '\u2062',
        'itilde': '\u0129',
        'Itilde': '\u0128',
        'iukcy': '\u0456',
        'Iukcy': '\u0406',
        'iuml': '\xEF',
        'Iuml': '\xCF',
        'jcirc': '\u0135',
        'Jcirc': '\u0134',
        'jcy': '\u0439',
        'Jcy': '\u0419',
        'jfr': '\uD835\uDD27',
        'Jfr': '\uD835\uDD0D',
        'jmath': '\u0237',
        'jopf': '\uD835\uDD5B',
        'Jopf': '\uD835\uDD41',
        'jscr': '\uD835\uDCBF',
        'Jscr': '\uD835\uDCA5',
        'jsercy': '\u0458',
        'Jsercy': '\u0408',
        'jukcy': '\u0454',
        'Jukcy': '\u0404',
        'kappa': '\u03BA',
        'Kappa': '\u039A',
        'kappav': '\u03F0',
        'kcedil': '\u0137',
        'Kcedil': '\u0136',
        'kcy': '\u043A',
        'Kcy': '\u041A',
        'kfr': '\uD835\uDD28',
        'Kfr': '\uD835\uDD0E',
        'kgreen': '\u0138',
        'khcy': '\u0445',
        'KHcy': '\u0425',
        'kjcy': '\u045C',
        'KJcy': '\u040C',
        'kopf': '\uD835\uDD5C',
        'Kopf': '\uD835\uDD42',
        'kscr': '\uD835\uDCC0',
        'Kscr': '\uD835\uDCA6',
        'lAarr': '\u21DA',
        'lacute': '\u013A',
        'Lacute': '\u0139',
        'laemptyv': '\u29B4',
        'lagran': '\u2112',
        'lambda': '\u03BB',
        'Lambda': '\u039B',
        'lang': '\u27E8',
        'Lang': '\u27EA',
        'langd': '\u2991',
        'langle': '\u27E8',
        'lap': '\u2A85',
        'Laplacetrf': '\u2112',
        'laquo': '\xAB',
        'larr': '\u2190',
        'lArr': '\u21D0',
        'Larr': '\u219E',
        'larrb': '\u21E4',
        'larrbfs': '\u291F',
        'larrfs': '\u291D',
        'larrhk': '\u21A9',
        'larrlp': '\u21AB',
        'larrpl': '\u2939',
        'larrsim': '\u2973',
        'larrtl': '\u21A2',
        'lat': '\u2AAB',
        'latail': '\u2919',
        'lAtail': '\u291B',
        'late': '\u2AAD',
        'lates': '\u2AAD\uFE00',
        'lbarr': '\u290C',
        'lBarr': '\u290E',
        'lbbrk': '\u2772',
        'lbrace': '{',
        'lbrack': '[',
        'lbrke': '\u298B',
        'lbrksld': '\u298F',
        'lbrkslu': '\u298D',
        'lcaron': '\u013E',
        'Lcaron': '\u013D',
        'lcedil': '\u013C',
        'Lcedil': '\u013B',
        'lceil': '\u2308',
        'lcub': '{',
        'lcy': '\u043B',
        'Lcy': '\u041B',
        'ldca': '\u2936',
        'ldquo': '\u201C',
        'ldquor': '\u201E',
        'ldrdhar': '\u2967',
        'ldrushar': '\u294B',
        'ldsh': '\u21B2',
        'le': '\u2264',
        'lE': '\u2266',
        'LeftAngleBracket': '\u27E8',
        'leftarrow': '\u2190',
        'Leftarrow': '\u21D0',
        'LeftArrow': '\u2190',
        'LeftArrowBar': '\u21E4',
        'LeftArrowRightArrow': '\u21C6',
        'leftarrowtail': '\u21A2',
        'LeftCeiling': '\u2308',
        'LeftDoubleBracket': '\u27E6',
        'LeftDownTeeVector': '\u2961',
        'LeftDownVector': '\u21C3',
        'LeftDownVectorBar': '\u2959',
        'LeftFloor': '\u230A',
        'leftharpoondown': '\u21BD',
        'leftharpoonup': '\u21BC',
        'leftleftarrows': '\u21C7',
        'leftrightarrow': '\u2194',
        'Leftrightarrow': '\u21D4',
        'LeftRightArrow': '\u2194',
        'leftrightarrows': '\u21C6',
        'leftrightharpoons': '\u21CB',
        'leftrightsquigarrow': '\u21AD',
        'LeftRightVector': '\u294E',
        'LeftTee': '\u22A3',
        'LeftTeeArrow': '\u21A4',
        'LeftTeeVector': '\u295A',
        'leftthreetimes': '\u22CB',
        'LeftTriangle': '\u22B2',
        'LeftTriangleBar': '\u29CF',
        'LeftTriangleEqual': '\u22B4',
        'LeftUpDownVector': '\u2951',
        'LeftUpTeeVector': '\u2960',
        'LeftUpVector': '\u21BF',
        'LeftUpVectorBar': '\u2958',
        'LeftVector': '\u21BC',
        'LeftVectorBar': '\u2952',
        'leg': '\u22DA',
        'lEg': '\u2A8B',
        'leq': '\u2264',
        'leqq': '\u2266',
        'leqslant': '\u2A7D',
        'les': '\u2A7D',
        'lescc': '\u2AA8',
        'lesdot': '\u2A7F',
        'lesdoto': '\u2A81',
        'lesdotor': '\u2A83',
        'lesg': '\u22DA\uFE00',
        'lesges': '\u2A93',
        'lessapprox': '\u2A85',
        'lessdot': '\u22D6',
        'lesseqgtr': '\u22DA',
        'lesseqqgtr': '\u2A8B',
        'LessEqualGreater': '\u22DA',
        'LessFullEqual': '\u2266',
        'LessGreater': '\u2276',
        'lessgtr': '\u2276',
        'LessLess': '\u2AA1',
        'lesssim': '\u2272',
        'LessSlantEqual': '\u2A7D',
        'LessTilde': '\u2272',
        'lfisht': '\u297C',
        'lfloor': '\u230A',
        'lfr': '\uD835\uDD29',
        'Lfr': '\uD835\uDD0F',
        'lg': '\u2276',
        'lgE': '\u2A91',
        'lHar': '\u2962',
        'lhard': '\u21BD',
        'lharu': '\u21BC',
        'lharul': '\u296A',
        'lhblk': '\u2584',
        'ljcy': '\u0459',
        'LJcy': '\u0409',
        'll': '\u226A',
        'Ll': '\u22D8',
        'llarr': '\u21C7',
        'llcorner': '\u231E',
        'Lleftarrow': '\u21DA',
        'llhard': '\u296B',
        'lltri': '\u25FA',
        'lmidot': '\u0140',
        'Lmidot': '\u013F',
        'lmoust': '\u23B0',
        'lmoustache': '\u23B0',
        'lnap': '\u2A89',
        'lnapprox': '\u2A89',
        'lne': '\u2A87',
        'lnE': '\u2268',
        'lneq': '\u2A87',
        'lneqq': '\u2268',
        'lnsim': '\u22E6',
        'loang': '\u27EC',
        'loarr': '\u21FD',
        'lobrk': '\u27E6',
        'longleftarrow': '\u27F5',
        'Longleftarrow': '\u27F8',
        'LongLeftArrow': '\u27F5',
        'longleftrightarrow': '\u27F7',
        'Longleftrightarrow': '\u27FA',
        'LongLeftRightArrow': '\u27F7',
        'longmapsto': '\u27FC',
        'longrightarrow': '\u27F6',
        'Longrightarrow': '\u27F9',
        'LongRightArrow': '\u27F6',
        'looparrowleft': '\u21AB',
        'looparrowright': '\u21AC',
        'lopar': '\u2985',
        'lopf': '\uD835\uDD5D',
        'Lopf': '\uD835\uDD43',
        'loplus': '\u2A2D',
        'lotimes': '\u2A34',
        'lowast': '\u2217',
        'lowbar': '_',
        'LowerLeftArrow': '\u2199',
        'LowerRightArrow': '\u2198',
        'loz': '\u25CA',
        'lozenge': '\u25CA',
        'lozf': '\u29EB',
        'lpar': '(',
        'lparlt': '\u2993',
        'lrarr': '\u21C6',
        'lrcorner': '\u231F',
        'lrhar': '\u21CB',
        'lrhard': '\u296D',
        'lrm': '\u200E',
        'lrtri': '\u22BF',
        'lsaquo': '\u2039',
        'lscr': '\uD835\uDCC1',
        'Lscr': '\u2112',
        'lsh': '\u21B0',
        'Lsh': '\u21B0',
        'lsim': '\u2272',
        'lsime': '\u2A8D',
        'lsimg': '\u2A8F',
        'lsqb': '[',
        'lsquo': '\u2018',
        'lsquor': '\u201A',
        'lstrok': '\u0142',
        'Lstrok': '\u0141',
        'lt': '<',
        'Lt': '\u226A',
        'LT': '<',
        'ltcc': '\u2AA6',
        'ltcir': '\u2A79',
        'ltdot': '\u22D6',
        'lthree': '\u22CB',
        'ltimes': '\u22C9',
        'ltlarr': '\u2976',
        'ltquest': '\u2A7B',
        'ltri': '\u25C3',
        'ltrie': '\u22B4',
        'ltrif': '\u25C2',
        'ltrPar': '\u2996',
        'lurdshar': '\u294A',
        'luruhar': '\u2966',
        'lvertneqq': '\u2268\uFE00',
        'lvnE': '\u2268\uFE00',
        'macr': '\xAF',
        'male': '\u2642',
        'malt': '\u2720',
        'maltese': '\u2720',
        'map': '\u21A6',
        'Map': '\u2905',
        'mapsto': '\u21A6',
        'mapstodown': '\u21A7',
        'mapstoleft': '\u21A4',
        'mapstoup': '\u21A5',
        'marker': '\u25AE',
        'mcomma': '\u2A29',
        'mcy': '\u043C',
        'Mcy': '\u041C',
        'mdash': '\u2014',
        'mDDot': '\u223A',
        'measuredangle': '\u2221',
        'MediumSpace': '\u205F',
        'Mellintrf': '\u2133',
        'mfr': '\uD835\uDD2A',
        'Mfr': '\uD835\uDD10',
        'mho': '\u2127',
        'micro': '\xB5',
        'mid': '\u2223',
        'midast': '*',
        'midcir': '\u2AF0',
        'middot': '\xB7',
        'minus': '\u2212',
        'minusb': '\u229F',
        'minusd': '\u2238',
        'minusdu': '\u2A2A',
        'MinusPlus': '\u2213',
        'mlcp': '\u2ADB',
        'mldr': '\u2026',
        'mnplus': '\u2213',
        'models': '\u22A7',
        'mopf': '\uD835\uDD5E',
        'Mopf': '\uD835\uDD44',
        'mp': '\u2213',
        'mscr': '\uD835\uDCC2',
        'Mscr': '\u2133',
        'mstpos': '\u223E',
        'mu': '\u03BC',
        'Mu': '\u039C',
        'multimap': '\u22B8',
        'mumap': '\u22B8',
        'nabla': '\u2207',
        'nacute': '\u0144',
        'Nacute': '\u0143',
        'nang': '\u2220\u20D2',
        'nap': '\u2249',
        'napE': '\u2A70\u0338',
        'napid': '\u224B\u0338',
        'napos': '\u0149',
        'napprox': '\u2249',
        'natur': '\u266E',
        'natural': '\u266E',
        'naturals': '\u2115',
        'nbsp': '\xA0',
        'nbump': '\u224E\u0338',
        'nbumpe': '\u224F\u0338',
        'ncap': '\u2A43',
        'ncaron': '\u0148',
        'Ncaron': '\u0147',
        'ncedil': '\u0146',
        'Ncedil': '\u0145',
        'ncong': '\u2247',
        'ncongdot': '\u2A6D\u0338',
        'ncup': '\u2A42',
        'ncy': '\u043D',
        'Ncy': '\u041D',
        'ndash': '\u2013',
        'ne': '\u2260',
        'nearhk': '\u2924',
        'nearr': '\u2197',
        'neArr': '\u21D7',
        'nearrow': '\u2197',
        'nedot': '\u2250\u0338',
        'NegativeMediumSpace': '\u200B',
        'NegativeThickSpace': '\u200B',
        'NegativeThinSpace': '\u200B',
        'NegativeVeryThinSpace': '\u200B',
        'nequiv': '\u2262',
        'nesear': '\u2928',
        'nesim': '\u2242\u0338',
        'NestedGreaterGreater': '\u226B',
        'NestedLessLess': '\u226A',
        'NewLine': '\n',
        'nexist': '\u2204',
        'nexists': '\u2204',
        'nfr': '\uD835\uDD2B',
        'Nfr': '\uD835\uDD11',
        'nge': '\u2271',
        'ngE': '\u2267\u0338',
        'ngeq': '\u2271',
        'ngeqq': '\u2267\u0338',
        'ngeqslant': '\u2A7E\u0338',
        'nges': '\u2A7E\u0338',
        'nGg': '\u22D9\u0338',
        'ngsim': '\u2275',
        'ngt': '\u226F',
        'nGt': '\u226B\u20D2',
        'ngtr': '\u226F',
        'nGtv': '\u226B\u0338',
        'nharr': '\u21AE',
        'nhArr': '\u21CE',
        'nhpar': '\u2AF2',
        'ni': '\u220B',
        'nis': '\u22FC',
        'nisd': '\u22FA',
        'niv': '\u220B',
        'njcy': '\u045A',
        'NJcy': '\u040A',
        'nlarr': '\u219A',
        'nlArr': '\u21CD',
        'nldr': '\u2025',
        'nle': '\u2270',
        'nlE': '\u2266\u0338',
        'nleftarrow': '\u219A',
        'nLeftarrow': '\u21CD',
        'nleftrightarrow': '\u21AE',
        'nLeftrightarrow': '\u21CE',
        'nleq': '\u2270',
        'nleqq': '\u2266\u0338',
        'nleqslant': '\u2A7D\u0338',
        'nles': '\u2A7D\u0338',
        'nless': '\u226E',
        'nLl': '\u22D8\u0338',
        'nlsim': '\u2274',
        'nlt': '\u226E',
        'nLt': '\u226A\u20D2',
        'nltri': '\u22EA',
        'nltrie': '\u22EC',
        'nLtv': '\u226A\u0338',
        'nmid': '\u2224',
        'NoBreak': '\u2060',
        'NonBreakingSpace': '\xA0',
        'nopf': '\uD835\uDD5F',
        'Nopf': '\u2115',
        'not': '\xAC',
        'Not': '\u2AEC',
        'NotCongruent': '\u2262',
        'NotCupCap': '\u226D',
        'NotDoubleVerticalBar': '\u2226',
        'NotElement': '\u2209',
        'NotEqual': '\u2260',
        'NotEqualTilde': '\u2242\u0338',
        'NotExists': '\u2204',
        'NotGreater': '\u226F',
        'NotGreaterEqual': '\u2271',
        'NotGreaterFullEqual': '\u2267\u0338',
        'NotGreaterGreater': '\u226B\u0338',
        'NotGreaterLess': '\u2279',
        'NotGreaterSlantEqual': '\u2A7E\u0338',
        'NotGreaterTilde': '\u2275',
        'NotHumpDownHump': '\u224E\u0338',
        'NotHumpEqual': '\u224F\u0338',
        'notin': '\u2209',
        'notindot': '\u22F5\u0338',
        'notinE': '\u22F9\u0338',
        'notinva': '\u2209',
        'notinvb': '\u22F7',
        'notinvc': '\u22F6',
        'NotLeftTriangle': '\u22EA',
        'NotLeftTriangleBar': '\u29CF\u0338',
        'NotLeftTriangleEqual': '\u22EC',
        'NotLess': '\u226E',
        'NotLessEqual': '\u2270',
        'NotLessGreater': '\u2278',
        'NotLessLess': '\u226A\u0338',
        'NotLessSlantEqual': '\u2A7D\u0338',
        'NotLessTilde': '\u2274',
        'NotNestedGreaterGreater': '\u2AA2\u0338',
        'NotNestedLessLess': '\u2AA1\u0338',
        'notni': '\u220C',
        'notniva': '\u220C',
        'notnivb': '\u22FE',
        'notnivc': '\u22FD',
        'NotPrecedes': '\u2280',
        'NotPrecedesEqual': '\u2AAF\u0338',
        'NotPrecedesSlantEqual': '\u22E0',
        'NotReverseElement': '\u220C',
        'NotRightTriangle': '\u22EB',
        'NotRightTriangleBar': '\u29D0\u0338',
        'NotRightTriangleEqual': '\u22ED',
        'NotSquareSubset': '\u228F\u0338',
        'NotSquareSubsetEqual': '\u22E2',
        'NotSquareSuperset': '\u2290\u0338',
        'NotSquareSupersetEqual': '\u22E3',
        'NotSubset': '\u2282\u20D2',
        'NotSubsetEqual': '\u2288',
        'NotSucceeds': '\u2281',
        'NotSucceedsEqual': '\u2AB0\u0338',
        'NotSucceedsSlantEqual': '\u22E1',
        'NotSucceedsTilde': '\u227F\u0338',
        'NotSuperset': '\u2283\u20D2',
        'NotSupersetEqual': '\u2289',
        'NotTilde': '\u2241',
        'NotTildeEqual': '\u2244',
        'NotTildeFullEqual': '\u2247',
        'NotTildeTilde': '\u2249',
        'NotVerticalBar': '\u2224',
        'npar': '\u2226',
        'nparallel': '\u2226',
        'nparsl': '\u2AFD\u20E5',
        'npart': '\u2202\u0338',
        'npolint': '\u2A14',
        'npr': '\u2280',
        'nprcue': '\u22E0',
        'npre': '\u2AAF\u0338',
        'nprec': '\u2280',
        'npreceq': '\u2AAF\u0338',
        'nrarr': '\u219B',
        'nrArr': '\u21CF',
        'nrarrc': '\u2933\u0338',
        'nrarrw': '\u219D\u0338',
        'nrightarrow': '\u219B',
        'nRightarrow': '\u21CF',
        'nrtri': '\u22EB',
        'nrtrie': '\u22ED',
        'nsc': '\u2281',
        'nsccue': '\u22E1',
        'nsce': '\u2AB0\u0338',
        'nscr': '\uD835\uDCC3',
        'Nscr': '\uD835\uDCA9',
        'nshortmid': '\u2224',
        'nshortparallel': '\u2226',
        'nsim': '\u2241',
        'nsime': '\u2244',
        'nsimeq': '\u2244',
        'nsmid': '\u2224',
        'nspar': '\u2226',
        'nsqsube': '\u22E2',
        'nsqsupe': '\u22E3',
        'nsub': '\u2284',
        'nsube': '\u2288',
        'nsubE': '\u2AC5\u0338',
        'nsubset': '\u2282\u20D2',
        'nsubseteq': '\u2288',
        'nsubseteqq': '\u2AC5\u0338',
        'nsucc': '\u2281',
        'nsucceq': '\u2AB0\u0338',
        'nsup': '\u2285',
        'nsupe': '\u2289',
        'nsupE': '\u2AC6\u0338',
        'nsupset': '\u2283\u20D2',
        'nsupseteq': '\u2289',
        'nsupseteqq': '\u2AC6\u0338',
        'ntgl': '\u2279',
        'ntilde': '\xF1',
        'Ntilde': '\xD1',
        'ntlg': '\u2278',
        'ntriangleleft': '\u22EA',
        'ntrianglelefteq': '\u22EC',
        'ntriangleright': '\u22EB',
        'ntrianglerighteq': '\u22ED',
        'nu': '\u03BD',
        'Nu': '\u039D',
        'num': '#',
        'numero': '\u2116',
        'numsp': '\u2007',
        'nvap': '\u224D\u20D2',
        'nvdash': '\u22AC',
        'nvDash': '\u22AD',
        'nVdash': '\u22AE',
        'nVDash': '\u22AF',
        'nvge': '\u2265\u20D2',
        'nvgt': '>\u20D2',
        'nvHarr': '\u2904',
        'nvinfin': '\u29DE',
        'nvlArr': '\u2902',
        'nvle': '\u2264\u20D2',
        'nvlt': '<\u20D2',
        'nvltrie': '\u22B4\u20D2',
        'nvrArr': '\u2903',
        'nvrtrie': '\u22B5\u20D2',
        'nvsim': '\u223C\u20D2',
        'nwarhk': '\u2923',
        'nwarr': '\u2196',
        'nwArr': '\u21D6',
        'nwarrow': '\u2196',
        'nwnear': '\u2927',
        'oacute': '\xF3',
        'Oacute': '\xD3',
        'oast': '\u229B',
        'ocir': '\u229A',
        'ocirc': '\xF4',
        'Ocirc': '\xD4',
        'ocy': '\u043E',
        'Ocy': '\u041E',
        'odash': '\u229D',
        'odblac': '\u0151',
        'Odblac': '\u0150',
        'odiv': '\u2A38',
        'odot': '\u2299',
        'odsold': '\u29BC',
        'oelig': '\u0153',
        'OElig': '\u0152',
        'ofcir': '\u29BF',
        'ofr': '\uD835\uDD2C',
        'Ofr': '\uD835\uDD12',
        'ogon': '\u02DB',
        'ograve': '\xF2',
        'Ograve': '\xD2',
        'ogt': '\u29C1',
        'ohbar': '\u29B5',
        'ohm': '\u03A9',
        'oint': '\u222E',
        'olarr': '\u21BA',
        'olcir': '\u29BE',
        'olcross': '\u29BB',
        'oline': '\u203E',
        'olt': '\u29C0',
        'omacr': '\u014D',
        'Omacr': '\u014C',
        'omega': '\u03C9',
        'Omega': '\u03A9',
        'omicron': '\u03BF',
        'Omicron': '\u039F',
        'omid': '\u29B6',
        'ominus': '\u2296',
        'oopf': '\uD835\uDD60',
        'Oopf': '\uD835\uDD46',
        'opar': '\u29B7',
        'OpenCurlyDoubleQuote': '\u201C',
        'OpenCurlyQuote': '\u2018',
        'operp': '\u29B9',
        'oplus': '\u2295',
        'or': '\u2228',
        'Or': '\u2A54',
        'orarr': '\u21BB',
        'ord': '\u2A5D',
        'order': '\u2134',
        'orderof': '\u2134',
        'ordf': '\xAA',
        'ordm': '\xBA',
        'origof': '\u22B6',
        'oror': '\u2A56',
        'orslope': '\u2A57',
        'orv': '\u2A5B',
        'oS': '\u24C8',
        'oscr': '\u2134',
        'Oscr': '\uD835\uDCAA',
        'oslash': '\xF8',
        'Oslash': '\xD8',
        'osol': '\u2298',
        'otilde': '\xF5',
        'Otilde': '\xD5',
        'otimes': '\u2297',
        'Otimes': '\u2A37',
        'otimesas': '\u2A36',
        'ouml': '\xF6',
        'Ouml': '\xD6',
        'ovbar': '\u233D',
        'OverBar': '\u203E',
        'OverBrace': '\u23DE',
        'OverBracket': '\u23B4',
        'OverParenthesis': '\u23DC',
        'par': '\u2225',
        'para': '\xB6',
        'parallel': '\u2225',
        'parsim': '\u2AF3',
        'parsl': '\u2AFD',
        'part': '\u2202',
        'PartialD': '\u2202',
        'pcy': '\u043F',
        'Pcy': '\u041F',
        'percnt': '%',
        'period': '.',
        'permil': '\u2030',
        'perp': '\u22A5',
        'pertenk': '\u2031',
        'pfr': '\uD835\uDD2D',
        'Pfr': '\uD835\uDD13',
        'phi': '\u03C6',
        'Phi': '\u03A6',
        'phiv': '\u03D5',
        'phmmat': '\u2133',
        'phone': '\u260E',
        'pi': '\u03C0',
        'Pi': '\u03A0',
        'pitchfork': '\u22D4',
        'piv': '\u03D6',
        'planck': '\u210F',
        'planckh': '\u210E',
        'plankv': '\u210F',
        'plus': '+',
        'plusacir': '\u2A23',
        'plusb': '\u229E',
        'pluscir': '\u2A22',
        'plusdo': '\u2214',
        'plusdu': '\u2A25',
        'pluse': '\u2A72',
        'PlusMinus': '\xB1',
        'plusmn': '\xB1',
        'plussim': '\u2A26',
        'plustwo': '\u2A27',
        'pm': '\xB1',
        'Poincareplane': '\u210C',
        'pointint': '\u2A15',
        'popf': '\uD835\uDD61',
        'Popf': '\u2119',
        'pound': '\xA3',
        'pr': '\u227A',
        'Pr': '\u2ABB',
        'prap': '\u2AB7',
        'prcue': '\u227C',
        'pre': '\u2AAF',
        'prE': '\u2AB3',
        'prec': '\u227A',
        'precapprox': '\u2AB7',
        'preccurlyeq': '\u227C',
        'Precedes': '\u227A',
        'PrecedesEqual': '\u2AAF',
        'PrecedesSlantEqual': '\u227C',
        'PrecedesTilde': '\u227E',
        'preceq': '\u2AAF',
        'precnapprox': '\u2AB9',
        'precneqq': '\u2AB5',
        'precnsim': '\u22E8',
        'precsim': '\u227E',
        'prime': '\u2032',
        'Prime': '\u2033',
        'primes': '\u2119',
        'prnap': '\u2AB9',
        'prnE': '\u2AB5',
        'prnsim': '\u22E8',
        'prod': '\u220F',
        'Product': '\u220F',
        'profalar': '\u232E',
        'profline': '\u2312',
        'profsurf': '\u2313',
        'prop': '\u221D',
        'Proportion': '\u2237',
        'Proportional': '\u221D',
        'propto': '\u221D',
        'prsim': '\u227E',
        'prurel': '\u22B0',
        'pscr': '\uD835\uDCC5',
        'Pscr': '\uD835\uDCAB',
        'psi': '\u03C8',
        'Psi': '\u03A8',
        'puncsp': '\u2008',
        'qfr': '\uD835\uDD2E',
        'Qfr': '\uD835\uDD14',
        'qint': '\u2A0C',
        'qopf': '\uD835\uDD62',
        'Qopf': '\u211A',
        'qprime': '\u2057',
        'qscr': '\uD835\uDCC6',
        'Qscr': '\uD835\uDCAC',
        'quaternions': '\u210D',
        'quatint': '\u2A16',
        'quest': '?',
        'questeq': '\u225F',
        'quot': '"',
        'QUOT': '"',
        'rAarr': '\u21DB',
        'race': '\u223D\u0331',
        'racute': '\u0155',
        'Racute': '\u0154',
        'radic': '\u221A',
        'raemptyv': '\u29B3',
        'rang': '\u27E9',
        'Rang': '\u27EB',
        'rangd': '\u2992',
        'range': '\u29A5',
        'rangle': '\u27E9',
        'raquo': '\xBB',
        'rarr': '\u2192',
        'rArr': '\u21D2',
        'Rarr': '\u21A0',
        'rarrap': '\u2975',
        'rarrb': '\u21E5',
        'rarrbfs': '\u2920',
        'rarrc': '\u2933',
        'rarrfs': '\u291E',
        'rarrhk': '\u21AA',
        'rarrlp': '\u21AC',
        'rarrpl': '\u2945',
        'rarrsim': '\u2974',
        'rarrtl': '\u21A3',
        'Rarrtl': '\u2916',
        'rarrw': '\u219D',
        'ratail': '\u291A',
        'rAtail': '\u291C',
        'ratio': '\u2236',
        'rationals': '\u211A',
        'rbarr': '\u290D',
        'rBarr': '\u290F',
        'RBarr': '\u2910',
        'rbbrk': '\u2773',
        'rbrace': '}',
        'rbrack': ']',
        'rbrke': '\u298C',
        'rbrksld': '\u298E',
        'rbrkslu': '\u2990',
        'rcaron': '\u0159',
        'Rcaron': '\u0158',
        'rcedil': '\u0157',
        'Rcedil': '\u0156',
        'rceil': '\u2309',
        'rcub': '}',
        'rcy': '\u0440',
        'Rcy': '\u0420',
        'rdca': '\u2937',
        'rdldhar': '\u2969',
        'rdquo': '\u201D',
        'rdquor': '\u201D',
        'rdsh': '\u21B3',
        'Re': '\u211C',
        'real': '\u211C',
        'realine': '\u211B',
        'realpart': '\u211C',
        'reals': '\u211D',
        'rect': '\u25AD',
        'reg': '\xAE',
        'REG': '\xAE',
        'ReverseElement': '\u220B',
        'ReverseEquilibrium': '\u21CB',
        'ReverseUpEquilibrium': '\u296F',
        'rfisht': '\u297D',
        'rfloor': '\u230B',
        'rfr': '\uD835\uDD2F',
        'Rfr': '\u211C',
        'rHar': '\u2964',
        'rhard': '\u21C1',
        'rharu': '\u21C0',
        'rharul': '\u296C',
        'rho': '\u03C1',
        'Rho': '\u03A1',
        'rhov': '\u03F1',
        'RightAngleBracket': '\u27E9',
        'rightarrow': '\u2192',
        'Rightarrow': '\u21D2',
        'RightArrow': '\u2192',
        'RightArrowBar': '\u21E5',
        'RightArrowLeftArrow': '\u21C4',
        'rightarrowtail': '\u21A3',
        'RightCeiling': '\u2309',
        'RightDoubleBracket': '\u27E7',
        'RightDownTeeVector': '\u295D',
        'RightDownVector': '\u21C2',
        'RightDownVectorBar': '\u2955',
        'RightFloor': '\u230B',
        'rightharpoondown': '\u21C1',
        'rightharpoonup': '\u21C0',
        'rightleftarrows': '\u21C4',
        'rightleftharpoons': '\u21CC',
        'rightrightarrows': '\u21C9',
        'rightsquigarrow': '\u219D',
        'RightTee': '\u22A2',
        'RightTeeArrow': '\u21A6',
        'RightTeeVector': '\u295B',
        'rightthreetimes': '\u22CC',
        'RightTriangle': '\u22B3',
        'RightTriangleBar': '\u29D0',
        'RightTriangleEqual': '\u22B5',
        'RightUpDownVector': '\u294F',
        'RightUpTeeVector': '\u295C',
        'RightUpVector': '\u21BE',
        'RightUpVectorBar': '\u2954',
        'RightVector': '\u21C0',
        'RightVectorBar': '\u2953',
        'ring': '\u02DA',
        'risingdotseq': '\u2253',
        'rlarr': '\u21C4',
        'rlhar': '\u21CC',
        'rlm': '\u200F',
        'rmoust': '\u23B1',
        'rmoustache': '\u23B1',
        'rnmid': '\u2AEE',
        'roang': '\u27ED',
        'roarr': '\u21FE',
        'robrk': '\u27E7',
        'ropar': '\u2986',
        'ropf': '\uD835\uDD63',
        'Ropf': '\u211D',
        'roplus': '\u2A2E',
        'rotimes': '\u2A35',
        'RoundImplies': '\u2970',
        'rpar': ')',
        'rpargt': '\u2994',
        'rppolint': '\u2A12',
        'rrarr': '\u21C9',
        'Rrightarrow': '\u21DB',
        'rsaquo': '\u203A',
        'rscr': '\uD835\uDCC7',
        'Rscr': '\u211B',
        'rsh': '\u21B1',
        'Rsh': '\u21B1',
        'rsqb': ']',
        'rsquo': '\u2019',
        'rsquor': '\u2019',
        'rthree': '\u22CC',
        'rtimes': '\u22CA',
        'rtri': '\u25B9',
        'rtrie': '\u22B5',
        'rtrif': '\u25B8',
        'rtriltri': '\u29CE',
        'RuleDelayed': '\u29F4',
        'ruluhar': '\u2968',
        'rx': '\u211E',
        'sacute': '\u015B',
        'Sacute': '\u015A',
        'sbquo': '\u201A',
        'sc': '\u227B',
        'Sc': '\u2ABC',
        'scap': '\u2AB8',
        'scaron': '\u0161',
        'Scaron': '\u0160',
        'sccue': '\u227D',
        'sce': '\u2AB0',
        'scE': '\u2AB4',
        'scedil': '\u015F',
        'Scedil': '\u015E',
        'scirc': '\u015D',
        'Scirc': '\u015C',
        'scnap': '\u2ABA',
        'scnE': '\u2AB6',
        'scnsim': '\u22E9',
        'scpolint': '\u2A13',
        'scsim': '\u227F',
        'scy': '\u0441',
        'Scy': '\u0421',
        'sdot': '\u22C5',
        'sdotb': '\u22A1',
        'sdote': '\u2A66',
        'searhk': '\u2925',
        'searr': '\u2198',
        'seArr': '\u21D8',
        'searrow': '\u2198',
        'sect': '\xA7',
        'semi': ';',
        'seswar': '\u2929',
        'setminus': '\u2216',
        'setmn': '\u2216',
        'sext': '\u2736',
        'sfr': '\uD835\uDD30',
        'Sfr': '\uD835\uDD16',
        'sfrown': '\u2322',
        'sharp': '\u266F',
        'shchcy': '\u0449',
        'SHCHcy': '\u0429',
        'shcy': '\u0448',
        'SHcy': '\u0428',
        'ShortDownArrow': '\u2193',
        'ShortLeftArrow': '\u2190',
        'shortmid': '\u2223',
        'shortparallel': '\u2225',
        'ShortRightArrow': '\u2192',
        'ShortUpArrow': '\u2191',
        'shy': '\xAD',
        'sigma': '\u03C3',
        'Sigma': '\u03A3',
        'sigmaf': '\u03C2',
        'sigmav': '\u03C2',
        'sim': '\u223C',
        'simdot': '\u2A6A',
        'sime': '\u2243',
        'simeq': '\u2243',
        'simg': '\u2A9E',
        'simgE': '\u2AA0',
        'siml': '\u2A9D',
        'simlE': '\u2A9F',
        'simne': '\u2246',
        'simplus': '\u2A24',
        'simrarr': '\u2972',
        'slarr': '\u2190',
        'SmallCircle': '\u2218',
        'smallsetminus': '\u2216',
        'smashp': '\u2A33',
        'smeparsl': '\u29E4',
        'smid': '\u2223',
        'smile': '\u2323',
        'smt': '\u2AAA',
        'smte': '\u2AAC',
        'smtes': '\u2AAC\uFE00',
        'softcy': '\u044C',
        'SOFTcy': '\u042C',
        'sol': '/',
        'solb': '\u29C4',
        'solbar': '\u233F',
        'sopf': '\uD835\uDD64',
        'Sopf': '\uD835\uDD4A',
        'spades': '\u2660',
        'spadesuit': '\u2660',
        'spar': '\u2225',
        'sqcap': '\u2293',
        'sqcaps': '\u2293\uFE00',
        'sqcup': '\u2294',
        'sqcups': '\u2294\uFE00',
        'Sqrt': '\u221A',
        'sqsub': '\u228F',
        'sqsube': '\u2291',
        'sqsubset': '\u228F',
        'sqsubseteq': '\u2291',
        'sqsup': '\u2290',
        'sqsupe': '\u2292',
        'sqsupset': '\u2290',
        'sqsupseteq': '\u2292',
        'squ': '\u25A1',
        'square': '\u25A1',
        'Square': '\u25A1',
        'SquareIntersection': '\u2293',
        'SquareSubset': '\u228F',
        'SquareSubsetEqual': '\u2291',
        'SquareSuperset': '\u2290',
        'SquareSupersetEqual': '\u2292',
        'SquareUnion': '\u2294',
        'squarf': '\u25AA',
        'squf': '\u25AA',
        'srarr': '\u2192',
        'sscr': '\uD835\uDCC8',
        'Sscr': '\uD835\uDCAE',
        'ssetmn': '\u2216',
        'ssmile': '\u2323',
        'sstarf': '\u22C6',
        'star': '\u2606',
        'Star': '\u22C6',
        'starf': '\u2605',
        'straightepsilon': '\u03F5',
        'straightphi': '\u03D5',
        'strns': '\xAF',
        'sub': '\u2282',
        'Sub': '\u22D0',
        'subdot': '\u2ABD',
        'sube': '\u2286',
        'subE': '\u2AC5',
        'subedot': '\u2AC3',
        'submult': '\u2AC1',
        'subne': '\u228A',
        'subnE': '\u2ACB',
        'subplus': '\u2ABF',
        'subrarr': '\u2979',
        'subset': '\u2282',
        'Subset': '\u22D0',
        'subseteq': '\u2286',
        'subseteqq': '\u2AC5',
        'SubsetEqual': '\u2286',
        'subsetneq': '\u228A',
        'subsetneqq': '\u2ACB',
        'subsim': '\u2AC7',
        'subsub': '\u2AD5',
        'subsup': '\u2AD3',
        'succ': '\u227B',
        'succapprox': '\u2AB8',
        'succcurlyeq': '\u227D',
        'Succeeds': '\u227B',
        'SucceedsEqual': '\u2AB0',
        'SucceedsSlantEqual': '\u227D',
        'SucceedsTilde': '\u227F',
        'succeq': '\u2AB0',
        'succnapprox': '\u2ABA',
        'succneqq': '\u2AB6',
        'succnsim': '\u22E9',
        'succsim': '\u227F',
        'SuchThat': '\u220B',
        'sum': '\u2211',
        'Sum': '\u2211',
        'sung': '\u266A',
        'sup': '\u2283',
        'Sup': '\u22D1',
        'sup1': '\xB9',
        'sup2': '\xB2',
        'sup3': '\xB3',
        'supdot': '\u2ABE',
        'supdsub': '\u2AD8',
        'supe': '\u2287',
        'supE': '\u2AC6',
        'supedot': '\u2AC4',
        'Superset': '\u2283',
        'SupersetEqual': '\u2287',
        'suphsol': '\u27C9',
        'suphsub': '\u2AD7',
        'suplarr': '\u297B',
        'supmult': '\u2AC2',
        'supne': '\u228B',
        'supnE': '\u2ACC',
        'supplus': '\u2AC0',
        'supset': '\u2283',
        'Supset': '\u22D1',
        'supseteq': '\u2287',
        'supseteqq': '\u2AC6',
        'supsetneq': '\u228B',
        'supsetneqq': '\u2ACC',
        'supsim': '\u2AC8',
        'supsub': '\u2AD4',
        'supsup': '\u2AD6',
        'swarhk': '\u2926',
        'swarr': '\u2199',
        'swArr': '\u21D9',
        'swarrow': '\u2199',
        'swnwar': '\u292A',
        'szlig': '\xDF',
        'Tab': '\t',
        'target': '\u2316',
        'tau': '\u03C4',
        'Tau': '\u03A4',
        'tbrk': '\u23B4',
        'tcaron': '\u0165',
        'Tcaron': '\u0164',
        'tcedil': '\u0163',
        'Tcedil': '\u0162',
        'tcy': '\u0442',
        'Tcy': '\u0422',
        'tdot': '\u20DB',
        'telrec': '\u2315',
        'tfr': '\uD835\uDD31',
        'Tfr': '\uD835\uDD17',
        'there4': '\u2234',
        'therefore': '\u2234',
        'Therefore': '\u2234',
        'theta': '\u03B8',
        'Theta': '\u0398',
        'thetasym': '\u03D1',
        'thetav': '\u03D1',
        'thickapprox': '\u2248',
        'thicksim': '\u223C',
        'ThickSpace': '\u205F\u200A',
        'thinsp': '\u2009',
        'ThinSpace': '\u2009',
        'thkap': '\u2248',
        'thksim': '\u223C',
        'thorn': '\xFE',
        'THORN': '\xDE',
        'tilde': '\u02DC',
        'Tilde': '\u223C',
        'TildeEqual': '\u2243',
        'TildeFullEqual': '\u2245',
        'TildeTilde': '\u2248',
        'times': '\xD7',
        'timesb': '\u22A0',
        'timesbar': '\u2A31',
        'timesd': '\u2A30',
        'tint': '\u222D',
        'toea': '\u2928',
        'top': '\u22A4',
        'topbot': '\u2336',
        'topcir': '\u2AF1',
        'topf': '\uD835\uDD65',
        'Topf': '\uD835\uDD4B',
        'topfork': '\u2ADA',
        'tosa': '\u2929',
        'tprime': '\u2034',
        'trade': '\u2122',
        'TRADE': '\u2122',
        'triangle': '\u25B5',
        'triangledown': '\u25BF',
        'triangleleft': '\u25C3',
        'trianglelefteq': '\u22B4',
        'triangleq': '\u225C',
        'triangleright': '\u25B9',
        'trianglerighteq': '\u22B5',
        'tridot': '\u25EC',
        'trie': '\u225C',
        'triminus': '\u2A3A',
        'TripleDot': '\u20DB',
        'triplus': '\u2A39',
        'trisb': '\u29CD',
        'tritime': '\u2A3B',
        'trpezium': '\u23E2',
        'tscr': '\uD835\uDCC9',
        'Tscr': '\uD835\uDCAF',
        'tscy': '\u0446',
        'TScy': '\u0426',
        'tshcy': '\u045B',
        'TSHcy': '\u040B',
        'tstrok': '\u0167',
        'Tstrok': '\u0166',
        'twixt': '\u226C',
        'twoheadleftarrow': '\u219E',
        'twoheadrightarrow': '\u21A0',
        'uacute': '\xFA',
        'Uacute': '\xDA',
        'uarr': '\u2191',
        'uArr': '\u21D1',
        'Uarr': '\u219F',
        'Uarrocir': '\u2949',
        'ubrcy': '\u045E',
        'Ubrcy': '\u040E',
        'ubreve': '\u016D',
        'Ubreve': '\u016C',
        'ucirc': '\xFB',
        'Ucirc': '\xDB',
        'ucy': '\u0443',
        'Ucy': '\u0423',
        'udarr': '\u21C5',
        'udblac': '\u0171',
        'Udblac': '\u0170',
        'udhar': '\u296E',
        'ufisht': '\u297E',
        'ufr': '\uD835\uDD32',
        'Ufr': '\uD835\uDD18',
        'ugrave': '\xF9',
        'Ugrave': '\xD9',
        'uHar': '\u2963',
        'uharl': '\u21BF',
        'uharr': '\u21BE',
        'uhblk': '\u2580',
        'ulcorn': '\u231C',
        'ulcorner': '\u231C',
        'ulcrop': '\u230F',
        'ultri': '\u25F8',
        'umacr': '\u016B',
        'Umacr': '\u016A',
        'uml': '\xA8',
        'UnderBar': '_',
        'UnderBrace': '\u23DF',
        'UnderBracket': '\u23B5',
        'UnderParenthesis': '\u23DD',
        'Union': '\u22C3',
        'UnionPlus': '\u228E',
        'uogon': '\u0173',
        'Uogon': '\u0172',
        'uopf': '\uD835\uDD66',
        'Uopf': '\uD835\uDD4C',
        'uparrow': '\u2191',
        'Uparrow': '\u21D1',
        'UpArrow': '\u2191',
        'UpArrowBar': '\u2912',
        'UpArrowDownArrow': '\u21C5',
        'updownarrow': '\u2195',
        'Updownarrow': '\u21D5',
        'UpDownArrow': '\u2195',
        'UpEquilibrium': '\u296E',
        'upharpoonleft': '\u21BF',
        'upharpoonright': '\u21BE',
        'uplus': '\u228E',
        'UpperLeftArrow': '\u2196',
        'UpperRightArrow': '\u2197',
        'upsi': '\u03C5',
        'Upsi': '\u03D2',
        'upsih': '\u03D2',
        'upsilon': '\u03C5',
        'Upsilon': '\u03A5',
        'UpTee': '\u22A5',
        'UpTeeArrow': '\u21A5',
        'upuparrows': '\u21C8',
        'urcorn': '\u231D',
        'urcorner': '\u231D',
        'urcrop': '\u230E',
        'uring': '\u016F',
        'Uring': '\u016E',
        'urtri': '\u25F9',
        'uscr': '\uD835\uDCCA',
        'Uscr': '\uD835\uDCB0',
        'utdot': '\u22F0',
        'utilde': '\u0169',
        'Utilde': '\u0168',
        'utri': '\u25B5',
        'utrif': '\u25B4',
        'uuarr': '\u21C8',
        'uuml': '\xFC',
        'Uuml': '\xDC',
        'uwangle': '\u29A7',
        'vangrt': '\u299C',
        'varepsilon': '\u03F5',
        'varkappa': '\u03F0',
        'varnothing': '\u2205',
        'varphi': '\u03D5',
        'varpi': '\u03D6',
        'varpropto': '\u221D',
        'varr': '\u2195',
        'vArr': '\u21D5',
        'varrho': '\u03F1',
        'varsigma': '\u03C2',
        'varsubsetneq': '\u228A\uFE00',
        'varsubsetneqq': '\u2ACB\uFE00',
        'varsupsetneq': '\u228B\uFE00',
        'varsupsetneqq': '\u2ACC\uFE00',
        'vartheta': '\u03D1',
        'vartriangleleft': '\u22B2',
        'vartriangleright': '\u22B3',
        'vBar': '\u2AE8',
        'Vbar': '\u2AEB',
        'vBarv': '\u2AE9',
        'vcy': '\u0432',
        'Vcy': '\u0412',
        'vdash': '\u22A2',
        'vDash': '\u22A8',
        'Vdash': '\u22A9',
        'VDash': '\u22AB',
        'Vdashl': '\u2AE6',
        'vee': '\u2228',
        'Vee': '\u22C1',
        'veebar': '\u22BB',
        'veeeq': '\u225A',
        'vellip': '\u22EE',
        'verbar': '|',
        'Verbar': '\u2016',
        'vert': '|',
        'Vert': '\u2016',
        'VerticalBar': '\u2223',
        'VerticalLine': '|',
        'VerticalSeparator': '\u2758',
        'VerticalTilde': '\u2240',
        'VeryThinSpace': '\u200A',
        'vfr': '\uD835\uDD33',
        'Vfr': '\uD835\uDD19',
        'vltri': '\u22B2',
        'vnsub': '\u2282\u20D2',
        'vnsup': '\u2283\u20D2',
        'vopf': '\uD835\uDD67',
        'Vopf': '\uD835\uDD4D',
        'vprop': '\u221D',
        'vrtri': '\u22B3',
        'vscr': '\uD835\uDCCB',
        'Vscr': '\uD835\uDCB1',
        'vsubne': '\u228A\uFE00',
        'vsubnE': '\u2ACB\uFE00',
        'vsupne': '\u228B\uFE00',
        'vsupnE': '\u2ACC\uFE00',
        'Vvdash': '\u22AA',
        'vzigzag': '\u299A',
        'wcirc': '\u0175',
        'Wcirc': '\u0174',
        'wedbar': '\u2A5F',
        'wedge': '\u2227',
        'Wedge': '\u22C0',
        'wedgeq': '\u2259',
        'weierp': '\u2118',
        'wfr': '\uD835\uDD34',
        'Wfr': '\uD835\uDD1A',
        'wopf': '\uD835\uDD68',
        'Wopf': '\uD835\uDD4E',
        'wp': '\u2118',
        'wr': '\u2240',
        'wreath': '\u2240',
        'wscr': '\uD835\uDCCC',
        'Wscr': '\uD835\uDCB2',
        'xcap': '\u22C2',
        'xcirc': '\u25EF',
        'xcup': '\u22C3',
        'xdtri': '\u25BD',
        'xfr': '\uD835\uDD35',
        'Xfr': '\uD835\uDD1B',
        'xharr': '\u27F7',
        'xhArr': '\u27FA',
        'xi': '\u03BE',
        'Xi': '\u039E',
        'xlarr': '\u27F5',
        'xlArr': '\u27F8',
        'xmap': '\u27FC',
        'xnis': '\u22FB',
        'xodot': '\u2A00',
        'xopf': '\uD835\uDD69',
        'Xopf': '\uD835\uDD4F',
        'xoplus': '\u2A01',
        'xotime': '\u2A02',
        'xrarr': '\u27F6',
        'xrArr': '\u27F9',
        'xscr': '\uD835\uDCCD',
        'Xscr': '\uD835\uDCB3',
        'xsqcup': '\u2A06',
        'xuplus': '\u2A04',
        'xutri': '\u25B3',
        'xvee': '\u22C1',
        'xwedge': '\u22C0',
        'yacute': '\xFD',
        'Yacute': '\xDD',
        'yacy': '\u044F',
        'YAcy': '\u042F',
        'ycirc': '\u0177',
        'Ycirc': '\u0176',
        'ycy': '\u044B',
        'Ycy': '\u042B',
        'yen': '\xA5',
        'yfr': '\uD835\uDD36',
        'Yfr': '\uD835\uDD1C',
        'yicy': '\u0457',
        'YIcy': '\u0407',
        'yopf': '\uD835\uDD6A',
        'Yopf': '\uD835\uDD50',
        'yscr': '\uD835\uDCCE',
        'Yscr': '\uD835\uDCB4',
        'yucy': '\u044E',
        'YUcy': '\u042E',
        'yuml': '\xFF',
        'Yuml': '\u0178',
        'zacute': '\u017A',
        'Zacute': '\u0179',
        'zcaron': '\u017E',
        'Zcaron': '\u017D',
        'zcy': '\u0437',
        'Zcy': '\u0417',
        'zdot': '\u017C',
        'Zdot': '\u017B',
        'zeetrf': '\u2128',
        'ZeroWidthSpace': '\u200B',
        'zeta': '\u03B6',
        'Zeta': '\u0396',
        'zfr': '\uD835\uDD37',
        'Zfr': '\u2128',
        'zhcy': '\u0436',
        'ZHcy': '\u0416',
        'zigrarr': '\u21DD',
        'zopf': '\uD835\uDD6B',
        'Zopf': '\u2124',
        'zscr': '\uD835\uDCCF',
        'Zscr': '\uD835\uDCB5',
        'zwj': '\u200D',
        'zwnj': '\u200C'
      };
      var decodeMapLegacy = {
        'aacute': '\xE1',
        'Aacute': '\xC1',
        'acirc': '\xE2',
        'Acirc': '\xC2',
        'acute': '\xB4',
        'aelig': '\xE6',
        'AElig': '\xC6',
        'agrave': '\xE0',
        'Agrave': '\xC0',
        'amp': '&',
        'AMP': '&',
        'aring': '\xE5',
        'Aring': '\xC5',
        'atilde': '\xE3',
        'Atilde': '\xC3',
        'auml': '\xE4',
        'Auml': '\xC4',
        'brvbar': '\xA6',
        'ccedil': '\xE7',
        'Ccedil': '\xC7',
        'cedil': '\xB8',
        'cent': '\xA2',
        'copy': '\xA9',
        'COPY': '\xA9',
        'curren': '\xA4',
        'deg': '\xB0',
        'divide': '\xF7',
        'eacute': '\xE9',
        'Eacute': '\xC9',
        'ecirc': '\xEA',
        'Ecirc': '\xCA',
        'egrave': '\xE8',
        'Egrave': '\xC8',
        'eth': '\xF0',
        'ETH': '\xD0',
        'euml': '\xEB',
        'Euml': '\xCB',
        'frac12': '\xBD',
        'frac14': '\xBC',
        'frac34': '\xBE',
        'gt': '>',
        'GT': '>',
        'iacute': '\xED',
        'Iacute': '\xCD',
        'icirc': '\xEE',
        'Icirc': '\xCE',
        'iexcl': '\xA1',
        'igrave': '\xEC',
        'Igrave': '\xCC',
        'iquest': '\xBF',
        'iuml': '\xEF',
        'Iuml': '\xCF',
        'laquo': '\xAB',
        'lt': '<',
        'LT': '<',
        'macr': '\xAF',
        'micro': '\xB5',
        'middot': '\xB7',
        'nbsp': '\xA0',
        'not': '\xAC',
        'ntilde': '\xF1',
        'Ntilde': '\xD1',
        'oacute': '\xF3',
        'Oacute': '\xD3',
        'ocirc': '\xF4',
        'Ocirc': '\xD4',
        'ograve': '\xF2',
        'Ograve': '\xD2',
        'ordf': '\xAA',
        'ordm': '\xBA',
        'oslash': '\xF8',
        'Oslash': '\xD8',
        'otilde': '\xF5',
        'Otilde': '\xD5',
        'ouml': '\xF6',
        'Ouml': '\xD6',
        'para': '\xB6',
        'plusmn': '\xB1',
        'pound': '\xA3',
        'quot': '"',
        'QUOT': '"',
        'raquo': '\xBB',
        'reg': '\xAE',
        'REG': '\xAE',
        'sect': '\xA7',
        'shy': '\xAD',
        'sup1': '\xB9',
        'sup2': '\xB2',
        'sup3': '\xB3',
        'szlig': '\xDF',
        'thorn': '\xFE',
        'THORN': '\xDE',
        'times': '\xD7',
        'uacute': '\xFA',
        'Uacute': '\xDA',
        'ucirc': '\xFB',
        'Ucirc': '\xDB',
        'ugrave': '\xF9',
        'Ugrave': '\xD9',
        'uml': '\xA8',
        'uuml': '\xFC',
        'Uuml': '\xDC',
        'yacute': '\xFD',
        'Yacute': '\xDD',
        'yen': '\xA5',
        'yuml': '\xFF'
      };
      var decodeMapNumeric = {
        '0': '\uFFFD',
        '128': '\u20AC',
        '130': '\u201A',
        '131': '\u0192',
        '132': '\u201E',
        '133': '\u2026',
        '134': '\u2020',
        '135': '\u2021',
        '136': '\u02C6',
        '137': '\u2030',
        '138': '\u0160',
        '139': '\u2039',
        '140': '\u0152',
        '142': '\u017D',
        '145': '\u2018',
        '146': '\u2019',
        '147': '\u201C',
        '148': '\u201D',
        '149': '\u2022',
        '150': '\u2013',
        '151': '\u2014',
        '152': '\u02DC',
        '153': '\u2122',
        '154': '\u0161',
        '155': '\u203A',
        '156': '\u0153',
        '158': '\u017E',
        '159': '\u0178'
      };
      var invalidReferenceCodePoints = [1, 2, 3, 4, 5, 6, 7, 8, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 64976, 64977, 64978, 64979, 64980, 64981, 64982, 64983, 64984, 64985, 64986, 64987, 64988, 64989, 64990, 64991, 64992, 64993, 64994, 64995, 64996, 64997, 64998, 64999, 65000, 65001, 65002, 65003, 65004, 65005, 65006, 65007, 65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111];

      /*--------------------------------------------------------------------------*/

      var stringFromCharCode = String.fromCharCode;
      var object = {};
      var hasOwnProperty = object.hasOwnProperty;
      var has = function (object, propertyName) {
        return hasOwnProperty.call(object, propertyName);
      };
      var contains = function (array, value) {
        var index = -1;
        var length = array.length;
        while (++index < length) {
          if (array[index] == value) {
            return true;
          }
        }
        return false;
      };
      var merge = function (options, defaults) {
        if (!options) {
          return defaults;
        }
        var result = {};
        var key;
        for (key in defaults) {
          // A `hasOwnProperty` check is not needed here, since only recognized
          // option names are used anyway. Any others are ignored.
          result[key] = has(options, key) ? options[key] : defaults[key];
        }
        return result;
      };

      // Modified version of `ucs2encode`; see https://mths.be/punycode.
      var codePointToSymbol = function (codePoint, strict) {
        var output = '';
        if (codePoint >= 0xD800 && codePoint <= 0xDFFF || codePoint > 0x10FFFF) {
          // See issue #4:
          // Otherwise, if the number is in the range 0xD800 to 0xDFFF or is
          // greater than 0x10FFFF, then this is a parse error. Return a U+FFFD
          // REPLACEMENT CHARACTER.
          if (strict) {
            parseError('character reference outside the permissible Unicode range');
          }
          return '\uFFFD';
        }
        if (has(decodeMapNumeric, codePoint)) {
          if (strict) {
            parseError('disallowed character reference');
          }
          return decodeMapNumeric[codePoint];
        }
        if (strict && contains(invalidReferenceCodePoints, codePoint)) {
          parseError('disallowed character reference');
        }
        if (codePoint > 0xFFFF) {
          codePoint -= 0x10000;
          output += stringFromCharCode(codePoint >>> 10 & 0x3FF | 0xD800);
          codePoint = 0xDC00 | codePoint & 0x3FF;
        }
        output += stringFromCharCode(codePoint);
        return output;
      };
      var hexEscape = function (codePoint) {
        return '&#x' + codePoint.toString(16).toUpperCase() + ';';
      };
      var decEscape = function (codePoint) {
        return '&#' + codePoint + ';';
      };
      var parseError = function (message) {
        throw Error('Parse error: ' + message);
      };

      /*--------------------------------------------------------------------------*/

      var encode = function (string, options) {
        options = merge(options, encode.options);
        var strict = options.strict;
        if (strict && regexInvalidRawCodePoint.test(string)) {
          parseError('forbidden code point');
        }
        var encodeEverything = options.encodeEverything;
        var useNamedReferences = options.useNamedReferences;
        var allowUnsafeSymbols = options.allowUnsafeSymbols;
        var escapeCodePoint = options.decimal ? decEscape : hexEscape;
        var escapeBmpSymbol = function (symbol) {
          return escapeCodePoint(symbol.charCodeAt(0));
        };
        if (encodeEverything) {
          // Encode ASCII symbols.
          string = string.replace(regexAsciiWhitelist, function (symbol) {
            // Use named references if requested & possible.
            if (useNamedReferences && has(encodeMap, symbol)) {
              return '&' + encodeMap[symbol] + ';';
            }
            return escapeBmpSymbol(symbol);
          });
          // Shorten a few escapes that represent two symbols, of which at least one
          // is within the ASCII range.
          if (useNamedReferences) {
            string = string.replace(/&gt;\u20D2/g, '&nvgt;').replace(/&lt;\u20D2/g, '&nvlt;').replace(/&#x66;&#x6A;/g, '&fjlig;');
          }
          // Encode non-ASCII symbols.
          if (useNamedReferences) {
            // Encode non-ASCII symbols that can be replaced with a named reference.
            string = string.replace(regexEncodeNonAscii, function (string) {
              // Note: there is no need to check `has(encodeMap, string)` here.
              return '&' + encodeMap[string] + ';';
            });
          }
          // Note: any remaining non-ASCII symbols are handled outside of the `if`.
        } else if (useNamedReferences) {
          // Apply named character references.
          // Encode `<>"'&` using named character references.
          if (!allowUnsafeSymbols) {
            string = string.replace(regexEscape, function (string) {
              return '&' + encodeMap[string] + ';'; // no need to check `has()` here
            });
          }
          // Shorten escapes that represent two symbols, of which at least one is
          // `<>"'&`.
          string = string.replace(/&gt;\u20D2/g, '&nvgt;').replace(/&lt;\u20D2/g, '&nvlt;');
          // Encode non-ASCII symbols that can be replaced with a named reference.
          string = string.replace(regexEncodeNonAscii, function (string) {
            // Note: there is no need to check `has(encodeMap, string)` here.
            return '&' + encodeMap[string] + ';';
          });
        } else if (!allowUnsafeSymbols) {
          // Encode `<>"'&` using hexadecimal escapes, now that theyre not handled
          // using named character references.
          string = string.replace(regexEscape, escapeBmpSymbol);
        }
        return string
        // Encode astral symbols.
        .replace(regexAstralSymbols, function ($0) {
          // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
          var high = $0.charCodeAt(0);
          var low = $0.charCodeAt(1);
          var codePoint = (high - 0xD800) * 0x400 + low - 0xDC00 + 0x10000;
          return escapeCodePoint(codePoint);
        })
        // Encode any remaining BMP symbols that are not printable ASCII symbols
        // using a hexadecimal escape.
        .replace(regexBmpWhitelist, escapeBmpSymbol);
      };
      // Expose default options (so they can be overridden globally).
      encode.options = {
        'allowUnsafeSymbols': false,
        'encodeEverything': false,
        'strict': false,
        'useNamedReferences': false,
        'decimal': false
      };
      var decode = function (html, options) {
        options = merge(options, decode.options);
        var strict = options.strict;
        if (strict && regexInvalidEntity.test(html)) {
          parseError('malformed character reference');
        }
        return html.replace(regexDecode, function ($0, $1, $2, $3, $4, $5, $6, $7, $8) {
          var codePoint;
          var semicolon;
          var decDigits;
          var hexDigits;
          var reference;
          var next;
          if ($1) {
            reference = $1;
            // Note: there is no need to check `has(decodeMap, reference)`.
            return decodeMap[reference];
          }
          if ($2) {
            // Decode named character references without trailing `;`, e.g. `&amp`.
            // This is only a parse error if it gets converted to `&`, or if it is
            // followed by `=` in an attribute context.
            reference = $2;
            next = $3;
            if (next && options.isAttributeValue) {
              if (strict && next == '=') {
                parseError('`&` did not start a character reference');
              }
              return $0;
            } else {
              if (strict) {
                parseError('named character reference was not terminated by a semicolon');
              }
              // Note: there is no need to check `has(decodeMapLegacy, reference)`.
              return decodeMapLegacy[reference] + (next || '');
            }
          }
          if ($4) {
            // Decode decimal escapes, e.g. `&#119558;`.
            decDigits = $4;
            semicolon = $5;
            if (strict && !semicolon) {
              parseError('character reference was not terminated by a semicolon');
            }
            codePoint = parseInt(decDigits, 10);
            return codePointToSymbol(codePoint, strict);
          }
          if ($6) {
            // Decode hexadecimal escapes, e.g. `&#x1D306;`.
            hexDigits = $6;
            semicolon = $7;
            if (strict && !semicolon) {
              parseError('character reference was not terminated by a semicolon');
            }
            codePoint = parseInt(hexDigits, 16);
            return codePointToSymbol(codePoint, strict);
          }

          // If were still here, `if ($7)` is implied; its an ambiguous
          // ampersand for sure. https://mths.be/notes/ambiguous-ampersands
          if (strict) {
            parseError('named character reference was not terminated by a semicolon');
          }
          return $0;
        });
      };
      // Expose default options (so they can be overridden globally).
      decode.options = {
        'isAttributeValue': false,
        'strict': false
      };
      var escape = function (string) {
        return string.replace(regexEscape, function ($0) {
          // Note: there is no need to check `has(escapeMap, $0)` here.
          return escapeMap[$0];
        });
      };

      /*--------------------------------------------------------------------------*/

      var he = {
        'version': '1.2.0',
        'encode': encode,
        'decode': decode,
        'escape': escape,
        'unescape': decode
      };

      // Some AMD build optimizers, like r.js, check for specific condition patterns
      // like the following:
      if (freeExports && !freeExports.nodeType) {
        if (freeModule) {
          // in Node.js, io.js, or RingoJS v0.8.0+
          freeModule.exports = he;
        } else {
          // in Narwhal or RingoJS v0.7.0-
          for (var key in he) {
            has(he, key) && (freeExports[key] = he[key]);
          }
        }
      } else {
        // in Rhino or a web browser
        root.he = he;
      }
    })(he);
  })(he$1, he$1.exports);
  return he$1.exports;
}

var htmlparser = {};

var utils$3 = {};

var hasRequiredUtils$3;
function requireUtils$3() {
  if (hasRequiredUtils$3) return utils$3;
  hasRequiredUtils$3 = 1;
  function createMap(values, ignoreCase) {
    var map = {};
    values.forEach(function (value) {
      map[value] = 1;
    });
    return ignoreCase ? function (value) {
      return map[value.toLowerCase()] === 1;
    } : function (value) {
      return map[value] === 1;
    };
  }
  utils$3.createMap = createMap;
  utils$3.createMapFromString = function (values, ignoreCase) {
    return createMap(values.split(/,/), ignoreCase);
  };
  return utils$3;
}

/*!
 * HTML Parser By John Resig (ejohn.org)
 * Modified by Juriy "kangax" Zaytsev
 * Original code by Erik Arvidsson, Mozilla Public License
 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
 */
var hasRequiredHtmlparser;
function requireHtmlparser() {
  if (hasRequiredHtmlparser) return htmlparser;
  hasRequiredHtmlparser = 1;
  var createMapFromString = requireUtils$3().createMapFromString;
  function makeMap(values) {
    return createMapFromString(values, true);
  }

  // Regular Expressions for parsing tags and attributes
  var singleAttrIdentifier = /([^\s"'<>/=]+)/,
    singleAttrAssigns = [/=/],
    singleAttrValues = [
    // attr value double quotes
    /"([^"]*)"+/.source,
    // attr value, single quotes
    /'([^']*)'+/.source,
    // attr value, no quotes
    /([^ \t\n\f\r"'`=<>]+)/.source],
    // https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
    qnameCapture = function () {
      // based on https://www.npmjs.com/package/ncname
      var combiningChar = '\\u0300-\\u0345\\u0360\\u0361\\u0483-\\u0486\\u0591-\\u05A1\\u05A3-\\u05B9\\u05BB-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u064B-\\u0652\\u0670\\u06D6-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0901-\\u0903\\u093C\\u093E-\\u094D\\u0951-\\u0954\\u0962\\u0963\\u0981-\\u0983\\u09BC\\u09BE-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CD\\u09D7\\u09E2\\u09E3\\u0A02\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A70\\u0A71\\u0A81-\\u0A83\\u0ABC\\u0ABE-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0B01-\\u0B03\\u0B3C\\u0B3E-\\u0B43\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B82\\u0B83\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7\\u0C01-\\u0C03\\u0C3E-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C82\\u0C83\\u0CBE-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0D02\\u0D03\\u0D3E-\\u0D43\\u0D46-\\u0D48\\u0D4A-\\u0D4D\\u0D57\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F3E\\u0F3F\\u0F71-\\u0F84\\u0F86-\\u0F8B\\u0F90-\\u0F95\\u0F97\\u0F99-\\u0FAD\\u0FB1-\\u0FB7\\u0FB9\\u20D0-\\u20DC\\u20E1\\u302A-\\u302F\\u3099\\u309A';
      var digit = '0-9\\u0660-\\u0669\\u06F0-\\u06F9\\u0966-\\u096F\\u09E6-\\u09EF\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0BE7-\\u0BEF\\u0C66-\\u0C6F\\u0CE6-\\u0CEF\\u0D66-\\u0D6F\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F29';
      var extender = '\\xB7\\u02D0\\u02D1\\u0387\\u0640\\u0E46\\u0EC6\\u3005\\u3031-\\u3035\\u309D\\u309E\\u30FC-\\u30FE';
      var letter = 'A-Za-z\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u0131\\u0134-\\u013E\\u0141-\\u0148\\u014A-\\u017E\\u0180-\\u01C3\\u01CD-\\u01F0\\u01F4\\u01F5\\u01FA-\\u0217\\u0250-\\u02A8\\u02BB-\\u02C1\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03CE\\u03D0-\\u03D6\\u03DA\\u03DC\\u03DE\\u03E0\\u03E2-\\u03F3\\u0401-\\u040C\\u040E-\\u044F\\u0451-\\u045C\\u045E-\\u0481\\u0490-\\u04C4\\u04C7\\u04C8\\u04CB\\u04CC\\u04D0-\\u04EB\\u04EE-\\u04F5\\u04F8\\u04F9\\u0531-\\u0556\\u0559\\u0561-\\u0586\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0621-\\u063A\\u0641-\\u064A\\u0671-\\u06B7\\u06BA-\\u06BE\\u06C0-\\u06CE\\u06D0-\\u06D3\\u06D5\\u06E5\\u06E6\\u0905-\\u0939\\u093D\\u0958-\\u0961\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8B\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AE0\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B36-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB5\\u0BB7-\\u0BB9\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CDE\\u0CE0\\u0CE1\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D28\\u0D2A-\\u0D39\\u0D60\\u0D61\\u0E01-\\u0E2E\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E45\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD\\u0EAE\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0F40-\\u0F47\\u0F49-\\u0F69\\u10A0-\\u10C5\\u10D0-\\u10F6\\u1100\\u1102\\u1103\\u1105-\\u1107\\u1109\\u110B\\u110C\\u110E-\\u1112\\u113C\\u113E\\u1140\\u114C\\u114E\\u1150\\u1154\\u1155\\u1159\\u115F-\\u1161\\u1163\\u1165\\u1167\\u1169\\u116D\\u116E\\u1172\\u1173\\u1175\\u119E\\u11A8\\u11AB\\u11AE\\u11AF\\u11B7\\u11B8\\u11BA\\u11BC-\\u11C2\\u11EB\\u11F0\\u11F9\\u1E00-\\u1E9B\\u1EA0-\\u1EF9\\u1F00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2126\\u212A\\u212B\\u212E\\u2180-\\u2182\\u3007\\u3021-\\u3029\\u3041-\\u3094\\u30A1-\\u30FA\\u3105-\\u312C\\u4E00-\\u9FA5\\uAC00-\\uD7A3';
      var ncname = '[' + letter + '_][' + letter + digit + '\\.\\-_' + combiningChar + extender + ']*';
      return '((?:' + ncname + '\\:)?' + ncname + ')';
    }(),
    startTagOpen = new RegExp('^<' + qnameCapture),
    startTagClose = /^\s*(\/?)>/,
    endTag = new RegExp('^<\\/' + qnameCapture + '[^>]*>'),
    doctype = /^<!DOCTYPE\s?[^>]+>/i;
  var IS_REGEX_CAPTURING_BROKEN = false;
  'x'.replace(/x(.)?/g, function (m, g) {
    IS_REGEX_CAPTURING_BROKEN = g === '';
  });

  // Empty Elements
  var empty = makeMap('area,base,basefont,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr');

  // Inline Elements
  var inline = makeMap('a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,noscript,object,q,s,samp,script,select,small,span,strike,strong,sub,sup,svg,textarea,tt,u,var');

  // Elements that you can, intentionally, leave open
  // (and which close themselves)
  var closeSelf = makeMap('colgroup,dd,dt,li,option,p,td,tfoot,th,thead,tr,source');

  // Attributes that have their values filled in disabled='disabled'
  var fillAttrs = makeMap('checked,compact,declare,defer,disabled,ismap,multiple,nohref,noresize,noshade,nowrap,readonly,selected');

  // Special Elements (can contain anything)
  var special = makeMap('script,style');

  // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
  // Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
  var nonPhrasing = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,ol,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track,ul');
  var reCache = {};
  function attrForHandler(handler) {
    var pattern = singleAttrIdentifier.source + '(?:\\s*(' + joinSingleAttrAssigns(handler) + ')' + '[ \\t\\n\\f\\r]*(?:' + singleAttrValues.join('|') + '))?';
    if (handler.customAttrSurround) {
      var attrClauses = [];
      for (var i = handler.customAttrSurround.length - 1; i >= 0; i--) {
        attrClauses[i] = '(?:' + '(' + handler.customAttrSurround[i][0].source + ')\\s*' + pattern + '\\s*(' + handler.customAttrSurround[i][1].source + ')' + ')';
      }
      attrClauses.push('(?:' + pattern + ')');
      pattern = '(?:' + attrClauses.join('|') + ')';
    }
    return new RegExp('^\\s*' + pattern);
  }
  function joinSingleAttrAssigns(handler) {
    return singleAttrAssigns.concat(handler.customAttrAssign || []).map(function (assign) {
      return '(?:' + assign.source + ')';
    }).join('|');
  }
  function HTMLParser(html, handler) {
    var stack = [],
      lastTag;
    var attribute = attrForHandler(handler);
    var last, prevTag, nextTag;
    while (html) {
      last = html;
      // Make sure we're not in a script or style element
      if (!lastTag || !special(lastTag)) {
        var textEnd = html.indexOf('<');
        if (textEnd === 0) {
          // Comment:
          if (/^<!--/.test(html)) {
            var commentEnd = html.indexOf('-->');
            if (commentEnd >= 0) {
              if (handler.comment) {
                handler.comment(html.substring(4, commentEnd));
              }
              html = html.substring(commentEnd + 3);
              prevTag = '';
              continue;
            }
          }

          // https://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
          if (/^<!\[/.test(html)) {
            var conditionalEnd = html.indexOf(']>');
            if (conditionalEnd >= 0) {
              if (handler.comment) {
                handler.comment(html.substring(2, conditionalEnd + 1), true /* non-standard */);
              }
              html = html.substring(conditionalEnd + 2);
              prevTag = '';
              continue;
            }
          }

          // Doctype:
          var doctypeMatch = html.match(doctype);
          if (doctypeMatch) {
            if (handler.doctype) {
              handler.doctype(doctypeMatch[0]);
            }
            html = html.substring(doctypeMatch[0].length);
            prevTag = '';
            continue;
          }

          // End tag:
          var endTagMatch = html.match(endTag);
          if (endTagMatch) {
            html = html.substring(endTagMatch[0].length);
            endTagMatch[0].replace(endTag, parseEndTag);
            prevTag = '/' + endTagMatch[1].toLowerCase();
            continue;
          }

          // Start tag:
          var startTagMatch = parseStartTag(html);
          if (startTagMatch) {
            html = startTagMatch.rest;
            handleStartTag(startTagMatch);
            prevTag = startTagMatch.tagName.toLowerCase();
            continue;
          }

          // Treat `<` as text
          if (handler.continueOnParseError) {
            textEnd = html.indexOf('<', 1);
          }
        }
        var text;
        if (textEnd >= 0) {
          text = html.substring(0, textEnd);
          html = html.substring(textEnd);
        } else {
          text = html;
          html = '';
        }

        // next tag
        var nextTagMatch = parseStartTag(html);
        if (nextTagMatch) {
          nextTag = nextTagMatch.tagName;
        } else {
          nextTagMatch = html.match(endTag);
          if (nextTagMatch) {
            nextTag = '/' + nextTagMatch[1];
          } else {
            nextTag = '';
          }
        }
        if (handler.chars) {
          handler.chars(text, prevTag, nextTag);
        }
        prevTag = '';
      } else {
        var stackedTag = lastTag.toLowerCase();
        var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)</' + stackedTag + '[^>]*>', 'i'));
        html = html.replace(reStackedTag, function (all, text) {
          if (stackedTag !== 'script' && stackedTag !== 'style' && stackedTag !== 'noscript') {
            text = text.replace(/<!--([\s\S]*?)-->/g, '$1').replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
          }
          if (handler.chars) {
            handler.chars(text);
          }
          return '';
        });
        parseEndTag('</' + stackedTag + '>', stackedTag);
      }
      if (html === last) {
        throw new Error('Parse Error: ' + html);
      }
    }
    if (!handler.partialMarkup) {
      // Clean up any remaining tags
      parseEndTag();
    }
    function parseStartTag(input) {
      var start = input.match(startTagOpen);
      if (start) {
        var match = {
          tagName: start[1],
          attrs: []
        };
        input = input.slice(start[0].length);
        var end, attr;
        while (!(end = input.match(startTagClose)) && (attr = input.match(attribute))) {
          input = input.slice(attr[0].length);
          match.attrs.push(attr);
        }
        if (end) {
          match.unarySlash = end[1];
          match.rest = input.slice(end[0].length);
          return match;
        }
      }
    }
    function closeIfFound(tagName) {
      if (findTag(tagName) >= 0) {
        parseEndTag('', tagName);
        return true;
      }
    }
    function handleStartTag(match) {
      var tagName = match.tagName;
      var unarySlash = match.unarySlash;
      if (handler.html5) {
        if (lastTag === 'p' && nonPhrasing(tagName)) {
          parseEndTag('', lastTag);
        } else if (tagName === 'tbody') {
          closeIfFound('thead');
        } else if (tagName === 'tfoot') {
          if (!closeIfFound('tbody')) {
            closeIfFound('thead');
          }
        }
        if (tagName === 'col' && findTag('colgroup') < 0) {
          lastTag = 'colgroup';
          stack.push({
            tag: lastTag,
            attrs: []
          });
          if (handler.start) {
            handler.start(lastTag, [], false, '');
          }
        }
      }
      if (!handler.html5 && !inline(tagName)) {
        while (lastTag && inline(lastTag)) {
          parseEndTag('', lastTag);
        }
      }
      if (closeSelf(tagName) && lastTag === tagName) {
        parseEndTag('', tagName);
      }
      var unary = empty(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;
      var attrs = match.attrs.map(function (args) {
        var name, value, customOpen, customClose, customAssign, quote;
        var ncp = 7; // number of captured parts, scalar

        // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778
        if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
          if (args[3] === '') {
            delete args[3];
          }
          if (args[4] === '') {
            delete args[4];
          }
          if (args[5] === '') {
            delete args[5];
          }
        }
        function populate(index) {
          customAssign = args[index];
          value = args[index + 1];
          if (typeof value !== 'undefined') {
            return '"';
          }
          value = args[index + 2];
          if (typeof value !== 'undefined') {
            return '\'';
          }
          value = args[index + 3];
          if (typeof value === 'undefined' && fillAttrs(name)) {
            value = name;
          }
          return '';
        }
        var j = 1;
        if (handler.customAttrSurround) {
          for (var i = 0, l = handler.customAttrSurround.length; i < l; i++, j += ncp) {
            name = args[j + 1];
            if (name) {
              quote = populate(j + 2);
              customOpen = args[j];
              customClose = args[j + 6];
              break;
            }
          }
        }
        if (!name && (name = args[j])) {
          quote = populate(j + 1);
        }
        return {
          name: name,
          value: value,
          customAssign: customAssign || '=',
          customOpen: customOpen || '',
          customClose: customClose || '',
          quote: quote || ''
        };
      });
      if (!unary) {
        stack.push({
          tag: tagName,
          attrs: attrs
        });
        lastTag = tagName;
        unarySlash = '';
      }
      if (handler.start) {
        handler.start(tagName, attrs, unary, unarySlash);
      }
    }
    function findTag(tagName) {
      var pos;
      var needle = tagName.toLowerCase();
      for (pos = stack.length - 1; pos >= 0; pos--) {
        if (stack[pos].tag.toLowerCase() === needle) {
          break;
        }
      }
      return pos;
    }
    function parseEndTag(tag, tagName) {
      var pos;

      // Find the closest opened tag of the same type
      if (tagName) {
        pos = findTag(tagName);
      }
      // If no tag name is provided, clean shop
      else {
        pos = 0;
      }
      if (pos >= 0) {
        // Close all the open elements, up the stack
        for (var i = stack.length - 1; i >= pos; i--) {
          if (handler.end) {
            handler.end(stack[i].tag, stack[i].attrs, i > pos || !tag);
          }
        }

        // Remove the open elements from the stack
        stack.length = pos;
        lastTag = pos && stack[pos - 1].tag;
      } else if (tagName.toLowerCase() === 'br') {
        if (handler.start) {
          handler.start(tagName, [], true, '');
        }
      } else if (tagName.toLowerCase() === 'p') {
        if (handler.start) {
          handler.start(tagName, [], false, '', true);
        }
        if (handler.end) {
          handler.end(tagName, []);
        }
      }
    }
  }
  htmlparser.HTMLParser = HTMLParser;
  htmlparser.HTMLtoXML = function (html) {
    var results = '';
    new HTMLParser(html, {
      start: function (tag, attrs, unary) {
        results += '<' + tag;
        for (var i = 0, len = attrs.length; i < len; i++) {
          results += ' ' + attrs[i].name + '="' + (attrs[i].value || '').replace(/"/g, '&#34;') + '"';
        }
        results += (unary ? '/' : '') + '>';
      },
      end: function (tag) {
        results += '</' + tag + '>';
      },
      chars: function (text) {
        results += text;
      },
      comment: function (text) {
        results += '<!--' + text + '-->';
      },
      ignore: function (text) {
        results += text;
      }
    });
    return results;
  };
  htmlparser.HTMLtoDOM = function (html, doc) {
    // There can be only one of these elements
    var one = {
      html: true,
      head: true,
      body: true,
      title: true
    };

    // Enforce a structure for the document
    var structure = {
      link: 'head',
      base: 'head'
    };
    if (doc) {
      doc = doc.ownerDocument || doc.getOwnerDocument && doc.getOwnerDocument() || doc;
    } else if (typeof DOMDocument !== 'undefined') {
      doc = new DOMDocument();
    } else if (typeof document !== 'undefined' && document.implementation && document.implementation.createDocument) {
      doc = document.implementation.createDocument('', '', null);
    } else if (typeof ActiveX !== 'undefined') {
      doc = new ActiveXObject('Msxml.DOMDocument');
    }
    var elems = [],
      documentElement = doc.documentElement || doc.getDocumentElement && doc.getDocumentElement();

    // If we're dealing with an empty document then we
    // need to pre-populate it with the HTML document structure
    if (!documentElement && doc.createElement) {
      (function () {
        var html = doc.createElement('html');
        var head = doc.createElement('head');
        head.appendChild(doc.createElement('title'));
        html.appendChild(head);
        html.appendChild(doc.createElement('body'));
        doc.appendChild(html);
      })();
    }

    // Find all the unique elements
    if (doc.getElementsByTagName) {
      for (var i in one) {
        one[i] = doc.getElementsByTagName(i)[0];
      }
    }

    // If we're working with a document, inject contents into
    // the body element
    var curParentNode = one.body;
    new HTMLParser(html, {
      start: function (tagName, attrs, unary) {
        // If it's a pre-built element, then we can ignore
        // its construction
        if (one[tagName]) {
          curParentNode = one[tagName];
          return;
        }
        var elem = doc.createElement(tagName);
        for (var attr in attrs) {
          elem.setAttribute(attrs[attr].name, attrs[attr].value);
        }
        if (structure[tagName] && typeof one[structure[tagName]] !== 'boolean') {
          one[structure[tagName]].appendChild(elem);
        } else if (curParentNode && curParentNode.appendChild) {
          curParentNode.appendChild(elem);
        }
        if (!unary) {
          elems.push(elem);
          curParentNode = elem;
        }
      },
      end: function /* tag */
      () {
        elems.length -= 1;

        // Init the new parentNode
        curParentNode = elems[elems.length - 1];
      },
      chars: function (text) {
        curParentNode.appendChild(doc.createTextNode(text));
      },
      comment: function /* text */
      () {
        // create comment node
      },
      ignore: function /* text */
      () {
        // What to do here?
      }
    });
    return doc;
  };
  return htmlparser;
}

var constants$1;
var hasRequiredConstants$1;
function requireConstants$1() {
  if (hasRequiredConstants$1) return constants$1;
  hasRequiredConstants$1 = 1;
  constants$1 = {
    // Output
    ABSOLUTE: "absolute",
    PATH_RELATIVE: "pathRelative",
    ROOT_RELATIVE: "rootRelative",
    SHORTEST: "shortest"
  };
  return constants$1;
}

var format;
var hasRequiredFormat;
function requireFormat() {
  if (hasRequiredFormat) return format;
  hasRequiredFormat = 1;
  var constants = requireConstants$1();
  function formatAuth(urlObj, options) {
    if (urlObj.auth && !options.removeAuth && (urlObj.extra.relation.maximumHost || options.output === constants.ABSOLUTE)) {
      return urlObj.auth + "@";
    }
    return "";
  }
  function formatHash(urlObj, options) {
    return urlObj.hash ? urlObj.hash : "";
  }
  function formatHost(urlObj, options) {
    if (urlObj.host.full && (urlObj.extra.relation.maximumAuth || options.output === constants.ABSOLUTE)) {
      return urlObj.host.full;
    }
    return "";
  }
  function formatPath(urlObj, options) {
    var str = "";
    var absolutePath = urlObj.path.absolute.string;
    var relativePath = urlObj.path.relative.string;
    var resource = showResource(urlObj, options);
    if (urlObj.extra.relation.maximumHost || options.output === constants.ABSOLUTE || options.output === constants.ROOT_RELATIVE) {
      str = absolutePath;
    } else if (relativePath.length <= absolutePath.length && options.output === constants.SHORTEST || options.output === constants.PATH_RELATIVE) {
      str = relativePath;
      if (str === "") {
        var query = showQuery(urlObj, options) && !!getQuery(urlObj, options);
        if (urlObj.extra.relation.maximumPath && !resource) {
          str = "./";
        } else if (urlObj.extra.relation.overridesQuery && !resource && !query) {
          str = "./";
        }
      }
    } else {
      str = absolutePath;
    }
    if (str === "/" && !resource && options.removeRootTrailingSlash && (!urlObj.extra.relation.minimumPort || options.output === constants.ABSOLUTE)) {
      str = "";
    }
    return str;
  }
  function formatPort(urlObj, options) {
    if (urlObj.port && !urlObj.extra.portIsDefault && urlObj.extra.relation.maximumHost) {
      return ":" + urlObj.port;
    }
    return "";
  }
  function formatQuery(urlObj, options) {
    return showQuery(urlObj, options) ? getQuery(urlObj, options) : "";
  }
  function formatResource(urlObj, options) {
    return showResource(urlObj, options) ? urlObj.resource : "";
  }
  function formatScheme(urlObj, options) {
    var str = "";
    if (urlObj.extra.relation.maximumHost || options.output === constants.ABSOLUTE) {
      if (!urlObj.extra.relation.minimumScheme || !options.schemeRelative || options.output === constants.ABSOLUTE) {
        str += urlObj.scheme + "://";
      } else {
        str += "//";
      }
    }
    return str;
  }
  function formatUrl(urlObj, options) {
    var url = "";
    url += formatScheme(urlObj, options);
    url += formatAuth(urlObj, options);
    url += formatHost(urlObj, options);
    url += formatPort(urlObj);
    url += formatPath(urlObj, options);
    url += formatResource(urlObj, options);
    url += formatQuery(urlObj, options);
    url += formatHash(urlObj);
    return url;
  }
  function getQuery(urlObj, options) {
    var stripQuery = options.removeEmptyQueries && urlObj.extra.relation.minimumPort;
    return urlObj.query.string[stripQuery ? "stripped" : "full"];
  }
  function showQuery(urlObj, options) {
    return !urlObj.extra.relation.minimumQuery || options.output === constants.ABSOLUTE || options.output === constants.ROOT_RELATIVE;
  }
  function showResource(urlObj, options) {
    var removeIndex = options.removeDirectoryIndexes && urlObj.extra.resourceIsIndex;
    var removeMatchingResource = urlObj.extra.relation.minimumResource && options.output !== constants.ABSOLUTE && options.output !== constants.ROOT_RELATIVE;
    return !!urlObj.resource && !removeMatchingResource && !removeIndex;
  }
  format = formatUrl;
  return format;
}

var object;
var hasRequiredObject;
function requireObject() {
  if (hasRequiredObject) return object;
  hasRequiredObject = 1;

  /*
  	Deep-clone an object.
  */
  function clone(obj) {
    if (obj instanceof Object) {
      var clonedObj = obj instanceof Array ? [] : {};
      for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
          clonedObj[i] = clone(obj[i]);
        }
      }
      return clonedObj;
    }
    return obj;
  }

  /*
  	https://github.com/jonschlinkert/is-plain-object
  */
  function isPlainObject(obj) {
    return !!obj && typeof obj === "object" && obj.constructor === Object;
  }

  /*
  	Shallow-merge two objects.
  */
  function shallowMerge(target, source) {
    if (target instanceof Object && source instanceof Object) {
      for (var i in source) {
        if (source.hasOwnProperty(i)) {
          target[i] = source[i];
        }
      }
    }
    return target;
  }
  object = {
    clone: clone,
    isPlainObject: isPlainObject,
    shallowMerge: shallowMerge
  };
  return object;
}

var options;
var hasRequiredOptions;
function requireOptions() {
  if (hasRequiredOptions) return options;
  hasRequiredOptions = 1;
  var objUtils = requireObject();
  function getOptions(options, defaults) {
    if (objUtils.isPlainObject(options)) {
      var newOptions = {};
      for (var i in defaults) {
        if (defaults.hasOwnProperty(i)) {
          if (options[i] !== undefined) {
            newOptions[i] = mergeOption(options[i], defaults[i]);
          } else {
            newOptions[i] = defaults[i];
          }
        }
      }
      return newOptions;
    } else {
      return defaults;
    }
  }
  function mergeOption(newValues, defaultValues) {
    if (defaultValues instanceof Object && newValues instanceof Object) {
      if (defaultValues instanceof Array && newValues instanceof Array) {
        return defaultValues.concat(newValues);
      } else {
        return objUtils.shallowMerge(newValues, defaultValues);
      }
    }
    return newValues;
  }
  options = getOptions;
  return options;
}

var hrefInfo_1;
var hasRequiredHrefInfo;
function requireHrefInfo() {
  if (hasRequiredHrefInfo) return hrefInfo_1;
  hasRequiredHrefInfo = 1;
  function hrefInfo(urlObj) {
    var minimumPathOnly = !urlObj.scheme && !urlObj.auth && !urlObj.host.full && !urlObj.port;
    var minimumResourceOnly = minimumPathOnly && !urlObj.path.absolute.string;
    var minimumQueryOnly = minimumResourceOnly && !urlObj.resource;
    var minimumHashOnly = minimumQueryOnly && !urlObj.query.string.full.length;
    var empty = minimumHashOnly && !urlObj.hash;
    urlObj.extra.hrefInfo.minimumPathOnly = minimumPathOnly;
    urlObj.extra.hrefInfo.minimumResourceOnly = minimumResourceOnly;
    urlObj.extra.hrefInfo.minimumQueryOnly = minimumQueryOnly;
    urlObj.extra.hrefInfo.minimumHashOnly = minimumHashOnly;
    urlObj.extra.hrefInfo.empty = empty;
  }
  hrefInfo_1 = hrefInfo;
  return hrefInfo_1;
}

var host;
var hasRequiredHost;
function requireHost() {
  if (hasRequiredHost) return host;
  hasRequiredHost = 1;
  function parseHost(urlObj, options) {
    // TWEAK :: condition only for speed optimization
    if (options.ignore_www) {
      var host = urlObj.host.full;
      if (host) {
        var stripped = host;
        if (host.indexOf("www.") === 0) {
          stripped = host.substr(4);
        }
        urlObj.host.stripped = stripped;
      }
    }
  }
  host = parseHost;
  return host;
}

var path$1;
var hasRequiredPath$1;
function requirePath$1() {
  if (hasRequiredPath$1) return path$1;
  hasRequiredPath$1 = 1;
  function isDirectoryIndex(resource, options) {
    var verdict = false;
    options.directoryIndexes.every(function (index) {
      if (index === resource) {
        verdict = true;
        return false;
      }
      return true;
    });
    return verdict;
  }
  function parsePath(urlObj, options) {
    var path = urlObj.path.absolute.string;
    if (path) {
      var lastSlash = path.lastIndexOf("/");
      if (lastSlash > -1) {
        if (++lastSlash < path.length) {
          var resource = path.substr(lastSlash);
          if (resource !== "." && resource !== "..") {
            urlObj.resource = resource;
            path = path.substr(0, lastSlash);
          } else {
            path += "/";
          }
        }
        urlObj.path.absolute.string = path;
        urlObj.path.absolute.array = splitPath(path);
      } else if (path === "." || path === "..") {
        // "..?var", "..#anchor", etc ... not "..index.html"
        path += "/";
        urlObj.path.absolute.string = path;
        urlObj.path.absolute.array = splitPath(path);
      } else {
        // Resource-only
        urlObj.resource = path;
        urlObj.path.absolute.string = null;
      }
      urlObj.extra.resourceIsIndex = isDirectoryIndex(urlObj.resource, options);
    }
    // Else: query/hash-only or empty
  }
  function splitPath(path) {
    // TWEAK :: condition only for speed optimization
    if (path !== "/") {
      var cleaned = [];
      path.split("/").forEach(function (dir) {
        // Cleanup -- splitting "/dir/" becomes ["","dir",""]
        if (dir !== "") {
          cleaned.push(dir);
        }
      });
      return cleaned;
    } else {
      // Faster to skip the above block and just create an array
      return [];
    }
  }
  path$1 = parsePath;
  return path$1;
}

var port;
var hasRequiredPort;
function requirePort() {
  if (hasRequiredPort) return port;
  hasRequiredPort = 1;
  function parsePort(urlObj, options) {
    var defaultPort = -1;
    for (var i in options.defaultPorts) {
      if (i === urlObj.scheme && options.defaultPorts.hasOwnProperty(i)) {
        defaultPort = options.defaultPorts[i];
        break;
      }
    }
    if (defaultPort > -1) {
      // Force same type as urlObj.port
      defaultPort = defaultPort.toString();
      if (urlObj.port === null) {
        urlObj.port = defaultPort;
      }
      urlObj.extra.portIsDefault = urlObj.port === defaultPort;
    }
  }
  port = parsePort;
  return port;
}

var query;
var hasRequiredQuery;
function requireQuery() {
  if (hasRequiredQuery) return query;
  hasRequiredQuery = 1;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function parseQuery(urlObj, options) {
    urlObj.query.string.full = stringify(urlObj.query.object, false);

    // TWEAK :: condition only for speed optimization
    if (options.removeEmptyQueries) {
      urlObj.query.string.stripped = stringify(urlObj.query.object, true);
    }
  }
  function stringify(queryObj, removeEmptyQueries) {
    var count = 0;
    var str = "";
    for (var i in queryObj) {
      if (i !== "" && hasOwnProperty.call(queryObj, i) === true) {
        var value = queryObj[i];
        if (value !== "" || !removeEmptyQueries) {
          str += ++count === 1 ? "?" : "&";
          i = encodeURIComponent(i);
          if (value !== "") {
            str += i + "=" + encodeURIComponent(value).replace(/%20/g, "+");
          } else {
            str += i;
          }
        }
      }
    }
    return str;
  }
  query = parseQuery;
  return query;
}

var urlstring;
var hasRequiredUrlstring;
function requireUrlstring() {
  if (hasRequiredUrlstring) return urlstring;
  hasRequiredUrlstring = 1;
  var _parseUrl = require$$1$2.parse;

  /*
  	Customize the URL object that Node generates
  	because:
  	
  	* necessary data for later
  	* urlObj.host is useless
  	* urlObj.hostname is too long
  	* urlObj.path is useless
  	* urlObj.pathname is too long
  	* urlObj.protocol is inaccurate; should be called "scheme"
  	* urlObj.search is mostly useless
  */
  function clean(urlObj) {
    var scheme = urlObj.protocol;
    if (scheme) {
      // Remove ":" suffix
      if (scheme.indexOf(":") === scheme.length - 1) {
        scheme = scheme.substr(0, scheme.length - 1);
      }
    }
    urlObj.host = {
      // TODO :: unescape(encodeURIComponent(s)) ? ... http://ecmanaut.blogspot.ca/2006/07/encoding-decoding-utf8-in-javascript.html
      full: urlObj.hostname,
      stripped: null
    };
    urlObj.path = {
      absolute: {
        array: null,
        string: urlObj.pathname
      },
      relative: {
        array: null,
        string: null
      }
    };
    urlObj.query = {
      object: urlObj.query,
      string: {
        full: null,
        stripped: null
      }
    };
    urlObj.extra = {
      hrefInfo: {
        minimumPathOnly: null,
        minimumResourceOnly: null,
        minimumQueryOnly: null,
        minimumHashOnly: null,
        empty: null,
        separatorOnlyQuery: urlObj.search === "?"
      },
      portIsDefault: null,
      relation: {
        maximumScheme: null,
        maximumAuth: null,
        maximumHost: null,
        maximumPort: null,
        maximumPath: null,
        maximumResource: null,
        maximumQuery: null,
        maximumHash: null,
        minimumScheme: null,
        minimumAuth: null,
        minimumHost: null,
        minimumPort: null,
        minimumPath: null,
        minimumResource: null,
        minimumQuery: null,
        minimumHash: null,
        overridesQuery: null
      },
      resourceIsIndex: null,
      slashes: urlObj.slashes
    };
    urlObj.resource = null;
    urlObj.scheme = scheme;
    delete urlObj.hostname;
    delete urlObj.pathname;
    delete urlObj.protocol;
    delete urlObj.search;
    delete urlObj.slashes;
    return urlObj;
  }
  function validScheme(url, options) {
    var valid = true;
    options.rejectedSchemes.every(function (rejectedScheme) {
      valid = !(url.indexOf(rejectedScheme + ":") === 0);

      // Break loop
      return valid;
    });
    return valid;
  }
  function parseUrlString(url, options) {
    if (validScheme(url, options)) {
      return clean(_parseUrl(url, true, options.slashesDenoteHost));
    } else {
      return {
        href: url,
        valid: false
      };
    }
  }
  urlstring = parseUrlString;
  return urlstring;
}

var path;
var hasRequiredPath;
function requirePath() {
  if (hasRequiredPath) return path;
  hasRequiredPath = 1;
  function joinPath(pathArray) {
    if (pathArray.length > 0) {
      return pathArray.join("/") + "/";
    } else {
      return "";
    }
  }
  function resolveDotSegments(pathArray) {
    var pathAbsolute = [];
    pathArray.forEach(function (dir) {
      if (dir !== "..") {
        if (dir !== ".") {
          pathAbsolute.push(dir);
        }
      } else {
        // Remove parent
        if (pathAbsolute.length > 0) {
          pathAbsolute.splice(pathAbsolute.length - 1, 1);
        }
      }
    });
    return pathAbsolute;
  }
  path = {
    join: joinPath,
    resolveDotSegments: resolveDotSegments
  };
  return path;
}

var parse$1;
var hasRequiredParse$1;
function requireParse$1() {
  if (hasRequiredParse$1) return parse$1;
  hasRequiredParse$1 = 1;
  var hrefInfo = requireHrefInfo();
  var parseHost = requireHost();
  var parsePath = requirePath$1();
  var parsePort = requirePort();
  var parseQuery = requireQuery();
  var parseUrlString = requireUrlstring();
  var pathUtils = requirePath();
  function parseFromUrl(url, options, fallback) {
    if (url) {
      var urlObj = parseUrl(url, options);

      // Because the following occurs in the relate stage for "to" URLs,
      // such had to be mostly duplicated here

      var pathArray = pathUtils.resolveDotSegments(urlObj.path.absolute.array);
      urlObj.path.absolute.array = pathArray;
      urlObj.path.absolute.string = "/" + pathUtils.join(pathArray);
      return urlObj;
    } else {
      return fallback;
    }
  }
  function parseUrl(url, options) {
    var urlObj = parseUrlString(url, options);
    if (urlObj.valid === false) return urlObj;
    parseHost(urlObj, options);
    parsePort(urlObj, options);
    parsePath(urlObj, options);
    parseQuery(urlObj, options);
    hrefInfo(urlObj);
    return urlObj;
  }
  parse$1 = {
    from: parseFromUrl,
    to: parseUrl
  };
  return parse$1;
}

var findRelation;
var hasRequiredFindRelation;
function requireFindRelation() {
  if (hasRequiredFindRelation) return findRelation;
  hasRequiredFindRelation = 1;
  function findRelation_upToPath(urlObj, siteUrlObj, options) {
    // Path- or root-relative URL
    var pathOnly = urlObj.extra.hrefInfo.minimumPathOnly;

    // Matching scheme, scheme-relative or path-only
    var minimumScheme = urlObj.scheme === siteUrlObj.scheme || !urlObj.scheme;

    // Matching auth, ignoring auth or path-only
    var minimumAuth = minimumScheme && (urlObj.auth === siteUrlObj.auth || options.removeAuth || pathOnly);

    // Matching host or path-only
    var www = options.ignore_www ? "stripped" : "full";
    var minimumHost = minimumAuth && (urlObj.host[www] === siteUrlObj.host[www] || pathOnly);

    // Matching port or path-only
    var minimumPort = minimumHost && (urlObj.port === siteUrlObj.port || pathOnly);
    urlObj.extra.relation.minimumScheme = minimumScheme;
    urlObj.extra.relation.minimumAuth = minimumAuth;
    urlObj.extra.relation.minimumHost = minimumHost;
    urlObj.extra.relation.minimumPort = minimumPort;
    urlObj.extra.relation.maximumScheme = !minimumScheme || minimumScheme && !minimumAuth;
    urlObj.extra.relation.maximumAuth = !minimumScheme || minimumScheme && !minimumHost;
    urlObj.extra.relation.maximumHost = !minimumScheme || minimumScheme && !minimumPort;
  }
  function findRelation_pathOn(urlObj, siteUrlObj, options) {
    var queryOnly = urlObj.extra.hrefInfo.minimumQueryOnly;
    var hashOnly = urlObj.extra.hrefInfo.minimumHashOnly;
    var empty = urlObj.extra.hrefInfo.empty; // not required, but self-documenting

    // From upToPath()
    var minimumPort = urlObj.extra.relation.minimumPort;
    var minimumScheme = urlObj.extra.relation.minimumScheme;

    // Matching port and path
    var minimumPath = minimumPort && urlObj.path.absolute.string === siteUrlObj.path.absolute.string;

    // Matching resource or query/hash-only or empty
    var matchingResource = urlObj.resource === siteUrlObj.resource || !urlObj.resource && siteUrlObj.extra.resourceIsIndex || options.removeDirectoryIndexes && urlObj.extra.resourceIsIndex && !siteUrlObj.resource;
    var minimumResource = minimumPath && (matchingResource || queryOnly || hashOnly || empty);

    // Matching query or hash-only/empty
    var query = options.removeEmptyQueries ? "stripped" : "full";
    var urlQuery = urlObj.query.string[query];
    var siteUrlQuery = siteUrlObj.query.string[query];
    var minimumQuery = minimumResource && !!urlQuery && urlQuery === siteUrlQuery || (hashOnly || empty) && !urlObj.extra.hrefInfo.separatorOnlyQuery;
    var minimumHash = minimumQuery && urlObj.hash === siteUrlObj.hash;
    urlObj.extra.relation.minimumPath = minimumPath;
    urlObj.extra.relation.minimumResource = minimumResource;
    urlObj.extra.relation.minimumQuery = minimumQuery;
    urlObj.extra.relation.minimumHash = minimumHash;
    urlObj.extra.relation.maximumPort = !minimumScheme || minimumScheme && !minimumPath;
    urlObj.extra.relation.maximumPath = !minimumScheme || minimumScheme && !minimumResource;
    urlObj.extra.relation.maximumResource = !minimumScheme || minimumScheme && !minimumQuery;
    urlObj.extra.relation.maximumQuery = !minimumScheme || minimumScheme && !minimumHash;
    urlObj.extra.relation.maximumHash = !minimumScheme || minimumScheme && !minimumHash; // there's nothing after hash, so it's the same as maximumQuery

    // Matching path and/or resource with existing but non-matching site query
    urlObj.extra.relation.overridesQuery = minimumPath && urlObj.extra.relation.maximumResource && !minimumQuery && !!siteUrlQuery;
  }
  findRelation = {
    pathOn: findRelation_pathOn,
    upToPath: findRelation_upToPath
  };
  return findRelation;
}

var absolutize_1;
var hasRequiredAbsolutize;
function requireAbsolutize() {
  if (hasRequiredAbsolutize) return absolutize_1;
  hasRequiredAbsolutize = 1;
  var findRelation = requireFindRelation();
  var objUtils = requireObject();
  var pathUtils = requirePath();
  function absolutize(urlObj, siteUrlObj, options) {
    findRelation.upToPath(urlObj, siteUrlObj, options);

    // Fill in relative URLs
    if (urlObj.extra.relation.minimumScheme) urlObj.scheme = siteUrlObj.scheme;
    if (urlObj.extra.relation.minimumAuth) urlObj.auth = siteUrlObj.auth;
    if (urlObj.extra.relation.minimumHost) urlObj.host = objUtils.clone(siteUrlObj.host);
    if (urlObj.extra.relation.minimumPort) copyPort(urlObj, siteUrlObj);
    if (urlObj.extra.relation.minimumScheme) copyPath(urlObj, siteUrlObj);

    // Check remaining relativeness now that path has been copied and/or resolved
    findRelation.pathOn(urlObj, siteUrlObj, options);

    // Fill in relative URLs
    if (urlObj.extra.relation.minimumResource) copyResource(urlObj, siteUrlObj);
    if (urlObj.extra.relation.minimumQuery) urlObj.query = objUtils.clone(siteUrlObj.query);
    if (urlObj.extra.relation.minimumHash) urlObj.hash = siteUrlObj.hash;
  }

  /*
  	Get an absolute path that's relative to site url.
  */
  function copyPath(urlObj, siteUrlObj) {
    if (urlObj.extra.relation.maximumHost || !urlObj.extra.hrefInfo.minimumResourceOnly) {
      var pathArray = urlObj.path.absolute.array;
      var pathString = "/";

      // If not erroneous URL
      if (pathArray) {
        // If is relative path
        if (urlObj.extra.hrefInfo.minimumPathOnly && urlObj.path.absolute.string.indexOf("/") !== 0) {
          // Append path to site path
          pathArray = siteUrlObj.path.absolute.array.concat(pathArray);
        }
        pathArray = pathUtils.resolveDotSegments(pathArray);
        pathString += pathUtils.join(pathArray);
      } else {
        pathArray = [];
      }
      urlObj.path.absolute.array = pathArray;
      urlObj.path.absolute.string = pathString;
    } else {
      // Resource-, query- or hash-only or empty
      urlObj.path = objUtils.clone(siteUrlObj.path);
    }
  }
  function copyPort(urlObj, siteUrlObj) {
    urlObj.port = siteUrlObj.port;
    urlObj.extra.portIsDefault = siteUrlObj.extra.portIsDefault;
  }
  function copyResource(urlObj, siteUrlObj) {
    urlObj.resource = siteUrlObj.resource;
    urlObj.extra.resourceIsIndex = siteUrlObj.extra.resourceIsIndex;
  }
  absolutize_1 = absolutize;
  return absolutize_1;
}

var relativize_1;
var hasRequiredRelativize;
function requireRelativize() {
  if (hasRequiredRelativize) return relativize_1;
  hasRequiredRelativize = 1;
  var pathUtils = requirePath();

  /*
  	Get a path relative to the site path.
  */
  function relatePath(absolutePath, siteAbsolutePath) {
    var relativePath = [];

    // At this point, it's related to the host/port
    var related = true;
    var parentIndex = -1;

    // Find parents
    siteAbsolutePath.forEach(function (siteAbsoluteDir, i) {
      if (related) {
        if (absolutePath[i] !== siteAbsoluteDir) {
          related = false;
        } else {
          parentIndex = i;
        }
      }
      if (!related) {
        // Up one level
        relativePath.push("..");
      }
    });

    // Form path
    absolutePath.forEach(function (dir, i) {
      if (i > parentIndex) {
        relativePath.push(dir);
      }
    });
    return relativePath;
  }
  function relativize(urlObj, siteUrlObj, options) {
    if (urlObj.extra.relation.minimumScheme) {
      var pathArray = relatePath(urlObj.path.absolute.array, siteUrlObj.path.absolute.array);
      urlObj.path.relative.array = pathArray;
      urlObj.path.relative.string = pathUtils.join(pathArray);
    }
  }
  relativize_1 = relativize;
  return relativize_1;
}

var relate;
var hasRequiredRelate;
function requireRelate() {
  if (hasRequiredRelate) return relate;
  hasRequiredRelate = 1;
  var absolutize = requireAbsolutize();
  var relativize = requireRelativize();
  function relateUrl(siteUrlObj, urlObj, options) {
    absolutize(urlObj, siteUrlObj, options);
    relativize(urlObj, siteUrlObj, options);
    return urlObj;
  }
  relate = relateUrl;
  return relate;
}

var lib$2;
var hasRequiredLib$2;
function requireLib$2() {
  if (hasRequiredLib$2) return lib$2;
  hasRequiredLib$2 = 1;
  var constants = requireConstants$1();
  var formatUrl = requireFormat();
  var getOptions = requireOptions();
  var objUtils = requireObject();
  var parseUrl = requireParse$1();
  var relateUrl = requireRelate();
  function RelateUrl(from, options) {
    this.options = getOptions(options, {
      defaultPorts: {
        ftp: 21,
        http: 80,
        https: 443
      },
      directoryIndexes: ["index.html"],
      ignore_www: false,
      output: RelateUrl.SHORTEST,
      rejectedSchemes: ["data", "javascript", "mailto"],
      removeAuth: false,
      removeDirectoryIndexes: true,
      removeEmptyQueries: false,
      removeRootTrailingSlash: true,
      schemeRelative: true,
      site: undefined,
      slashesDenoteHost: true
    });
    this.from = parseUrl.from(from, this.options, null);
  }

  /*
  	Usage: instance=new RelateUrl(); instance.relate();
  */
  RelateUrl.prototype.relate = function (from, to, options) {
    // relate(to,options)
    if (objUtils.isPlainObject(to)) {
      options = to;
      to = from;
      from = null;
    }
    // relate(to)
    else if (!to) {
      to = from;
      from = null;
    }
    options = getOptions(options, this.options);
    from = from || options.site;
    from = parseUrl.from(from, options, this.from);
    if (!from || !from.href) {
      throw new Error("from value not defined.");
    } else if (from.extra.hrefInfo.minimumPathOnly) {
      throw new Error("from value supplied is not absolute: " + from.href);
    }
    to = parseUrl.to(to, options);
    if (to.valid === false) return to.href;
    to = relateUrl(from, to, options);
    to = formatUrl(to, options);
    return to;
  };

  /*
  	Usage: RelateUrl.relate();
  */
  RelateUrl.relate = function (from, to, options) {
    return new RelateUrl().relate(from, to, options);
  };

  // Make constants accessible from API
  objUtils.shallowMerge(RelateUrl, constants);
  lib$2 = RelateUrl;
  return lib$2;
}

var tokenchain;
var hasRequiredTokenchain;
function requireTokenchain() {
  if (hasRequiredTokenchain) return tokenchain;
  hasRequiredTokenchain = 1;
  function Sorter() {}
  Sorter.prototype.sort = function (tokens, fromIndex) {
    fromIndex = fromIndex || 0;
    for (var i = 0, len = this.keys.length; i < len; i++) {
      var key = this.keys[i];
      var token = key.slice(1);
      var index = tokens.indexOf(token, fromIndex);
      if (index !== -1) {
        do {
          if (index !== fromIndex) {
            tokens.splice(index, 1);
            tokens.splice(fromIndex, 0, token);
          }
          fromIndex++;
        } while ((index = tokens.indexOf(token, fromIndex)) !== -1);
        return this[key].sort(tokens, fromIndex);
      }
    }
    return tokens;
  };
  function TokenChain() {}
  TokenChain.prototype = {
    add: function (tokens) {
      var self = this;
      tokens.forEach(function (token) {
        var key = '$' + token;
        if (!self[key]) {
          self[key] = [];
          self[key].processed = 0;
        }
        self[key].push(tokens);
      });
    },
    createSorter: function () {
      var self = this;
      var sorter = new Sorter();
      sorter.keys = Object.keys(self).sort(function (j, k) {
        var m = self[j].length;
        var n = self[k].length;
        return m < n ? 1 : m > n ? -1 : j < k ? -1 : j > k ? 1 : 0;
      }).filter(function (key) {
        if (self[key].processed < self[key].length) {
          var token = key.slice(1);
          var chain = new TokenChain();
          self[key].forEach(function (tokens) {
            var index;
            while ((index = tokens.indexOf(token)) !== -1) {
              tokens.splice(index, 1);
            }
            tokens.forEach(function (token) {
              self['$' + token].processed++;
            });
            chain.add(tokens.slice(0));
          });
          sorter[key] = chain.createSorter();
          return true;
        }
        return false;
      });
      return sorter;
    }
  };
  tokenchain = TokenChain;
  return tokenchain;
}

var node1 = {};

var hasRequiredNode1;function requireNode1(){if(hasRequiredNode1)return node1;hasRequiredNode1=1;(function(exports){function characters(str){return str.split("");}function member(name,array){return array.indexOf(name)>=0;}function find_if(func,array){for(var i=array.length;--i>=0;)if(func(array[i]))return array[i];}function configure_error_stack(ex,cause){var stack=ex.name+": "+ex.message;Object.defineProperty(ex,"stack",{get:function(){if(cause){cause.name=""+ex.name;stack=""+cause.stack;var msg=""+cause.message;cause=null;var index=stack.indexOf(msg);if(index<0){index=0;}else {index+=msg.length;index=stack.indexOf("\n",index)+1;}stack=stack.slice(0,index)+stack.slice(stack.indexOf("\n",index)+1);}return stack;}});}function DefaultsError(msg,defs){this.message=msg;this.defs=defs;try{throw new Error(msg);}catch(cause){configure_error_stack(this,cause);}}DefaultsError.prototype=Object.create(Error.prototype);DefaultsError.prototype.constructor=DefaultsError;DefaultsError.prototype.name="DefaultsError";function defaults(args,defs,croak){if(croak)for(var i in args){if(HOP(args,i)&&!HOP(defs,i))throw new DefaultsError("`"+i+"` is not a supported option",defs);}for(var i in args){if(HOP(args,i))defs[i]=args[i];}return defs;}function noop(){}function return_false(){return false;}function return_true(){return true;}function return_this(){return this;}function return_null(){return null;}var List=function(){function List(a,f){var ret=[];for(var i=0;i<a.length;i++){var val=f(a[i],i);if(val===skip)continue;if(val instanceof Splice){ret.push.apply(ret,val.v);}else {ret.push(val);}}return ret;}List.is_op=function(val){return val===skip||val instanceof Splice;};List.splice=function(val){return new Splice(val);};var skip=List.skip={};function Splice(val){this.v=val;}return List;}();function push_uniq(array,el){if(array.indexOf(el)<0)return array.push(el);}function string_template(text,props){return text.replace(/\{([^{}]+)\}/g,function(str,p){var value=p=="this"?props:props[p];if(value instanceof AST_Node)return value.print_to_string();if(value instanceof AST_Token)return value.file+":"+value.line+","+value.col;return value;});}function remove(array,el){var index=array.indexOf(el);if(index>=0)array.splice(index,1);}function makePredicate(words){if(!Array.isArray(words))words=words.split(" ");var map=Object.create(null);words.forEach(function(word){map[word]=true;});return map;}function all(array,predicate){for(var i=array.length;--i>=0;)if(!predicate(array[i],i))return false;return true;}function Dictionary(){this.values=Object.create(null);}Dictionary.prototype={set:function(key,val){if(key=="__proto__"){this.proto_value=val;}else {this.values[key]=val;}return this;},add:function(key,val){var list=this.get(key);if(list){list.push(val);}else {this.set(key,[val]);}return this;},get:function(key){return key=="__proto__"?this.proto_value:this.values[key];},del:function(key){if(key=="__proto__"){delete this.proto_value;}else {delete this.values[key];}return this;},has:function(key){return key=="__proto__"?"proto_value"in this:key in this.values;},all:function(predicate){for(var i in this.values)if(!predicate(this.values[i],i))return false;if("proto_value"in this&&!predicate(this.proto_value,"__proto__"))return false;return true;},each:function(f){for(var i in this.values)f(this.values[i],i);if("proto_value"in this)f(this.proto_value,"__proto__");},size:function(){return Object.keys(this.values).length+("proto_value"in this);},map:function(f){var ret=[];for(var i in this.values)ret.push(f(this.values[i],i));if("proto_value"in this)ret.push(f(this.proto_value,"__proto__"));return ret;},clone:function(){var ret=new Dictionary();this.each(function(value,i){ret.set(i,value);});return ret;},toObject:function(){var obj={};this.each(function(value,i){obj["$"+i]=value;});return obj;}};Dictionary.fromObject=function(obj){var dict=new Dictionary();for(var i in obj)if(HOP(obj,i))dict.set(i.slice(1),obj[i]);return dict;};function HOP(obj,prop){return Object.prototype.hasOwnProperty.call(obj,prop);}// return true if the node at the top of the stack (that means the
// innermost node in the current output) is lexically the first in
// a statement.
function first_in_statement(stack,arrow,export_default){var node=stack.parent(-1);for(var i=0,p;p=stack.parent(i++);node=p){if(is_arrow(p)){return arrow&&p.value===node;}else if(p instanceof AST_Binary){if(p.left===node)continue;}else if(p.TYPE=="Call"){if(p.expression===node)continue;}else if(p instanceof AST_Conditional){if(p.condition===node)continue;}else if(p instanceof AST_ExportDefault){return export_default;}else if(p instanceof AST_PropAccess){if(p.expression===node)continue;}else if(p instanceof AST_Sequence){if(p.expressions[0]===node)continue;}else if(p instanceof AST_SimpleStatement){return true;}else if(p instanceof AST_Template){if(p.tag===node)continue;}else if(p instanceof AST_UnaryPostfix){if(p.expression===node)continue;}return false;}}function DEF_BITPROPS(ctor,props){if(props.length>31)throw new Error("Too many properties: "+props.length+"\n"+props.join(", "));props.forEach(function(name,pos){var mask=1<<pos;Object.defineProperty(ctor.prototype,name,{get:function(){return !!(this._bits&mask);},set:function(val){if(val)this._bits|=mask;else this._bits&=~mask;}});});}function DEFNODE(type,props,methods,base){if(typeof base==="undefined")base=AST_Node;props=props?props.split(/\s+/):[];var self_props=props;if(base&&base.PROPS)props=props.concat(base.PROPS);var code=["return function AST_",type,"(props){",// not essential, but speeds up compress by a few percent
"this._bits=0;","if(props){"];props.forEach(function(prop){code.push("this.",prop,"=props.",prop,";");});code.push("}");var proto=Object.create(base&&base.prototype);if(methods.initialize||proto.initialize)code.push("this.initialize();");code.push("};");var ctor=new Function(code.join(""))();ctor.prototype=proto;ctor.prototype.CTOR=ctor;ctor.prototype.TYPE=ctor.TYPE=type;if(base){ctor.BASE=base;base.SUBCLASSES.push(ctor);}ctor.DEFMETHOD=function(name,method){this.prototype[name]=method;};ctor.PROPS=props;ctor.SELF_PROPS=self_props;ctor.SUBCLASSES=[];for(var name in methods)if(HOP(methods,name)){if(/^\$/.test(name)){ctor[name.substr(1)]=methods[name];}else {ctor.DEFMETHOD(name,methods[name]);}}exports["AST_"+type]=ctor;return ctor;}var AST_Token=DEFNODE("Token","type value line col pos endline endcol endpos nlb comments_before comments_after file raw",{},null);var AST_Node=DEFNODE("Node","start end",{_clone:function(deep){if(deep){var self=this.clone();return self.transform(new TreeTransformer(function(node){if(node!==self){return node.clone(true);}}));}return new this.CTOR(this);},clone:function(deep){return this._clone(deep);},$documentation:"Base class of all AST nodes",$propdoc:{start:"[AST_Token] The first token of this node",end:"[AST_Token] The last token of this node"},equals:function(node){return this.TYPE==node.TYPE&&this._equals(node);},walk:function(visitor){visitor.visit(this);},_validate:function(){if(this.TYPE=="Node")throw new Error("should not instantiate AST_Node");},validate:function(){var ctor=this.CTOR;do{ctor.prototype._validate.call(this);}while(ctor=ctor.BASE);},validate_ast:function(){var marker={};this.walk(new TreeWalker(function(node){if(node.validate_visited===marker){throw new Error(string_template("cannot reuse AST_{TYPE} from [{start}]",node));}node.validate_visited=marker;}));}},null);DEF_BITPROPS(AST_Node,[// AST_Node
"_optimized","_squeezed",// AST_Call
"call_only",// AST_Lambda
"collapse_scanning",// AST_SymbolRef
"defined","evaluating","falsy",// AST_SymbolRef
"in_arg",// AST_Return
"in_bool",// AST_SymbolRef
"is_undefined",// AST_LambdaExpression
// AST_LambdaDefinition
"inlined",// AST_Lambda
"length_read",// AST_Yield
"nested",// AST_Lambda
"new",// AST_Call
// AST_PropAccess
"optional",// AST_ClassProperty
"private",// AST_Call
"pure",// AST_Node
"single_use",// AST_ClassProperty
"static",// AST_Call
// AST_PropAccess
"terminal","truthy",// AST_Scope
"uses_eval",// AST_Scope
"uses_with"]);(AST_Node.log_function=function(fn,verbose){if(typeof fn!="function"){AST_Node.info=AST_Node.warn=noop;return;}var printed=Object.create(null);AST_Node.info=verbose?function(text,props){log("INFO: "+string_template(text,props));}:noop;AST_Node.warn=function(text,props){log("WARN: "+string_template(text,props));};function log(msg){if(printed[msg])return;printed[msg]=true;fn(msg);}})();var restore_transforms=[];AST_Node.enable_validation=function(){AST_Node.disable_validation();(function validate_transform(ctor){ctor.SUBCLASSES.forEach(validate_transform);if(!HOP(ctor.prototype,"transform"))return;var transform=ctor.prototype.transform;ctor.prototype.transform=function(tw,in_list){var node=transform.call(this,tw,in_list);if(node instanceof AST_Node){node.validate();}else if(!(node===null||in_list&&List.is_op(node))){throw new Error("invalid transformed value: "+node);}return node;};restore_transforms.push(function(){ctor.prototype.transform=transform;});})(this);};AST_Node.disable_validation=function(){var restore;while(restore=restore_transforms.pop())restore();};function all_equals(k,l){return k.length==l.length&&all(k,function(m,i){return m.equals(l[i]);});}function list_equals(s,t){return s.length==t.length&&all(s,function(u,i){return u==t[i];});}function prop_equals(u,v){if(u===v)return true;if(u==null)return v==null;return u instanceof AST_Node&&v instanceof AST_Node&&u.equals(v);}/* -----[ statements ]----- */var AST_Statement=DEFNODE("Statement",null,{$documentation:"Base class of all statements",_validate:function(){if(this.TYPE=="Statement")throw new Error("should not instantiate AST_Statement");}});var AST_Debugger=DEFNODE("Debugger",null,{$documentation:"Represents a debugger statement",_equals:return_true},AST_Statement);var AST_Directive=DEFNODE("Directive","quote value",{$documentation:"Represents a directive, like \"use strict\";",$propdoc:{quote:"[string?] the original quote character",value:"[string] The value of this directive as a plain string (it's not an AST_String!)"},_equals:function(node){return this.value==node.value;},_validate:function(){if(this.quote!=null){if(typeof this.quote!="string")throw new Error("quote must be string");if(!/^["']$/.test(this.quote))throw new Error("invalid quote: "+this.quote);}if(typeof this.value!="string")throw new Error("value must be string");}},AST_Statement);var AST_EmptyStatement=DEFNODE("EmptyStatement",null,{$documentation:"The empty statement (empty block or simply a semicolon)",_equals:return_true},AST_Statement);function is_statement(node){return node instanceof AST_Statement&&!(node instanceof AST_ClassExpression)&&!(node instanceof AST_LambdaExpression);}function validate_expression(value,prop,multiple,allow_spread,allow_hole){multiple=multiple?"contain":"be";if(!(value instanceof AST_Node))throw new Error(prop+" must "+multiple+" AST_Node");if(value instanceof AST_DefaultValue)throw new Error(prop+" cannot "+multiple+" AST_DefaultValue");if(value instanceof AST_Destructured)throw new Error(prop+" cannot "+multiple+" AST_Destructured");if(value instanceof AST_Hole&&!allow_hole)throw new Error(prop+" cannot "+multiple+" AST_Hole");if(value instanceof AST_Spread&&!allow_spread)throw new Error(prop+" cannot "+multiple+" AST_Spread");if(is_statement(value))throw new Error(prop+" cannot "+multiple+" AST_Statement");if(value instanceof AST_SymbolDeclaration){throw new Error(prop+" cannot "+multiple+" AST_SymbolDeclaration");}}function must_be_expression(node,prop){validate_expression(node[prop],prop);}var AST_SimpleStatement=DEFNODE("SimpleStatement","body",{$documentation:"A statement consisting of an expression, i.e. a = 1 + 2",$propdoc:{body:"[AST_Node] an expression node (should not be instanceof AST_Statement)"},_equals:function(node){return this.body.equals(node.body);},walk:function(visitor){var node=this;visitor.visit(node,function(){node.body.walk(visitor);});},_validate:function(){must_be_expression(this,"body");}},AST_Statement);var AST_BlockScope=DEFNODE("BlockScope","_var_names enclosed functions make_def parent_scope variables",{$documentation:"Base class for all statements introducing a lexical scope",$propdoc:{enclosed:"[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any inner scopes",functions:"[Dictionary/S] like `variables`, but only lists function declarations",parent_scope:"[AST_Scope?/S] link to the parent scope",variables:"[Dictionary/S] a map of name ---> SymbolDef for all variables/functions defined in this scope"},clone:function(deep){var node=this._clone(deep);if(this.enclosed)node.enclosed=this.enclosed.slice();if(this.functions)node.functions=this.functions.clone();if(this.variables)node.variables=this.variables.clone();return node;},pinned:function(){return this.resolve().pinned();},resolve:function(){return this.parent_scope.resolve();},_validate:function(){if(this.TYPE=="BlockScope")throw new Error("should not instantiate AST_BlockScope");if(this.parent_scope==null)return;if(!(this.parent_scope instanceof AST_BlockScope))throw new Error("parent_scope must be AST_BlockScope");if(!(this.resolve()instanceof AST_Scope))throw new Error("must be contained within AST_Scope");}},AST_Statement);function walk_body(node,visitor){node.body.forEach(function(node){node.walk(visitor);});}var AST_Block=DEFNODE("Block","body",{$documentation:"A body of statements (usually braced)",$propdoc:{body:"[AST_Statement*] an array of statements"},_equals:function(node){return all_equals(this.body,node.body);},walk:function(visitor){var node=this;visitor.visit(node,function(){walk_body(node,visitor);});},_validate:function(){if(this.TYPE=="Block")throw new Error("should not instantiate AST_Block");this.body.forEach(function(node){if(!is_statement(node))throw new Error("body must contain AST_Statement");});}},AST_BlockScope);var AST_BlockStatement=DEFNODE("BlockStatement",null,{$documentation:"A block statement"},AST_Block);var AST_StatementWithBody=DEFNODE("StatementWithBody","body",{$documentation:"Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`",$propdoc:{body:"[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement"},_validate:function(){if(this.TYPE=="StatementWithBody")throw new Error("should not instantiate AST_StatementWithBody");if(!is_statement(this.body))throw new Error("body must be AST_Statement");}},AST_BlockScope);var AST_LabeledStatement=DEFNODE("LabeledStatement","label",{$documentation:"Statement with a label",$propdoc:{label:"[AST_Label] a label definition"},_equals:function(node){return this.label.equals(node.label)&&this.body.equals(node.body);},walk:function(visitor){var node=this;visitor.visit(node,function(){node.label.walk(visitor);node.body.walk(visitor);});},clone:function(deep){var node=this._clone(deep);if(deep){var label=node.label;var def=this.label;node.walk(new TreeWalker(function(node){if(node instanceof AST_LoopControl){if(!node.label||node.label.thedef!==def)return;node.label.thedef=label;label.references.push(node);return true;}if(node instanceof AST_Scope)return true;}));}return node;},_validate:function(){if(!(this.label instanceof AST_Label))throw new Error("label must be AST_Label");}},AST_StatementWithBody);var AST_IterationStatement=DEFNODE("IterationStatement",null,{$documentation:"Internal class.  All loops inherit from it.",_validate:function(){if(this.TYPE=="IterationStatement")throw new Error("should not instantiate AST_IterationStatement");}},AST_StatementWithBody);var AST_DWLoop=DEFNODE("DWLoop","condition",{$documentation:"Base class for do/while statements",$propdoc:{condition:"[AST_Node] the loop condition.  Should not be instanceof AST_Statement"},_equals:function(node){return this.body.equals(node.body)&&this.condition.equals(node.condition);},_validate:function(){if(this.TYPE=="DWLoop")throw new Error("should not instantiate AST_DWLoop");must_be_expression(this,"condition");}},AST_IterationStatement);var AST_Do=DEFNODE("Do",null,{$documentation:"A `do` statement",walk:function(visitor){var node=this;visitor.visit(node,function(){node.body.walk(visitor);node.condition.walk(visitor);});}},AST_DWLoop);var AST_While=DEFNODE("While",null,{$documentation:"A `while` statement",walk:function(visitor){var node=this;visitor.visit(node,function(){node.condition.walk(visitor);node.body.walk(visitor);});}},AST_DWLoop);var AST_For=DEFNODE("For","init condition step",{$documentation:"A `for` statement",$propdoc:{init:"[AST_Node?] the `for` initialization code, or null if empty",condition:"[AST_Node?] the `for` termination clause, or null if empty",step:"[AST_Node?] the `for` update clause, or null if empty"},_equals:function(node){return prop_equals(this.init,node.init)&&prop_equals(this.condition,node.condition)&&prop_equals(this.step,node.step)&&this.body.equals(node.body);},walk:function(visitor){var node=this;visitor.visit(node,function(){if(node.init)node.init.walk(visitor);if(node.condition)node.condition.walk(visitor);if(node.step)node.step.walk(visitor);node.body.walk(visitor);});},_validate:function(){if(this.init!=null){if(!(this.init instanceof AST_Node))throw new Error("init must be AST_Node");if(is_statement(this.init)&&!(this.init instanceof AST_Definitions)){throw new Error("init cannot be AST_Statement");}}if(this.condition!=null)must_be_expression(this,"condition");if(this.step!=null)must_be_expression(this,"step");}},AST_IterationStatement);var AST_ForEnumeration=DEFNODE("ForEnumeration","init object",{$documentation:"Base class for enumeration loops, i.e. `for ... in`, `for ... of` & `for await ... of`",$propdoc:{init:"[AST_Node] the assignment target during iteration",object:"[AST_Node] the object to iterate over"},_equals:function(node){return this.init.equals(node.init)&&this.object.equals(node.object)&&this.body.equals(node.body);},walk:function(visitor){var node=this;visitor.visit(node,function(){node.init.walk(visitor);node.object.walk(visitor);node.body.walk(visitor);});},_validate:function(){if(this.TYPE=="ForEnumeration")throw new Error("should not instantiate AST_ForEnumeration");if(this.init instanceof AST_Definitions){if(this.init.definitions.length!=1)throw new Error("init must have single declaration");}else {validate_destructured(this.init,function(node){if(!(node instanceof AST_PropAccess||node instanceof AST_SymbolRef)){throw new Error("init must be assignable: "+node.TYPE);}});}must_be_expression(this,"object");}},AST_IterationStatement);var AST_ForIn=DEFNODE("ForIn",null,{$documentation:"A `for ... in` statement"},AST_ForEnumeration);var AST_ForOf=DEFNODE("ForOf",null,{$documentation:"A `for ... of` statement"},AST_ForEnumeration);var AST_ForAwaitOf=DEFNODE("ForAwaitOf",null,{$documentation:"A `for await ... of` statement"},AST_ForOf);var AST_With=DEFNODE("With","expression",{$documentation:"A `with` statement",$propdoc:{expression:"[AST_Node] the `with` expression"},_equals:function(node){return this.expression.equals(node.expression)&&this.body.equals(node.body);},walk:function(visitor){var node=this;visitor.visit(node,function(){node.expression.walk(visitor);node.body.walk(visitor);});},_validate:function(){must_be_expression(this,"expression");}},AST_StatementWithBody);/* -----[ scope and functions ]----- */var AST_Scope=DEFNODE("Scope","fn_defs may_call_this uses_eval uses_with",{$documentation:"Base class for all statements introducing a lambda scope",$propdoc:{uses_eval:"[boolean/S] tells whether this scope contains a direct call to the global `eval`",uses_with:"[boolean/S] tells whether this scope uses the `with` statement"},pinned:function(){return this.uses_eval||this.uses_with;},resolve:return_this,_validate:function(){if(this.TYPE=="Scope")throw new Error("should not instantiate AST_Scope");}},AST_Block);var AST_Toplevel=DEFNODE("Toplevel","globals",{$documentation:"The toplevel scope",$propdoc:{globals:"[Dictionary/S] a map of name ---> SymbolDef for all undeclared names"},wrap:function(name){var body=this.body;return parse(["(function(exports){'$ORIG';})(typeof ",name,"=='undefined'?(",name,"={}):",name,");"].join(""),{filename:"wrap="+JSON.stringify(name)}).transform(new TreeTransformer(function(node){if(node instanceof AST_Directive&&node.value=="$ORIG"){return List.splice(body);}}));},enclose:function(args_values){if(typeof args_values!="string")args_values="";var index=args_values.indexOf(":");if(index<0)index=args_values.length;var body=this.body;return parse(["(function(",args_values.slice(0,index),'){"$ORIG"})(',args_values.slice(index+1),")"].join(""),{filename:"enclose="+JSON.stringify(args_values)}).transform(new TreeTransformer(function(node){if(node instanceof AST_Directive&&node.value=="$ORIG"){return List.splice(body);}}));}},AST_Scope);var AST_ClassInitBlock=DEFNODE("ClassInitBlock",null,{$documentation:"Value for `class` static initialization blocks"},AST_Scope);var AST_Lambda=DEFNODE("Lambda","argnames length_read rest safe_ids uses_arguments",{$documentation:"Base class for functions",$propdoc:{argnames:"[(AST_DefaultValue|AST_Destructured|AST_SymbolFunarg)*] array of function arguments and/or destructured literals",length_read:"[boolean/S] whether length property of this function is accessed",rest:"[(AST_Destructured|AST_SymbolFunarg)?] rest parameter, or null if absent",uses_arguments:"[boolean|number/S] whether this function accesses the arguments array"},each_argname:function(visit){var tw=new TreeWalker(function(node){if(node instanceof AST_DefaultValue){node.name.walk(tw);return true;}if(node instanceof AST_DestructuredKeyVal){node.value.walk(tw);return true;}if(node instanceof AST_SymbolFunarg)visit(node);});this.argnames.forEach(function(argname){argname.walk(tw);});if(this.rest)this.rest.walk(tw);},_equals:function(node){return prop_equals(this.rest,node.rest)&&prop_equals(this.name,node.name)&&prop_equals(this.value,node.value)&&all_equals(this.argnames,node.argnames)&&all_equals(this.body,node.body);},walk:function(visitor){var node=this;visitor.visit(node,function(){if(node.name)node.name.walk(visitor);node.argnames.forEach(function(argname){argname.walk(visitor);});if(node.rest)node.rest.walk(visitor);walk_body(node,visitor);});},_validate:function(){if(this.TYPE=="Lambda")throw new Error("should not instantiate AST_Lambda");this.argnames.forEach(function(node){validate_destructured(node,function(node){if(!(node instanceof AST_SymbolFunarg))throw new Error("argnames must be AST_SymbolFunarg[]");},true);});if(this.rest!=null)validate_destructured(this.rest,function(node){if(!(node instanceof AST_SymbolFunarg))throw new Error("rest must be AST_SymbolFunarg");});}},AST_Scope);var AST_Accessor=DEFNODE("Accessor",null,{$documentation:"A getter/setter function",_validate:function(){if(this.name!=null)throw new Error("name must be null");}},AST_Lambda);var AST_LambdaExpression=DEFNODE("LambdaExpression","inlined",{$documentation:"Base class for function expressions",$propdoc:{inlined:"[boolean/S] whether this function has been inlined"},_validate:function(){if(this.TYPE=="LambdaExpression")throw new Error("should not instantiate AST_LambdaExpression");}},AST_Lambda);function is_arrow(node){return node instanceof AST_Arrow||node instanceof AST_AsyncArrow;}function is_async(node){return node instanceof AST_AsyncArrow||node instanceof AST_AsyncDefun||node instanceof AST_AsyncFunction||node instanceof AST_AsyncGeneratorDefun||node instanceof AST_AsyncGeneratorFunction;}function is_generator(node){return node instanceof AST_AsyncGeneratorDefun||node instanceof AST_AsyncGeneratorFunction||node instanceof AST_GeneratorDefun||node instanceof AST_GeneratorFunction;}function walk_lambda(node,tw){if(is_arrow(node)&&node.value){node.value.walk(tw);}else {walk_body(node,tw);}}var AST_Arrow=DEFNODE("Arrow","value",{$documentation:"An arrow function expression",$propdoc:{value:"[AST_Node?] simple return expression, or null if using function body."},walk:function(visitor){var node=this;visitor.visit(node,function(){node.argnames.forEach(function(argname){argname.walk(visitor);});if(node.rest)node.rest.walk(visitor);if(node.value){node.value.walk(visitor);}else {walk_body(node,visitor);}});},_validate:function(){if(this.name!=null)throw new Error("name must be null");if(this.uses_arguments)throw new Error("uses_arguments must be false");if(this.value!=null){must_be_expression(this,"value");if(this.body.length)throw new Error("body must be empty if value exists");}}},AST_LambdaExpression);var AST_AsyncArrow=DEFNODE("AsyncArrow","value",{$documentation:"An asynchronous arrow function expression",$propdoc:{value:"[AST_Node?] simple return expression, or null if using function body."},walk:function(visitor){var node=this;visitor.visit(node,function(){node.argnames.forEach(function(argname){argname.walk(visitor);});if(node.rest)node.rest.walk(visitor);if(node.value){node.value.walk(visitor);}else {walk_body(node,visitor);}});},_validate:function(){if(this.name!=null)throw new Error("name must be null");if(this.uses_arguments)throw new Error("uses_arguments must be false");if(this.value!=null){must_be_expression(this,"value");if(this.body.length)throw new Error("body must be empty if value exists");}}},AST_LambdaExpression);var AST_AsyncFunction=DEFNODE("AsyncFunction","name",{$documentation:"An asynchronous function expression",$propdoc:{name:"[AST_SymbolLambda?] the name of this function, or null if not specified"},_validate:function(){if(this.name!=null){if(!(this.name instanceof AST_SymbolLambda))throw new Error("name must be AST_SymbolLambda");}}},AST_LambdaExpression);var AST_AsyncGeneratorFunction=DEFNODE("AsyncGeneratorFunction","name",{$documentation:"An asynchronous generator function expression",$propdoc:{name:"[AST_SymbolLambda?] the name of this function, or null if not specified"},_validate:function(){if(this.name!=null){if(!(this.name instanceof AST_SymbolLambda))throw new Error("name must be AST_SymbolLambda");}}},AST_LambdaExpression);var AST_Function=DEFNODE("Function","name",{$documentation:"A function expression",$propdoc:{name:"[AST_SymbolLambda?] the name of this function, or null if not specified"},_validate:function(){if(this.name!=null){if(!(this.name instanceof AST_SymbolLambda))throw new Error("name must be AST_SymbolLambda");}}},AST_LambdaExpression);var AST_GeneratorFunction=DEFNODE("GeneratorFunction","name",{$documentation:"A generator function expression",$propdoc:{name:"[AST_SymbolLambda?] the name of this function, or null if not specified"},_validate:function(){if(this.name!=null){if(!(this.name instanceof AST_SymbolLambda))throw new Error("name must be AST_SymbolLambda");}}},AST_LambdaExpression);var AST_LambdaDefinition=DEFNODE("LambdaDefinition","inlined name",{$documentation:"Base class for function definitions",$propdoc:{inlined:"[boolean/S] whether this function has been inlined",name:"[AST_SymbolDefun] the name of this function"},_validate:function(){if(this.TYPE=="LambdaDefinition")throw new Error("should not instantiate AST_LambdaDefinition");if(!(this.name instanceof AST_SymbolDefun))throw new Error("name must be AST_SymbolDefun");}},AST_Lambda);var AST_AsyncDefun=DEFNODE("AsyncDefun",null,{$documentation:"An asynchronous function definition"},AST_LambdaDefinition);var AST_AsyncGeneratorDefun=DEFNODE("AsyncGeneratorDefun",null,{$documentation:"An asynchronous generator function definition"},AST_LambdaDefinition);var AST_Defun=DEFNODE("Defun",null,{$documentation:"A function definition"},AST_LambdaDefinition);var AST_GeneratorDefun=DEFNODE("GeneratorDefun",null,{$documentation:"A generator function definition"},AST_LambdaDefinition);/* -----[ classes ]----- */var AST_Class=DEFNODE("Class","extends name properties",{$documentation:"Base class for class literals",$propdoc:{extends:"[AST_Node?] the super class, or null if not specified",properties:"[AST_ClassProperty*] array of class properties"},_equals:function(node){return prop_equals(this.name,node.name)&&prop_equals(this.extends,node.extends)&&all_equals(this.properties,node.properties);},resolve:function(def_class){return def_class?this:this.parent_scope.resolve();},walk:function(visitor){var node=this;visitor.visit(node,function(){if(node.name)node.name.walk(visitor);if(node.extends)node.extends.walk(visitor);node.properties.forEach(function(prop){prop.walk(visitor);});});},_validate:function(){if(this.TYPE=="Class")throw new Error("should not instantiate AST_Class");if(this.extends!=null)must_be_expression(this,"extends");this.properties.forEach(function(node){if(!(node instanceof AST_ClassProperty))throw new Error("properties must contain AST_ClassProperty");});}},AST_BlockScope);var AST_DefClass=DEFNODE("DefClass",null,{$documentation:"A class definition",$propdoc:{name:"[AST_SymbolDefClass] the name of this class"},_validate:function(){if(!(this.name instanceof AST_SymbolDefClass))throw new Error("name must be AST_SymbolDefClass");}},AST_Class);var AST_ClassExpression=DEFNODE("ClassExpression",null,{$documentation:"A class expression",$propdoc:{name:"[AST_SymbolClass?] the name of this class, or null if not specified"},_validate:function(){if(this.name!=null){if(!(this.name instanceof AST_SymbolClass))throw new Error("name must be AST_SymbolClass");}}},AST_Class);var AST_ClassProperty=DEFNODE("ClassProperty","key private static value",{$documentation:"Base class for `class` properties",$propdoc:{key:"[string|AST_Node?] property name (AST_Node for computed property, null for initialization block)",private:"[boolean] whether this is a private property",static:"[boolean] whether this is a static property",value:"[AST_Node?] property value (AST_Accessor for getters/setters, AST_LambdaExpression for methods, null if not specified for fields)"},_equals:function(node){return !this.private==!node.private&&!this.static==!node.static&&prop_equals(this.key,node.key)&&prop_equals(this.value,node.value);},walk:function(visitor){var node=this;visitor.visit(node,function(){if(node.key instanceof AST_Node)node.key.walk(visitor);if(node.value)node.value.walk(visitor);});},_validate:function(){if(this.TYPE=="ClassProperty")throw new Error("should not instantiate AST_ClassProperty");if(this instanceof AST_ClassInit){if(this.key!=null)throw new Error("key must be null");}else if(typeof this.key!="string"){if(!(this.key instanceof AST_Node))throw new Error("key must be string or AST_Node");if(this.private)throw new Error("computed key cannot be private");must_be_expression(this,"key");}else if(this.private){if(!/^#/.test(this.key))throw new Error("private key must prefix with #");}if(this.value!=null){if(!(this.value instanceof AST_Node))throw new Error("value must be AST_Node");}}});var AST_ClassField=DEFNODE("ClassField",null,{$documentation:"A `class` field",_validate:function(){if(this.value!=null)must_be_expression(this,"value");}},AST_ClassProperty);var AST_ClassGetter=DEFNODE("ClassGetter",null,{$documentation:"A `class` getter",_validate:function(){if(!(this.value instanceof AST_Accessor))throw new Error("value must be AST_Accessor");}},AST_ClassProperty);var AST_ClassSetter=DEFNODE("ClassSetter",null,{$documentation:"A `class` setter",_validate:function(){if(!(this.value instanceof AST_Accessor))throw new Error("value must be AST_Accessor");}},AST_ClassProperty);var AST_ClassMethod=DEFNODE("ClassMethod",null,{$documentation:"A `class` method",_validate:function(){if(!(this.value instanceof AST_LambdaExpression))throw new Error("value must be AST_LambdaExpression");if(is_arrow(this.value))throw new Error("value cannot be AST_Arrow or AST_AsyncArrow");if(this.value.name!=null)throw new Error("name of class method's lambda must be null");}},AST_ClassProperty);var AST_ClassInit=DEFNODE("ClassInit",null,{$documentation:"A `class` static initialization block",_validate:function(){if(!this.static)throw new Error("static must be true");if(!(this.value instanceof AST_ClassInitBlock))throw new Error("value must be AST_ClassInitBlock");},initialize:function(){this.static=true;}},AST_ClassProperty);/* -----[ JUMPS ]----- */var AST_Jump=DEFNODE("Jump",null,{$documentation:"Base class for jumps (for now that's `return`, `throw`, `break` and `continue`)",_validate:function(){if(this.TYPE=="Jump")throw new Error("should not instantiate AST_Jump");}},AST_Statement);var AST_Exit=DEFNODE("Exit","value",{$documentation:"Base class for exits (`return` and `throw`)",$propdoc:{value:"[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return"},_equals:function(node){return prop_equals(this.value,node.value);},walk:function(visitor){var node=this;visitor.visit(node,function(){if(node.value)node.value.walk(visitor);});},_validate:function(){if(this.TYPE=="Exit")throw new Error("should not instantiate AST_Exit");}},AST_Jump);var AST_Return=DEFNODE("Return",null,{$documentation:"A `return` statement",_validate:function(){if(this.value!=null)must_be_expression(this,"value");}},AST_Exit);var AST_Throw=DEFNODE("Throw",null,{$documentation:"A `throw` statement",_validate:function(){must_be_expression(this,"value");}},AST_Exit);var AST_LoopControl=DEFNODE("LoopControl","label",{$documentation:"Base class for loop control statements (`break` and `continue`)",$propdoc:{label:"[AST_LabelRef?] the label, or null if none"},_equals:function(node){return prop_equals(this.label,node.label);},walk:function(visitor){var node=this;visitor.visit(node,function(){if(node.label)node.label.walk(visitor);});},_validate:function(){if(this.TYPE=="LoopControl")throw new Error("should not instantiate AST_LoopControl");if(this.label!=null){if(!(this.label instanceof AST_LabelRef))throw new Error("label must be AST_LabelRef");}}},AST_Jump);var AST_Break=DEFNODE("Break",null,{$documentation:"A `break` statement"},AST_LoopControl);var AST_Continue=DEFNODE("Continue",null,{$documentation:"A `continue` statement"},AST_LoopControl);/* -----[ IF ]----- */var AST_If=DEFNODE("If","condition alternative",{$documentation:"A `if` statement",$propdoc:{condition:"[AST_Node] the `if` condition",alternative:"[AST_Statement?] the `else` part, or null if not present"},_equals:function(node){return this.body.equals(node.body)&&this.condition.equals(node.condition)&&prop_equals(this.alternative,node.alternative);},walk:function(visitor){var node=this;visitor.visit(node,function(){node.condition.walk(visitor);node.body.walk(visitor);if(node.alternative)node.alternative.walk(visitor);});},_validate:function(){must_be_expression(this,"condition");if(this.alternative!=null){if(!is_statement(this.alternative))throw new Error("alternative must be AST_Statement");}}},AST_StatementWithBody);/* -----[ SWITCH ]----- */var AST_Switch=DEFNODE("Switch","expression",{$documentation:"A `switch` statement",$propdoc:{expression:"[AST_Node] the `switch` discriminant"},_equals:function(node){return this.expression.equals(node.expression)&&all_equals(this.body,node.body);},walk:function(visitor){var node=this;visitor.visit(node,function(){node.expression.walk(visitor);walk_body(node,visitor);});},_validate:function(){must_be_expression(this,"expression");this.body.forEach(function(node){if(!(node instanceof AST_SwitchBranch))throw new Error("body must be AST_SwitchBranch[]");});}},AST_Block);var AST_SwitchBranch=DEFNODE("SwitchBranch",null,{$documentation:"Base class for `switch` branches",_validate:function(){if(this.TYPE=="SwitchBranch")throw new Error("should not instantiate AST_SwitchBranch");}},AST_Block);var AST_Default=DEFNODE("Default",null,{$documentation:"A `default` switch branch"},AST_SwitchBranch);var AST_Case=DEFNODE("Case","expression",{$documentation:"A `case` switch branch",$propdoc:{expression:"[AST_Node] the `case` expression"},_equals:function(node){return this.expression.equals(node.expression)&&all_equals(this.body,node.body);},walk:function(visitor){var node=this;visitor.visit(node,function(){node.expression.walk(visitor);walk_body(node,visitor);});},_validate:function(){must_be_expression(this,"expression");}},AST_SwitchBranch);/* -----[ EXCEPTIONS ]----- */var AST_Try=DEFNODE("Try","bcatch bfinally",{$documentation:"A `try` statement",$propdoc:{bcatch:"[AST_Catch?] the catch block, or null if not present",bfinally:"[AST_Finally?] the finally block, or null if not present"},_equals:function(node){return all_equals(this.body,node.body)&&prop_equals(this.bcatch,node.bcatch)&&prop_equals(this.bfinally,node.bfinally);},walk:function(visitor){var node=this;visitor.visit(node,function(){walk_body(node,visitor);if(node.bcatch)node.bcatch.walk(visitor);if(node.bfinally)node.bfinally.walk(visitor);});},_validate:function(){if(this.bcatch!=null){if(!(this.bcatch instanceof AST_Catch))throw new Error("bcatch must be AST_Catch");}if(this.bfinally!=null){if(!(this.bfinally instanceof AST_Finally))throw new Error("bfinally must be AST_Finally");}}},AST_Block);var AST_Catch=DEFNODE("Catch","argname",{$documentation:"A `catch` node; only makes sense as part of a `try` statement",$propdoc:{argname:"[(AST_Destructured|AST_SymbolCatch)?] symbol for the exception, or null if not present"},_equals:function(node){return prop_equals(this.argname,node.argname)&&all_equals(this.body,node.body);},walk:function(visitor){var node=this;visitor.visit(node,function(){if(node.argname)node.argname.walk(visitor);walk_body(node,visitor);});},_validate:function(){if(this.argname!=null)validate_destructured(this.argname,function(node){if(!(node instanceof AST_SymbolCatch))throw new Error("argname must be AST_SymbolCatch");});}},AST_Block);var AST_Finally=DEFNODE("Finally",null,{$documentation:"A `finally` node; only makes sense as part of a `try` statement"},AST_Block);/* -----[ VAR ]----- */var AST_Definitions=DEFNODE("Definitions","definitions",{$documentation:"Base class for `var` nodes (variable declarations/initializations)",$propdoc:{definitions:"[AST_VarDef*] array of variable definitions"},_equals:function(node){return all_equals(this.definitions,node.definitions);},walk:function(visitor){var node=this;visitor.visit(node,function(){node.definitions.forEach(function(defn){defn.walk(visitor);});});},_validate:function(){if(this.TYPE=="Definitions")throw new Error("should not instantiate AST_Definitions");if(this.definitions.length<1)throw new Error("must have at least one definition");}},AST_Statement);var AST_Const=DEFNODE("Const",null,{$documentation:"A `const` statement",_validate:function(){this.definitions.forEach(function(node){if(!(node instanceof AST_VarDef))throw new Error("definitions must be AST_VarDef[]");validate_destructured(node.name,function(node){if(!(node instanceof AST_SymbolConst))throw new Error("name must be AST_SymbolConst");});});}},AST_Definitions);var AST_Let=DEFNODE("Let",null,{$documentation:"A `let` statement",_validate:function(){this.definitions.forEach(function(node){if(!(node instanceof AST_VarDef))throw new Error("definitions must be AST_VarDef[]");validate_destructured(node.name,function(node){if(!(node instanceof AST_SymbolLet))throw new Error("name must be AST_SymbolLet");});});}},AST_Definitions);var AST_Var=DEFNODE("Var",null,{$documentation:"A `var` statement",_validate:function(){this.definitions.forEach(function(node){if(!(node instanceof AST_VarDef))throw new Error("definitions must be AST_VarDef[]");validate_destructured(node.name,function(node){if(!(node instanceof AST_SymbolVar))throw new Error("name must be AST_SymbolVar");});});}},AST_Definitions);var AST_VarDef=DEFNODE("VarDef","name value",{$documentation:"A variable declaration; only appears in a AST_Definitions node",$propdoc:{name:"[AST_Destructured|AST_SymbolVar] name of the variable",value:"[AST_Node?] initializer, or null of there's no initializer"},_equals:function(node){return this.name.equals(node.name)&&prop_equals(this.value,node.value);},walk:function(visitor){var node=this;visitor.visit(node,function(){node.name.walk(visitor);if(node.value)node.value.walk(visitor);});},_validate:function(){if(this.value!=null)must_be_expression(this,"value");}});/* -----[ OTHER ]----- */var AST_ExportDeclaration=DEFNODE("ExportDeclaration","body",{$documentation:"An `export` statement",$propdoc:{body:"[AST_DefClass|AST_Definitions|AST_LambdaDefinition] the statement to export"},_equals:function(node){return this.body.equals(node.body);},walk:function(visitor){var node=this;visitor.visit(node,function(){node.body.walk(visitor);});},_validate:function(){if(!(this.body instanceof AST_DefClass||this.body instanceof AST_Definitions||this.body instanceof AST_LambdaDefinition)){throw new Error("body must be AST_DefClass, AST_Definitions or AST_LambdaDefinition");}}},AST_Statement);var AST_ExportDefault=DEFNODE("ExportDefault","body",{$documentation:"An `export default` statement",$propdoc:{body:"[AST_Node] the default export"},_equals:function(node){return this.body.equals(node.body);},walk:function(visitor){var node=this;visitor.visit(node,function(){node.body.walk(visitor);});},_validate:function(){if(!(this.body instanceof AST_DefClass||this.body instanceof AST_LambdaDefinition)){must_be_expression(this,"body");}}},AST_Statement);var AST_ExportForeign=DEFNODE("ExportForeign","aliases keys path",{$documentation:"An `export ... from '...'` statement",$propdoc:{aliases:"[AST_String*] array of aliases to export",keys:"[AST_String*] array of keys to import",path:"[AST_String] the path to import module"},_equals:function(node){return this.path.equals(node.path)&&all_equals(this.aliases,node.aliases)&&all_equals(this.keys,node.keys);},_validate:function(){if(this.aliases.length!=this.keys.length){throw new Error("aliases:key length mismatch: "+this.aliases.length+" != "+this.keys.length);}this.aliases.forEach(function(name){if(!(name instanceof AST_String))throw new Error("aliases must contain AST_String");});this.keys.forEach(function(name){if(!(name instanceof AST_String))throw new Error("keys must contain AST_String");});if(!(this.path instanceof AST_String))throw new Error("path must be AST_String");}},AST_Statement);var AST_ExportReferences=DEFNODE("ExportReferences","properties",{$documentation:"An `export { ... }` statement",$propdoc:{properties:"[AST_SymbolExport*] array of aliases to export"},_equals:function(node){return all_equals(this.properties,node.properties);},walk:function(visitor){var node=this;visitor.visit(node,function(){node.properties.forEach(function(prop){prop.walk(visitor);});});},_validate:function(){this.properties.forEach(function(prop){if(!(prop instanceof AST_SymbolExport))throw new Error("properties must contain AST_SymbolExport");});}},AST_Statement);var AST_Import=DEFNODE("Import","all default path properties",{$documentation:"An `import` statement",$propdoc:{all:"[AST_SymbolImport?] the imported namespace, or null if not specified",default:"[AST_SymbolImport?] the alias for default `export`, or null if not specified",path:"[AST_String] the path to import module",properties:"[(AST_SymbolImport*)?] array of aliases, or null if not specified"},_equals:function(node){return this.path.equals(node.path)&&prop_equals(this.all,node.all)&&prop_equals(this.default,node.default)&&!this.properties==!node.properties&&(!this.properties||all_equals(this.properties,node.properties));},walk:function(visitor){var node=this;visitor.visit(node,function(){if(node.all)node.all.walk(visitor);if(node.default)node.default.walk(visitor);if(node.properties)node.properties.forEach(function(prop){prop.walk(visitor);});});},_validate:function(){if(this.all!=null){if(!(this.all instanceof AST_SymbolImport))throw new Error("all must be AST_SymbolImport");if(this.properties!=null)throw new Error("cannot import both * and {} in the same statement");}if(this.default!=null){if(!(this.default instanceof AST_SymbolImport))throw new Error("default must be AST_SymbolImport");if(this.default.key.value!=="")throw new Error("invalid default key: "+this.default.key.value);}if(!(this.path instanceof AST_String))throw new Error("path must be AST_String");if(this.properties!=null)this.properties.forEach(function(node){if(!(node instanceof AST_SymbolImport))throw new Error("properties must contain AST_SymbolImport");});}},AST_Statement);var AST_DefaultValue=DEFNODE("DefaultValue","name value",{$documentation:"A default value declaration",$propdoc:{name:"[AST_Destructured|AST_SymbolDeclaration] name of the variable",value:"[AST_Node] value to assign if variable is `undefined`"},_equals:function(node){return this.name.equals(node.name)&&this.value.equals(node.value);},walk:function(visitor){var node=this;visitor.visit(node,function(){node.name.walk(visitor);node.value.walk(visitor);});},_validate:function(){must_be_expression(this,"value");}});function must_be_expressions(node,prop,allow_spread,allow_hole){node[prop].forEach(function(node){validate_expression(node,prop,true,allow_spread,allow_hole);});}var AST_Call=DEFNODE("Call","args expression optional pure terminal",{$documentation:"A function call expression",$propdoc:{args:"[AST_Node*] array of arguments",expression:"[AST_Node] expression to invoke as function",optional:"[boolean] whether the expression is optional chaining",pure:"[boolean/S] marker for side-effect-free call expression",terminal:"[boolean] whether the chain has ended"},_equals:function(node){return !this.optional==!node.optional&&this.expression.equals(node.expression)&&all_equals(this.args,node.args);},walk:function(visitor){var node=this;visitor.visit(node,function(){node.expression.walk(visitor);node.args.forEach(function(arg){arg.walk(visitor);});});},_validate:function(){must_be_expression(this,"expression");must_be_expressions(this,"args",true);}});var AST_New=DEFNODE("New",null,{$documentation:"An object instantiation.  Derives from a function call since it has exactly the same properties",_validate:function(){if(this.optional)throw new Error("optional must be false");if(this.terminal)throw new Error("terminal must be false");}},AST_Call);var AST_Sequence=DEFNODE("Sequence","expressions",{$documentation:"A sequence expression (comma-separated expressions)",$propdoc:{expressions:"[AST_Node*] array of expressions (at least two)"},_equals:function(node){return all_equals(this.expressions,node.expressions);},walk:function(visitor){var node=this;visitor.visit(node,function(){node.expressions.forEach(function(expr){expr.walk(visitor);});});},_validate:function(){if(this.expressions.length<2)throw new Error("expressions must contain multiple elements");must_be_expressions(this,"expressions");}});function root_expr(prop){while(prop instanceof AST_PropAccess)prop=prop.expression;return prop;}var AST_PropAccess=DEFNODE("PropAccess","expression optional property terminal",{$documentation:"Base class for property access expressions, i.e. `a.foo` or `a[\"foo\"]`",$propdoc:{expression:"[AST_Node] the container expression",optional:"[boolean] whether the expression is optional chaining",property:"[AST_Node|string] the property to access.  For AST_Dot this is always a plain string, while for AST_Sub it's an arbitrary AST_Node",terminal:"[boolean] whether the chain has ended"},_equals:function(node){return !this.optional==!node.optional&&prop_equals(this.property,node.property)&&this.expression.equals(node.expression);},get_property:function(){var p=this.property;if(p instanceof AST_Constant)return p.value;if(p instanceof AST_UnaryPrefix&&p.operator=="void"&&p.expression instanceof AST_Constant)return;return p;},_validate:function(){if(this.TYPE=="PropAccess")throw new Error("should not instantiate AST_PropAccess");must_be_expression(this,"expression");}});var AST_Dot=DEFNODE("Dot","quoted",{$documentation:"A dotted property access expression",$propdoc:{quoted:"[boolean] whether property is transformed from a quoted string"},walk:function(visitor){var node=this;visitor.visit(node,function(){node.expression.walk(visitor);});},_validate:function(){if(typeof this.property!="string")throw new Error("property must be string");}},AST_PropAccess);var AST_Sub=DEFNODE("Sub",null,{$documentation:"Index-style property access, i.e. `a[\"foo\"]`",walk:function(visitor){var node=this;visitor.visit(node,function(){node.expression.walk(visitor);node.property.walk(visitor);});},_validate:function(){must_be_expression(this,"property");}},AST_PropAccess);var AST_Spread=DEFNODE("Spread","expression",{$documentation:"Spread expression in array/object literals or function calls",$propdoc:{expression:"[AST_Node] expression to be expanded"},_equals:function(node){return this.expression.equals(node.expression);},walk:function(visitor){var node=this;visitor.visit(node,function(){node.expression.walk(visitor);});},_validate:function(){must_be_expression(this,"expression");}});var AST_Unary=DEFNODE("Unary","operator expression",{$documentation:"Base class for unary expressions",$propdoc:{operator:"[string] the operator",expression:"[AST_Node] expression that this unary operator applies to"},_equals:function(node){return this.operator==node.operator&&this.expression.equals(node.expression);},walk:function(visitor){var node=this;visitor.visit(node,function(){node.expression.walk(visitor);});},_validate:function(){if(this.TYPE=="Unary")throw new Error("should not instantiate AST_Unary");if(typeof this.operator!="string")throw new Error("operator must be string");must_be_expression(this,"expression");}});var AST_UnaryPrefix=DEFNODE("UnaryPrefix",null,{$documentation:"Unary prefix expression, i.e. `typeof i` or `++i`"},AST_Unary);var AST_UnaryPostfix=DEFNODE("UnaryPostfix",null,{$documentation:"Unary postfix expression, i.e. `i++`"},AST_Unary);var AST_Binary=DEFNODE("Binary","operator left right",{$documentation:"Binary expression, i.e. `a + b`",$propdoc:{left:"[AST_Node] left-hand side expression",operator:"[string] the operator",right:"[AST_Node] right-hand side expression"},_equals:function(node){return this.operator==node.operator&&this.left.equals(node.left)&&this.right.equals(node.right);},walk:function(visitor){var node=this;visitor.visit(node,function(){node.left.walk(visitor);node.right.walk(visitor);});},_validate:function(){if(!(this instanceof AST_Assign))must_be_expression(this,"left");if(typeof this.operator!="string")throw new Error("operator must be string");must_be_expression(this,"right");}});var AST_Conditional=DEFNODE("Conditional","condition consequent alternative",{$documentation:"Conditional expression using the ternary operator, i.e. `a ? b : c`",$propdoc:{condition:"[AST_Node]",consequent:"[AST_Node]",alternative:"[AST_Node]"},_equals:function(node){return this.condition.equals(node.condition)&&this.consequent.equals(node.consequent)&&this.alternative.equals(node.alternative);},walk:function(visitor){var node=this;visitor.visit(node,function(){node.condition.walk(visitor);node.consequent.walk(visitor);node.alternative.walk(visitor);});},_validate:function(){must_be_expression(this,"condition");must_be_expression(this,"consequent");must_be_expression(this,"alternative");}});var AST_Assign=DEFNODE("Assign",null,{$documentation:"An assignment expression  `a = b + 5`",_validate:function(){if(this.operator.indexOf("=")<0)throw new Error('operator must contain "="');if(this.left instanceof AST_Destructured){if(this.operator!="=")throw new Error("invalid destructuring operator: "+this.operator);validate_destructured(this.left,function(node){if(!(node instanceof AST_PropAccess||node instanceof AST_SymbolRef)){throw new Error("left must be assignable: "+node.TYPE);}});}else if(!(this.left instanceof AST_Infinity||this.left instanceof AST_NaN||this.left instanceof AST_PropAccess&&!this.left.optional||this.left instanceof AST_SymbolRef||this.left instanceof AST_Undefined)){throw new Error("left must be assignable");}}},AST_Binary);var AST_Await=DEFNODE("Await","expression",{$documentation:"An await expression",$propdoc:{expression:"[AST_Node] expression with Promise to resolve on"},_equals:function(node){return this.expression.equals(node.expression);},walk:function(visitor){var node=this;visitor.visit(node,function(){node.expression.walk(visitor);});},_validate:function(){must_be_expression(this,"expression");}});var AST_Yield=DEFNODE("Yield","expression nested",{$documentation:"A yield expression",$propdoc:{expression:"[AST_Node?] return value for iterator, or null if undefined",nested:"[boolean] whether to iterate over expression as generator"},_equals:function(node){return !this.nested==!node.nested&&prop_equals(this.expression,node.expression);},walk:function(visitor){var node=this;visitor.visit(node,function(){if(node.expression)node.expression.walk(visitor);});},_validate:function(){if(this.expression!=null){must_be_expression(this,"expression");}else if(this.nested){throw new Error("yield* must contain expression");}}});/* -----[ LITERALS ]----- */var AST_Array=DEFNODE("Array","elements",{$documentation:"An array literal",$propdoc:{elements:"[AST_Node*] array of elements"},_equals:function(node){return all_equals(this.elements,node.elements);},walk:function(visitor){var node=this;visitor.visit(node,function(){node.elements.forEach(function(element){element.walk(visitor);});});},_validate:function(){must_be_expressions(this,"elements",true,true);}});var AST_Destructured=DEFNODE("Destructured","rest",{$documentation:"Base class for destructured literal",$propdoc:{rest:"[(AST_Destructured|AST_SymbolDeclaration|AST_SymbolRef)?] rest parameter, or null if absent"},_validate:function(){if(this.TYPE=="Destructured")throw new Error("should not instantiate AST_Destructured");}});function validate_destructured(node,check,allow_default){if(node instanceof AST_DefaultValue&&allow_default)return validate_destructured(node.name,check);if(node instanceof AST_Destructured){if(node.rest!=null)validate_destructured(node.rest,check);if(node instanceof AST_DestructuredArray)return node.elements.forEach(function(node){if(!(node instanceof AST_Hole))validate_destructured(node,check,true);});if(node instanceof AST_DestructuredObject)return node.properties.forEach(function(prop){validate_destructured(prop.value,check,true);});}check(node);}var AST_DestructuredArray=DEFNODE("DestructuredArray","elements",{$documentation:"A destructured array literal",$propdoc:{elements:"[(AST_DefaultValue|AST_Destructured|AST_SymbolDeclaration|AST_SymbolRef)*] array of elements"},_equals:function(node){return prop_equals(this.rest,node.rest)&&all_equals(this.elements,node.elements);},walk:function(visitor){var node=this;visitor.visit(node,function(){node.elements.forEach(function(element){element.walk(visitor);});if(node.rest)node.rest.walk(visitor);});}},AST_Destructured);var AST_DestructuredKeyVal=DEFNODE("DestructuredKeyVal","key value",{$documentation:"A key: value destructured property",$propdoc:{key:"[string|AST_Node] property name.  For computed property this is an AST_Node.",value:"[AST_DefaultValue|AST_Destructured|AST_SymbolDeclaration|AST_SymbolRef] property value"},_equals:function(node){return prop_equals(this.key,node.key)&&this.value.equals(node.value);},walk:function(visitor){var node=this;visitor.visit(node,function(){if(node.key instanceof AST_Node)node.key.walk(visitor);node.value.walk(visitor);});},_validate:function(){if(typeof this.key!="string"){if(!(this.key instanceof AST_Node))throw new Error("key must be string or AST_Node");must_be_expression(this,"key");}if(!(this.value instanceof AST_Node))throw new Error("value must be AST_Node");}});var AST_DestructuredObject=DEFNODE("DestructuredObject","properties",{$documentation:"A destructured object literal",$propdoc:{properties:"[AST_DestructuredKeyVal*] array of properties"},_equals:function(node){return prop_equals(this.rest,node.rest)&&all_equals(this.properties,node.properties);},walk:function(visitor){var node=this;visitor.visit(node,function(){node.properties.forEach(function(prop){prop.walk(visitor);});if(node.rest)node.rest.walk(visitor);});},_validate:function(){this.properties.forEach(function(node){if(!(node instanceof AST_DestructuredKeyVal))throw new Error("properties must be AST_DestructuredKeyVal[]");});}},AST_Destructured);var AST_Object=DEFNODE("Object","properties",{$documentation:"An object literal",$propdoc:{properties:"[(AST_ObjectProperty|AST_Spread)*] array of properties"},_equals:function(node){return all_equals(this.properties,node.properties);},walk:function(visitor){var node=this;visitor.visit(node,function(){node.properties.forEach(function(prop){prop.walk(visitor);});});},_validate:function(){this.properties.forEach(function(node){if(!(node instanceof AST_ObjectProperty||node instanceof AST_Spread)){throw new Error("properties must contain AST_ObjectProperty and/or AST_Spread only");}});}});var AST_ObjectProperty=DEFNODE("ObjectProperty","key value",{$documentation:"Base class for literal object properties",$propdoc:{key:"[string|AST_Node] property name.  For computed property this is an AST_Node.",value:"[AST_Node] property value.  For getters and setters this is an AST_Accessor."},_equals:function(node){return prop_equals(this.key,node.key)&&this.value.equals(node.value);},walk:function(visitor){var node=this;visitor.visit(node,function(){if(node.key instanceof AST_Node)node.key.walk(visitor);node.value.walk(visitor);});},_validate:function(){if(this.TYPE=="ObjectProperty")throw new Error("should not instantiate AST_ObjectProperty");if(typeof this.key!="string"){if(!(this.key instanceof AST_Node))throw new Error("key must be string or AST_Node");must_be_expression(this,"key");}if(!(this.value instanceof AST_Node))throw new Error("value must be AST_Node");}});var AST_ObjectKeyVal=DEFNODE("ObjectKeyVal",null,{$documentation:"A key: value object property",_validate:function(){must_be_expression(this,"value");}},AST_ObjectProperty);var AST_ObjectMethod=DEFNODE("ObjectMethod",null,{$documentation:"A key(){} object property",_validate:function(){if(!(this.value instanceof AST_LambdaExpression))throw new Error("value must be AST_LambdaExpression");if(is_arrow(this.value))throw new Error("value cannot be AST_Arrow or AST_AsyncArrow");if(this.value.name!=null)throw new Error("name of object method's lambda must be null");}},AST_ObjectKeyVal);var AST_ObjectSetter=DEFNODE("ObjectSetter",null,{$documentation:"An object setter property",_validate:function(){if(!(this.value instanceof AST_Accessor))throw new Error("value must be AST_Accessor");}},AST_ObjectProperty);var AST_ObjectGetter=DEFNODE("ObjectGetter",null,{$documentation:"An object getter property",_validate:function(){if(!(this.value instanceof AST_Accessor))throw new Error("value must be AST_Accessor");}},AST_ObjectProperty);var AST_Symbol=DEFNODE("Symbol","scope name thedef",{$documentation:"Base class for all symbols",$propdoc:{name:"[string] name of this symbol",scope:"[AST_Scope/S] the current scope (not necessarily the definition scope)",thedef:"[SymbolDef/S] the definition of this symbol"},_equals:function(node){return this.thedef?this.thedef===node.thedef:this.name==node.name;},_validate:function(){if(this.TYPE=="Symbol")throw new Error("should not instantiate AST_Symbol");if(typeof this.name!="string")throw new Error("name must be string");}});var AST_SymbolDeclaration=DEFNODE("SymbolDeclaration","init",{$documentation:"A declaration symbol (symbol in var, function name or argument, symbol in catch)"},AST_Symbol);var AST_SymbolConst=DEFNODE("SymbolConst",null,{$documentation:"Symbol defining a constant"},AST_SymbolDeclaration);var AST_SymbolImport=DEFNODE("SymbolImport","key",{$documentation:"Symbol defined by an `import` statement",$propdoc:{key:"[AST_String] the original `export` name"},_equals:function(node){return this.name==node.name&&this.key.equals(node.key);},_validate:function(){if(!(this.key instanceof AST_String))throw new Error("key must be AST_String");}},AST_SymbolConst);var AST_SymbolLet=DEFNODE("SymbolLet",null,{$documentation:"Symbol defining a lexical-scoped variable"},AST_SymbolDeclaration);var AST_SymbolVar=DEFNODE("SymbolVar",null,{$documentation:"Symbol defining a variable"},AST_SymbolDeclaration);var AST_SymbolFunarg=DEFNODE("SymbolFunarg","unused",{$documentation:"Symbol naming a function argument"},AST_SymbolVar);var AST_SymbolDefun=DEFNODE("SymbolDefun",null,{$documentation:"Symbol defining a function"},AST_SymbolDeclaration);var AST_SymbolLambda=DEFNODE("SymbolLambda",null,{$documentation:"Symbol naming a function expression"},AST_SymbolDeclaration);var AST_SymbolDefClass=DEFNODE("SymbolDefClass",null,{$documentation:"Symbol defining a class"},AST_SymbolConst);var AST_SymbolClass=DEFNODE("SymbolClass",null,{$documentation:"Symbol naming a class expression"},AST_SymbolConst);var AST_SymbolCatch=DEFNODE("SymbolCatch",null,{$documentation:"Symbol naming the exception in catch"},AST_SymbolDeclaration);var AST_Label=DEFNODE("Label","references",{$documentation:"Symbol naming a label (declaration)",$propdoc:{references:"[AST_LoopControl*] a list of nodes referring to this label"},initialize:function(){this.references=[];this.thedef=this;}},AST_Symbol);var AST_SymbolRef=DEFNODE("SymbolRef","fixed in_arg redef",{$documentation:"Reference to some symbol (not definition/declaration)"},AST_Symbol);var AST_SymbolExport=DEFNODE("SymbolExport","alias",{$documentation:"Reference in an `export` statement",$propdoc:{alias:"[AST_String] the `export` alias"},_equals:function(node){return this.name==node.name&&this.alias.equals(node.alias);},_validate:function(){if(!(this.alias instanceof AST_String))throw new Error("alias must be AST_String");}},AST_SymbolRef);var AST_LabelRef=DEFNODE("LabelRef",null,{$documentation:"Reference to a label symbol"},AST_Symbol);var AST_ObjectIdentity=DEFNODE("ObjectIdentity",null,{$documentation:"Base class for `super` & `this`",_equals:return_true,_validate:function(){if(this.TYPE=="ObjectIdentity")throw new Error("should not instantiate AST_ObjectIdentity");}},AST_Symbol);var AST_Super=DEFNODE("Super",null,{$documentation:"The `super` symbol",_validate:function(){if(this.name!=="super")throw new Error('name must be "super"');}},AST_ObjectIdentity);var AST_This=DEFNODE("This",null,{$documentation:"The `this` symbol",_validate:function(){if(this.TYPE=="This"&&this.name!=="this")throw new Error('name must be "this"');}},AST_ObjectIdentity);var AST_NewTarget=DEFNODE("NewTarget",null,{$documentation:"The `new.target` symbol",initialize:function(){this.name="new.target";},_validate:function(){if(this.name!=="new.target")throw new Error('name must be "new.target": '+this.name);}},AST_This);var AST_Template=DEFNODE("Template","expressions strings tag",{$documentation:"A template literal, i.e. tag`str1${expr1}...strN${exprN}strN+1`",$propdoc:{expressions:"[AST_Node*] the placeholder expressions",strings:"[string*] the raw text segments",tag:"[AST_Node?] tag function, or null if absent"},_equals:function(node){return prop_equals(this.tag,node.tag)&&list_equals(this.strings,node.strings)&&all_equals(this.expressions,node.expressions);},walk:function(visitor){var node=this;visitor.visit(node,function(){if(node.tag)node.tag.walk(visitor);node.expressions.forEach(function(expr){expr.walk(visitor);});});},_validate:function(){if(this.expressions.length+1!=this.strings.length){throw new Error("malformed template with "+this.expressions.length+" placeholder(s) but "+this.strings.length+" text segment(s)");}must_be_expressions(this,"expressions");this.strings.forEach(function(string){if(typeof string!="string")throw new Error("strings must contain string");});if(this.tag!=null)must_be_expression(this,"tag");}});var AST_Constant=DEFNODE("Constant",null,{$documentation:"Base class for all constants",_equals:function(node){return this.value===node.value;},_validate:function(){if(this.TYPE=="Constant")throw new Error("should not instantiate AST_Constant");}});var AST_String=DEFNODE("String","quote value",{$documentation:"A string literal",$propdoc:{quote:"[string?] the original quote character",value:"[string] the contents of this string"},_validate:function(){if(this.quote!=null){if(typeof this.quote!="string")throw new Error("quote must be string");if(!/^["']$/.test(this.quote))throw new Error("invalid quote: "+this.quote);}if(typeof this.value!="string")throw new Error("value must be string");}},AST_Constant);var AST_Number=DEFNODE("Number","value",{$documentation:"A number literal",$propdoc:{value:"[number] the numeric value"},_validate:function(){if(typeof this.value!="number")throw new Error("value must be number");if(!isFinite(this.value))throw new Error("value must be finite");if(this.value<0)throw new Error("value cannot be negative");}},AST_Constant);var AST_BigInt=DEFNODE("BigInt","value",{$documentation:"A BigInt literal",$propdoc:{value:"[string] the numeric representation"},_validate:function(){if(typeof this.value!="string")throw new Error("value must be string");if(this.value[0]=="-")throw new Error("value cannot be negative");}},AST_Constant);var AST_RegExp=DEFNODE("RegExp","value",{$documentation:"A regexp literal",$propdoc:{value:"[RegExp] the actual regexp"},_equals:function(node){return ""+this.value==""+node.value;},_validate:function(){if(!(this.value instanceof RegExp))throw new Error("value must be RegExp");}},AST_Constant);var AST_Atom=DEFNODE("Atom",null,{$documentation:"Base class for atoms",_equals:return_true,_validate:function(){if(this.TYPE=="Atom")throw new Error("should not instantiate AST_Atom");}},AST_Constant);var AST_Null=DEFNODE("Null",null,{$documentation:"The `null` atom",value:null},AST_Atom);var AST_NaN=DEFNODE("NaN",null,{$documentation:"The impossible value",value:0/0},AST_Atom);var AST_Undefined=DEFNODE("Undefined",null,{$documentation:"The `undefined` value",value:function(){}()},AST_Atom);var AST_Hole=DEFNODE("Hole",null,{$documentation:"A hole in an array",value:function(){}()},AST_Atom);var AST_Infinity=DEFNODE("Infinity",null,{$documentation:"The `Infinity` value",value:1/0},AST_Atom);var AST_Boolean=DEFNODE("Boolean",null,{$documentation:"Base class for booleans",_validate:function(){if(this.TYPE=="Boolean")throw new Error("should not instantiate AST_Boolean");}},AST_Atom);var AST_False=DEFNODE("False",null,{$documentation:"The `false` atom",value:false},AST_Boolean);var AST_True=DEFNODE("True",null,{$documentation:"The `true` atom",value:true},AST_Boolean);/* -----[ TreeWalker ]----- */function TreeWalker(callback){this.callback=callback;this.directives=Object.create(null);this.stack=[];}TreeWalker.prototype={visit:function(node,descend){this.push(node);var done=this.callback(node,descend||noop);if(!done&&descend)descend();this.pop();},parent:function(n){return this.stack[this.stack.length-2-(n||0)];},push:function(node){var value;if(node instanceof AST_Class){this.directives=Object.create(this.directives);value="use strict";}else if(node instanceof AST_Directive){value=node.value;}else if(node instanceof AST_Lambda){this.directives=Object.create(this.directives);}if(value&&!this.directives[value])this.directives[value]=node;this.stack.push(node);},pop:function(){var node=this.stack.pop();if(node instanceof AST_Class||node instanceof AST_Lambda){this.directives=Object.getPrototypeOf(this.directives);}},self:function(){return this.stack[this.stack.length-1];},find_parent:function(type){var stack=this.stack;for(var i=stack.length-1;--i>=0;){var x=stack[i];if(x instanceof type)return x;}},has_directive:function(type){var dir=this.directives[type];if(dir)return dir;var node=this.stack[this.stack.length-1];if(node instanceof AST_Scope){for(var i=0;i<node.body.length;++i){var st=node.body[i];if(!(st instanceof AST_Directive))break;if(st.value==type)return st;}}},loopcontrol_target:function(node){var stack=this.stack;if(node.label)for(var i=stack.length;--i>=0;){var x=stack[i];if(x instanceof AST_LabeledStatement&&x.label.name==node.label.name)return x.body;}else for(var i=stack.length;--i>=0;){var x=stack[i];if(x instanceof AST_IterationStatement||node instanceof AST_Break&&x instanceof AST_Switch)return x;}},in_boolean_context:function(){for(var drop=true,level=0,parent,self=this.self();parent=this.parent(level++);self=parent){if(parent instanceof AST_Binary)switch(parent.operator){case"&&":case"||":if(parent.left===self)drop=false;continue;default:return false;}if(parent instanceof AST_Conditional){if(parent.condition===self)return true;continue;}if(parent instanceof AST_DWLoop)return parent.condition===self;if(parent instanceof AST_For)return parent.condition===self;if(parent instanceof AST_If)return parent.condition===self;if(parent instanceof AST_Return){if(parent.in_bool)return true;while(parent=this.parent(level++)){if(parent instanceof AST_Lambda){if(parent.name)return false;parent=this.parent(level++);if(parent.TYPE!="Call")return false;break;}}}if(parent instanceof AST_Sequence){if(parent.tail_node()===self)continue;return drop?"d":true;}if(parent instanceof AST_SimpleStatement)return drop?"d":true;if(parent instanceof AST_UnaryPrefix)return parent.operator=="!";return false;}}};function TreeTransformer(before,after){TreeWalker.call(this);this.before=before;this.after=after;}TreeTransformer.prototype=new TreeWalker();(function(DEF){function do_list(list,tw){return List(list,function(node){return node.transform(tw,true);});}DEF(AST_Node,noop);DEF(AST_LabeledStatement,function(self,tw){self.label=self.label.transform(tw);self.body=self.body.transform(tw);});DEF(AST_SimpleStatement,function(self,tw){self.body=self.body.transform(tw);});DEF(AST_Block,function(self,tw){self.body=do_list(self.body,tw);});DEF(AST_Do,function(self,tw){self.body=self.body.transform(tw);self.condition=self.condition.transform(tw);});DEF(AST_While,function(self,tw){self.condition=self.condition.transform(tw);self.body=self.body.transform(tw);});DEF(AST_For,function(self,tw){if(self.init)self.init=self.init.transform(tw);if(self.condition)self.condition=self.condition.transform(tw);if(self.step)self.step=self.step.transform(tw);self.body=self.body.transform(tw);});DEF(AST_ForEnumeration,function(self,tw){self.init=self.init.transform(tw);self.object=self.object.transform(tw);self.body=self.body.transform(tw);});DEF(AST_With,function(self,tw){self.expression=self.expression.transform(tw);self.body=self.body.transform(tw);});DEF(AST_Exit,function(self,tw){if(self.value)self.value=self.value.transform(tw);});DEF(AST_LoopControl,function(self,tw){if(self.label)self.label=self.label.transform(tw);});DEF(AST_If,function(self,tw){self.condition=self.condition.transform(tw);self.body=self.body.transform(tw);if(self.alternative)self.alternative=self.alternative.transform(tw);});DEF(AST_Switch,function(self,tw){self.expression=self.expression.transform(tw);self.body=do_list(self.body,tw);});DEF(AST_Case,function(self,tw){self.expression=self.expression.transform(tw);self.body=do_list(self.body,tw);});DEF(AST_Try,function(self,tw){self.body=do_list(self.body,tw);if(self.bcatch)self.bcatch=self.bcatch.transform(tw);if(self.bfinally)self.bfinally=self.bfinally.transform(tw);});DEF(AST_Catch,function(self,tw){if(self.argname)self.argname=self.argname.transform(tw);self.body=do_list(self.body,tw);});DEF(AST_Definitions,function(self,tw){self.definitions=do_list(self.definitions,tw);});DEF(AST_VarDef,function(self,tw){self.name=self.name.transform(tw);if(self.value)self.value=self.value.transform(tw);});DEF(AST_DefaultValue,function(self,tw){self.name=self.name.transform(tw);self.value=self.value.transform(tw);});DEF(AST_Lambda,function(self,tw){if(self.name)self.name=self.name.transform(tw);self.argnames=do_list(self.argnames,tw);if(self.rest)self.rest=self.rest.transform(tw);self.body=do_list(self.body,tw);});function transform_arrow(self,tw){self.argnames=do_list(self.argnames,tw);if(self.rest)self.rest=self.rest.transform(tw);if(self.value){self.value=self.value.transform(tw);}else {self.body=do_list(self.body,tw);}}DEF(AST_Arrow,transform_arrow);DEF(AST_AsyncArrow,transform_arrow);DEF(AST_Class,function(self,tw){if(self.name)self.name=self.name.transform(tw);if(self.extends)self.extends=self.extends.transform(tw);self.properties=do_list(self.properties,tw);});DEF(AST_ClassProperty,function(self,tw){if(self.key instanceof AST_Node)self.key=self.key.transform(tw);if(self.value)self.value=self.value.transform(tw);});DEF(AST_Call,function(self,tw){self.expression=self.expression.transform(tw);self.args=do_list(self.args,tw);});DEF(AST_Sequence,function(self,tw){self.expressions=do_list(self.expressions,tw);});DEF(AST_Await,function(self,tw){self.expression=self.expression.transform(tw);});DEF(AST_Yield,function(self,tw){if(self.expression)self.expression=self.expression.transform(tw);});DEF(AST_Dot,function(self,tw){self.expression=self.expression.transform(tw);});DEF(AST_Sub,function(self,tw){self.expression=self.expression.transform(tw);self.property=self.property.transform(tw);});DEF(AST_Spread,function(self,tw){self.expression=self.expression.transform(tw);});DEF(AST_Unary,function(self,tw){self.expression=self.expression.transform(tw);});DEF(AST_Binary,function(self,tw){self.left=self.left.transform(tw);self.right=self.right.transform(tw);});DEF(AST_Conditional,function(self,tw){self.condition=self.condition.transform(tw);self.consequent=self.consequent.transform(tw);self.alternative=self.alternative.transform(tw);});DEF(AST_Array,function(self,tw){self.elements=do_list(self.elements,tw);});DEF(AST_DestructuredArray,function(self,tw){self.elements=do_list(self.elements,tw);if(self.rest)self.rest=self.rest.transform(tw);});DEF(AST_DestructuredKeyVal,function(self,tw){if(self.key instanceof AST_Node)self.key=self.key.transform(tw);self.value=self.value.transform(tw);});DEF(AST_DestructuredObject,function(self,tw){self.properties=do_list(self.properties,tw);if(self.rest)self.rest=self.rest.transform(tw);});DEF(AST_Object,function(self,tw){self.properties=do_list(self.properties,tw);});DEF(AST_ObjectProperty,function(self,tw){if(self.key instanceof AST_Node)self.key=self.key.transform(tw);self.value=self.value.transform(tw);});DEF(AST_ExportDeclaration,function(self,tw){self.body=self.body.transform(tw);});DEF(AST_ExportDefault,function(self,tw){self.body=self.body.transform(tw);});DEF(AST_ExportReferences,function(self,tw){self.properties=do_list(self.properties,tw);});DEF(AST_Import,function(self,tw){if(self.all)self.all=self.all.transform(tw);if(self.default)self.default=self.default.transform(tw);if(self.properties)self.properties=do_list(self.properties,tw);});DEF(AST_Template,function(self,tw){if(self.tag)self.tag=self.tag.transform(tw);self.expressions=do_list(self.expressions,tw);});})(function(node,descend){node.DEFMETHOD("transform",function(tw,in_list){var x,y;tw.push(this);if(tw.before)x=tw.before(this,descend,in_list);if(typeof x==="undefined"){x=this;descend(x,tw);if(tw.after){y=tw.after(x,in_list);if(typeof y!=="undefined")x=y;}}tw.pop();return x;});});var KEYWORDS="break case catch class const continue debugger default delete do else extends finally for function if in instanceof new return switch throw try typeof var void while with";var KEYWORDS_ATOM="false null true";var RESERVED_WORDS=["abstract async await boolean byte char double enum export final float goto implements import int interface let long native package private protected public short static super synchronized this throws transient volatile yield",KEYWORDS_ATOM,KEYWORDS].join(" ");var KEYWORDS_BEFORE_EXPRESSION="return new delete throw else case";KEYWORDS=makePredicate(KEYWORDS);RESERVED_WORDS=makePredicate(RESERVED_WORDS);KEYWORDS_BEFORE_EXPRESSION=makePredicate(KEYWORDS_BEFORE_EXPRESSION);KEYWORDS_ATOM=makePredicate(KEYWORDS_ATOM);var RE_BIN_NUMBER=/^0b([01]+)$/i;var RE_HEX_NUMBER=/^0x([0-9a-f]+)$/i;var RE_OCT_NUMBER=/^0o?([0-7]+)$/i;var OPERATORS=makePredicate(["in","instanceof","typeof","new","void","delete","++","--","+","-","!","~","&","|","^","*","/","%","**",">>","<<",">>>","<",">","<=",">=","==","===","!=","!==","?","=","+=","-=","/=","*=","%=","**=",">>=","<<=",">>>=","&=","|=","^=","&&","||","??","&&=","||=","??="]);var NEWLINE_CHARS="\n\r\u2028\u2029";var OPERATOR_CHARS="+-*&%=<>!?|~^";var PUNC_OPENERS="[{(";var PUNC_SEPARATORS=",;:";var PUNC_CLOSERS=")}]";var PUNC_AFTER_EXPRESSION=PUNC_SEPARATORS+PUNC_CLOSERS;var PUNC_BEFORE_EXPRESSION=PUNC_OPENERS+PUNC_SEPARATORS;var PUNC_CHARS=PUNC_BEFORE_EXPRESSION+"`"+PUNC_CLOSERS;var WHITESPACE_CHARS=NEWLINE_CHARS+" \u00a0\t\f\u000b\u200b\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\uFEFF";var NON_IDENTIFIER_CHARS=makePredicate(characters("./'\"#"+OPERATOR_CHARS+PUNC_CHARS+WHITESPACE_CHARS));NEWLINE_CHARS=makePredicate(characters(NEWLINE_CHARS));OPERATOR_CHARS=makePredicate(characters(OPERATOR_CHARS));PUNC_AFTER_EXPRESSION=makePredicate(characters(PUNC_AFTER_EXPRESSION));PUNC_BEFORE_EXPRESSION=makePredicate(characters(PUNC_BEFORE_EXPRESSION));PUNC_CHARS=makePredicate(characters(PUNC_CHARS));WHITESPACE_CHARS=makePredicate(characters(WHITESPACE_CHARS));/* -----[ Tokenizer ]----- */function is_surrogate_pair_head(code){return code>=0xd800&&code<=0xdbff;}function is_surrogate_pair_tail(code){return code>=0xdc00&&code<=0xdfff;}function is_digit(code){return code>=48&&code<=57;}function is_identifier_char(ch){return !NON_IDENTIFIER_CHARS[ch];}function is_identifier_string(str){return /^[a-z_$][a-z0-9_$]*$/i.test(str);}function decode_escape_sequence(seq){switch(seq[0]){case"b":return "\b";case"f":return "\f";case"n":return "\n";case"r":return "\r";case"t":return "\t";case"u":var code;if(seq[1]=="{"&&seq.slice(-1)=="}"){code=seq.slice(2,-1);}else if(seq.length==5){code=seq.slice(1);}else {return;}var num=parseInt(code,16);if(num<0||isNaN(num))return;if(num<0x10000)return String.fromCharCode(num);if(num>0x10ffff)return;return String.fromCharCode((num>>10)+0xd7c0)+String.fromCharCode((num&0x03ff)+0xdc00);case"v":return "\u000b";case"x":if(seq.length!=3)return;var num=parseInt(seq.slice(1),16);if(num<0||isNaN(num))return;return String.fromCharCode(num);case"\r":case"\n":return "";default:if(seq=="0")return "\0";if(seq[0]>="0"&&seq[0]<="9")return;return seq;}}function parse_js_number(num){var match;if(match=RE_BIN_NUMBER.exec(num))return parseInt(match[1],2);if(match=RE_HEX_NUMBER.exec(num))return parseInt(match[1],16);if(match=RE_OCT_NUMBER.exec(num))return parseInt(match[1],8);var val=parseFloat(num);if(val==num)return val;}function JS_Parse_Error(message,filename,line,col,pos){this.message=message;this.filename=filename;this.line=line;this.col=col;this.pos=pos;try{throw new SyntaxError(message,filename,line,col);}catch(cause){configure_error_stack(this,cause);}}JS_Parse_Error.prototype=Object.create(SyntaxError.prototype);JS_Parse_Error.prototype.constructor=JS_Parse_Error;function js_error(message,filename,line,col,pos){throw new JS_Parse_Error(message,filename,line,col,pos);}function is_token(token,type,val){return token.type==type&&(val==null||token.value==val);}var EX_EOF={};function tokenizer($TEXT,filename,html5_comments,shebang){var S={text:$TEXT,filename:filename,pos:0,tokpos:0,line:1,tokline:0,col:0,tokcol:0,newline_before:false,regex_allowed:false,comments_before:[],directives:Object.create(null),read_template:with_eof_error("Unterminated template literal",function(strings){var s="";for(;;){var ch=read();switch(ch){case"\\":ch+=read();break;case"`":strings.push(s);return;case"$":if(peek()=="{"){next();strings.push(s);S.regex_allowed=true;return true;}}s+=ch;}function read(){var ch=next(true,true);return ch=="\r"?"\n":ch;}})};var prev_was_dot=false;function peek(){return S.text.charAt(S.pos);}function next(signal_eof,in_string){var ch=S.text.charAt(S.pos++);if(signal_eof&&!ch)throw EX_EOF;if(NEWLINE_CHARS[ch]){S.col=0;S.line++;if(!in_string)S.newline_before=true;if(ch=="\r"&&peek()=="\n"){// treat `\r\n` as `\n`
S.pos++;ch="\n";}}else {S.col++;}return ch;}function forward(i){while(i-->0)next();}function looking_at(str){return S.text.substr(S.pos,str.length)==str;}function find_eol(){var text=S.text;for(var i=S.pos;i<S.text.length;++i){if(NEWLINE_CHARS[text[i]])return i;}return -1;}function find(what,signal_eof){var pos=S.text.indexOf(what,S.pos);if(pos==-1)throw EX_EOF;return pos;}function start_token(){S.tokline=S.line;S.tokcol=S.col;S.tokpos=S.pos;}function token(type,value,is_comment){S.regex_allowed=type=="operator"&&!UNARY_POSTFIX[value]||type=="keyword"&&KEYWORDS_BEFORE_EXPRESSION[value]||type=="punc"&&PUNC_BEFORE_EXPRESSION[value];if(type=="punc"&&value==".")prev_was_dot=true;else if(!is_comment)prev_was_dot=false;var ret={type:type,value:value,line:S.tokline,col:S.tokcol,pos:S.tokpos,endline:S.line,endcol:S.col,endpos:S.pos,nlb:S.newline_before,file:filename};if(/^(?:num|string|regexp)$/i.test(type)){ret.raw=$TEXT.substring(ret.pos,ret.endpos);}if(!is_comment){ret.comments_before=S.comments_before;ret.comments_after=S.comments_before=[];}S.newline_before=false;return new AST_Token(ret);}function skip_whitespace(){while(WHITESPACE_CHARS[peek()])next();}function read_while(pred){var ret="",ch;while((ch=peek())&&pred(ch,ret))ret+=next();return ret;}function parse_error(err){js_error(err,filename,S.tokline,S.tokcol,S.tokpos);}function is_octal(num){return /^0[0-7_]+$/.test(num);}function read_num(prefix){var has_e=false,after_e=false,has_x=false,has_dot=prefix==".";var num=read_while(function(ch,str){switch(ch){case"x":case"X":return has_x?false:has_x=true;case"e":case"E":return has_x?true:has_e?false:has_e=after_e=true;case"+":case"-":return after_e;case(after_e=false,"."):return has_dot||has_e||has_x||is_octal(str)?false:has_dot=true;}return /[_0-9a-dfo]/i.test(ch);});if(prefix)num=prefix+num;if(is_octal(num)){if(next_token.has_directive("use strict"))parse_error("Legacy octal literals are not allowed in strict mode");}else {num=num.replace(has_x?/([1-9a-f]|.0)_(?=[0-9a-f])/gi:/([1-9]|.0)_(?=[0-9])/gi,"$1");}var valid=parse_js_number(num);if(isNaN(valid))parse_error("Invalid syntax: "+num);if(has_dot||has_e||peek()!="n")return token("num",valid);next();return token("bigint",num.toLowerCase());}function read_escaped_char(in_string){var seq=next(true,in_string);if(seq>="0"&&seq<="7")return read_octal_escape_sequence(seq);if(seq=="u"){var ch=next(true,in_string);seq+=ch;if(ch!="{"){seq+=next(true,in_string)+next(true,in_string)+next(true,in_string);}else do{ch=next(true,in_string);seq+=ch;}while(ch!="}");}else if(seq=="x"){seq+=next(true,in_string)+next(true,in_string);}var str=decode_escape_sequence(seq);if(typeof str!="string")parse_error("Invalid escape sequence: \\"+seq);return str;}function read_octal_escape_sequence(ch){// Read
var p=peek();if(p>="0"&&p<="7"){ch+=next(true);if(ch[0]<="3"&&(p=peek())>="0"&&p<="7")ch+=next(true);}// Parse
if(ch==="0")return "\0";if(ch.length>0&&next_token.has_directive("use strict"))parse_error("Legacy octal escape sequences are not allowed in strict mode");return String.fromCharCode(parseInt(ch,8));}var read_string=with_eof_error("Unterminated string constant",function(quote_char){var quote=next(),ret="";for(;;){var ch=next(true,true);if(ch=="\\")ch=read_escaped_char(true);else if(NEWLINE_CHARS[ch])parse_error("Unterminated string constant");else if(ch==quote)break;ret+=ch;}var tok=token("string",ret);tok.quote=quote_char;return tok;});function skip_line_comment(type){var regex_allowed=S.regex_allowed;var i=find_eol(),ret;if(i==-1){ret=S.text.substr(S.pos);S.pos=S.text.length;}else {ret=S.text.substring(S.pos,i);S.pos=i;}S.col=S.tokcol+(S.pos-S.tokpos);S.comments_before.push(token(type,ret,true));S.regex_allowed=regex_allowed;return next_token;}var skip_multiline_comment=with_eof_error("Unterminated multiline comment",function(){var regex_allowed=S.regex_allowed;var i=find("*/",true);var text=S.text.substring(S.pos,i).replace(/\r\n|\r|\u2028|\u2029/g,"\n");// update stream position
forward(text.length/* doesn't count \r\n as 2 char while S.pos - i does */+2);S.comments_before.push(token("comment2",text,true));S.regex_allowed=regex_allowed;return next_token;});function read_name(){var backslash=false,ch,escaped=false,name=peek()=="#"?next():"";while(ch=peek()){if(!backslash){if(ch=="\\")escaped=backslash=true,next();else if(is_identifier_char(ch))name+=next();else break;}else {if(ch!="u")parse_error("Expecting UnicodeEscapeSequence -- uXXXX");ch=read_escaped_char();if(!is_identifier_char(ch))parse_error("Unicode char: "+ch.charCodeAt(0)+" is not valid in identifier");name+=ch;backslash=false;}}if(KEYWORDS[name]&&escaped){var hex=name.charCodeAt(0).toString(16).toUpperCase();name="\\u"+"0000".substr(hex.length)+hex+name.slice(1);}return name;}var read_regexp=with_eof_error("Unterminated regular expression",function(source){var prev_backslash=false,ch,in_class=false;while(ch=next(true))if(NEWLINE_CHARS[ch]){parse_error("Unexpected line terminator");}else if(prev_backslash){source+="\\"+ch;prev_backslash=false;}else if(ch=="["){in_class=true;source+=ch;}else if(ch=="]"&&in_class){in_class=false;source+=ch;}else if(ch=="/"&&!in_class){break;}else if(ch=="\\"){prev_backslash=true;}else {source+=ch;}var mods=read_name();try{var regexp=new RegExp(source,mods);regexp.raw_source=source;return token("regexp",regexp);}catch(e){parse_error(e.message);}});function read_operator(prefix){function grow(op){if(!peek())return op;var bigger=op+peek();if(OPERATORS[bigger]){next();return grow(bigger);}else {return op;}}return token("operator",grow(prefix||next()));}function handle_slash(){next();switch(peek()){case"/":next();return skip_line_comment("comment1");case"*":next();return skip_multiline_comment();}return S.regex_allowed?read_regexp(""):read_operator("/");}function handle_dot(){next();if(looking_at(".."))return token("operator","."+next()+next());return is_digit(peek().charCodeAt(0))?read_num("."):token("punc",".");}function read_word(){var word=read_name();if(prev_was_dot)return token("name",word);return KEYWORDS_ATOM[word]?token("atom",word):!KEYWORDS[word]?token("name",word):OPERATORS[word]?token("operator",word):token("keyword",word);}function with_eof_error(eof_error,cont){return function(x){try{return cont(x);}catch(ex){if(ex===EX_EOF)parse_error(eof_error);else throw ex;}};}function next_token(force_regexp){if(force_regexp!=null)return read_regexp(force_regexp);if(shebang&&S.pos==0&&looking_at("#!")){start_token();forward(2);skip_line_comment("comment5");}for(;;){skip_whitespace();start_token();if(html5_comments){if(looking_at("<!--")){forward(4);skip_line_comment("comment3");continue;}if(looking_at("-->")&&S.newline_before){forward(3);skip_line_comment("comment4");continue;}}var ch=peek();if(!ch)return token("eof");var code=ch.charCodeAt(0);switch(code){case 34:case 39:return read_string(ch);case 46:return handle_dot();case 47:var tok=handle_slash();if(tok===next_token)continue;return tok;}if(is_digit(code))return read_num();if(PUNC_CHARS[ch])return token("punc",next());if(looking_at("=>"))return token("punc",next()+next());if(OPERATOR_CHARS[ch])return read_operator();if(code==35||code==92||!NON_IDENTIFIER_CHARS[ch])return read_word();break;}parse_error("Unexpected character '"+ch+"'");}next_token.context=function(nc){if(nc)S=nc;return S;};next_token.add_directive=function(directive){S.directives[directive]=true;};next_token.push_directives_stack=function(){S.directives=Object.create(S.directives);};next_token.pop_directives_stack=function(){S.directives=Object.getPrototypeOf(S.directives);};next_token.has_directive=function(directive){return !!S.directives[directive];};return next_token;}/* -----[ Parser (constants) ]----- */var UNARY_PREFIX=makePredicate("typeof void delete -- ++ ! ~ - +");var UNARY_POSTFIX=makePredicate("-- ++");var ASSIGNMENT=makePredicate("= += -= /= *= %= **= >>= <<= >>>= &= |= ^= &&= ||= ??=");var PRECEDENCE=function(a,ret){for(var i=0;i<a.length;){var b=a[i++];for(var j=0;j<b.length;j++){ret[b[j]]=i;}}return ret;}([["??"],["||"],["&&"],["|"],["^"],["&"],["==","===","!=","!=="],["<",">","<=",">=","in","instanceof"],[">>","<<",">>>"],["+","-"],["*","/","%"],["**"]],{});var ATOMIC_START_TOKEN=makePredicate("atom bigint num regexp string");/* -----[ Parser ]----- */function parse($TEXT,options){options=defaults(options,{bare_returns:false,expression:false,filename:null,html5_comments:true,module:false,shebang:true,strict:false,toplevel:null},true);var S={input:typeof $TEXT=="string"?tokenizer($TEXT,options.filename,options.html5_comments,options.shebang):$TEXT,in_async:false,in_directives:true,in_funarg:-1,in_function:0,in_generator:false,in_loop:0,labels:[],peeked:null,prev:null,token:null};S.token=next();function is(type,value){return is_token(S.token,type,value);}function peek(){return S.peeked||(S.peeked=S.input());}function next(){S.prev=S.token;if(S.peeked){S.token=S.peeked;S.peeked=null;}else {S.token=S.input();}S.in_directives=S.in_directives&&(S.token.type=="string"||is("punc",";"));return S.token;}function prev(){return S.prev;}function croak(msg,line,col,pos){var ctx=S.input.context();js_error(msg,ctx.filename,line!=null?line:ctx.tokline,col!=null?col:ctx.tokcol,ctx.tokpos);}function token_error(token,msg){croak(msg,token.line,token.col);}function token_to_string(type,value){return type+(value===undefined?"":" "+value+"");}function unexpected(token){if(token==null)token=S.token;token_error(token,"Unexpected token: "+token_to_string(token.type,token.value));}function expect_token(type,val){if(is(type,val))return next();token_error(S.token,"Unexpected token: "+token_to_string(S.token.type,S.token.value)+", expected: "+token_to_string(type,val));}function expect(punc){return expect_token("punc",punc);}function has_newline_before(token){return token.nlb||!all(token.comments_before,function(comment){return !comment.nlb;});}function can_insert_semicolon(){return !options.strict&&(is("eof")||is("punc","}")||has_newline_before(S.token));}function semicolon(optional){if(is("punc",";"))next();else if(!optional&&!can_insert_semicolon())expect(";");}function parenthesized(){expect("(");var exp=expression();expect(")");return exp;}function embed_tokens(parser){return function(){var start=S.token;var expr=parser.apply(null,arguments);var end=prev();expr.start=start;expr.end=end;return expr;};}function handle_regexp(){if(is("operator","/")||is("operator","/=")){S.peeked=null;S.token=S.input(S.token.value.substr(1));// force regexp
}}var statement=embed_tokens(function(toplevel){handle_regexp();switch(S.token.type){case"string":var dir=S.in_directives;var body=expression();if(dir){if(body instanceof AST_String){var value=body.start.raw.slice(1,-1);S.input.add_directive(value);body.value=value;}else {S.in_directives=dir=false;}}semicolon();return dir?new AST_Directive(body):new AST_SimpleStatement({body:body});case"num":case"bigint":case"regexp":case"operator":case"atom":return simple_statement();case"name":switch(S.token.value){case"async":if(is_token(peek(),"keyword","function")){next();next();if(!is("operator","*"))return function_(AST_AsyncDefun);next();return function_(AST_AsyncGeneratorDefun);}break;case"await":if(S.in_async)return simple_statement();break;case"export":if(!toplevel&&options.module!=="")unexpected();next();return export_();case"import":var token=peek();if(token.type=="punc"&&/^[(.]$/.test(token.value))break;if(!toplevel&&options.module!=="")unexpected();next();return import_();case"let":if(is_vardefs()){next();var node=let_();semicolon();return node;}break;case"yield":if(S.in_generator)return simple_statement();break;}return is_token(peek(),"punc",":")?labeled_statement():simple_statement();case"punc":switch(S.token.value){case"{":return new AST_BlockStatement({start:S.token,body:block_(),end:prev()});case"[":case"(":case"`":return simple_statement();case";":S.in_directives=false;next();return new AST_EmptyStatement();default:unexpected();}case"keyword":switch(S.token.value){case"break":next();return break_cont(AST_Break);case"class":next();return class_(AST_DefClass);case"const":next();var node=const_();semicolon();return node;case"continue":next();return break_cont(AST_Continue);case"debugger":next();semicolon();return new AST_Debugger();case"do":next();var body=in_loop(statement);expect_token("keyword","while");var condition=parenthesized();semicolon(true);return new AST_Do({body:body,condition:condition});case"while":next();return new AST_While({condition:parenthesized(),body:in_loop(statement)});case"for":next();return for_();case"function":next();if(!is("operator","*"))return function_(AST_Defun);next();return function_(AST_GeneratorDefun);case"if":next();return if_();case"return":if(S.in_function==0&&!options.bare_returns)croak("'return' outside of function");next();var value=null;if(is("punc",";")){next();}else if(!can_insert_semicolon()){value=expression();semicolon();}return new AST_Return({value:value});case"switch":next();return new AST_Switch({expression:parenthesized(),body:in_loop(switch_body_)});case"throw":next();if(has_newline_before(S.token))croak("Illegal newline after 'throw'");var value=expression();semicolon();return new AST_Throw({value:value});case"try":next();return try_();case"var":next();var node=var_();semicolon();return node;case"with":if(S.input.has_directive("use strict")){croak("Strict mode may not include a with statement");}next();return new AST_With({expression:parenthesized(),body:statement()});}}unexpected();});function labeled_statement(){var label=as_symbol(AST_Label);if(!all(S.labels,function(l){return l.name!=label.name;})){// ECMA-262, 12.12: An ECMAScript program is considered
// syntactically incorrect if it contains a
// LabelledStatement that is enclosed by a
// LabelledStatement with the same Identifier as label.
croak("Label "+label.name+" defined twice");}expect(":");S.labels.push(label);var stat=statement();S.labels.pop();if(!(stat instanceof AST_IterationStatement)){// check for `continue` that refers to this label.
// those should be reported as syntax errors.
// https://github.com/mishoo/UglifyJS/issues/287
label.references.forEach(function(ref){if(ref instanceof AST_Continue){token_error(ref.label.start,"Continue label `"+label.name+"` must refer to IterationStatement");}});}return new AST_LabeledStatement({body:stat,label:label});}function simple_statement(){var body=expression();semicolon();return new AST_SimpleStatement({body:body});}function break_cont(type){var label=null,ldef;if(!can_insert_semicolon()){label=as_symbol(AST_LabelRef,true);}if(label!=null){ldef=find_if(function(l){return l.name==label.name;},S.labels);if(!ldef)token_error(label.start,"Undefined label "+label.name);label.thedef=ldef;}else if(S.in_loop==0)croak(type.TYPE+" not inside a loop or switch");semicolon();var stat=new type({label:label});if(ldef)ldef.references.push(stat);return stat;}function has_modifier(name,no_nlb){if(!is("name",name))return;var token=peek();if(!token)return;if(is_token(token,"operator","="))return;if(token.type=="punc"&&/^[(;}]$/.test(token.value))return;if(no_nlb&&has_newline_before(token))return;return next();}function class_(ctor){var was_async=S.in_async;var was_gen=S.in_generator;S.input.push_directives_stack();S.input.add_directive("use strict");var name;if(ctor===AST_DefClass){name=as_symbol(AST_SymbolDefClass);}else {name=as_symbol(AST_SymbolClass,true);}var parent=null;if(is("keyword","extends")){next();handle_regexp();parent=expr_atom(true);}expect("{");var props=[];while(!is("punc","}")){if(is("punc",";")){next();continue;}var start=S.token;var fixed=!!has_modifier("static");var async=has_modifier("async",true);if(is("operator","*")){next();var internal=is("name")&&/^#/.test(S.token.value);var key=as_property_key();var gen_start=S.token;var gen=function_(async?AST_AsyncGeneratorFunction:AST_GeneratorFunction);gen.start=gen_start;gen.end=prev();props.push(new AST_ClassMethod({start:start,static:fixed,private:internal,key:key,value:gen,end:prev()}));continue;}if(fixed&&is("punc","{")){props.push(new AST_ClassInit({start:start,value:new AST_ClassInitBlock({start:start,body:block_(),end:prev()}),end:prev()}));continue;}var internal=is("name")&&/^#/.test(S.token.value);var key=as_property_key();if(is("punc","(")){var func_start=S.token;var func=function_(async?AST_AsyncFunction:AST_Function);func.start=func_start;func.end=prev();props.push(new AST_ClassMethod({start:start,static:fixed,private:internal,key:key,value:func,end:prev()}));continue;}if(async)unexpected(async);var value=null;if(is("operator","=")){next();S.in_async=false;S.in_generator=false;value=maybe_assign();S.in_generator=was_gen;S.in_async=was_async;}else if(!(is("punc",";")||is("punc","}"))){var type=null;switch(key){case"get":type=AST_ClassGetter;break;case"set":type=AST_ClassSetter;break;}if(type){props.push(new type({start:start,static:fixed,private:is("name")&&/^#/.test(S.token.value),key:as_property_key(),value:create_accessor(),end:prev()}));continue;}}semicolon();props.push(new AST_ClassField({start:start,static:fixed,private:internal,key:key,value:value,end:prev()}));}next();S.input.pop_directives_stack();S.in_generator=was_gen;S.in_async=was_async;return new ctor({extends:parent,name:name,properties:props});}function for_(){var await_token=is("name","await")&&next();expect("(");var init=null;if(await_token||!is("punc",";")){init=is("keyword","const")?(next(),const_(true)):is("name","let")&&is_vardefs()?(next(),let_(true)):is("keyword","var")?(next(),var_(true)):expression(true);var ctor;if(await_token){expect_token("name","of");ctor=AST_ForAwaitOf;}else if(is("operator","in")){next();ctor=AST_ForIn;}else if(is("name","of")){next();ctor=AST_ForOf;}if(ctor){if(init instanceof AST_Definitions){if(init.definitions.length>1){token_error(init.start,"Only one variable declaration allowed in for..in/of loop");}if(ctor!==AST_ForIn&&init.definitions[0].value){token_error(init.definitions[0].value.start,"No initializers allowed in for..of loop");}}else if(!(is_assignable(init)||(init=to_destructured(init))instanceof AST_Destructured)){token_error(init.start,"Invalid left-hand side in for..in/of loop");}return for_enum(ctor,init);}}return regular_for(init);}function regular_for(init){expect(";");var test=is("punc",";")?null:expression();expect(";");var step=is("punc",")")?null:expression();expect(")");return new AST_For({init:init,condition:test,step:step,body:in_loop(statement)});}function for_enum(ctor,init){handle_regexp();var obj=expression();expect(")");return new ctor({init:init,object:obj,body:in_loop(statement)});}function to_funarg(node){if(node instanceof AST_Array){var rest=null;if(node.elements[node.elements.length-1]instanceof AST_Spread){rest=to_funarg(node.elements.pop().expression);}return new AST_DestructuredArray({start:node.start,elements:node.elements.map(to_funarg),rest:rest,end:node.end});}if(node instanceof AST_Assign)return new AST_DefaultValue({start:node.start,name:to_funarg(node.left),value:node.right,end:node.end});if(node instanceof AST_DefaultValue){node.name=to_funarg(node.name);return node;}if(node instanceof AST_DestructuredArray){node.elements=node.elements.map(to_funarg);if(node.rest)node.rest=to_funarg(node.rest);return node;}if(node instanceof AST_DestructuredObject){node.properties.forEach(function(prop){prop.value=to_funarg(prop.value);});if(node.rest)node.rest=to_funarg(node.rest);return node;}if(node instanceof AST_Hole)return node;if(node instanceof AST_Object){var rest=null;if(node.properties[node.properties.length-1]instanceof AST_Spread){rest=to_funarg(node.properties.pop().expression);}return new AST_DestructuredObject({start:node.start,properties:node.properties.map(function(prop){if(!(prop instanceof AST_ObjectKeyVal))token_error(prop.start,"Invalid destructuring assignment");return new AST_DestructuredKeyVal({start:prop.start,key:prop.key,value:to_funarg(prop.value),end:prop.end});}),rest:rest,end:node.end});}if(node instanceof AST_SymbolFunarg)return node;if(node instanceof AST_SymbolRef)return new AST_SymbolFunarg(node);if(node instanceof AST_Yield)return new AST_SymbolFunarg({start:node.start,name:"yield",end:node.end});token_error(node.start,"Invalid arrow parameter");}function arrow(exprs,start,async){var was_async=S.in_async;var was_gen=S.in_generator;S.in_async=async;S.in_generator=false;var was_funarg=S.in_funarg;S.in_funarg=S.in_function;var argnames=exprs.map(to_funarg);var rest=exprs.rest||null;if(rest)rest=to_funarg(rest);S.in_funarg=was_funarg;expect("=>");var body,value;var loop=S.in_loop;var labels=S.labels;++S.in_function;S.input.push_directives_stack();S.in_loop=0;S.labels=[];if(is("punc","{")){S.in_directives=true;body=block_();value=null;}else {body=[];handle_regexp();value=maybe_assign();}var is_strict=S.input.has_directive("use strict");S.input.pop_directives_stack();--S.in_function;S.in_loop=loop;S.labels=labels;S.in_generator=was_gen;S.in_async=was_async;var node=new(async?AST_AsyncArrow:AST_Arrow)({start:start,argnames:argnames,rest:rest,body:body,value:value,end:prev()});if(is_strict)node.each_argname(strict_verify_symbol);return node;}var function_=function(ctor){var was_async=S.in_async;var was_gen=S.in_generator;var name;if(/Defun$/.test(ctor.TYPE)){name=as_symbol(AST_SymbolDefun);S.in_async=/^Async/.test(ctor.TYPE);S.in_generator=/Generator/.test(ctor.TYPE);}else {S.in_async=/^Async/.test(ctor.TYPE);S.in_generator=/Generator/.test(ctor.TYPE);name=as_symbol(AST_SymbolLambda,true);}if(name&&ctor!==AST_Accessor&&!(name instanceof AST_SymbolDeclaration))unexpected(prev());expect("(");var was_funarg=S.in_funarg;S.in_funarg=S.in_function;var argnames=expr_list(")",!options.strict,false,function(){return maybe_default(AST_SymbolFunarg);});S.in_funarg=was_funarg;var loop=S.in_loop;var labels=S.labels;++S.in_function;S.in_directives=true;S.input.push_directives_stack();S.in_loop=0;S.labels=[];var body=block_();var is_strict=S.input.has_directive("use strict");S.input.pop_directives_stack();--S.in_function;S.in_loop=loop;S.labels=labels;S.in_generator=was_gen;S.in_async=was_async;var node=new ctor({name:name,argnames:argnames,rest:argnames.rest||null,body:body});if(is_strict){if(name)strict_verify_symbol(name);node.each_argname(strict_verify_symbol);}return node;};function if_(){var cond=parenthesized(),body=statement(),alt=null;if(is("keyword","else")){next();alt=statement();}return new AST_If({condition:cond,body:body,alternative:alt});}function is_alias(){return is("name")||is("string")||is_identifier_string(S.token.value);}function make_string(token){return new AST_String({start:token,quote:token.quote,value:token.value,end:token});}function as_path(){var path=S.token;expect_token("string");semicolon();return make_string(path);}function export_(){if(is("operator","*")){var key=S.token;var alias=key;next();if(is("name","as")){next();if(!is_alias())expect_token("name");alias=S.token;next();}expect_token("name","from");return new AST_ExportForeign({aliases:[make_string(alias)],keys:[make_string(key)],path:as_path()});}if(is("punc","{")){next();var aliases=[];var keys=[];while(is_alias()){var key=S.token;next();keys.push(key);if(is("name","as")){next();if(!is_alias())expect_token("name");aliases.push(S.token);next();}else {aliases.push(key);}if(!is("punc","}"))expect(",");}expect("}");if(is("name","from")){next();return new AST_ExportForeign({aliases:aliases.map(make_string),keys:keys.map(make_string),path:as_path()});}semicolon();return new AST_ExportReferences({properties:keys.map(function(token,index){if(!is_token(token,"name"))token_error(token,"Name expected");var sym=_make_symbol(AST_SymbolExport,token);sym.alias=make_string(aliases[index]);return sym;})});}if(is("keyword","default")){next();var start=S.token;var body=export_default_decl();if(body){body.start=start;body.end=prev();}else {handle_regexp();body=expression();semicolon();}return new AST_ExportDefault({body:body});}return new AST_ExportDeclaration({body:export_decl()});}function maybe_named(def,expr){if(expr.name){expr=new def(expr);expr.name=new(def===AST_DefClass?AST_SymbolDefClass:AST_SymbolDefun)(expr.name);}return expr;}function export_default_decl(){if(is("name","async")){if(!is_token(peek(),"keyword","function"))return;next();next();if(!is("operator","*"))return maybe_named(AST_AsyncDefun,function_(AST_AsyncFunction));next();return maybe_named(AST_AsyncGeneratorDefun,function_(AST_AsyncGeneratorFunction));}else if(is("keyword"))switch(S.token.value){case"class":next();return maybe_named(AST_DefClass,class_(AST_ClassExpression));case"function":next();if(!is("operator","*"))return maybe_named(AST_Defun,function_(AST_Function));next();return maybe_named(AST_GeneratorDefun,function_(AST_GeneratorFunction));}}var export_decl=embed_tokens(function(){if(is("name"))switch(S.token.value){case"async":next();expect_token("keyword","function");if(!is("operator","*"))return function_(AST_AsyncDefun);next();return function_(AST_AsyncGeneratorDefun);case"let":next();var node=let_();semicolon();return node;}else if(is("keyword"))switch(S.token.value){case"class":next();return class_(AST_DefClass);case"const":next();var node=const_();semicolon();return node;case"function":next();if(!is("operator","*"))return function_(AST_Defun);next();return function_(AST_GeneratorDefun);case"var":next();var node=var_();semicolon();return node;}unexpected();});function import_(){var all=null;var def=as_symbol(AST_SymbolImport,true);var props=null;var cont;if(def){def.key=new AST_String({start:def.start,value:"",end:def.end});if(cont=is("punc",","))next();}else {cont=!is("string");}if(cont){if(is("operator","*")){var key=S.token;next();expect_token("name","as");all=as_symbol(AST_SymbolImport);all.key=make_string(key);}else {expect("{");props=[];while(is_alias()){var alias;if(is_token(peek(),"name","as")){var key=S.token;next();next();alias=as_symbol(AST_SymbolImport);alias.key=make_string(key);}else {alias=as_symbol(AST_SymbolImport);alias.key=new AST_String({start:alias.start,value:alias.name,end:alias.end});}props.push(alias);if(!is("punc","}"))expect(",");}expect("}");}}if(all||def||props)expect_token("name","from");return new AST_Import({all:all,default:def,path:as_path(),properties:props});}function block_(){expect("{");var a=[];while(!is("punc","}")){if(is("eof"))expect("}");a.push(statement());}next();return a;}function switch_body_(){expect("{");var a=[],branch,cur,default_branch,tmp;while(!is("punc","}")){if(is("eof"))expect("}");if(is("keyword","case")){if(branch)branch.end=prev();cur=[];branch=new AST_Case({start:(tmp=S.token,next(),tmp),expression:expression(),body:cur});a.push(branch);expect(":");}else if(is("keyword","default")){if(branch)branch.end=prev();if(default_branch)croak("More than one default clause in switch statement");cur=[];branch=new AST_Default({start:(tmp=S.token,next(),expect(":"),tmp),body:cur});a.push(branch);default_branch=branch;}else {if(!cur)unexpected();cur.push(statement());}}if(branch)branch.end=prev();next();return a;}function try_(){var body=block_(),bcatch=null,bfinally=null;if(is("keyword","catch")){var start=S.token;next();var name=null;if(is("punc","(")){next();name=maybe_destructured(AST_SymbolCatch);expect(")");}bcatch=new AST_Catch({start:start,argname:name,body:block_(),end:prev()});}if(is("keyword","finally")){var start=S.token;next();bfinally=new AST_Finally({start:start,body:block_(),end:prev()});}if(!bcatch&&!bfinally)croak("Missing catch/finally blocks");return new AST_Try({body:body,bcatch:bcatch,bfinally:bfinally});}function vardefs(type,no_in){var a=[];for(;;){var start=S.token;var name=maybe_destructured(type);var value=null;if(is("operator","=")){next();value=maybe_assign(no_in);}else if(!no_in&&(type===AST_SymbolConst||name instanceof AST_Destructured)){croak("Missing initializer in declaration");}a.push(new AST_VarDef({start:start,name:name,value:value,end:prev()}));if(!is("punc",","))break;next();}return a;}function is_vardefs(){var token=peek();return is_token(token,"name")||is_token(token,"punc","[")||is_token(token,"punc","{");}var const_=function(no_in){return new AST_Const({start:prev(),definitions:vardefs(AST_SymbolConst,no_in),end:prev()});};var let_=function(no_in){return new AST_Let({start:prev(),definitions:vardefs(AST_SymbolLet,no_in),end:prev()});};var var_=function(no_in){return new AST_Var({start:prev(),definitions:vardefs(AST_SymbolVar,no_in),end:prev()});};var new_=function(allow_calls){var start=S.token;expect_token("operator","new");var call;if(is("punc",".")&&is_token(peek(),"name","target")){next();next();call=new AST_NewTarget();}else {var exp=expr_atom(false),args;if(is("punc","(")){next();args=expr_list(")",!options.strict);}else {args=[];}call=new AST_New({expression:exp,args:args});}call.start=start;call.end=prev();return subscripts(call,allow_calls);};function as_atom_node(){var ret,tok=S.token,value=tok.value;switch(tok.type){case"num":if(isFinite(value)){ret=new AST_Number({value:value});}else {ret=new AST_Infinity();if(value<0)ret=new AST_UnaryPrefix({operator:"-",expression:ret});}break;case"bigint":ret=new AST_BigInt({value:value});break;case"string":ret=new AST_String({value:value,quote:tok.quote});break;case"regexp":ret=new AST_RegExp({value:value});break;case"atom":switch(value){case"false":ret=new AST_False();break;case"true":ret=new AST_True();break;case"null":ret=new AST_Null();break;default:unexpected();}break;default:unexpected();}next();ret.start=ret.end=tok;return ret;}var expr_atom=function(allow_calls){if(is("operator","new")){return new_(allow_calls);}var start=S.token;if(is("punc")){switch(start.value){case"`":return subscripts(template(null),allow_calls);case"(":next();if(is("punc",")")){next();return arrow([],start);}var ex=expression(false,true);var len=start.comments_before.length;[].unshift.apply(ex.start.comments_before,start.comments_before);start.comments_before.length=0;start.comments_before=ex.start.comments_before;start.comments_before_length=len;if(len==0&&start.comments_before.length>0){var comment=start.comments_before[0];if(!comment.nlb){comment.nlb=start.nlb;start.nlb=false;}}start.comments_after=ex.start.comments_after;ex.start=start;expect(")");var end=prev();end.comments_before=ex.end.comments_before;end.comments_after.forEach(function(comment){ex.end.comments_after.push(comment);if(comment.nlb)S.token.nlb=true;});end.comments_after.length=0;end.comments_after=ex.end.comments_after;ex.end=end;if(is("punc","=>"))return arrow(ex instanceof AST_Sequence?ex.expressions:[ex],start);return subscripts(ex,allow_calls);case"[":return subscripts(array_(),allow_calls);case"{":return subscripts(object_(),allow_calls);}unexpected();}if(is("keyword"))switch(start.value){case"class":next();var clazz=class_(AST_ClassExpression);clazz.start=start;clazz.end=prev();return subscripts(clazz,allow_calls);case"function":next();var func;if(is("operator","*")){next();func=function_(AST_GeneratorFunction);}else {func=function_(AST_Function);}func.start=start;func.end=prev();return subscripts(func,allow_calls);}if(is("name")){var sym=_make_symbol(AST_SymbolRef,start);next();if(sym.name=="async"){if(is("keyword","function")){next();var func;if(is("operator","*")){next();func=function_(AST_AsyncGeneratorFunction);}else {func=function_(AST_AsyncFunction);}func.start=start;func.end=prev();return subscripts(func,allow_calls);}if(is("name")&&is_token(peek(),"punc","=>")){start=S.token;sym=_make_symbol(AST_SymbolRef,start);next();return arrow([sym],start,true);}if(is("punc","(")){var call=subscripts(sym,allow_calls);if(!is("punc","=>"))return call;var args=call.args;if(args[args.length-1]instanceof AST_Spread){args.rest=args.pop().expression;}return arrow(args,start,true);}}return is("punc","=>")?arrow([sym],start):subscripts(sym,allow_calls);}if(ATOMIC_START_TOKEN[S.token.type]){return subscripts(as_atom_node(),allow_calls);}unexpected();};function expr_list(closing,allow_trailing_comma,allow_empty,parser){if(!parser)parser=maybe_assign;var first=true,a=[];while(!is("punc",closing)){if(first)first=false;else expect(",");if(allow_trailing_comma&&is("punc",closing))break;if(allow_empty&&is("punc",",")){a.push(new AST_Hole({start:S.token,end:S.token}));}else if(!is("operator","...")){a.push(parser());}else if(parser===maybe_assign){a.push(new AST_Spread({start:S.token,expression:(next(),parser()),end:prev()}));}else {next();a.rest=parser();if(a.rest instanceof AST_DefaultValue)token_error(a.rest.start,"Invalid rest parameter");break;}}expect(closing);return a;}var array_=embed_tokens(function(){expect("[");return new AST_Array({elements:expr_list("]",!options.strict,true)});});var create_accessor=embed_tokens(function(){return function_(AST_Accessor);});var object_=embed_tokens(function(){expect("{");var first=true,a=[];while(!is("punc","}")){if(first)first=false;else expect(",");// allow trailing comma
if(!options.strict&&is("punc","}"))break;var start=S.token;if(is("operator","*")){next();var key=as_property_key();var gen_start=S.token;var gen=function_(AST_GeneratorFunction);gen.start=gen_start;gen.end=prev();a.push(new AST_ObjectMethod({start:start,key:key,value:gen,end:prev()}));continue;}if(is("operator","...")){next();a.push(new AST_Spread({start:start,expression:maybe_assign(),end:prev()}));continue;}if(is_token(peek(),"operator","=")){var name=as_symbol(AST_SymbolRef);next();a.push(new AST_ObjectKeyVal({start:start,key:start.value,value:new AST_Assign({start:start,left:name,operator:"=",right:maybe_assign(),end:prev()}),end:prev()}));continue;}if(is_token(peek(),"punc",",")||is_token(peek(),"punc","}")){a.push(new AST_ObjectKeyVal({start:start,key:start.value,value:as_symbol(AST_SymbolRef),end:prev()}));continue;}var key=as_property_key();if(is("punc","(")){var func_start=S.token;var func=function_(AST_Function);func.start=func_start;func.end=prev();a.push(new AST_ObjectMethod({start:start,key:key,value:func,end:prev()}));continue;}if(is("punc",":")){next();a.push(new AST_ObjectKeyVal({start:start,key:key,value:maybe_assign(),end:prev()}));continue;}if(start.type=="name")switch(key){case"async":var is_gen=is("operator","*")&&next();key=as_property_key();var func_start=S.token;var func=function_(is_gen?AST_AsyncGeneratorFunction:AST_AsyncFunction);func.start=func_start;func.end=prev();a.push(new AST_ObjectMethod({start:start,key:key,value:func,end:prev()}));continue;case"get":a.push(new AST_ObjectGetter({start:start,key:as_property_key(),value:create_accessor(),end:prev()}));continue;case"set":a.push(new AST_ObjectSetter({start:start,key:as_property_key(),value:create_accessor(),end:prev()}));continue;}unexpected();}next();return new AST_Object({properties:a});});function as_property_key(){var tmp=S.token;switch(tmp.type){case"operator":if(!KEYWORDS[tmp.value])unexpected();case"num":case"string":case"name":case"keyword":case"atom":next();return ""+tmp.value;case"punc":expect("[");var key=maybe_assign();expect("]");return key;default:unexpected();}}function as_name(){var name=S.token.value;expect_token("name");return name;}function _make_symbol(type,token){var name=token.value;switch(name){case"await":if(S.in_async)unexpected(token);break;case"super":type=AST_Super;break;case"this":type=AST_This;break;case"yield":if(S.in_generator)unexpected(token);break;}return new type({name:""+name,start:token,end:token});}function strict_verify_symbol(sym){if(sym.name=="arguments"||sym.name=="eval"||sym.name=="let")token_error(sym.start,"Unexpected "+sym.name+" in strict mode");}function as_symbol(type,no_error){if(!is("name")){if(!no_error)croak("Name expected");return null;}var sym=_make_symbol(type,S.token);if(S.input.has_directive("use strict")&&sym instanceof AST_SymbolDeclaration){strict_verify_symbol(sym);}next();return sym;}function maybe_destructured(type){var start=S.token;if(is("punc","[")){next();var elements=expr_list("]",!options.strict,true,function(){return maybe_default(type);});return new AST_DestructuredArray({start:start,elements:elements,rest:elements.rest||null,end:prev()});}if(is("punc","{")){next();var first=true,a=[],rest=null;while(!is("punc","}")){if(first)first=false;else expect(",");// allow trailing comma
if(!options.strict&&is("punc","}"))break;var key_start=S.token;if(is("punc","[")||is_token(peek(),"punc",":")){var key=as_property_key();expect(":");a.push(new AST_DestructuredKeyVal({start:key_start,key:key,value:maybe_default(type),end:prev()}));continue;}if(is("operator","...")){next();rest=maybe_destructured(type);break;}var name=as_symbol(type);if(is("operator","=")){next();name=new AST_DefaultValue({start:name.start,name:name,value:maybe_assign(),end:prev()});}a.push(new AST_DestructuredKeyVal({start:key_start,key:key_start.value,value:name,end:prev()}));}expect("}");return new AST_DestructuredObject({start:start,properties:a,rest:rest,end:prev()});}return as_symbol(type);}function maybe_default(type){var start=S.token;var name=maybe_destructured(type);if(!is("operator","="))return name;next();return new AST_DefaultValue({start:start,name:name,value:maybe_assign(),end:prev()});}function template(tag){var start=tag?tag.start:S.token;var read=S.input.context().read_template;var strings=[];var expressions=[];while(read(strings)){next();expressions.push(expression());if(!is("punc","}"))unexpected();}next();return new AST_Template({start:start,expressions:expressions,strings:strings,tag:tag,end:prev()});}function subscripts(expr,allow_calls){var start=expr.start;var optional=null;while(true){if(is("operator","?")&&is_token(peek(),"punc",".")){next();next();optional=expr;}if(is("punc","[")){next();var prop=expression();expect("]");expr=new AST_Sub({start:start,optional:optional===expr,expression:expr,property:prop,end:prev()});}else if(allow_calls&&is("punc","(")){next();expr=new AST_Call({start:start,optional:optional===expr,expression:expr,args:expr_list(")",!options.strict),end:prev()});}else if(optional===expr||is("punc",".")){if(optional!==expr)next();expr=new AST_Dot({start:start,optional:optional===expr,expression:expr,property:as_name(),end:prev()});}else if(is("punc","`")){if(optional)croak("Invalid template on optional chain");expr=template(expr);}else {break;}}if(optional)expr.terminal=true;if(expr instanceof AST_Call&&!expr.pure){var start=expr.start;var comments=start.comments_before;var i=HOP(start,"comments_before_length")?start.comments_before_length:comments.length;while(--i>=0){if(/[@#]__PURE__/.test(comments[i].value)){expr.pure=true;break;}}}return expr;}function maybe_unary(no_in){var start=S.token;if(S.in_async&&is("name","await")){if(S.in_funarg===S.in_function)croak("Invalid use of await in function argument");S.input.context().regex_allowed=true;next();return new AST_Await({start:start,expression:maybe_unary(no_in),end:prev()});}if(S.in_generator&&is("name","yield")){if(S.in_funarg===S.in_function)croak("Invalid use of yield in function argument");S.input.context().regex_allowed=true;next();var exp=null;var nested=false;if(is("operator","*")){next();exp=maybe_assign(no_in);nested=true;}else if(is("punc")?!PUNC_AFTER_EXPRESSION[S.token.value]:!can_insert_semicolon()){exp=maybe_assign(no_in);}return new AST_Yield({start:start,expression:exp,nested:nested,end:prev()});}if(is("operator")&&UNARY_PREFIX[start.value]){next();handle_regexp();var ex=make_unary(AST_UnaryPrefix,start,maybe_unary(no_in));ex.start=start;ex.end=prev();return ex;}var val=expr_atom(true);while(is("operator")&&UNARY_POSTFIX[S.token.value]&&!has_newline_before(S.token)){val=make_unary(AST_UnaryPostfix,S.token,val);val.start=start;val.end=S.token;next();}return val;}function make_unary(ctor,token,expr){var op=token.value;switch(op){case"++":case"--":if(!is_assignable(expr))token_error(token,"Invalid use of "+op+" operator");break;case"delete":if(expr instanceof AST_SymbolRef&&S.input.has_directive("use strict"))token_error(expr.start,"Calling delete on expression not allowed in strict mode");break;}return new ctor({operator:op,expression:expr});}var expr_op=function(left,min_precision,no_in){var op=is("operator")?S.token.value:null;if(op=="in"&&no_in)op=null;var precision=op!=null?PRECEDENCE[op]:null;if(precision!=null&&precision>min_precision){next();var right=expr_op(maybe_unary(no_in),op=="**"?precision-1:precision,no_in);return expr_op(new AST_Binary({start:left.start,left:left,operator:op,right:right,end:right.end}),min_precision,no_in);}return left;};function expr_ops(no_in){return expr_op(maybe_unary(no_in),0,no_in);}var maybe_conditional=function(no_in){var start=S.token;var expr=expr_ops(no_in);if(is("operator","?")){next();var yes=maybe_assign();expect(":");return new AST_Conditional({start:start,condition:expr,consequent:yes,alternative:maybe_assign(no_in),end:prev()});}return expr;};function is_assignable(expr){return expr instanceof AST_PropAccess&&!expr.optional||expr instanceof AST_SymbolRef;}function to_destructured(node){if(node instanceof AST_Array){var rest=null;if(node.elements[node.elements.length-1]instanceof AST_Spread){rest=to_destructured(node.elements.pop().expression);if(!(rest instanceof AST_Destructured||is_assignable(rest)))return node;}var elements=node.elements.map(to_destructured);return all(elements,function(node){return node instanceof AST_DefaultValue||node instanceof AST_Destructured||node instanceof AST_Hole||is_assignable(node);})?new AST_DestructuredArray({start:node.start,elements:elements,rest:rest,end:node.end}):node;}if(node instanceof AST_Assign){var name=to_destructured(node.left);return name instanceof AST_Destructured||is_assignable(name)?new AST_DefaultValue({start:node.start,name:name,value:node.right,end:node.end}):node;}if(!(node instanceof AST_Object))return node;var rest=null;if(node.properties[node.properties.length-1]instanceof AST_Spread){rest=to_destructured(node.properties.pop().expression);if(!(rest instanceof AST_Destructured||is_assignable(rest)))return node;}var props=[];for(var i=0;i<node.properties.length;i++){var prop=node.properties[i];if(!(prop instanceof AST_ObjectKeyVal))return node;var value=to_destructured(prop.value);if(!(value instanceof AST_DefaultValue||value instanceof AST_Destructured||is_assignable(value))){return node;}props.push(new AST_DestructuredKeyVal({start:prop.start,key:prop.key,value:value,end:prop.end}));}return new AST_DestructuredObject({start:node.start,properties:props,rest:rest,end:node.end});}function maybe_assign(no_in){var start=S.token;var left=maybe_conditional(no_in),val=S.token.value;if(is("operator")&&ASSIGNMENT[val]){if(is_assignable(left)||val=="="&&(left=to_destructured(left))instanceof AST_Destructured){next();return new AST_Assign({start:start,left:left,operator:val,right:maybe_assign(no_in),end:prev()});}croak("Invalid assignment");}return left;}function expression(no_in,maybe_arrow){var start=S.token;var exprs=[];while(true){if(maybe_arrow&&is("operator","...")){next();exprs.rest=maybe_destructured(AST_SymbolFunarg);break;}exprs.push(maybe_assign(no_in));if(!is("punc",","))break;next();if(maybe_arrow&&is("punc",")")&&is_token(peek(),"punc","=>"))break;}return exprs.length==1&&!exprs.rest?exprs[0]:new AST_Sequence({start:start,expressions:exprs,end:prev()});}function in_loop(cont){++S.in_loop;var ret=cont();--S.in_loop;return ret;}if(options.expression){handle_regexp();var exp=expression();expect_token("eof");return exp;}return function(){var start=S.token;var body=[];if(options.module){S.in_async=true;S.input.add_directive("use strict");}S.input.push_directives_stack();while(!is("eof"))body.push(statement(true));S.input.pop_directives_stack();var end=prev()||start;var toplevel=options.toplevel;if(toplevel){toplevel.body=toplevel.body.concat(body);toplevel.end=end;}else {toplevel=new AST_Toplevel({start:start,body:body,end:end});}return toplevel;}();}function SymbolDef(id,scope,orig,init){this._bits=0;this.defun=undefined;this.eliminated=0;this.id=id;this.init=init;this.mangled_name=null;this.name=orig.name;this.orig=[orig];this.references=[];this.replaced=0;this.safe_ids=undefined;this.scope=scope;}SymbolDef.prototype={forEach:function(fn){this.orig.forEach(fn);this.references.forEach(fn);},mangle:function(options){if(this.mangled_name)return;var cache=this.global&&options.cache&&options.cache.props;if(cache&&cache.has(this.name)){this.mangled_name=cache.get(this.name);}else if(!this.unmangleable(options)){var def=this.redefined();if(def){this.mangled_name=def.mangled_name||def.name;}else {this.mangled_name=next_mangled_name(this,options);}if(cache)cache.set(this.name,this.mangled_name);}},redefined:function(){var self=this;var scope=self.defun;if(!scope)return;var name=self.name;var def=scope.variables.get(name)||scope instanceof AST_Toplevel&&scope.globals.get(name)||self.orig[0]instanceof AST_SymbolConst&&find_if(function(def){return def.name==name;},scope.enclosed);if(def&&def!==self)return def.redefined()||def;},unmangleable:function(options){if(this.exported)return true;if(this.undeclared)return true;if(!options.eval&&this.scope.pinned())return true;if(options.keep_fargs&&is_funarg(this))return true;if(options.keep_fnames){var sym=this.orig[0];if(sym instanceof AST_SymbolClass)return true;if(sym instanceof AST_SymbolDefClass)return true;if(sym instanceof AST_SymbolDefun)return true;if(sym instanceof AST_SymbolLambda)return true;}if(!options.toplevel&&this.global)return true;return false;}};DEF_BITPROPS(SymbolDef,["const_redefs","cross_loop","direct_access","exported","global","undeclared"]);function is_funarg(def){return def.orig[0]instanceof AST_SymbolFunarg||def.orig[1]instanceof AST_SymbolFunarg;}var unary_side_effects=makePredicate("delete ++ --");function is_lhs(node,parent){if(parent instanceof AST_Assign)return parent.left===node&&node;if(parent instanceof AST_DefaultValue)return parent.name===node&&node;if(parent instanceof AST_Destructured)return node;if(parent instanceof AST_DestructuredKeyVal)return node;if(parent instanceof AST_ForEnumeration)return parent.init===node&&node;if(parent instanceof AST_Unary)return unary_side_effects[parent.operator]&&parent.expression;}AST_Toplevel.DEFMETHOD("figure_out_scope",function(options){options=defaults(options,{cache:null,ie:false});// pass 1: setup scope chaining and handle definitions
var self=this;var defun=null;var exported=false;var next_def_id=0;var scope=self.parent_scope=null;var tw=new TreeWalker(function(node,descend){if(node instanceof AST_DefClass){var save_exported=exported;exported=tw.parent()instanceof AST_ExportDeclaration;node.name.walk(tw);exported=save_exported;walk_scope(function(){if(node.extends)node.extends.walk(tw);node.properties.forEach(function(prop){prop.walk(tw);});});return true;}if(node instanceof AST_Definitions){var save_exported=exported;exported=tw.parent()instanceof AST_ExportDeclaration;descend();exported=save_exported;return true;}if(node instanceof AST_LambdaDefinition){var save_exported=exported;exported=tw.parent()instanceof AST_ExportDeclaration;node.name.walk(tw);exported=save_exported;walk_scope(function(){node.argnames.forEach(function(argname){argname.walk(tw);});if(node.rest)node.rest.walk(tw);walk_body(node,tw);});return true;}if(node instanceof AST_Switch){node.expression.walk(tw);walk_scope(function(){walk_body(node,tw);});return true;}if(node instanceof AST_SwitchBranch){node.init_vars(scope);descend();return true;}if(node instanceof AST_Try){walk_scope(function(){walk_body(node,tw);});if(node.bcatch)node.bcatch.walk(tw);if(node.bfinally)node.bfinally.walk(tw);return true;}if(node instanceof AST_With){var s=scope;do{s=s.resolve();if(s.uses_with)break;s.uses_with=true;}while(s=s.parent_scope);walk_scope(descend);return true;}if(node instanceof AST_BlockScope){walk_scope(descend);return true;}if(node instanceof AST_Symbol){node.scope=scope;}if(node instanceof AST_Label){node.thedef=node;node.references=[];}if(node instanceof AST_SymbolCatch){scope.def_variable(node).defun=defun;}else if(node instanceof AST_SymbolConst){var def=scope.def_variable(node);def.defun=defun;if(exported)def.exported=true;}else if(node instanceof AST_SymbolDefun){var def=defun.def_function(node,tw.parent());if(exported)def.exported=true;}else if(node instanceof AST_SymbolFunarg){defun.def_variable(node);}else if(node instanceof AST_SymbolLambda){var def=defun.def_function(node,node.name=="arguments"?undefined:defun);if(options.ie&&node.name!="arguments")def.defun=defun.parent_scope.resolve();}else if(node instanceof AST_SymbolLet){var def=scope.def_variable(node);if(exported)def.exported=true;}else if(node instanceof AST_SymbolVar){var def=defun.def_variable(node,node instanceof AST_SymbolImport?undefined:null);if(exported)def.exported=true;}function walk_scope(descend){node.init_vars(scope);var save_defun=defun;var save_scope=scope;if(node instanceof AST_Scope)defun=node;scope=node;descend();scope=save_scope;defun=save_defun;}});self.make_def=function(orig,init){return new SymbolDef(++next_def_id,this,orig,init);};self.walk(tw);// pass 2: find back references and eval
self.globals=new Dictionary();var in_arg=[];var tw=new TreeWalker(function(node){if(node instanceof AST_Catch){if(!(node.argname instanceof AST_Destructured))return;in_arg.push(node);node.argname.walk(tw);in_arg.pop();walk_body(node,tw);return true;}if(node instanceof AST_Lambda){in_arg.push(node);if(node.name)node.name.walk(tw);node.argnames.forEach(function(argname){argname.walk(tw);});if(node.rest)node.rest.walk(tw);in_arg.pop();walk_lambda(node,tw);return true;}if(node instanceof AST_LoopControl){if(node.label)node.label.thedef.references.push(node);return true;}if(node instanceof AST_SymbolDeclaration){var def=node.definition();def.preinit=def.references.length;if(node instanceof AST_SymbolCatch){// ensure mangling works if `catch` reuses a scope variable
var redef=def.redefined();if(redef)for(var s=node.scope;s;s=s.parent_scope){if(!push_uniq(s.enclosed,redef))break;if(s===redef.scope)break;}}else if(node instanceof AST_SymbolConst){// ensure compression works if `const` reuses a scope variable
var redef=def.redefined();if(redef)redef.const_redefs=true;}else if(def.scope!==node.scope&&(node instanceof AST_SymbolDefun||node instanceof AST_SymbolFunarg||node instanceof AST_SymbolVar)){node.mark_enclosed(options);var redef=node.scope.find_variable(node.name);if(node.thedef!==redef){node.thedef=redef;redef.orig.push(node);node.mark_enclosed(options);}}if(node.name!="arguments")return true;var parent=node instanceof AST_SymbolVar&&tw.parent();if(parent instanceof AST_VarDef&&!parent.value)return true;var sym=node.scope.resolve().find_variable("arguments");if(sym&&is_arguments(sym))sym.scope.uses_arguments=3;return true;}if(node instanceof AST_SymbolRef){var name=node.name;var sym=node.scope.find_variable(name);for(var i=in_arg.length;i>0&&sym;){i=in_arg.lastIndexOf(sym.scope,i-1);if(i<0)break;var decl=sym.orig[0];if(decl instanceof AST_SymbolCatch||decl instanceof AST_SymbolFunarg||decl instanceof AST_SymbolLambda){node.in_arg=true;break;}sym=sym.scope.parent_scope.find_variable(name);}if(!sym){sym=self.def_global(node);}else if(name=="arguments"&&is_arguments(sym)){var parent=tw.parent();if(is_lhs(node,parent)){sym.scope.uses_arguments=3;}else if(sym.scope.uses_arguments<2&&!(parent instanceof AST_PropAccess&&parent.expression===node)){sym.scope.uses_arguments=2;}else if(!sym.scope.uses_arguments){sym.scope.uses_arguments=true;}}if(name=="eval"){var parent=tw.parent();if(parent.TYPE=="Call"&&parent.expression===node){var s=node.scope;do{s=s.resolve();if(s.uses_eval)break;s.uses_eval=true;}while(s=s.parent_scope);}else if(sym.undeclared){self.uses_eval=true;}}if(sym.init instanceof AST_LambdaDefinition&&sym.scope!==sym.init.name.scope){var scope=node.scope;do{if(scope===sym.init.name.scope)break;}while(scope=scope.parent_scope);if(!scope)sym.init=undefined;}node.thedef=sym;node.reference(options);return true;}});self.walk(tw);// pass 3: fix up any scoping issue with IE8
if(options.ie)self.walk(new TreeWalker(function(node){if(node instanceof AST_SymbolCatch){var def=node.thedef;var scope=def.defun;if(def.name!="arguments"&&scope.name instanceof AST_SymbolLambda&&scope.name.name==def.name){scope=scope.parent_scope.resolve();}redefine(node,scope);return true;}if(node instanceof AST_SymbolLambda){var def=node.thedef;if(!redefine(node,node.scope.parent_scope.resolve())){def.defun=undefined;}else if(typeof node.thedef.init!=="undefined"){node.thedef.init=false;}else if(def.init){node.thedef.init=def.init;}return true;}}));function is_arguments(sym){return sym.orig[0]instanceof AST_SymbolFunarg&&!(sym.orig[1]instanceof AST_SymbolFunarg||sym.orig[2]instanceof AST_SymbolFunarg)&&!is_arrow(sym.scope);}function redefine(node,scope){var name=node.name;var old_def=node.thedef;if(!all(old_def.orig,function(sym){return !(sym instanceof AST_SymbolConst||sym instanceof AST_SymbolLet);}))return false;var new_def=scope.find_variable(name);if(new_def){var redef=new_def.redefined();if(redef)new_def=redef;}else {new_def=self.globals.get(name);}if(new_def){new_def.orig.push(node);}else {new_def=scope.def_variable(node);}if(new_def.undeclared)self.variables.set(name,new_def);if(name=="arguments"&&is_arguments(old_def)&&node instanceof AST_SymbolLambda)return true;old_def.defun=new_def.scope;old_def.forEach(function(node){node.redef=old_def;node.thedef=new_def;node.reference(options);});return true;}});AST_Toplevel.DEFMETHOD("def_global",function(node){var globals=this.globals,name=node.name;if(globals.has(name)){return globals.get(name);}else {var g=this.make_def(node);g.undeclared=true;g.global=true;globals.set(name,g);return g;}});function init_block_vars(scope,parent,orig){// variables from this or outer scope(s) that are referenced from this or inner scopes
scope.enclosed=orig?orig.enclosed.slice():[];// map name to AST_SymbolDefun (functions defined in this scope)
scope.functions=orig?orig.functions.clone():new Dictionary();// map name to AST_SymbolVar (variables defined in this scope; includes functions)
scope.variables=orig?orig.variables.clone():new Dictionary();if(!parent)return;// top-level tracking of SymbolDef instances
scope.make_def=parent.make_def;// the parent scope (null if this is the top level)
scope.parent_scope=parent;}function init_scope_vars(scope,parent,orig){init_block_vars(scope,parent,orig);// will be set to true if this or nested scope uses the global `eval`
scope.uses_eval=false;// will be set to true if this or some nested scope uses the `with` statement
scope.uses_with=false;}AST_BlockScope.DEFMETHOD("init_vars",function(parent,orig){init_block_vars(this,parent,orig);});AST_Scope.DEFMETHOD("init_vars",function(parent,orig){init_scope_vars(this,parent,orig);});AST_Arrow.DEFMETHOD("init_vars",function(parent,orig){init_scope_vars(this,parent,orig);return this;});AST_AsyncArrow.DEFMETHOD("init_vars",function(parent,orig){init_scope_vars(this,parent,orig);});AST_Lambda.DEFMETHOD("init_vars",function(parent,orig){init_scope_vars(this,parent,orig);this.uses_arguments=false;this.def_variable(new AST_SymbolFunarg({name:"arguments",scope:this,start:this.start,end:this.end}));return this;});AST_Symbol.DEFMETHOD("mark_enclosed",function(options){var def=this.definition();for(var s=this.scope;s;s=s.parent_scope){if(!push_uniq(s.enclosed,def))break;if(!options){s._var_names=undefined;}else {if(options.keep_fargs&&s instanceof AST_Lambda)s.each_argname(function(arg){push_uniq(def.scope.enclosed,arg.definition());});if(options.keep_fnames)s.functions.each(function(d){push_uniq(def.scope.enclosed,d);});}if(s===def.scope)break;}});AST_Symbol.DEFMETHOD("reference",function(options){this.definition().references.push(this);this.mark_enclosed(options);});AST_BlockScope.DEFMETHOD("find_variable",function(name){return this.variables.get(name)||this.parent_scope&&this.parent_scope.find_variable(name);});AST_BlockScope.DEFMETHOD("def_function",function(symbol,init){var def=this.def_variable(symbol,init);if(!def.init||def.init instanceof AST_LambdaDefinition)def.init=init;this.functions.set(symbol.name,def);return def;});AST_BlockScope.DEFMETHOD("def_variable",function(symbol,init){var def=this.variables.get(symbol.name);if(def){def.orig.push(symbol);if(def.init instanceof AST_LambdaExpression)def.init=init;}else {def=this.make_def(symbol,init);this.variables.set(symbol.name,def);def.global=!this.parent_scope;}return symbol.thedef=def;});function names_in_use(scope,options){var names=scope.names_in_use;if(!names){scope.cname=-1;scope.cname_holes=[];scope.names_in_use=names=new Dictionary();var cache=options.cache&&options.cache.props;scope.enclosed.forEach(function(def){if(def.unmangleable(options))names.set(def.name,true);if(def.global&&cache&&cache.has(def.name)){names.set(cache.get(def.name),true);}});}return names;}function next_mangled_name(def,options){var scope=def.scope;var in_use=names_in_use(scope,options);var holes=scope.cname_holes;var names=new Dictionary();var scopes=[scope];def.forEach(function(sym){var scope=sym.scope;do{if(member(scope,scopes))break;names_in_use(scope,options).each(function(marker,name){names.set(name,marker);});scopes.push(scope);}while(scope=scope.parent_scope);});var name;for(var i=0;i<holes.length;i++){name=base54(holes[i]);if(names.has(name))continue;holes.splice(i,1);in_use.set(name,true);return name;}while(true){name=base54(++scope.cname);if(in_use.has(name)||RESERVED_WORDS[name]||options.reserved.has[name])continue;if(!names.has(name))break;holes.push(scope.cname);}in_use.set(name,true);return name;}AST_Symbol.DEFMETHOD("unmangleable",function(options){var def=this.definition();return !def||def.unmangleable(options);});// labels are always mangleable
AST_Label.DEFMETHOD("unmangleable",return_false);AST_Symbol.DEFMETHOD("definition",function(){return this.thedef;});function _default_mangler_options(options){options=defaults(options,{eval:false,ie:false,keep_fargs:false,keep_fnames:false,reserved:[],toplevel:false,v8:false,webkit:false});if(!Array.isArray(options.reserved))options.reserved=[];// Never mangle `arguments`
push_uniq(options.reserved,"arguments");options.reserved.has=makePredicate(options.reserved);return options;}// We only need to mangle declaration nodes. Special logic wired into the code
// generator will display the mangled name if it is present (and for
// `AST_SymbolRef`s it will use the mangled name of the `AST_SymbolDeclaration`
// that it points to).
AST_Toplevel.DEFMETHOD("mangle_names",function(options){options=_default_mangler_options(options);if(options.cache&&options.cache.props){var mangled_names=names_in_use(this,options);options.cache.props.each(function(mangled_name){mangled_names.set(mangled_name,true);});}var cutoff=36;var lname=-1;var redefined=[];var tw=new TreeWalker(function(node,descend){var save_nesting;if(node instanceof AST_BlockScope){// `lname` is incremented when we get to the `AST_Label`
if(node instanceof AST_LabeledStatement)save_nesting=lname;if(options.webkit&&node instanceof AST_IterationStatement&&node.init instanceof AST_Let){node.init.definitions.forEach(function(defn){defn.name.match_symbol(function(sym){if(!(sym instanceof AST_SymbolLet))return;var def=sym.definition();var scope=sym.scope.parent_scope;var redef=scope.def_variable(sym);sym.thedef=def;scope.to_mangle.push(redef);def.redefined=function(){return redef;};});},true);}var to_mangle=node.to_mangle=[];node.variables.each(function(def,name){if(def.unmangleable(options)){names_in_use(node,options).set(name,true);}else if(!defer_redef(def)){to_mangle.push(def);}});descend();if(options.cache&&node instanceof AST_Toplevel){node.globals.each(mangle);}if(node instanceof AST_Defun&&tw.has_directive("use asm")){var sym=new AST_SymbolRef(node.name);sym.scope=node;sym.reference(options);}if(to_mangle.length>cutoff){var indices=to_mangle.map(function(def,index){return index;}).sort(function(i,j){return to_mangle[j].references.length-to_mangle[i].references.length||i-j;});to_mangle=indices.slice(0,cutoff).sort(function(i,j){return i-j;}).map(function(index){return to_mangle[index];}).concat(indices.slice(cutoff).sort(function(i,j){return i-j;}).map(function(index){return to_mangle[index];}));}to_mangle.forEach(mangle);if(node instanceof AST_LabeledStatement&&!(options.v8&&in_label(tw)))lname=save_nesting;return true;}if(node instanceof AST_Label){var name;do{name=base54(++lname);}while(RESERVED_WORDS[name]);node.mangled_name=name;return true;}});this.walk(tw);redefined.forEach(mangle);function mangle(def){if(options.reserved.has[def.name])return;def.mangle(options);}function defer_redef(def){var sym=def.orig[0];var redef=def.redefined();if(!redef){if(!(sym instanceof AST_SymbolConst))return false;var scope=def.scope.resolve();if(def.scope===scope)return false;if(def.scope.parent_scope.find_variable(sym.name))return false;redef=scope.def_variable(sym);scope.to_mangle.push(redef);}redefined.push(def);def.references.forEach(reference);if(sym instanceof AST_SymbolCatch||sym instanceof AST_SymbolConst){reference(sym);def.redefined=function(){return redef;};}return true;function reference(sym){sym.thedef=redef;sym.reference(options);sym.thedef=def;}}function in_label(tw){var level=0,parent;while(parent=tw.parent(level++)){if(parent instanceof AST_Block)return parent instanceof AST_Toplevel&&!options.toplevel;if(parent instanceof AST_LabeledStatement)return true;}}});AST_Toplevel.DEFMETHOD("find_colliding_names",function(options){var cache=options.cache&&options.cache.props;var avoid=Object.create(RESERVED_WORDS);options.reserved.forEach(to_avoid);this.globals.each(add_def);this.walk(new TreeWalker(function(node){if(node instanceof AST_BlockScope)node.variables.each(add_def);}));return avoid;function to_avoid(name){avoid[name]=true;}function add_def(def){var name=def.name;if(def.global&&cache&&cache.has(name))name=cache.get(name);else if(!def.unmangleable(options))return;to_avoid(name);}});AST_Toplevel.DEFMETHOD("expand_names",function(options){base54.reset();base54.sort();options=_default_mangler_options(options);var avoid=this.find_colliding_names(options);var cname=0;this.globals.each(rename);this.walk(new TreeWalker(function(node){if(node instanceof AST_BlockScope)node.variables.each(rename);}));function next_name(){var name;do{name=base54(cname++);}while(avoid[name]);return name;}function rename(def){if(def.global&&options.cache)return;if(def.unmangleable(options))return;if(options.reserved.has[def.name])return;var redef=def.redefined();var name=redef?redef.rename||redef.name:next_name();def.rename=name;def.forEach(function(sym){if(sym.definition()===def)sym.name=name;});}});AST_Node.DEFMETHOD("tail_node",return_this);AST_Sequence.DEFMETHOD("tail_node",function(){return this.expressions[this.expressions.length-1];});AST_Toplevel.DEFMETHOD("compute_char_frequency",function(options){options=_default_mangler_options(options);base54.reset();var fn=AST_Symbol.prototype.add_source_map;try{AST_Symbol.prototype.add_source_map=function(){if(!this.unmangleable(options))base54.consider(this.name,-1);};if(options.properties){AST_Dot.prototype.add_source_map=function(){base54.consider(this.property,-1);};AST_Sub.prototype.add_source_map=function(){skip_string(this.property);};}base54.consider(this.print_to_string(),1);}finally{AST_Symbol.prototype.add_source_map=fn;delete AST_Dot.prototype.add_source_map;delete AST_Sub.prototype.add_source_map;}base54.sort();function skip_string(node){if(node instanceof AST_String){base54.consider(node.value,-1);}else if(node instanceof AST_Conditional){skip_string(node.consequent);skip_string(node.alternative);}else if(node instanceof AST_Sequence){skip_string(node.tail_node());}}});var base54=function(){var freq=Object.create(null);function init(chars){var array=[];for(var i=0;i<chars.length;i++){var ch=chars[i];array.push(ch);freq[ch]=-1e-2*i;}return array;}var digits=init("0123456789");var leading=init("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_");var chars,frequency;function reset(){chars=null;frequency=Object.create(freq);}base54.consider=function(str,delta){for(var i=str.length;--i>=0;){frequency[str[i]]+=delta;}};function compare(a,b){return frequency[b]-frequency[a];}base54.sort=function(){chars=leading.sort(compare).concat(digits).sort(compare);};base54.reset=reset;reset();function base54(num){var ret=leading[num%54];for(num=Math.floor(num/54);--num>=0;num>>=6){ret+=chars[num&0x3F];}return ret;}return base54;}();function Compressor(options,false_by_default){if(!(this instanceof Compressor))return new Compressor(options,false_by_default);TreeTransformer.call(this,this.before,this.after);this.options=defaults(options,{annotations:!false_by_default,arguments:!false_by_default,arrows:!false_by_default,assignments:!false_by_default,awaits:!false_by_default,booleans:!false_by_default,collapse_vars:!false_by_default,comparisons:!false_by_default,conditionals:!false_by_default,dead_code:!false_by_default,default_values:!false_by_default,directives:!false_by_default,drop_console:false,drop_debugger:!false_by_default,evaluate:!false_by_default,expression:false,functions:!false_by_default,global_defs:false,hoist_exports:!false_by_default,hoist_funs:false,hoist_props:!false_by_default,hoist_vars:false,ie:false,if_return:!false_by_default,imports:!false_by_default,inline:!false_by_default,join_vars:!false_by_default,keep_fargs:false_by_default,keep_fnames:false,keep_infinity:false,loops:!false_by_default,merge_vars:!false_by_default,module:false,negate_iife:!false_by_default,objects:!false_by_default,optional_chains:!false_by_default,passes:1,properties:!false_by_default,pure_funcs:null,pure_getters:!false_by_default&&"strict",reduce_funcs:!false_by_default,reduce_vars:!false_by_default,rests:!false_by_default,sequences:!false_by_default,side_effects:!false_by_default,spreads:!false_by_default,strings:!false_by_default,switches:!false_by_default,templates:!false_by_default,top_retain:null,toplevel:!!(options&&!options["expression"]&&options["top_retain"]),typeofs:!false_by_default,unsafe:false,unsafe_comps:false,unsafe_Function:false,unsafe_math:false,unsafe_proto:false,unsafe_regexp:false,unsafe_undefined:false,unused:!false_by_default,varify:!false_by_default,webkit:false,yields:!false_by_default},true);var evaluate=this.options["evaluate"];this.eval_threshold=/eager/.test(evaluate)?1/0:+evaluate;var global_defs=this.options["global_defs"];if(typeof global_defs=="object")for(var key in global_defs){if(/^@/.test(key)&&HOP(global_defs,key)){global_defs[key.slice(1)]=parse(global_defs[key],{expression:true});}}if(this.options["inline"]===true)this.options["inline"]=4;this.drop_fargs=this.options["keep_fargs"]?return_false:function(lambda,parent){if(lambda.length_read)return false;var name=lambda.name;if(!name)return parent&&parent.TYPE=="Call"&&parent.expression===lambda;if(name.fixed_value()!==lambda)return false;var def=name.definition();if(def.direct_access)return false;var escaped=def.escaped;return escaped&&escaped.depth!=1;};if(this.options["module"])this.directives["use strict"]=true;var pure_funcs=this.options["pure_funcs"];if(typeof pure_funcs=="function"){this.pure_funcs=pure_funcs;}else if(typeof pure_funcs=="string"){this.pure_funcs=function(node){var expr;if(node instanceof AST_Call){expr=node.expression;}else if(node instanceof AST_Template){expr=node.tag;}return !(expr&&pure_funcs===expr.print_to_string());};}else if(Array.isArray(pure_funcs)){this.pure_funcs=function(node){var expr;if(node instanceof AST_Call){expr=node.expression;}else if(node instanceof AST_Template){expr=node.tag;}return !(expr&&member(expr.print_to_string(),pure_funcs));};}else {this.pure_funcs=return_true;}var sequences=this.options["sequences"];this.sequences_limit=sequences==1?800:sequences|0;var top_retain=this.options["top_retain"];if(top_retain instanceof RegExp){this.top_retain=function(def){return top_retain.test(def.name);};}else if(typeof top_retain=="function"){this.top_retain=top_retain;}else if(top_retain){if(typeof top_retain=="string"){top_retain=top_retain.split(/,/);}this.top_retain=function(def){return member(def.name,top_retain);};}var toplevel=this.options["toplevel"];this.toplevel=typeof toplevel=="string"?{funcs:/funcs/.test(toplevel),vars:/vars/.test(toplevel)}:{funcs:toplevel,vars:toplevel};}Compressor.prototype=new TreeTransformer(function(node,descend){if(node._squeezed)return node;var is_scope=node instanceof AST_Scope;if(is_scope){if(this.option("arrows")&&is_arrow(node)&&node.value){node.body=[node.first_statement()];node.value=null;}node.hoist_properties(this);node.hoist_declarations(this);node.process_returns(this);}// Before https://github.com/mishoo/UglifyJS/pull/1602 AST_Node.optimize()
// would call AST_Node.transform() if a different instance of AST_Node is
// produced after OPT().
// This corrupts TreeWalker.stack, which cause AST look-ups to malfunction.
// Migrate and defer all children's AST_Node.transform() to below, which
// will now happen after this parent AST_Node has been properly substituted
// thus gives a consistent AST snapshot.
descend(node,this);// Existing code relies on how AST_Node.optimize() worked, and omitting the
// following replacement call would result in degraded efficiency of both
// output and performance.
descend(node,this);var opt=node.optimize(this);if(is_scope){if(opt===node&&!this.has_directive("use asm")&&!opt.pinned()){opt.drop_unused(this);if(opt.merge_variables(this))opt.drop_unused(this);descend(opt,this);}if(this.option("arrows")&&is_arrow(opt)&&opt.body.length==1){var stat=opt.body[0];if(stat instanceof AST_Return){opt.body.length=0;opt.value=stat.value;}}}if(opt===node)opt._squeezed=true;return opt;});Compressor.prototype.option=function(key){return this.options[key];};Compressor.prototype.exposed=function(def){if(def.exported)return true;if(def.undeclared)return true;if(!(def.global||def.scope.resolve()instanceof AST_Toplevel))return false;var toplevel=this.toplevel;return !all(def.orig,function(sym){return toplevel[sym instanceof AST_SymbolDefun?"funcs":"vars"];});};Compressor.prototype.compress=function(node){node=node.resolve_defines(this);node.hoist_exports(this);if(this.option("expression"))node.process_expression(true);var merge_vars=this.options.merge_vars;var passes=+this.options.passes||1;var min_count=1/0;var stopping=false;var mangle={ie:this.option("ie")};for(var pass=0;pass<passes;pass++){node.figure_out_scope(mangle);if(pass>0||this.option("reduce_vars"))node.reset_opt_flags(this);this.options.merge_vars=merge_vars&&(stopping||pass==passes-1);node=node.transform(this);if(passes>1){var count=0;node.walk(new TreeWalker(function(){count++;}));AST_Node.info("pass {pass}: last_count: {min_count}, count: {count}",{pass:pass,min_count:min_count,count:count});if(count<min_count){min_count=count;stopping=false;}else if(stopping){break;}else {stopping=true;}}}if(this.option("expression"))node.process_expression(false);return node;};(function(OPT){OPT(AST_Node,function(self){return self;});AST_Toplevel.DEFMETHOD("hoist_exports",function(compressor){if(!compressor.option("hoist_exports"))return;var body=this.body,props=[];for(var i=0;i<body.length;i++){var stat=body[i];if(stat instanceof AST_ExportDeclaration){body[i]=stat=stat.body;if(stat instanceof AST_Definitions){stat.definitions.forEach(function(defn){defn.name.match_symbol(export_symbol,true);});}else {export_symbol(stat.name);}}else if(stat instanceof AST_ExportReferences){body.splice(i--,1);[].push.apply(props,stat.properties);}}if(props.length)body.push(make_node(AST_ExportReferences,this,{properties:props}));function export_symbol(sym){if(!(sym instanceof AST_SymbolDeclaration))return;var node=make_node(AST_SymbolExport,sym);node.alias=make_node(AST_String,node,{value:node.name});props.push(node);}});AST_Scope.DEFMETHOD("process_expression",function(insert,transform){var self=this;var tt=new TreeTransformer(function(node){if(insert){if(node instanceof AST_Directive)node=make_node(AST_SimpleStatement,node,{body:make_node(AST_String,node)});if(node instanceof AST_SimpleStatement){return transform?transform(node):make_node(AST_Return,node,{value:node.body});}}else if(node instanceof AST_Return){if(transform)return transform(node);var value=node.value;if(value instanceof AST_String)return make_node(AST_Directive,value);return make_node(AST_SimpleStatement,node,{body:value||make_node(AST_UnaryPrefix,node,{operator:"void",expression:make_node(AST_Number,node,{value:0})})});}if(node instanceof AST_Block){if(node instanceof AST_Lambda){if(node!==self)return node;}else if(insert==="awaits"&&node instanceof AST_Try){if(node.bfinally)return node;}for(var index=node.body.length;--index>=0;){var stat=node.body[index];if(!is_declaration(stat,true)){node.body[index]=stat.transform(tt);break;}}}else if(node instanceof AST_If){node.body=node.body.transform(tt);if(node.alternative)node.alternative=node.alternative.transform(tt);}else if(node instanceof AST_With){node.body=node.body.transform(tt);}return node;});self.transform(tt);});AST_Toplevel.DEFMETHOD("unwrap_expression",function(){var self=this;switch(self.body.length){case 0:return make_node(AST_UnaryPrefix,self,{operator:"void",expression:make_node(AST_Number,self,{value:0})});case 1:var stat=self.body[0];if(stat instanceof AST_Directive)return make_node(AST_String,stat);if(stat instanceof AST_SimpleStatement)return stat.body;default:return make_node(AST_Call,self,{expression:make_node(AST_Function,self,{argnames:[],body:self.body}).init_vars(self,self),args:[]});}});AST_Node.DEFMETHOD("wrap_expression",function(){var self=this;if(!is_statement(self))self=make_node(AST_SimpleStatement,self,{body:self});if(!(self instanceof AST_Toplevel))self=make_node(AST_Toplevel,self,{body:[self]});return self;});function read_property(obj,node){var key=node.get_property();if(key instanceof AST_Node)return;var value;if(obj instanceof AST_Array){var elements=obj.elements;if(key=="length")return make_node_from_constant(elements.length,obj);if(typeof key=="number"&&key in elements)value=elements[key];}else if(obj instanceof AST_Lambda){if(key=="length"){obj.length_read=true;return make_node_from_constant(obj.argnames.length,obj);}}else if(obj instanceof AST_Object){key=""+key;var props=obj.properties;for(var i=props.length;--i>=0;){var prop=props[i];if(!can_hoist_property(prop))return;if(!value&&props[i].key===key)value=props[i].value;}}return value instanceof AST_SymbolRef&&value.fixed_value()||value;}function is_read_only_fn(value,name){if(value instanceof AST_Boolean)return native_fns.Boolean[name];if(value instanceof AST_Number)return native_fns.Number[name];if(value instanceof AST_String)return native_fns.String[name];if(name=="valueOf")return false;if(value instanceof AST_Array)return native_fns.Array[name];if(value instanceof AST_Lambda)return native_fns.Function[name];if(value instanceof AST_Object)return native_fns.Object[name];if(value instanceof AST_RegExp)return native_fns.RegExp[name]&&!value.value.global;}function is_modified(compressor,tw,node,value,level,immutable,recursive){var parent=tw.parent(level);if(compressor.option("unsafe")&&parent instanceof AST_Dot&&is_read_only_fn(value,parent.property)){return;}var lhs=is_lhs(node,parent);if(lhs)return lhs;if(level==0&&value&&value.is_constant())return;if(parent instanceof AST_Array)return is_modified(compressor,tw,parent,parent,level+1);if(parent instanceof AST_Assign)switch(parent.operator){case"=":return is_modified(compressor,tw,parent,value,level+1,immutable,recursive);case"&&=":case"||=":case"??=":return is_modified(compressor,tw,parent,parent,level+1);default:return;}if(parent instanceof AST_Binary){if(!lazy_op[parent.operator])return;return is_modified(compressor,tw,parent,parent,level+1);}if(parent instanceof AST_Call){return !immutable&&parent.expression===node&&!parent.is_expr_pure(compressor)&&(!(value instanceof AST_LambdaExpression)||!(parent instanceof AST_New)&&value.contains_this());}if(parent instanceof AST_Conditional){if(parent.condition===node)return;return is_modified(compressor,tw,parent,parent,level+1);}if(parent instanceof AST_ForEnumeration)return parent.init===node;if(parent instanceof AST_ObjectKeyVal){if(parent.value!==node)return;var obj=tw.parent(level+1);return is_modified(compressor,tw,obj,obj,level+2);}if(parent instanceof AST_PropAccess){if(parent.expression!==node)return;var prop=read_property(value,parent);return (!immutable||recursive)&&is_modified(compressor,tw,parent,prop,level+1);}if(parent instanceof AST_Sequence){if(parent.tail_node()!==node)return;return is_modified(compressor,tw,parent,value,level+1,immutable,recursive);}}function is_lambda(node){return node instanceof AST_Class||node instanceof AST_Lambda;}function safe_for_extends(node){return node instanceof AST_Class||node instanceof AST_Defun||node instanceof AST_Function;}function is_arguments(def){return def.name=="arguments"&&def.scope.uses_arguments;}function cross_scope(def,sym){do{if(def===sym)return false;if(sym instanceof AST_Scope)return true;}while(sym=sym.parent_scope);}function can_drop_symbol(ref,compressor,keep_lambda){var def=ref.redef||ref.definition();if(ref.in_arg&&is_funarg(def))return false;return all(def.orig,function(sym){if(sym instanceof AST_SymbolConst||sym instanceof AST_SymbolLet){if(sym instanceof AST_SymbolImport)return true;return compressor&&safe_from_tdz(compressor,sym);}return !(keep_lambda&&sym instanceof AST_SymbolLambda);});}function has_escaped(d,scope,node,parent){if(parent instanceof AST_Assign)return parent.operator=="="&&parent.right===node;if(parent instanceof AST_Call)return parent.expression!==node||parent instanceof AST_New;if(parent instanceof AST_ClassField)return parent.value===node&&!parent.static;if(parent instanceof AST_Exit)return parent.value===node&&scope.resolve()!==d.scope.resolve();if(parent instanceof AST_VarDef)return parent.value===node;}function make_ref(ref,fixed){var node=make_node(AST_SymbolRef,ref);node.fixed=fixed||make_node(AST_Undefined,ref);return node;}function replace_ref(resolve,fixed){return function(node){var ref=resolve(node);var node=make_ref(ref,fixed);var def=ref.definition();def.references.push(node);def.replaced++;return node;};}var RE_POSITIVE_INTEGER=/^(0|[1-9][0-9]*)$/;(function(def){def(AST_Node,noop);function reset_def(tw,compressor,def){def.assignments=0;def.bool_return=0;def.cross_loop=false;def.direct_access=false;def.drop_return=0;def.escaped=[];def.first_decl=null;def.fixed=!def.const_redefs&&!def.scope.pinned()&&!compressor.exposed(def)&&!(def.init instanceof AST_LambdaExpression&&def.init!==def.scope)&&def.init;def.reassigned=0;def.recursive_refs=0;def.references=[];def.single_use=undefined;}function reset_block_variables(tw,compressor,scope){scope.variables.each(function(def){reset_def(tw,compressor,def);});}function reset_variables(tw,compressor,scope){scope.fn_defs=[];scope.variables.each(function(def){reset_def(tw,compressor,def);var init=def.init;if(init instanceof AST_LambdaDefinition){scope.fn_defs.push(init);init.safe_ids=null;}if(def.fixed===null){def.safe_ids=tw.safe_ids;mark(tw,def);}else if(def.fixed){tw.loop_ids[def.id]=tw.in_loop;mark(tw,def);}});scope.may_call_this=function(){scope.may_call_this=scope.contains_this()?return_true:return_false;};if(scope.uses_arguments)scope.each_argname(function(node){node.definition().last_ref=false;});if(compressor.option("ie"))scope.variables.each(function(def){var d=def.orig[0].definition();if(d!==def)d.fixed=false;});}function safe_to_visit(tw,fn){var marker=fn.safe_ids;return marker===undefined||marker===tw.safe_ids;}function walk_fn_def(tw,fn){var was_scanning=tw.fn_scanning;tw.fn_scanning=fn;fn.walk(tw);tw.fn_scanning=was_scanning;}function revisit_fn_def(tw,fn){fn.enclosed.forEach(function(d){if(fn.variables.get(d.name)===d)return;if(safe_to_read(tw,d))return;d.single_use=false;var fixed=d.fixed;if(typeof fixed=="function")fixed=fixed();if(fixed instanceof AST_Lambda){var safe_ids=fixed.safe_ids;switch(safe_ids){case null:case false:return;default:if(safe_ids&&safe_ids.seq!==tw.safe_ids.seq)return;}}d.fixed=false;});}function mark_fn_def(tw,def,fn){var marker=fn.safe_ids;if(marker===undefined)return;if(marker===false)return;if(fn.parent_scope.resolve().may_call_this===return_true){if(member(fn,tw.fn_visited))revisit_fn_def(tw,fn);}else if(marker){var visited=member(fn,tw.fn_visited);if(marker===tw.safe_ids){if(!visited)walk_fn_def(tw,fn);}else if(visited){revisit_fn_def(tw,fn);}else {fn.safe_ids=false;}}else if(tw.fn_scanning&&tw.fn_scanning!==def.scope.resolve()){fn.safe_ids=false;}else {fn.safe_ids=tw.safe_ids;walk_fn_def(tw,fn);}}function pop_scope(tw,scope){pop(tw);var fn_defs=scope.fn_defs;fn_defs.forEach(function(fn){fn.safe_ids=tw.safe_ids;walk_fn_def(tw,fn);});fn_defs.forEach(function(fn){fn.safe_ids=undefined;});scope.fn_defs=undefined;scope.may_call_this=undefined;}function push(tw,sequential,conditional){var defined_ids=Object.create(tw.defined_ids);if(!sequential||conditional)defined_ids.seq=Object.create(null);tw.defined_ids=defined_ids;var safe_ids=Object.create(tw.safe_ids);if(!sequential)safe_ids.seq={};if(conditional)safe_ids.cond=true;tw.safe_ids=safe_ids;}function pop(tw){tw.defined_ids=Object.getPrototypeOf(tw.defined_ids);tw.safe_ids=Object.getPrototypeOf(tw.safe_ids);}function access(tw,def){var seq=tw.defined_ids.seq;tw.defined_ids[def.id]=seq;seq[def.id]=true;}function assign(tw,def){var seq=tw.defined_ids.seq;tw.assigned_ids[def.id]=seq;seq[def.id]=false;}function safe_to_access(tw,def){var seq=tw.defined_ids.seq;var defined=tw.defined_ids[def.id];if(defined!==seq)return false;if(!defined[def.id])return false;var assigned=tw.assigned_ids[def.id];return !assigned||assigned===seq;}function mark(tw,def){tw.safe_ids[def.id]={};}function push_ref(def,ref){def.references.push(ref);if(def.last_ref!==false)def.last_ref=ref;}function safe_to_read(tw,def){if(def.single_use=="m")return false;var safe=tw.safe_ids[def.id];if(safe){var in_order=HOP(tw.safe_ids,def.id);if(!in_order){var seq=tw.safe_ids.seq;if(!safe.read){safe.read=seq;}else if(safe.read!==seq){safe.read=true;}}if(def.fixed==null){if(is_arguments(def))return false;if(def.global&&def.name=="arguments")return false;tw.loop_ids[def.id]=null;def.fixed=make_node(AST_Undefined,def.orig[0]);if(in_order)def.safe_ids=undefined;return true;}return !safe.assign||safe.assign===tw.safe_ids;}return def.fixed instanceof AST_LambdaDefinition;}function safe_to_assign(tw,def,declare){if(!declare){if(is_funarg(def)&&def.scope.uses_arguments&&!tw.has_directive("use strict"))return false;if(!all(def.orig,function(sym){return !(sym instanceof AST_SymbolConst);}))return false;}if(def.fixed===undefined)return declare||all(def.orig,function(sym){return !(sym instanceof AST_SymbolLet);});if(def.fixed===false||def.fixed===0)return false;var safe=tw.safe_ids[def.id];if(def.safe_ids){def.safe_ids[def.id]=false;def.safe_ids=undefined;return def.fixed===null||HOP(tw.safe_ids,def.id)&&!safe.read;}if(!HOP(tw.safe_ids,def.id)){if(!safe)return false;if(safe.read||tw.in_loop){var scope=tw.find_parent(AST_BlockScope);if(scope instanceof AST_Class)return false;if(def.scope.resolve()!==scope.resolve())return false;}safe.assign=safe.assign&&safe.assign!==tw.safe_ids?true:tw.safe_ids;}if(def.fixed!=null&&safe.read){if(safe.read!==tw.safe_ids.seq)return false;if(tw.loop_ids[def.id]!==tw.in_loop)return false;}return safe_to_read(tw,def)&&all(def.orig,function(sym){return !(sym instanceof AST_SymbolLambda);});}function ref_once(compressor,def){return compressor.option("unused")&&!def.scope.pinned()&&def.single_use!==false&&def.references.length-def.recursive_refs==1&&!(is_funarg(def)&&def.scope.uses_arguments);}function is_immutable(value){if(!value)return false;if(value instanceof AST_Assign){var op=value.operator;return op=="="?is_immutable(value.right):!lazy_op[op.slice(0,-1)];}if(value instanceof AST_Sequence)return is_immutable(value.tail_node());return value.is_constant()||is_lambda(value)||value instanceof AST_ObjectIdentity;}function value_in_use(node,parent){if(parent instanceof AST_Array)return true;if(parent instanceof AST_Binary)return lazy_op[parent.operator];if(parent instanceof AST_Conditional)return parent.condition!==node;if(parent instanceof AST_Sequence)return parent.tail_node()===node;if(parent instanceof AST_Spread)return true;}function mark_escaped(tw,d,scope,node,value,level,depth){var parent=tw.parent(level);if(value&&value.is_constant())return;if(has_escaped(d,scope,node,parent)){d.escaped.push(parent);if(depth>1&&!(value&&value.is_constant_expression(scope)))depth=1;if(!d.escaped.depth||d.escaped.depth>depth)d.escaped.depth=depth;if(d.scope.resolve()!==scope.resolve())d.escaped.cross_scope=true;if(d.fixed)d.fixed.escaped=d.escaped;return;}else if(value_in_use(node,parent)){mark_escaped(tw,d,scope,parent,parent,level+1,depth);}else if(parent instanceof AST_ObjectKeyVal&&parent.value===node){var obj=tw.parent(level+1);mark_escaped(tw,d,scope,obj,obj,level+2,depth);}else if(parent instanceof AST_PropAccess&&parent.expression===node){value=read_property(value,parent);mark_escaped(tw,d,scope,parent,value,level+1,depth+1);if(value)return;}if(level>0)return;if(parent instanceof AST_Call&&parent.expression===node)return;if(parent instanceof AST_Sequence&&parent.tail_node()!==node)return;if(parent instanceof AST_SimpleStatement)return;if(parent instanceof AST_Unary&&!unary_side_effects[parent.operator])return;d.direct_access=true;if(d.fixed)d.fixed.direct_access=true;}function mark_assignment_to_arguments(node){if(!(node instanceof AST_Sub))return;var expr=node.expression;if(!(expr instanceof AST_SymbolRef))return;var def=expr.definition();if(!is_arguments(def))return;var key=node.property;if(key.is_constant())key=key.value;if(!(key instanceof AST_Node)&&!RE_POSITIVE_INTEGER.test(key))return;def.reassigned++;(key instanceof AST_Node?def.scope.argnames:[def.scope.argnames[key]]).forEach(function(argname){if(argname instanceof AST_SymbolFunarg)argname.definition().fixed=false;});}function make_fixed(save,fn){var prev_save,prev_value;return function(){var current=save();if(prev_save!==current){prev_save=current;prev_value=fn(current);}return prev_value;};}function make_fixed_default(compressor,node,save){var prev_save,prev_seq;return function(){if(prev_seq===node)return node;var current=save();var ev=fuzzy_eval(compressor,current,true);if(ev instanceof AST_Node){prev_seq=node;}else if(prev_save!==current){prev_save=current;prev_seq=ev===undefined?make_sequence(node,[current,node.value]):current;}return prev_seq;};}function scan_declaration(tw,compressor,lhs,fixed,visit){var scanner=new TreeWalker(function(node){if(node instanceof AST_DefaultValue){reset_flags(node);push(tw,true,true);node.value.walk(tw);pop(tw);var save=fixed;if(save)fixed=make_fixed_default(compressor,node,save);node.name.walk(scanner);fixed=save;return true;}if(node instanceof AST_DestructuredArray){reset_flags(node);var save=fixed;node.elements.forEach(function(node,index){if(node instanceof AST_Hole)return reset_flags(node);if(save)fixed=make_fixed(save,function(value){return make_node(AST_Sub,node,{expression:value,property:make_node(AST_Number,node,{value:index})});});node.walk(scanner);});if(node.rest){var fixed_node;if(save)fixed=compressor.option("rests")&&make_fixed(save,function(value){if(!(value instanceof AST_Array))return node;for(var i=0,len=node.elements.length;i<len;i++){if(value.elements[i]instanceof AST_Spread)return node;}if(!fixed_node)fixed_node=make_node(AST_Array,node,{});fixed_node.elements=value.elements.slice(len);return fixed_node;});node.rest.walk(scanner);}fixed=save;return true;}if(node instanceof AST_DestructuredObject){reset_flags(node);var save=fixed;node.properties.forEach(function(node){reset_flags(node);if(node.key instanceof AST_Node){push(tw);node.key.walk(tw);pop(tw);}if(save)fixed=make_fixed(save,function(value){var key=node.key;var type=AST_Sub;if(typeof key=="string"){if(is_identifier_string(key)){type=AST_Dot;}else {key=make_node_from_constant(key,node);}}return make_node(type,node,{expression:value,property:key});});node.value.walk(scanner);});if(node.rest){fixed=false;node.rest.walk(scanner);}fixed=save;return true;}visit(node,fixed,function(){var save_len=tw.stack.length;for(var i=0,len=scanner.stack.length-1;i<len;i++){tw.stack.push(scanner.stack[i]);}node.walk(tw);tw.stack.length=save_len;});return true;});lhs.walk(scanner);}function reduce_iife(tw,descend,compressor){var fn=this;fn.inlined=false;var iife=tw.parent();var sequential=!is_async(fn)&&!is_generator(fn);var hit=!sequential;var aborts=false;fn.walk(new TreeWalker(function(node){if(hit)return aborts=true;if(node instanceof AST_Return)return hit=true;if(node instanceof AST_Scope&&node!==fn)return true;}));if(aborts)push(tw,sequential);reset_variables(tw,compressor,fn);// Virtually turn IIFE parameters into variable definitions:
//   (function(a,b) {...})(c,d) ---> (function() {var a=c,b=d; ...})()
// So existing transformation rules can work on them.
var safe=!fn.uses_arguments||tw.has_directive("use strict");fn.argnames.forEach(function(argname,i){var value=iife.args[i];scan_declaration(tw,compressor,argname,function(){var j=fn.argnames.indexOf(argname);var arg=j<0?value:iife.args[j];if(arg instanceof AST_Sequence&&arg.expressions.length<2)arg=arg.expressions[0];return arg||make_node(AST_Undefined,iife);},visit);});var rest=fn.rest,fixed_node;if(rest)scan_declaration(tw,compressor,rest,compressor.option("rests")&&function(){if(fn.rest!==rest)return rest;if(!fixed_node)fixed_node=make_node(AST_Array,fn,{});fixed_node.elements=iife.args.slice(fn.argnames.length);return fixed_node;},visit);walk_lambda(fn,tw);var defined_ids=tw.defined_ids;var safe_ids=tw.safe_ids;pop_scope(tw,fn);if(!aborts){tw.defined_ids=defined_ids;tw.safe_ids=safe_ids;}return true;function visit(node,fixed){var d=node.definition();if(!d.first_decl&&d.references.length==0)d.first_decl=node;if(fixed&&safe&&d.fixed===undefined){mark(tw,d);tw.loop_ids[d.id]=tw.in_loop;d.fixed=fixed;d.fixed.assigns=[node];}else {d.fixed=false;}}}def(AST_Assign,function(tw,descend,compressor){var node=this;var left=node.left;var right=node.right;var ld=left instanceof AST_SymbolRef&&left.definition();var scan=ld||left instanceof AST_Destructured;switch(node.operator){case"=":if(left.equals(right)&&!left.has_side_effects(compressor)){right.walk(tw);walk_prop(left);return true;}if(ld&&right instanceof AST_LambdaExpression){walk_assign();right.parent_scope.resolve().fn_defs.push(right);right.safe_ids=null;if(!ld.fixed||!node.write_only||tw.safe_ids.cond)mark_fn_def(tw,ld,right);return true;}if(scan){right.walk(tw);walk_assign();return true;}mark_assignment_to_arguments(left);return;case"&&=":case"||=":case"??=":var lazy=true;default:if(!scan){mark_assignment_to_arguments(left);return walk_lazy();}assign(tw,ld);ld.assignments++;var fixed=ld.fixed;if(is_modified(compressor,tw,node,node,0)){ld.fixed=false;return walk_lazy();}var safe=safe_to_read(tw,ld);if(lazy)push(tw,true,true);right.walk(tw);if(lazy)pop(tw);if(safe&&!left.in_arg&&safe_to_assign(tw,ld)){push_ref(ld,left);mark(tw,ld);if(ld.single_use)ld.single_use=false;left.fixed=ld.fixed=function(){return make_node(AST_Binary,node,{operator:node.operator.slice(0,-1),left:make_ref(left,fixed),right:node.right});};left.fixed.assigns=!fixed||!fixed.assigns?[ld.orig[0]]:fixed.assigns.slice();left.fixed.assigns.push(node);left.fixed.to_binary=replace_ref(function(node){return node.left;},fixed);}else {left.walk(tw);ld.fixed=false;}return true;}function walk_prop(lhs){reset_flags(lhs);if(lhs instanceof AST_Dot){walk_prop(lhs.expression);}else if(lhs instanceof AST_Sub){walk_prop(lhs.expression);lhs.property.walk(tw);}else if(lhs instanceof AST_SymbolRef){var d=lhs.definition();push_ref(d,lhs);if(d.fixed){lhs.fixed=d.fixed;if(lhs.fixed.assigns){lhs.fixed.assigns.push(node);}else {lhs.fixed.assigns=[node];}}}else {lhs.walk(tw);}}function walk_assign(){var recursive=ld&&recursive_ref(tw,ld);var modified=is_modified(compressor,tw,node,right,0,is_immutable(right),recursive);scan_declaration(tw,compressor,left,function(){return node.right;},function(sym,fixed,walk){if(!(sym instanceof AST_SymbolRef)){mark_assignment_to_arguments(sym);walk();return;}var d=sym.definition();assign(tw,d);d.assignments++;if(!fixed||sym.in_arg||!safe_to_assign(tw,d)){walk();d.fixed=false;}else {push_ref(d,sym);mark(tw,d);if(left instanceof AST_Destructured||d.orig.length==1&&d.orig[0]instanceof AST_SymbolDefun){d.single_use=false;}tw.loop_ids[d.id]=tw.in_loop;d.fixed=modified?0:fixed;sym.fixed=fixed;sym.fixed.assigns=[node];mark_escaped(tw,d,sym.scope,node,right,0,1);}});}function walk_lazy(){if(!lazy)return;left.walk(tw);push(tw,true,true);right.walk(tw);pop(tw);return true;}});def(AST_Binary,function(tw){if(!lazy_op[this.operator])return;this.left.walk(tw);push(tw,true,true);this.right.walk(tw);pop(tw);return true;});def(AST_BlockScope,function(tw,descend,compressor){reset_block_variables(tw,compressor,this);});def(AST_Call,function(tw){var node=this;var exp=node.expression;if(exp instanceof AST_LambdaExpression){var iife=is_iife_single(node);node.args.forEach(function(arg){arg.walk(tw);if(arg instanceof AST_Spread)iife=false;});if(iife)exp.reduce_vars=reduce_iife;exp.walk(tw);if(iife)delete exp.reduce_vars;return true;}if(node.TYPE=="Call")switch(tw.in_boolean_context()){case"d":var drop=true;case true:mark_refs(exp,drop);}exp.walk(tw);var optional=node.optional;if(optional)push(tw,true,true);node.args.forEach(function(arg){arg.walk(tw);});if(optional)pop(tw);var fixed=exp instanceof AST_SymbolRef&&exp.fixed_value();if(fixed instanceof AST_Lambda){mark_fn_def(tw,exp.definition(),fixed);}else {tw.defined_ids.seq={};tw.find_parent(AST_Scope).may_call_this();}return true;function mark_refs(node,drop){if(node instanceof AST_Assign){if(node.operator!="=")return;mark_refs(node.left,drop);mark_refs(node.right,drop);}else if(node instanceof AST_Binary){if(!lazy_op[node.operator])return;mark_refs(node.left,drop);mark_refs(node.right,drop);}else if(node instanceof AST_Conditional){mark_refs(node.consequent,drop);mark_refs(node.alternative,drop);}else if(node instanceof AST_SymbolRef){var def=node.definition();def.bool_return++;if(drop)def.drop_return++;}}});def(AST_Class,function(tw,descend,compressor){var node=this;reset_block_variables(tw,compressor,node);if(node.extends)node.extends.walk(tw);var props=node.properties.filter(function(prop){reset_flags(prop);if(prop.key instanceof AST_Node){tw.push(prop);prop.key.walk(tw);tw.pop();}return prop.value;});if(node.name){var d=node.name.definition();var parent=tw.parent();if(parent instanceof AST_ExportDeclaration||parent instanceof AST_ExportDefault)d.single_use=false;if(safe_to_assign(tw,d,true)){mark(tw,d);tw.loop_ids[d.id]=tw.in_loop;d.fixed=function(){return node;};d.fixed.assigns=[node];if(!is_safe_lexical(d))d.single_use=false;}else {d.fixed=false;}}props.forEach(function(prop){tw.push(prop);if(!prop.static||is_static_field_or_init(prop)&&prop.value.contains_this()){push(tw);prop.value.walk(tw);pop(tw);}else {prop.value.walk(tw);}tw.pop();});return true;});def(AST_ClassInitBlock,function(tw,descend,compressor){var node=this;push(tw,true);reset_variables(tw,compressor,node);descend();pop_scope(tw,node);return true;});def(AST_Conditional,function(tw){this.condition.walk(tw);push(tw,true,true);this.consequent.walk(tw);pop(tw);push(tw,true,true);this.alternative.walk(tw);pop(tw);return true;});def(AST_DefaultValue,function(tw){push(tw,true,true);this.value.walk(tw);pop(tw);this.name.walk(tw);return true;});def(AST_Do,function(tw){var save_loop=tw.in_loop;tw.in_loop=this;push(tw);this.body.walk(tw);if(has_loop_control(this,tw.parent())){pop(tw);push(tw);}this.condition.walk(tw);pop(tw);tw.in_loop=save_loop;return true;});def(AST_Dot,function(tw,descend){descend();var node=this;var expr=node.expression;if(!node.optional){while(expr instanceof AST_Assign&&expr.operator=="="){var lhs=expr.left;if(lhs instanceof AST_SymbolRef)access(tw,lhs.definition());expr=expr.right;}if(expr instanceof AST_SymbolRef)access(tw,expr.definition());}return true;});def(AST_For,function(tw,descend,compressor){var node=this;reset_block_variables(tw,compressor,node);if(node.init)node.init.walk(tw);var save_loop=tw.in_loop;tw.in_loop=node;push(tw);if(node.condition)node.condition.walk(tw);node.body.walk(tw);if(node.step){if(has_loop_control(node,tw.parent())){pop(tw);push(tw);}node.step.walk(tw);}pop(tw);tw.in_loop=save_loop;return true;});def(AST_ForEnumeration,function(tw,descend,compressor){var node=this;reset_block_variables(tw,compressor,node);node.object.walk(tw);var save_loop=tw.in_loop;tw.in_loop=node;push(tw);var init=node.init;if(init instanceof AST_Definitions){init.definitions[0].name.mark_symbol(function(node){if(node instanceof AST_SymbolDeclaration){var def=node.definition();def.assignments++;def.fixed=false;}},tw);}else if(init instanceof AST_Destructured||init instanceof AST_SymbolRef){init.mark_symbol(function(node){if(node instanceof AST_SymbolRef){var def=node.definition();push_ref(def,node);def.assignments++;if(!node.is_immutable())def.fixed=false;}},tw);}else {init.walk(tw);}node.body.walk(tw);pop(tw);tw.in_loop=save_loop;return true;});def(AST_If,function(tw){this.condition.walk(tw);push(tw,true,true);this.body.walk(tw);pop(tw);if(this.alternative){push(tw,true,true);this.alternative.walk(tw);pop(tw);}return true;});def(AST_LabeledStatement,function(tw){push(tw,true);this.body.walk(tw);pop(tw);return true;});def(AST_Lambda,function(tw,descend,compressor){var fn=this;if(!safe_to_visit(tw,fn))return true;if(!push_uniq(tw.fn_visited,fn))return true;fn.inlined=false;push(tw);reset_variables(tw,compressor,fn);descend();pop_scope(tw,fn);if(fn.name)mark_escaped(tw,fn.name.definition(),fn,fn.name,fn,0,1);return true;});def(AST_LambdaDefinition,function(tw,descend,compressor){var fn=this;var def=fn.name.definition();if(!safe_to_trim(fn))def.fixed=false;var parent=tw.parent();if(parent instanceof AST_ExportDeclaration||parent instanceof AST_ExportDefault)def.single_use=false;if(!safe_to_visit(tw,fn))return true;if(!push_uniq(tw.fn_visited,fn))return true;fn.inlined=false;push(tw);reset_variables(tw,compressor,fn);descend();pop_scope(tw,fn);return true;});def(AST_Sub,function(tw,descend){var node=this;var expr=node.expression;if(node.optional){expr.walk(tw);push(tw,true,true);node.property.walk(tw);pop(tw);}else {descend();while(expr instanceof AST_Assign&&expr.operator=="="){var lhs=expr.left;if(lhs instanceof AST_SymbolRef)access(tw,lhs.definition());expr=expr.right;}if(expr instanceof AST_SymbolRef)access(tw,expr.definition());}return true;});def(AST_Switch,function(tw,descend,compressor){var node=this;reset_block_variables(tw,compressor,node);node.expression.walk(tw);var first=true;node.body.forEach(function(branch){if(branch instanceof AST_Default)return;branch.expression.walk(tw);if(first){first=false;push(tw,true,true);}});if(!first)pop(tw);walk_body(node,tw);return true;});def(AST_SwitchBranch,function(tw){push(tw,true,true);walk_body(this,tw);pop(tw);return true;});def(AST_SymbolCatch,function(){var d=this.definition();if(!d.first_decl&&d.references.length==0)d.first_decl=this;d.fixed=false;});def(AST_SymbolDeclaration,function(){var d=this.definition();if(!d.first_decl&&d.references.length==0)d.first_decl=this;});def(AST_SymbolDefun,function(){var d=this.definition();if(!d.first_decl&&d.references.length==0)d.first_decl=this;if(d.orig.length>1&&d.scope.resolve()!==this.scope)d.fixed=false;});def(AST_SymbolImport,function(){var d=this.definition();d.first_decl=this;d.fixed=false;});def(AST_SymbolRef,function(tw,descend,compressor){var ref=this;var d=ref.definition();var fixed=d.fixed||d.last_ref&&d.last_ref.fixed;push_ref(d,ref);if(safe_to_access(tw,d))ref.defined=true;if(d.references.length==1&&!d.fixed&&d.orig[0]instanceof AST_SymbolDefun){tw.loop_ids[d.id]=tw.in_loop;}var recursive=recursive_ref(tw,d);if(recursive)recursive.enclosed.forEach(function(def){if(d===def)return;if(def.scope.resolve()===recursive)return;var assigns=def.fixed&&def.fixed.assigns;if(!assigns)return;if(assigns[assigns.length-1]instanceof AST_VarDef)return;var safe=tw.safe_ids[def.id];if(!safe)return;safe.assign=true;});if(d.single_use=="m"&&d.fixed){d.fixed=0;d.single_use=false;}switch(d.fixed){case 0:if(!safe_to_read(tw,d))d.fixed=false;case false:var redef=d.redefined();if(redef&&cross_scope(d.scope,ref.scope))redef.single_use=false;break;case undefined:d.fixed=false;break;default:if(!safe_to_read(tw,d)){d.fixed=false;break;}if(ref.in_arg&&d.orig[0]instanceof AST_SymbolLambda)ref.fixed=d.scope;var value=ref.fixed_value();if(recursive){d.recursive_refs++;}else if(value&&ref_once(compressor,d)){d.in_loop=tw.loop_ids[d.id]!==tw.in_loop;d.single_use=is_lambda(value)&&!value.pinned()&&(!d.in_loop||tw.parent()instanceof AST_Call)||!d.in_loop&&d.scope===ref.scope.resolve()&&value.is_constant_expression();}else {d.single_use=false;}if(is_modified(compressor,tw,ref,value,0,is_immutable(value),recursive)){if(d.single_use){d.single_use="m";}else {d.fixed=0;}}if(d.fixed&&tw.loop_ids[d.id]!==tw.in_loop)d.cross_loop=true;mark_escaped(tw,d,ref.scope,ref,value,0,1);break;}if(!ref.fixed)ref.fixed=d.fixed===0?fixed:d.fixed;if(!value&&fixed)value=fixed instanceof AST_Node?fixed:fixed();if(!(value instanceof AST_Lambda))return;if(d.fixed){var parent=tw.parent();if(parent instanceof AST_Call&&parent.expression===ref)return;}mark_fn_def(tw,d,value);});def(AST_Template,function(tw){var node=this;var tag=node.tag;if(!tag)return;if(tag instanceof AST_LambdaExpression){node.expressions.forEach(function(exp){exp.walk(tw);});tag.walk(tw);return true;}tag.walk(tw);node.expressions.forEach(function(exp){exp.walk(tw);});var fixed=tag instanceof AST_SymbolRef&&tag.fixed_value();if(fixed instanceof AST_Lambda){mark_fn_def(tw,tag.definition(),fixed);}else {tw.find_parent(AST_Scope).may_call_this();}return true;});def(AST_Toplevel,function(tw,descend,compressor){var node=this;node.globals.each(function(def){reset_def(tw,compressor,def);});push(tw,true);reset_variables(tw,compressor,node);descend();pop_scope(tw,node);return true;});def(AST_Try,function(tw,descend,compressor){var node=this;reset_block_variables(tw,compressor,node);push(tw,true);walk_body(node,tw);pop(tw);if(node.bcatch){push(tw,true,true);node.bcatch.walk(tw);pop(tw);}if(node.bfinally)node.bfinally.walk(tw);return true;});def(AST_Unary,function(tw){var node=this;if(!UNARY_POSTFIX[node.operator])return;var exp=node.expression;if(!(exp instanceof AST_SymbolRef)){mark_assignment_to_arguments(exp);return;}var d=exp.definition();d.assignments++;var fixed=d.fixed;if(safe_to_read(tw,d)&&!exp.in_arg&&safe_to_assign(tw,d)){push_ref(d,exp);mark(tw,d);if(d.single_use)d.single_use=false;d.fixed=function(){return make_node(AST_Binary,node,{operator:node.operator.slice(0,-1),left:make_node(AST_UnaryPrefix,node,{operator:"+",expression:make_ref(exp,fixed)}),right:make_node(AST_Number,node,{value:1})});};d.fixed.assigns=fixed&&fixed.assigns?fixed.assigns.slice():[];d.fixed.assigns.push(node);if(node instanceof AST_UnaryPrefix){exp.fixed=d.fixed;}else {exp.fixed=function(){return make_node(AST_UnaryPrefix,node,{operator:"+",expression:make_ref(exp,fixed)});};exp.fixed.assigns=fixed&&fixed.assigns;exp.fixed.to_prefix=replace_ref(function(node){return node.expression;},d.fixed);}}else {exp.walk(tw);d.fixed=false;}return true;});def(AST_VarDef,function(tw,descend,compressor){var node=this;var value=node.value;if(value instanceof AST_LambdaExpression&&node.name instanceof AST_SymbolDeclaration){walk_defn();value.parent_scope.resolve().fn_defs.push(value);value.safe_ids=null;var ld=node.name.definition();if(!ld.fixed)mark_fn_def(tw,ld,value);}else if(value){value.walk(tw);walk_defn();}else if(tw.parent()instanceof AST_Let){walk_defn();}else {node.name.walk(tw);}return true;function walk_defn(){scan_declaration(tw,compressor,node.name,function(){return node.value||make_node(AST_Undefined,node);},function(name,fixed){var d=name.definition();assign(tw,d);if(!d.first_decl&&d.references.length==0)d.first_decl=name;if(fixed&&safe_to_assign(tw,d,true)){mark(tw,d);tw.loop_ids[d.id]=tw.in_loop;d.fixed=fixed;d.fixed.assigns=[node];if(name instanceof AST_SymbolConst&&d.redefined()||!(can_drop_symbol(name)||is_safe_lexical(d))){d.single_use=false;}}else {d.fixed=false;}});}});def(AST_While,function(tw,descend){var save_loop=tw.in_loop;tw.in_loop=this;push(tw);descend();pop(tw);tw.in_loop=save_loop;return true;});})(function(node,func){node.DEFMETHOD("reduce_vars",func);});function reset_flags(node){node._squeezed=false;node._optimized=false;node.single_use=false;if(node instanceof AST_BlockScope)node._var_names=undefined;if(node instanceof AST_SymbolRef)node.fixed=undefined;}AST_Toplevel.DEFMETHOD("reset_opt_flags",function(compressor){var tw=new TreeWalker(compressor.option("reduce_vars")?function(node,descend){reset_flags(node);return node.reduce_vars(tw,descend,compressor);}:reset_flags);// Side-effect tracking on sequential property access
tw.assigned_ids=Object.create(null);tw.defined_ids=Object.create(null);tw.defined_ids.seq={};// Flow control for visiting lambda definitions
tw.fn_scanning=null;tw.fn_visited=[];// Record the loop body in which `AST_SymbolDeclaration` is first encountered
tw.in_loop=null;tw.loop_ids=Object.create(null);// Stack of look-up tables to keep track of whether a `SymbolDef` has been
// properly assigned before use:
// - `push()` & `pop()` when visiting conditional branches
// - backup & restore via `save_ids` when visiting out-of-order sections
tw.safe_ids=Object.create(null);tw.safe_ids.seq={};this.walk(tw);});AST_Symbol.DEFMETHOD("fixed_value",function(ref_only){var def=this.definition();var fixed=def.fixed;if(fixed){if(this.fixed)fixed=this.fixed;return (fixed instanceof AST_Node?fixed:fixed()).tail_node();}fixed=fixed===0&&this.fixed;if(!fixed)return fixed;var value=(fixed instanceof AST_Node?fixed:fixed()).tail_node();if(ref_only&&def.escaped.depth!=1&&is_object(value,true))return value;if(value.is_constant())return value;});AST_SymbolRef.DEFMETHOD("is_immutable",function(){var def=this.redef||this.definition();if(!(def.orig[0]instanceof AST_SymbolLambda))return false;if(def.orig.length==1)return true;if(!this.in_arg)return false;return !(def.orig[1]instanceof AST_SymbolFunarg);});AST_Node.DEFMETHOD("convert_symbol",noop);function convert_destructured(type,process){return this.transform(new TreeTransformer(function(node,descend){if(node instanceof AST_DefaultValue){node=node.clone();node.name=node.name.transform(this);return node;}if(node instanceof AST_Destructured){node=node.clone();descend(node,this);return node;}if(node instanceof AST_DestructuredKeyVal){node=node.clone();node.value=node.value.transform(this);return node;}return node.convert_symbol(type,process);}));}AST_DefaultValue.DEFMETHOD("convert_symbol",convert_destructured);AST_Destructured.DEFMETHOD("convert_symbol",convert_destructured);function convert_symbol(type,process){var node=make_node(type,this);return process(node,this)||node;}AST_SymbolDeclaration.DEFMETHOD("convert_symbol",convert_symbol);AST_SymbolRef.DEFMETHOD("convert_symbol",convert_symbol);function process_to_assign(ref){var def=ref.definition();def.assignments++;def.references.push(ref);}function mark_destructured(process,tw){var marker=new TreeWalker(function(node){if(node instanceof AST_DefaultValue){node.value.walk(tw);node.name.walk(marker);return true;}if(node instanceof AST_DestructuredKeyVal){if(node.key instanceof AST_Node)node.key.walk(tw);node.value.walk(marker);return true;}return process(node);});this.walk(marker);}AST_DefaultValue.DEFMETHOD("mark_symbol",mark_destructured);AST_Destructured.DEFMETHOD("mark_symbol",mark_destructured);function mark_symbol(process){return process(this);}AST_SymbolDeclaration.DEFMETHOD("mark_symbol",mark_symbol);AST_SymbolRef.DEFMETHOD("mark_symbol",mark_symbol);AST_Node.DEFMETHOD("match_symbol",function(predicate){return predicate(this);});function match_destructured(predicate,ignore_side_effects){var found=false;var tw=new TreeWalker(function(node){if(found)return true;if(node instanceof AST_DefaultValue){if(!ignore_side_effects)return found=true;node.name.walk(tw);return true;}if(node instanceof AST_DestructuredKeyVal){if(!ignore_side_effects&&node.key instanceof AST_Node)return found=true;node.value.walk(tw);return true;}if(predicate(node))return found=true;});this.walk(tw);return found;}AST_DefaultValue.DEFMETHOD("match_symbol",match_destructured);AST_Destructured.DEFMETHOD("match_symbol",match_destructured);function in_async_generator(scope){return scope instanceof AST_AsyncGeneratorDefun||scope instanceof AST_AsyncGeneratorFunction;}function find_scope(compressor){var level=0,node=compressor.self();do{if(node.variables)return node;}while(node=compressor.parent(level++));}function find_try(compressor,level,node,scope,may_throw,sync){for(var parent;parent=compressor.parent(level++);node=parent){if(parent===scope)return false;if(sync&&parent instanceof AST_Lambda){if(parent.name||is_async(parent)||is_generator(parent))return true;}else if(parent instanceof AST_Try){if(parent.bfinally&&parent.bfinally!==node)return true;if(may_throw&&parent.bcatch&&parent.bcatch!==node)return true;}}return false;}var identifier_atom=makePredicate("Infinity NaN undefined");function is_lhs_read_only(lhs,compressor){if(lhs instanceof AST_Assign){if(lhs.operator!="=")return true;if(lhs.right.tail_node().is_constant())return true;return is_lhs_read_only(lhs.left,compressor);}if(lhs instanceof AST_Atom)return true;if(lhs instanceof AST_ObjectIdentity)return true;if(lhs instanceof AST_PropAccess){if(lhs.property==="__proto__")return true;lhs=lhs.expression;if(lhs instanceof AST_SymbolRef){if(lhs.is_immutable())return false;lhs=lhs.fixed_value();}if(!lhs)return true;if(lhs.tail_node().is_constant())return true;return is_lhs_read_only(lhs,compressor);}if(lhs instanceof AST_SymbolRef){if(lhs.is_immutable())return true;var def=lhs.definition();return compressor.exposed(def)&&identifier_atom[def.name];}return false;}function make_node(ctor,orig,props){if(props){props.start=orig.start;props.end=orig.end;}else {props=orig;}return new ctor(props);}function make_sequence(orig,expressions){if(expressions.length==1)return expressions[0];return make_node(AST_Sequence,orig,{expressions:expressions.reduce(merge_sequence,[])});}function make_node_from_constant(val,orig){switch(typeof val){case"string":return make_node(AST_String,orig,{value:val});case"number":if(isNaN(val))return make_node(AST_NaN,orig);if(isFinite(val)){return 1/val<0?make_node(AST_UnaryPrefix,orig,{operator:"-",expression:make_node(AST_Number,orig,{value:-val})}):make_node(AST_Number,orig,{value:val});}return val<0?make_node(AST_UnaryPrefix,orig,{operator:"-",expression:make_node(AST_Infinity,orig)}):make_node(AST_Infinity,orig);case"boolean":return make_node(val?AST_True:AST_False,orig);case"undefined":return make_node(AST_Undefined,orig);default:if(val===null){return make_node(AST_Null,orig);}if(val instanceof RegExp){return make_node(AST_RegExp,orig,{value:val});}throw new Error(string_template("Can't handle constant of type: {type}",{type:typeof val}));}}function needs_unbinding(val){return val instanceof AST_PropAccess||is_undeclared_ref(val)&&val.name=="eval";}// we shouldn't compress (1,func)(something) to
// func(something) because that changes the meaning of
// the func (becomes lexical instead of global).
function maintain_this_binding(parent,orig,val){var wrap=false;if(parent.TYPE=="Call"){wrap=parent.expression===orig&&needs_unbinding(val);}else if(parent instanceof AST_Template){wrap=parent.tag===orig&&needs_unbinding(val);}else if(parent instanceof AST_UnaryPrefix){wrap=parent.operator=="delete"||parent.operator=="typeof"&&is_undeclared_ref(val);}return wrap?make_sequence(orig,[make_node(AST_Number,orig,{value:0}),val]):val;}function merge_expression(base,target){var fixed_by_id=new Dictionary();base.walk(new TreeWalker(function(node){if(!(node instanceof AST_SymbolRef))return;var def=node.definition();var fixed=node.fixed;if(!fixed||!fixed_by_id.has(def.id)){fixed_by_id.set(def.id,fixed);}else if(fixed_by_id.get(def.id)!==fixed){fixed_by_id.set(def.id,false);}}));if(fixed_by_id.size()>0)target.walk(new TreeWalker(function(node){if(!(node instanceof AST_SymbolRef))return;var def=node.definition();var fixed=node.fixed;if(!fixed||!fixed_by_id.has(def.id))return;if(fixed_by_id.get(def.id)!==fixed)node.fixed=false;}));return target;}function merge_sequence(array,node){if(node instanceof AST_Sequence){[].push.apply(array,node.expressions);}else {array.push(node);}return array;}function is_lexical_definition(stat){return stat instanceof AST_Const||stat instanceof AST_DefClass||stat instanceof AST_Let;}function safe_to_trim(stat){if(stat instanceof AST_LambdaDefinition){var def=stat.name.definition();var scope=stat.name.scope;if(def.orig.length>1&&def.scope.resolve()!==scope)return false;return def.scope===scope||all(def.references,function(ref){var s=ref.scope;do{if(s===scope)return true;}while(s=s.parent_scope);});}return !is_lexical_definition(stat);}function as_statement_array(thing){if(thing===null)return [];if(thing instanceof AST_BlockStatement)return all(thing.body,safe_to_trim)?thing.body:[thing];if(thing instanceof AST_EmptyStatement)return [];if(is_statement(thing))return [thing];throw new Error("Can't convert thing to statement array");}function is_empty(thing){if(thing===null)return true;if(thing instanceof AST_EmptyStatement)return true;if(thing instanceof AST_BlockStatement)return thing.body.length==0;return false;}function has_declarations_only(block){return all(block.body,function(stat){return is_empty(stat)||stat instanceof AST_Defun||stat instanceof AST_Var&&declarations_only(stat);});}function loop_body(x){if(x instanceof AST_IterationStatement){return x.body instanceof AST_BlockStatement?x.body:x;}return x;}function is_iife_call(node){if(node.TYPE!="Call")return false;do{node=node.expression;}while(node instanceof AST_PropAccess);return node instanceof AST_LambdaExpression?!is_arrow(node):is_iife_call(node);}function is_iife_single(call){var exp=call.expression;if(exp.name)return false;if(!(call instanceof AST_New))return true;var found=false;exp.walk(new TreeWalker(function(node){if(found)return true;if(node instanceof AST_NewTarget)return found=true;if(node instanceof AST_Scope&&node!==exp)return true;}));return !found;}function is_undeclared_ref(node){return node instanceof AST_SymbolRef&&node.definition().undeclared;}var global_names=makePredicate("Array Boolean clearInterval clearTimeout console Date decodeURI decodeURIComponent encodeURI encodeURIComponent Error escape eval EvalError Function isFinite isNaN JSON Map Math Number parseFloat parseInt RangeError ReferenceError RegExp Object Set setInterval setTimeout String SyntaxError TypeError unescape URIError WeakMap WeakSet");AST_SymbolRef.DEFMETHOD("is_declared",function(compressor){return this.defined||!this.definition().undeclared||compressor.option("unsafe")&&global_names[this.name];});function is_static_field_or_init(prop){return prop.static&&prop.value&&(prop instanceof AST_ClassField||prop instanceof AST_ClassInit);}function declarations_only(node){return all(node.definitions,function(var_def){return !var_def.value;});}function is_declaration(stat,lexical){if(stat instanceof AST_DefClass)return lexical&&!stat.extends&&all(stat.properties,function(prop){if(prop.key instanceof AST_Node)return false;return !is_static_field_or_init(prop);});if(stat instanceof AST_Definitions)return (lexical||stat instanceof AST_Var)&&declarations_only(stat);if(stat instanceof AST_ExportDeclaration)return is_declaration(stat.body,lexical);if(stat instanceof AST_ExportDefault)return is_declaration(stat.body,lexical);return stat instanceof AST_LambdaDefinition;}function is_last_statement(body,stat){var index=body.lastIndexOf(stat);if(index<0)return false;while(++index<body.length){if(!is_declaration(body[index],true))return false;}return true;}// Certain combination of unused name + side effect leads to invalid AST:
//    https://github.com/mishoo/UglifyJS/issues/44
//    https://github.com/mishoo/UglifyJS/issues/1838
//    https://github.com/mishoo/UglifyJS/issues/3371
// We fix it at this stage by moving the `var` outside the `for`.
function patch_for_init(node,in_list){var block;if(node.init instanceof AST_BlockStatement){block=node.init;node.init=block.body.pop();block.body.push(node);}if(node.init instanceof AST_Defun){if(!block)block=make_node(AST_BlockStatement,node,{body:[node]});block.body.splice(-1,0,node.init);node.init=null;}else if(node.init instanceof AST_SimpleStatement){node.init=node.init.body;}else if(is_empty(node.init)){node.init=null;}if(!block)return;return in_list?List.splice(block.body):block;}function tighten_body(statements,compressor){var in_lambda=last_of(compressor,function(node){return node instanceof AST_Lambda;});var block_scope,iife_in_try,in_iife_single,in_loop,in_try,scope;find_loop_scope_try();var changed,last_changed,max_iter=10;do{last_changed=changed;changed=0;if(eliminate_spurious_blocks(statements))changed=1;if(!changed&&last_changed==1)break;if(compressor.option("dead_code")){if(eliminate_dead_code(statements,compressor))changed=2;if(!changed&&last_changed==2)break;}if(compressor.option("if_return")){if(handle_if_return(statements,compressor))changed=3;if(!changed&&last_changed==3)break;}if(compressor.option("awaits")&&compressor.option("side_effects")){if(trim_awaits(statements,compressor))changed=4;if(!changed&&last_changed==4)break;}if(compressor.option("inline")>=4){if(inline_iife(statements,compressor))changed=5;if(!changed&&last_changed==5)break;}if(compressor.sequences_limit>0){if(sequencesize(statements,compressor))changed=6;if(!changed&&last_changed==6)break;if(sequencesize_2(statements,compressor))changed=7;if(!changed&&last_changed==7)break;}if(compressor.option("join_vars")){if(join_consecutive_vars(statements))changed=8;if(!changed&&last_changed==8)break;}if(compressor.option("collapse_vars")){if(collapse(statements,compressor))changed=9;}}while(changed&&max_iter-->0);return statements;function last_of(compressor,predicate){var block=compressor.self(),level=0,stat;do{if(block instanceof AST_Catch){block=compressor.parent(level++);}else if(block instanceof AST_LabeledStatement){block=block.body;}else if(block instanceof AST_SwitchBranch){var branches=compressor.parent(level);if(branches.body[branches.body.length-1]===block||has_break(block.body)){level++;block=branches;}}do{stat=block;if(predicate(stat))return stat;block=compressor.parent(level++);}while(block instanceof AST_If);}while(stat&&(block instanceof AST_BlockStatement||block instanceof AST_Catch||block instanceof AST_Scope||block instanceof AST_SwitchBranch||block instanceof AST_Try)&&is_last_statement(block.body,stat));function has_break(stats){for(var i=stats.length;--i>=0;){if(stats[i]instanceof AST_Break)return true;}return false;}}function find_loop_scope_try(){var node=compressor.self(),level=0;do{if(!block_scope&&node.variables)block_scope=node;if(node instanceof AST_Catch){if(compressor.parent(level).bfinally){if(!in_try)in_try={};in_try.bfinally=true;}level++;}else if(node instanceof AST_Finally){level++;}else if(node instanceof AST_IterationStatement){in_loop=true;}else if(node instanceof AST_Scope){scope=node;break;}else if(node instanceof AST_Try){if(!in_try)in_try={};if(node.bcatch)in_try.bcatch=true;if(node.bfinally)in_try.bfinally=true;}}while(node=compressor.parent(level++));}// Search from right to left for assignment-like expressions:
// - `var a = x;`
// - `a = x;`
// - `++a`
// For each candidate, scan from left to right for first usage, then try
// to fold assignment into the site for compression.
// Will not attempt to collapse assignments into or past code blocks
// which are not sequentially executed, e.g. loops and conditionals.
function collapse(statements,compressor){if(scope.pinned())return;var args;var assignments=new Dictionary();var candidates=[];var changed=false;var declare_only=new Dictionary();var force_single;var stat_index=statements.length;var scanner=new TreeTransformer(function(node,descend){if(abort)return node;// Skip nodes before `candidate` as quickly as possible
if(!hit){if(node!==hit_stack[hit_index])return node;hit_index++;if(hit_index<hit_stack.length)return handle_custom_scan_order(node,scanner);hit=true;stop_after=(value_def?find_stop_value:find_stop)(node,0);if(stop_after===node)abort=true;return node;}var parent=scanner.parent();// Stop only if candidate is found within conditional branches
if(!stop_if_hit&&in_conditional(node,parent)){stop_if_hit=parent;}// Cascade compound assignments
if(compound&&scan_lhs&&can_replace&&!stop_if_hit&&node instanceof AST_Assign&&node.operator!="="&&node.left.equals(lhs)){replaced++;changed=true;AST_Node.info("Cascading {this} [{start}]",node);can_replace=false;lvalues=get_lvalues(lhs);node.right.transform(scanner);clear_write_only(candidate);var folded;if(abort){folded=candidate;}else {abort=true;folded=make_node(AST_Binary,candidate,{operator:compound,left:lhs.fixed&&lhs.definition().fixed?lhs.fixed.to_binary(candidate):lhs,right:rvalue});}return make_node(AST_Assign,node,{operator:"=",left:node.left,right:make_node(AST_Binary,node,{operator:node.operator.slice(0,-1),left:folded,right:node.right})});}// Stop immediately if these node types are encountered
if(should_stop(node,parent)){abort=true;return node;}// Skip transient nodes caused by single-use variable replacement
if(node.single_use)return node;// Replace variable with assignment when found
var hit_rhs;if(!(node instanceof AST_SymbolDeclaration)&&(scan_lhs&&lhs.equals(node)||scan_rhs&&(hit_rhs=scan_rhs(node,this)))){if(!can_replace||stop_if_hit&&(hit_rhs||!lhs_local||!replace_all)){if(!hit_rhs&&!value_def)abort=true;return node;}if(is_lhs(node,parent)){if(value_def&&!hit_rhs)assign_used=true;return node;}if(!hit_rhs&&verify_ref&&node.fixed!==lhs.fixed){abort=true;return node;}if(value_def){if(stop_if_hit&&assign_pos==0)assign_pos=remaining-replaced;if(!hit_rhs)replaced++;return node;}replaced++;changed=abort=true;AST_Node.info("Collapsing {this} [{start}]",node);if(candidate.TYPE=="Binary"){update_symbols(candidate,node);return make_node(AST_Assign,candidate,{operator:"=",left:candidate.right.left,right:candidate.operator=="&&"?make_node(AST_Conditional,candidate,{condition:candidate.left,consequent:candidate.right.right,alternative:node}):make_node(AST_Conditional,candidate,{condition:candidate.left,consequent:node,alternative:candidate.right.right})});}if(candidate instanceof AST_UnaryPostfix)return make_node(AST_UnaryPrefix,candidate,{operator:candidate.operator,expression:lhs.fixed&&lhs.definition().fixed?lhs.fixed.to_prefix(candidate):lhs});if(candidate instanceof AST_UnaryPrefix){clear_write_only(candidate);return candidate;}update_symbols(rvalue,node);if(candidate instanceof AST_VarDef){var def=candidate.name.definition();if(def.references.length-def.replaced==1&&!compressor.exposed(def)){def.replaced++;return maintain_this_binding(parent,node,rvalue);}return make_node(AST_Assign,candidate,{operator:"=",left:node,right:rvalue});}clear_write_only(rvalue);var assign=candidate.clone();assign.right=rvalue;return assign;}// Stop signals related to AST_SymbolRef
if(should_stop_ref(node,parent)){abort=true;return node;}// These node types have child nodes that execute sequentially,
// but are otherwise not safe to scan into or beyond them.
if(is_last_node(node,parent)||may_throw(node)){stop_after=node;if(node instanceof AST_Scope)abort=true;}// Scan but don't replace inside getter/setter
if(node instanceof AST_Accessor){var replace=can_replace;can_replace=false;descend(node,scanner);can_replace=replace;return signal_abort(node);}// Scan but don't replace inside destructuring expression
if(node instanceof AST_Destructured){var replace=can_replace;can_replace=false;descend(node,scanner);can_replace=replace;return signal_abort(node);}// Scan but don't replace inside default value
if(node instanceof AST_DefaultValue){node.name=node.name.transform(scanner);var replace=can_replace;can_replace=false;node.value=node.value.transform(scanner);can_replace=replace;return signal_abort(node);}// Scan but don't replace inside block scope with colliding variable
if(node instanceof AST_BlockScope&&!(node instanceof AST_Scope)&&!(node.variables&&node.variables.all(function(def){return !enclosed.has(def.name)&&!lvalues.has(def.name);}))){var replace=can_replace;can_replace=false;if(!handle_custom_scan_order(node,scanner))descend(node,scanner);can_replace=replace;return signal_abort(node);}if(handle_custom_scan_order(node,scanner))return signal_abort(node);},signal_abort);var multi_replacer=new TreeTransformer(function(node){if(abort)return node;// Skip nodes before `candidate` as quickly as possible
if(!hit){if(node!==hit_stack[hit_index])return node;hit_index++;switch(hit_stack.length-hit_index){case 0:hit=true;if(assign_used)return node;if(node!==candidate)return node;if(node instanceof AST_VarDef)return node;def.replaced++;var parent=multi_replacer.parent();if(parent instanceof AST_Sequence&&parent.tail_node()!==node){value_def.replaced++;if(rvalue===rhs_value)return List.skip;return make_sequence(rhs_value,rhs_value.expressions.slice(0,-1));}return rvalue;case 1:if(!assign_used&&node.body===candidate){hit=true;def.replaced++;value_def.replaced++;return null;}default:return handle_custom_scan_order(node,multi_replacer);}}// Replace variable when found
if(node instanceof AST_SymbolRef&&node.definition()===def){if(is_lhs(node,multi_replacer.parent()))return node;if(! --replaced)abort=true;AST_Node.info("Replacing {this} [{start}]",node);var ref=rvalue.clone();ref.scope=node.scope;ref.reference();if(replaced==assign_pos){abort=true;return make_node(AST_Assign,candidate,{operator:"=",left:node,right:ref});}def.replaced++;return ref;}// Skip (non-executed) functions and (leading) default case in switch statements
if(node instanceof AST_Default||node instanceof AST_Scope)return node;},function(node){return patch_sequence(node,multi_replacer);});while(--stat_index>=0){// Treat parameters as collapsible in IIFE, i.e.
//   function(a, b){ ... }(x());
// would be translated into equivalent assignments:
//   var a = x(), b = undefined;
if(stat_index==0&&compressor.option("unused"))extract_args();// Find collapsible assignments
var hit_stack=[];extract_candidates(statements[stat_index]);while(candidates.length>0){hit_stack=candidates.pop();var hit_index=0;var candidate=hit_stack[hit_stack.length-1];var assign_pos=-1;var assign_used=false;var verify_ref=false;var remaining;var value_def=null;var stop_after=null;var stop_if_hit=null;var lhs=get_lhs(candidate);var side_effects=lhs&&lhs.has_side_effects(compressor);var scan_lhs=lhs&&(!side_effects||lhs instanceof AST_SymbolRef)&&!is_lhs_read_only(lhs,compressor);var scan_rhs=foldable(candidate);if(!scan_lhs&&!scan_rhs)continue;var compound=candidate instanceof AST_Assign&&candidate.operator.slice(0,-1);var funarg=candidate.name instanceof AST_SymbolFunarg;var may_throw=return_false;if(candidate.may_throw(compressor)){if(funarg&&is_async(scope))continue;may_throw=in_try?function(node){return node.has_side_effects(compressor);}:side_effects_external;}var read_toplevel=false;var modify_toplevel=false;var defun_scopes=get_defun_scopes(lhs);// Locate symbols which may execute code outside of scanning range
var enclosed=new Dictionary();var well_defined=true;var lvalues=get_lvalues(candidate);var lhs_local=is_lhs_local(lhs);var rhs_value=get_rvalue(candidate);var rvalue=rhs_value;if(!side_effects){if(!compound&&rvalue instanceof AST_Sequence)rvalue=rvalue.tail_node();side_effects=value_has_side_effects();}var check_destructured=in_try||!lhs_local?function(node){return node instanceof AST_Destructured;}:return_false;var replace_all=replace_all_symbols(candidate);var hit=funarg;var abort=false;var replaced=0;var can_replace=!args||!hit;if(!can_replace){for(var j=candidate.arg_index+1;!abort&&j<args.length;j++){if(args[j])args[j].transform(scanner);}can_replace=true;}for(var i=stat_index;!abort&&i<statements.length;i++){statements[i].transform(scanner);}if(value_def){if(!replaced||remaining>replaced+assign_used){candidates.push(hit_stack);force_single=true;continue;}if(replaced==assign_pos)assign_used=true;var def=lhs.definition();abort=false;hit_index=0;hit=funarg;for(var i=stat_index;!abort&&i<statements.length;i++){if(!statements[i].transform(multi_replacer))statements.splice(i--,1);}replaced=candidate instanceof AST_VarDef&&candidate===hit_stack[hit_stack.length-1]&&def.references.length==def.replaced&&!compressor.exposed(def);value_def.last_ref=false;value_def.single_use=false;changed=true;}if(replaced)remove_candidate(candidate);}}return changed;function signal_abort(node){if(abort)return node;if(stop_after===node)abort=true;if(stop_if_hit===node)stop_if_hit=null;return node;}function handle_custom_scan_order(node,tt){if(!(node instanceof AST_BlockScope))return;// Skip (non-executed) functions
if(node instanceof AST_Scope)return node;// Scan computed keys, static fields & initializers in class
if(node instanceof AST_Class){var replace=can_replace;can_replace=false;if(node.name)node.name.transform(tt);if(!abort&&node.extends)node.extends.transform(tt);var fields=[],stats=[];for(var i=0;!abort&&i<node.properties.length;i++){var prop=node.properties[i];if(prop.key instanceof AST_Node)prop.key=prop.key.transform(tt);if(!prop.static)continue;if(prop instanceof AST_ClassField){if(prop.value)fields.push(prop);}else if(prop instanceof AST_ClassInit){[].push.apply(stats,prop.value.body);}}for(var i=0;!abort&&i<stats.length;i++){stats[i].transform(tt);}for(var i=0;!abort&&i<fields.length;i++){fields[i].value.transform(tt);}can_replace=replace;return node;}// Scan object only in a for-in/of statement
if(node instanceof AST_ForEnumeration){node.object=node.object.transform(tt);abort=true;return node;}// Scan first case expression only in a switch statement
if(node instanceof AST_Switch){node.expression=node.expression.transform(tt);for(var i=0;!abort&&i<node.body.length;i++){var branch=node.body[i];if(branch instanceof AST_Case){if(!hit){if(branch!==hit_stack[hit_index])continue;hit_index++;}branch.expression=branch.expression.transform(tt);if(!replace_all||verify_ref)break;scan_rhs=false;}}abort=true;return node;}}function is_direct_assignment(node,parent){if(parent instanceof AST_Assign)return parent.operator=="="&&parent.left===node;if(parent instanceof AST_DefaultValue)return parent.name===node;if(parent instanceof AST_DestructuredArray)return true;if(parent instanceof AST_DestructuredKeyVal)return parent.value===node;}function should_stop(node,parent){if(node===rvalue)return true;if(parent instanceof AST_For){if(node!==parent.init)return true;}if(node instanceof AST_Assign)return node.operator!="="&&lhs.equals(node.left);if(node instanceof AST_BlockStatement){return defun_scopes&&!all(defun_scopes,function(scope){return node!==scope;});}if(node instanceof AST_Call){if(!(lhs instanceof AST_PropAccess))return false;if(!lhs.equals(node.expression))return false;return !(rvalue instanceof AST_LambdaExpression&&!rvalue.contains_this());}if(node instanceof AST_Class)return !compressor.has_directive("use strict");if(node instanceof AST_Debugger)return true;if(node instanceof AST_Defun)return funarg&&lhs.name===node.name.name;if(node instanceof AST_DestructuredKeyVal)return node.key instanceof AST_Node;if(node instanceof AST_DWLoop)return true;if(node instanceof AST_LoopControl)return true;if(node instanceof AST_Try)return true;if(node instanceof AST_With)return true;return false;}function should_stop_ref(node,parent){if(!(node instanceof AST_SymbolRef))return false;if(node.is_declared(compressor)){if(node.fixed_value())return false;if(can_drop_symbol(node)){return !(parent instanceof AST_PropAccess&&parent.expression===node)&&is_arguments(node.definition());}}else if(is_direct_assignment(node,parent)){return false;}if(!replace_all)return true;scan_rhs=false;return false;}function in_conditional(node,parent){if(parent instanceof AST_Assign)return parent.left!==node&&lazy_op[parent.operator.slice(0,-1)];if(parent instanceof AST_Binary)return parent.left!==node&&lazy_op[parent.operator];if(parent instanceof AST_Call)return parent.optional&&parent.expression!==node;if(parent instanceof AST_Case)return parent.expression!==node;if(parent instanceof AST_Conditional)return parent.condition!==node;if(parent instanceof AST_If)return parent.condition!==node;if(parent instanceof AST_Sub)return parent.optional&&parent.expression!==node;}function is_last_node(node,parent){if(node instanceof AST_Await)return true;if(node.TYPE=="Binary")return !can_drop_op(node,compressor);if(node instanceof AST_Call){var def,fn=node.expression;if(fn instanceof AST_SymbolRef){def=fn.definition();fn=fn.fixed_value();}if(!(fn instanceof AST_Lambda))return !node.is_expr_pure(compressor);if(def&&recursive_ref(compressor,def,fn))return true;if(fn.collapse_scanning)return false;fn.collapse_scanning=true;var replace=can_replace;can_replace=false;var after=stop_after;var if_hit=stop_if_hit;for(var i=0;!abort&&i<fn.argnames.length;i++){if(arg_may_throw(reject,fn.argnames[i],node.args[i]))abort=true;}if(!abort){if(fn.rest&&arg_may_throw(reject,fn.rest,make_node(AST_Array,node,{elements:node.args.slice(i)}))){abort=true;}else if(is_arrow(fn)&&fn.value){fn.value.transform(scanner);}else for(var i=0;!abort&&i<fn.body.length;i++){var stat=fn.body[i];if(stat instanceof AST_Return){if(stat.value)stat.value.transform(scanner);break;}stat.transform(scanner);}}stop_if_hit=if_hit;stop_after=after;can_replace=replace;fn.collapse_scanning=false;if(!abort)return false;abort=false;return true;}if(node instanceof AST_Class){if(!in_try)return false;var base=node.extends;if(!base)return false;if(base instanceof AST_SymbolRef)base=base.fixed_value();return !safe_for_extends(base);}if(node instanceof AST_Exit){if(in_try){if(in_try.bfinally)return true;if(in_try.bcatch&&node instanceof AST_Throw)return true;}return side_effects||lhs instanceof AST_PropAccess||may_modify(lhs);}if(node instanceof AST_Function){return compressor.option("ie")&&node.name&&lvalues.has(node.name.name);}if(node instanceof AST_ObjectIdentity)return symbol_in_lvalues(node);if(node instanceof AST_PropAccess){var exp=node.expression;if(compressor.option("unsafe")){if(is_undeclared_ref(exp)&&global_names[exp.name])return false;if(is_static_fn(exp))return false;}if(exp instanceof AST_SymbolRef&&is_arguments(exp.definition()))return true;if(side_effects)return true;if(!well_defined)return true;if(value_def)return false;if(!in_try&&lhs_local)return false;if(node.optional)return false;return exp.may_throw_on_access(compressor);}if(node instanceof AST_Spread)return true;if(node instanceof AST_SymbolRef){var assign_direct=symbol_in_lvalues(node);if(is_undeclared_ref(node)&&node.is_declared(compressor))return false;if(assign_direct)return !is_direct_assignment(node,parent);if(side_effects&&may_modify(node))return true;var def=node.definition();return (in_try||def.scope.resolve()!==scope)&&!can_drop_symbol(node);}if(node instanceof AST_Template)return !node.is_expr_pure(compressor);if(node instanceof AST_VarDef){if(check_destructured(node.name))return true;return (node.value||parent instanceof AST_Let)&&node.name.match_symbol(function(node){return node instanceof AST_SymbolDeclaration&&(lvalues.has(node.name)||side_effects&&may_modify(node));},true);}if(node instanceof AST_Yield)return true;var sym=is_lhs(node.left,node);if(!sym)return false;if(sym instanceof AST_PropAccess)return true;if(check_destructured(sym))return true;return sym.match_symbol(function(node){if(node instanceof AST_PropAccess)return true;if(node instanceof AST_SymbolRef){return lvalues.has(node.name)||read_toplevel&&compressor.exposed(node.definition());}},true);function reject(node){node.transform(scanner);return abort;}}function arg_may_throw(reject,node,value){if(node instanceof AST_DefaultValue){return reject(node.value)||arg_may_throw(reject,node.name,node.value)||!is_undefined(value)&&arg_may_throw(reject,node.name,value);}if(!value)return !(node instanceof AST_Symbol);if(node instanceof AST_Destructured){if(node.rest&&arg_may_throw(reject,node.rest))return true;if(node instanceof AST_DestructuredArray){if(value instanceof AST_Array)return !all(node.elements,function(element,index){return !arg_may_throw(reject,element,value[index]);});if(!value.is_string(compressor))return true;return !all(node.elements,function(element){return !arg_may_throw(reject,element);});}if(node instanceof AST_DestructuredObject){if(value.may_throw_on_access(compressor))return true;return !all(node.properties,function(prop){if(prop.key instanceof AST_Node&&reject(prop.key))return false;return !arg_may_throw(reject,prop.value);});}}}function extract_args(){if(in_iife_single===false)return;var iife=compressor.parent(),fn=compressor.self();if(in_iife_single===undefined){if(!(fn instanceof AST_LambdaExpression)||is_generator(fn)||fn.uses_arguments||fn.pinned()||!(iife instanceof AST_Call)||iife.expression!==fn||!all(iife.args,function(arg){return !(arg instanceof AST_Spread);})){in_iife_single=false;return;}if(!is_iife_single(iife))return;in_iife_single=true;}var fn_strict=fn.in_strict_mode(compressor)&&!fn.parent_scope.resolve(true).in_strict_mode(compressor);var has_await;if(is_async(fn)){has_await=function(node){return node instanceof AST_Symbol&&node.name=="await";};iife_in_try=true;}else {has_await=function(node){return node instanceof AST_Await&&!tw.find_parent(AST_Scope);};if(iife_in_try===undefined)iife_in_try=find_try(compressor,1,iife,null,true,true);}var arg_scope=null;var tw=new TreeWalker(function(node,descend){if(!arg)return true;if(has_await(node)||node instanceof AST_Yield){arg=null;return true;}if(node instanceof AST_ObjectIdentity){if(fn_strict||!arg_scope)arg=null;return true;}if(node instanceof AST_SymbolRef){var def;if(node.in_arg&&!is_safe_lexical(node.definition())||(def=fn.variables.get(node.name))&&def!==node.definition()){arg=null;}return true;}if(node instanceof AST_Scope&&!is_arrow(node)){var save_scope=arg_scope;arg_scope=node;descend();arg_scope=save_scope;return true;}});args=iife.args.slice();var len=args.length;var names=new Dictionary();for(var i=fn.argnames.length;--i>=0;){var sym=fn.argnames[i];var arg=args[i];var value=null;if(sym instanceof AST_DefaultValue){value=sym.value;sym=sym.name;args[len+i]=value;}if(sym instanceof AST_Destructured){if(iife_in_try&&arg_may_throw(function(node){return node.has_side_effects(compressor);},sym,arg)){candidates.length=0;break;}args[len+i]=fn.argnames[i];continue;}if(names.has(sym.name))continue;names.set(sym.name,true);if(value)arg=is_undefined(arg)?value:null;if(!arg&&!value){arg=make_node(AST_Undefined,sym).transform(compressor);}else if(arg instanceof AST_Lambda&&arg.pinned()){arg=null;}else if(arg){arg.walk(tw);}if(!arg)continue;var candidate=make_node(AST_VarDef,sym,{name:sym,value:arg});candidate.name_index=i;candidate.arg_index=value?len+i:i;candidates.unshift([candidate]);}if(fn.rest)args.push(fn.rest);}function extract_candidates(expr,unused){hit_stack.push(expr);if(expr instanceof AST_Array){expr.elements.forEach(function(node){extract_candidates(node,unused);});}else if(expr instanceof AST_Assign){var lhs=expr.left;if(!(lhs instanceof AST_Destructured))candidates.push(hit_stack.slice());extract_candidates(lhs);extract_candidates(expr.right);if(lhs instanceof AST_SymbolRef&&expr.operator=="="){assignments.set(lhs.name,(assignments.get(lhs.name)||0)+1);}}else if(expr instanceof AST_Await){extract_candidates(expr.expression,unused);}else if(expr instanceof AST_Binary){var lazy=lazy_op[expr.operator];if(unused&&lazy&&expr.operator!="??"&&expr.right instanceof AST_Assign&&expr.right.operator=="="&&!(expr.right.left instanceof AST_Destructured)){candidates.push(hit_stack.slice());}extract_candidates(expr.left,!lazy&&unused);extract_candidates(expr.right,unused);}else if(expr instanceof AST_Call){extract_candidates(expr.expression);expr.args.forEach(extract_candidates);}else if(expr instanceof AST_Case){extract_candidates(expr.expression);}else if(expr instanceof AST_Conditional){extract_candidates(expr.condition);extract_candidates(expr.consequent,unused);extract_candidates(expr.alternative,unused);}else if(expr instanceof AST_Definitions){expr.definitions.forEach(extract_candidates);}else if(expr instanceof AST_Dot){extract_candidates(expr.expression);}else if(expr instanceof AST_DWLoop){extract_candidates(expr.condition);if(!(expr.body instanceof AST_Block)){extract_candidates(expr.body);}}else if(expr instanceof AST_Exit){if(expr.value)extract_candidates(expr.value);}else if(expr instanceof AST_For){if(expr.init)extract_candidates(expr.init,true);if(expr.condition)extract_candidates(expr.condition);if(expr.step)extract_candidates(expr.step,true);if(!(expr.body instanceof AST_Block)){extract_candidates(expr.body);}}else if(expr instanceof AST_ForEnumeration){extract_candidates(expr.object);if(!(expr.body instanceof AST_Block)){extract_candidates(expr.body);}}else if(expr instanceof AST_If){extract_candidates(expr.condition);if(!(expr.body instanceof AST_Block)){extract_candidates(expr.body);}if(expr.alternative&&!(expr.alternative instanceof AST_Block)){extract_candidates(expr.alternative);}}else if(expr instanceof AST_Object){expr.properties.forEach(function(prop){hit_stack.push(prop);if(prop.key instanceof AST_Node)extract_candidates(prop.key);if(prop instanceof AST_ObjectKeyVal)extract_candidates(prop.value,unused);hit_stack.pop();});}else if(expr instanceof AST_Sequence){var end=expr.expressions.length-(unused?0:1);expr.expressions.forEach(function(node,index){extract_candidates(node,index<end);});}else if(expr instanceof AST_SimpleStatement){extract_candidates(expr.body,true);}else if(expr instanceof AST_Spread){extract_candidates(expr.expression);}else if(expr instanceof AST_Sub){extract_candidates(expr.expression);extract_candidates(expr.property);}else if(expr instanceof AST_Switch){extract_candidates(expr.expression);expr.body.forEach(extract_candidates);}else if(expr instanceof AST_Unary){if(UNARY_POSTFIX[expr.operator]){candidates.push(hit_stack.slice());}else {extract_candidates(expr.expression);}}else if(expr instanceof AST_VarDef){if(expr.name instanceof AST_SymbolVar){if(expr.value){var def=expr.name.definition();if(def.references.length>def.replaced){candidates.push(hit_stack.slice());}}else {declare_only.set(expr.name.name,(declare_only.get(expr.name.name)||0)+1);}}if(expr.value)extract_candidates(expr.value);}else if(expr instanceof AST_Yield){if(expr.expression)extract_candidates(expr.expression);}hit_stack.pop();}function find_stop(node,level){var parent=scanner.parent(level);if(parent instanceof AST_Array)return node;if(parent instanceof AST_Assign)return node;if(parent instanceof AST_Await)return node;if(parent instanceof AST_Binary)return node;if(parent instanceof AST_Call)return node;if(parent instanceof AST_Case)return node;if(parent instanceof AST_Conditional)return node;if(parent instanceof AST_Definitions)return find_stop_unused(parent,level+1);if(parent instanceof AST_Exit)return node;if(parent instanceof AST_If)return node;if(parent instanceof AST_IterationStatement)return node;if(parent instanceof AST_ObjectProperty)return node;if(parent instanceof AST_PropAccess)return node;if(parent instanceof AST_Sequence){return (parent.tail_node()===node?find_stop:find_stop_unused)(parent,level+1);}if(parent instanceof AST_SimpleStatement)return find_stop_unused(parent,level+1);if(parent instanceof AST_Spread)return node;if(parent instanceof AST_Switch)return node;if(parent instanceof AST_Unary)return node;if(parent instanceof AST_VarDef)return node;if(parent instanceof AST_Yield)return node;return null;}function find_stop_logical(parent,op,level){var node;do{node=parent;parent=scanner.parent(++level);}while(parent instanceof AST_Assign&&parent.operator.slice(0,-1)==op||parent instanceof AST_Binary&&parent.operator==op);return node;}function find_stop_expr(expr,cont,node,parent,level){var replace=can_replace;can_replace=false;var after=stop_after;var if_hit=stop_if_hit;var stack=scanner.stack;scanner.stack=[parent];expr.transform(scanner);scanner.stack=stack;stop_if_hit=if_hit;stop_after=after;can_replace=replace;if(abort){abort=false;return node;}return cont(parent,level+1);}function find_stop_value(node,level){var parent=scanner.parent(level);if(parent instanceof AST_Array)return find_stop_value(parent,level+1);if(parent instanceof AST_Assign){if(may_throw(parent))return node;if(parent.left.match_symbol(function(ref){return ref instanceof AST_SymbolRef&&(lhs.name==ref.name||value_def.name==ref.name);}))return node;var op;if(parent.left===node||!lazy_op[op=parent.operator.slice(0,-1)]){return find_stop_value(parent,level+1);}return find_stop_logical(parent,op,level);}if(parent instanceof AST_Await)return find_stop_value(parent,level+1);if(parent instanceof AST_Binary){var op;if(parent.left===node||!lazy_op[op=parent.operator]){return find_stop_value(parent,level+1);}return find_stop_logical(parent,op,level);}if(parent instanceof AST_Call)return parent;if(parent instanceof AST_Case){if(parent.expression!==node)return node;return find_stop_value(parent,level+1);}if(parent instanceof AST_Conditional){if(parent.condition!==node)return node;return find_stop_value(parent,level+1);}if(parent instanceof AST_Definitions)return find_stop_unused(parent,level+1);if(parent instanceof AST_Do)return node;if(parent instanceof AST_Exit)return find_stop_unused(parent,level+1);if(parent instanceof AST_For){if(parent.init!==node&&parent.condition!==node)return node;return find_stop_value(parent,level+1);}if(parent instanceof AST_ForEnumeration){if(parent.init!==node)return node;return find_stop_value(parent,level+1);}if(parent instanceof AST_If){if(parent.condition!==node)return node;return find_stop_value(parent,level+1);}if(parent instanceof AST_ObjectProperty){var obj=scanner.parent(level+1);return all(obj.properties,function(prop){return prop instanceof AST_ObjectKeyVal;})?find_stop_value(obj,level+2):obj;}if(parent instanceof AST_PropAccess){var exp=parent.expression;return exp===node?find_stop_value(parent,level+1):node;}if(parent instanceof AST_Sequence){return (parent.tail_node()===node?find_stop_value:find_stop_unused)(parent,level+1);}if(parent instanceof AST_SimpleStatement)return find_stop_unused(parent,level+1);if(parent instanceof AST_Spread)return find_stop_value(parent,level+1);if(parent instanceof AST_Switch){if(parent.expression!==node)return node;return find_stop_value(parent,level+1);}if(parent instanceof AST_Unary){if(parent.operator=="delete")return node;return find_stop_value(parent,level+1);}if(parent instanceof AST_VarDef)return parent.name.match_symbol(function(sym){return sym instanceof AST_SymbolDeclaration&&(lhs.name==sym.name||value_def.name==sym.name);})?node:find_stop_value(parent,level+1);if(parent instanceof AST_While){if(parent.condition!==node)return node;return find_stop_value(parent,level+1);}if(parent instanceof AST_Yield)return find_stop_value(parent,level+1);return null;}function find_stop_unused(node,level){var parent=scanner.parent(level);if(is_last_node(node,parent))return node;if(in_conditional(node,parent))return node;if(parent instanceof AST_Array)return find_stop_unused(parent,level+1);if(parent instanceof AST_Assign)return check_assignment(parent.left);if(parent instanceof AST_Await)return node;if(parent instanceof AST_Binary)return find_stop_unused(parent,level+1);if(parent instanceof AST_Call)return find_stop_unused(parent,level+1);if(parent instanceof AST_Case)return find_stop_unused(parent,level+1);if(parent instanceof AST_Conditional)return find_stop_unused(parent,level+1);if(parent instanceof AST_Definitions)return find_stop_unused(parent,level+1);if(parent instanceof AST_Exit)return find_stop_unused(parent,level+1);if(parent instanceof AST_If)return find_stop_unused(parent,level+1);if(parent instanceof AST_IterationStatement)return node;if(parent instanceof AST_ObjectProperty){var obj=scanner.parent(level+1);return all(obj.properties,function(prop){return prop instanceof AST_ObjectKeyVal;})?find_stop_unused(obj,level+2):obj;}if(parent instanceof AST_PropAccess){var exp=parent.expression;if(exp===node)return find_stop_unused(parent,level+1);return find_stop_expr(exp,find_stop_unused,node,parent,level);}if(parent instanceof AST_Sequence)return find_stop_unused(parent,level+1);if(parent instanceof AST_SimpleStatement)return find_stop_unused(parent,level+1);if(parent instanceof AST_Spread)return node;if(parent instanceof AST_Switch)return find_stop_unused(parent,level+1);if(parent instanceof AST_Unary)return find_stop_unused(parent,level+1);if(parent instanceof AST_VarDef)return check_assignment(parent.name);if(parent instanceof AST_Yield)return node;return null;function check_assignment(lhs){if(may_throw(parent))return node;if(lhs!==node&&lhs instanceof AST_Destructured){return find_stop_expr(lhs,find_stop_unused,node,parent,level);}return find_stop_unused(parent,level+1);}}function mangleable_var(rhs){if(force_single){force_single=false;return;}if(remaining<1)return;rhs=rhs.tail_node();var value=rhs instanceof AST_Assign&&rhs.operator=="="?rhs.left:rhs;if(!(value instanceof AST_SymbolRef))return;var def=value.definition();if(def.undeclared)return;if(is_arguments(def))return;if(value!==rhs){if(is_lhs_read_only(value,compressor))return;var referenced=def.references.length-def.replaced;if(referenced<2)return;var expr=candidate.clone();expr[expr instanceof AST_Assign?"right":"value"]=value;if(candidate.name_index>=0){expr.name_index=candidate.name_index;expr.arg_index=candidate.arg_index;}candidate=expr;}return value_def=def;}function remaining_refs(def){return def.references.length-def.replaced-(assignments.get(def.name)||0);}function get_lhs(expr){if(expr instanceof AST_Assign){var lhs=expr.left;if(!(lhs instanceof AST_SymbolRef))return lhs;var def=lhs.definition();if(scope.uses_arguments&&is_funarg(def))return lhs;if(compressor.exposed(def))return lhs;remaining=remaining_refs(def);if(def.fixed&&lhs.fixed){var matches=def.references.filter(function(ref){return ref.fixed===lhs.fixed;}).length-1;if(matches<remaining){remaining=matches;assign_pos=0;verify_ref=true;}}if(expr.operator=="=")mangleable_var(expr.right);return lhs;}if(expr instanceof AST_Binary)return expr.right.left;if(expr instanceof AST_Unary)return expr.expression;if(expr instanceof AST_VarDef){var lhs=expr.name;var def=lhs.definition();if(def.const_redefs)return;if(!member(lhs,def.orig))return;if(scope.uses_arguments&&is_funarg(def))return;var declared=def.orig.length-def.eliminated-(declare_only.get(def.name)||0);remaining=remaining_refs(def);if(def.fixed)remaining=Math.min(remaining,def.references.filter(function(ref){if(!ref.fixed)return true;if(!ref.fixed.assigns)return true;var assign=ref.fixed.assigns[0];return assign===lhs||get_rvalue(assign)===expr.value;}).length);if(declared>1&&!(lhs instanceof AST_SymbolFunarg)){mangleable_var(expr.value);return make_node(AST_SymbolRef,lhs);}if(mangleable_var(expr.value)||remaining==1&&!compressor.exposed(def)){return make_node(AST_SymbolRef,lhs);}return;}}function get_rvalue(expr){if(expr instanceof AST_Assign)return expr.right;if(expr instanceof AST_Binary){var node=expr.clone();node.right=expr.right.right;return node;}if(expr instanceof AST_VarDef)return expr.value;}function invariant(expr){if(expr instanceof AST_Array)return false;if(expr instanceof AST_Binary&&lazy_op[expr.operator]){return invariant(expr.left)&&invariant(expr.right);}if(expr instanceof AST_Call)return false;if(expr instanceof AST_Conditional){return invariant(expr.consequent)&&invariant(expr.alternative);}if(expr instanceof AST_Object)return false;return !expr.has_side_effects(compressor);}function foldable(expr){if(expr instanceof AST_Assign&&expr.right.single_use)return;var lhs_ids=Object.create(null);var marker=new TreeWalker(function(node){if(!(node instanceof AST_SymbolRef))return;for(var level=0,parent,child=node;parent=marker.parent(level++);child=parent){if(is_direct_assignment(child,parent)){if(parent instanceof AST_DestructuredKeyVal)parent=marker.parent(level++);continue;}lhs_ids[node.definition().id]=true;return;}lhs_ids[node.definition().id]="a";});while(expr instanceof AST_Assign&&expr.operator=="="){expr.left.walk(marker);expr=expr.right;}if(expr instanceof AST_ObjectIdentity)return rhs_exact_match;if(expr instanceof AST_SymbolRef){if(lhs_ids[expr.definition().id]==="a")return;var value=expr.evaluate(compressor);if(value===expr)return rhs_exact_match;return rhs_fuzzy_match(value,rhs_exact_match);}if(expr.is_truthy())return rhs_fuzzy_match(true,return_false);if(expr.is_constant()){var ev=expr.evaluate(compressor);if(!(ev instanceof AST_Node))return rhs_fuzzy_match(ev,rhs_exact_match);}if(!(lhs instanceof AST_SymbolRef))return false;if(!invariant(expr))return false;var circular;expr.walk(new TreeWalker(function(node){if(circular)return true;if(node instanceof AST_SymbolRef&&lhs_ids[node.definition().id])circular=true;}));return !circular&&rhs_exact_match;function rhs_exact_match(node){return expr.equals(node);}}function rhs_fuzzy_match(value,fallback){return function(node,tw){if(tw.in_boolean_context()){if(value&&node.is_truthy()&&!node.has_side_effects(compressor)){return true;}if(node.is_constant()){var ev=node.evaluate(compressor);if(!(ev instanceof AST_Node))return !ev==!value;}}return fallback(node);};}function clear_write_only(assign){while(assign.write_only){assign.write_only=false;if(!(assign instanceof AST_Assign))break;assign=assign.right;}}function update_symbols(value,node){var clear_defined=node instanceof AST_SymbolRef&&!node.defined;var scope=node.scope||find_scope(scanner)||block_scope;value.walk(new TreeWalker(function(node){if(node instanceof AST_BlockScope)return true;if(node instanceof AST_Symbol){if(clear_defined&&node instanceof AST_SymbolRef)node.defined=false;node.scope=scope;}}));}function may_be_global(node){if(node instanceof AST_SymbolRef){node=node.fixed_value();if(!node)return true;}if(node instanceof AST_Assign)return node.operator=="="&&may_be_global(node.right);return node instanceof AST_PropAccess||node instanceof AST_ObjectIdentity;}function get_lvalues(expr){var lvalues=new Dictionary();if(expr instanceof AST_VarDef){if(!expr.name.definition().fixed)well_defined=false;lvalues.add(expr.name.name,lhs);}var find_arguments=scope.uses_arguments&&!compressor.has_directive("use strict");var scan_toplevel=scope instanceof AST_Toplevel;var tw=new TreeWalker(function(node){if(node.inlined_node)node.inlined_node.walk(tw);var value;if(node instanceof AST_SymbolRef){value=node.fixed_value();if(!value){value=node;var def=node.definition();var escaped=node.fixed&&node.fixed.escaped||def.escaped;if(!def.undeclared&&(def.assignments||!escaped||escaped.cross_scope)&&(has_escaped(def,node.scope,node,tw.parent())||!same_scope(def))){well_defined=false;}}}else if(node instanceof AST_ObjectIdentity){value=node;}if(value){lvalues.add(node.name,is_modified(compressor,tw,node,value,0));}else if(node instanceof AST_Lambda){for(var level=0,parent,child=node;parent=tw.parent(level++);child=parent){if(parent instanceof AST_Assign){if(parent.left===child)break;if(parent.operator=="=")continue;if(lazy_op[parent.operator.slice(0,-1)])continue;break;}if(parent instanceof AST_Binary){if(lazy_op[parent.operator])continue;break;}if(parent instanceof AST_Call)return;if(parent instanceof AST_Scope)return;if(parent instanceof AST_Sequence){if(parent.tail_node()===child)continue;break;}if(parent instanceof AST_Template){if(parent.tag)return;break;}}node.enclosed.forEach(function(def){if(def.scope!==node)enclosed.set(def.name,true);});return true;}else if(find_arguments&&node instanceof AST_Sub){scope.each_argname(function(argname){if(!compressor.option("reduce_vars")||argname.definition().assignments){if(!argname.definition().fixed)well_defined=false;lvalues.add(argname.name,true);}});find_arguments=false;}if(!scan_toplevel)return;if(node.TYPE=="Call"){if(modify_toplevel)return;var exp=node.expression;if(exp instanceof AST_PropAccess)return;if(exp instanceof AST_LambdaExpression&&!exp.contains_this())return;modify_toplevel=true;}else if(node instanceof AST_PropAccess&&may_be_global(node.expression)){if(node===lhs&&!(expr instanceof AST_Unary)){modify_toplevel=true;}else {read_toplevel=true;}}});expr.walk(tw);return lvalues;}function remove_candidate(expr){var value=rvalue===rhs_value?null:make_sequence(rhs_value,rhs_value.expressions.slice(0,-1));var index=expr.name_index;if(index>=0){var args,argname=scope.argnames[index];if(argname instanceof AST_DefaultValue){scope.argnames[index]=argname=argname.clone();argname.value=value||make_node(AST_Number,argname,{value:0});}else if((args=compressor.parent().args)[index]){scope.argnames[index]=argname.clone();args[index]=value||make_node(AST_Number,args[index],{value:0});}return;}var end=hit_stack.length-1;var last=hit_stack[end];if(last instanceof AST_VarDef||hit_stack[end-1].body===last)end--;var tt=new TreeTransformer(function(node,descend,in_list){if(hit)return node;if(node!==hit_stack[hit_index])return node;hit_index++;if(hit_index<=end)return handle_custom_scan_order(node,tt);hit=true;if(node instanceof AST_Definitions){declare_only.set(last.name.name,(declare_only.get(last.name.name)||0)+1);if(value_def)value_def.replaced++;var defns=node.definitions;var index=defns.indexOf(last);var defn=last.clone();defn.value=null;if(!value){node.definitions[index]=defn;return node;}var body=[make_node(AST_SimpleStatement,value,{body:value})];if(index>0){var head=node.clone();head.definitions=defns.slice(0,index);body.unshift(head);node=node.clone();node.definitions=defns.slice(index);}body.push(node);node.definitions[0]=defn;return in_list?List.splice(body):make_node(AST_BlockStatement,node,{body:body});}if(!value)return in_list?List.skip:null;return is_statement(node)?make_node(AST_SimpleStatement,value,{body:value}):value;},function(node,in_list){if(node instanceof AST_For)return patch_for_init(node,in_list);return patch_sequence(node,tt);});abort=false;hit=false;hit_index=0;if(!(statements[stat_index]=statements[stat_index].transform(tt)))statements.splice(stat_index,1);}function patch_sequence(node,tt){if(node instanceof AST_Sequence)switch(node.expressions.length){case 0:return null;case 1:return maintain_this_binding(tt.parent(),node,node.expressions[0]);}}function get_defun_scopes(lhs){if(!(lhs instanceof AST_SymbolDeclaration||lhs instanceof AST_SymbolRef||lhs instanceof AST_Destructured))return;var scopes=[];lhs.mark_symbol(function(node){if(node instanceof AST_Symbol){var def=node.definition();var scope=def.scope.resolve();def.orig.forEach(function(sym){if(sym instanceof AST_SymbolDefun){if(sym.scope!==scope)push_uniq(scopes,sym.scope);}});}});if(scopes.length==0)return;return scopes;}function is_lhs_local(lhs){var sym=root_expr(lhs);if(!(sym instanceof AST_SymbolRef))return false;if(sym.definition().scope.resolve()!==scope)return false;if(!in_loop)return true;if(compound)return false;if(candidate instanceof AST_Unary)return false;var lvalue=lvalues.get(sym.name);return !lvalue||lvalue[0]===lhs;}function value_has_side_effects(){if(candidate instanceof AST_Unary)return false;return rvalue.has_side_effects(compressor);}function replace_all_symbols(expr){if(expr instanceof AST_Unary)return false;if(side_effects)return false;if(value_def)return true;if(!(lhs instanceof AST_SymbolRef))return false;var referenced;if(expr instanceof AST_VarDef){referenced=1;}else if(expr.operator=="="){referenced=2;}else {return false;}var def=lhs.definition();if(def.references.length-def.replaced==referenced)return true;if(!def.fixed)return false;if(!lhs.fixed)return false;var assigns=lhs.fixed.assigns;var matched=0;if(!all(def.references,function(ref,index){var fixed=ref.fixed;if(!fixed)return false;if(fixed.to_binary||fixed.to_prefix)return false;if(fixed===lhs.fixed){matched++;return true;}return assigns&&fixed.assigns&&assigns[0]!==fixed.assigns[0];}))return false;if(matched!=referenced)return false;verify_ref=true;return true;}function symbol_in_lvalues(sym){var lvalue=lvalues.get(sym.name);if(!lvalue||all(lvalue,function(lhs){return !lhs;}))return;if(lvalue[0]!==lhs)return true;scan_rhs=false;}function may_modify(sym){var def=sym.definition();if(def.orig.length==1&&def.orig[0]instanceof AST_SymbolDefun)return false;if(def.scope.resolve()!==scope)return true;if(modify_toplevel&&compressor.exposed(def))return true;return !all(def.references,function(ref){return ref.scope.resolve(true)===scope;});}function side_effects_external(node,lhs){if(node instanceof AST_Assign)return side_effects_external(node.left,true);if(node instanceof AST_Unary)return side_effects_external(node.expression,true);if(node instanceof AST_VarDef)return node.value&&side_effects_external(node.value);if(lhs){if(node instanceof AST_Dot)return side_effects_external(node.expression,true);if(node instanceof AST_Sub)return side_effects_external(node.expression,true);if(node instanceof AST_SymbolRef)return node.definition().scope.resolve()!==scope;}return false;}}function eliminate_spurious_blocks(statements){var changed=false,seen_dirs=[];for(var i=0;i<statements.length;){var stat=statements[i];if(stat instanceof AST_BlockStatement){if(all(stat.body,safe_to_trim)){changed=true;eliminate_spurious_blocks(stat.body);[].splice.apply(statements,[i,1].concat(stat.body));i+=stat.body.length;continue;}}if(stat instanceof AST_Directive){if(member(stat.value,seen_dirs)){changed=true;statements.splice(i,1);continue;}seen_dirs.push(stat.value);}if(stat instanceof AST_EmptyStatement){changed=true;statements.splice(i,1);continue;}i++;}return changed;}function handle_if_return(statements,compressor){var changed=false;var parent=compressor.parent();var self=compressor.self();var declare_only,jump,merge_jump;var in_iife=in_lambda&&parent&&parent.TYPE=="Call"&&parent.expression===self;var chain_if_returns=in_lambda&&compressor.option("conditionals")&&compressor.option("sequences");var drop_return_void=!(in_try&&in_try.bfinally&&in_async_generator(scope));var multiple_if_returns=has_multiple_if_returns(statements);for(var i=statements.length;--i>=0;){var stat=statements[i];var j=next_index(i);var next=statements[j];if(in_lambda&&declare_only&&!next&&stat instanceof AST_Return&&drop_return_void&&!(self instanceof AST_SwitchBranch)){var body=stat.value;if(!body){changed=true;statements.splice(i,1);continue;}var tail=body.tail_node();if(is_undefined(tail)){changed=true;if(body instanceof AST_UnaryPrefix){body=body.expression;}else if(tail instanceof AST_UnaryPrefix){body=body.clone();body.expressions[body.expressions.length-1]=tail.expression;}statements[i]=make_node(AST_SimpleStatement,stat,{body:body});continue;}}if(stat instanceof AST_If){var ab=aborts(stat.body);// if (foo()) { bar(); return; } else baz(); moo(); ---> if (foo()) bar(); else { baz(); moo(); }
if(can_merge_flow(ab)){if(ab.label)remove(ab.label.thedef.references,ab);changed=true;stat=stat.clone();stat.body=make_node(AST_BlockStatement,stat,{body:as_statement_array_with_return(stat.body,ab)});stat.alternative=make_node(AST_BlockStatement,stat,{body:as_statement_array(stat.alternative).concat(extract_functions(merge_jump,jump))});adjust_refs(ab.value,merge_jump);statements[i]=stat;statements[i]=stat.transform(compressor);continue;}// if (foo()) { bar(); return x; } return y; ---> if (!foo()) return y; bar(); return x;
if(ab&&!stat.alternative&&next instanceof AST_Jump){var cond=stat.condition;var preference=i+1==j&&stat.body instanceof AST_BlockStatement;cond=best_of_expression(cond,cond.negate(compressor),preference);if(cond!==stat.condition){changed=true;stat=stat.clone();stat.condition=cond;var body=stat.body;stat.body=make_node(AST_BlockStatement,next,{body:extract_functions(true,null,j+1)});statements.splice(i,1,stat,body);// proceed further only if `TreeWalker.stack` is in a consistent state
//    https://github.com/mishoo/UglifyJS/issues/5595
//    https://github.com/mishoo/UglifyJS/issues/5597
if(!in_lambda||self instanceof AST_Block&&self.body===statements){statements[i]=stat.transform(compressor);}continue;}}var alt=aborts(stat.alternative);// if (foo()) bar(); else { baz(); return; } moo(); ---> if (foo()) { bar(); moo(); } else baz();
if(can_merge_flow(alt)){if(alt.label)remove(alt.label.thedef.references,alt);changed=true;stat=stat.clone();stat.body=make_node(AST_BlockStatement,stat.body,{body:as_statement_array(stat.body).concat(extract_functions(merge_jump,jump))});stat.alternative=make_node(AST_BlockStatement,stat.alternative,{body:as_statement_array_with_return(stat.alternative,alt)});adjust_refs(alt.value,merge_jump);statements[i]=stat;statements[i]=stat.transform(compressor);continue;}if(compressor.option("typeofs")){if(ab&&!alt){var stats=make_node(AST_BlockStatement,self,{body:statements.slice(i+1)});mark_locally_defined(stat.condition,null,stats);}if(!ab&&alt){var stats=make_node(AST_BlockStatement,self,{body:statements.slice(i+1)});mark_locally_defined(stat.condition,stats);}}}if(stat instanceof AST_If&&stat.body instanceof AST_Return){var value=stat.body.value;var in_bool=stat.body.in_bool||next instanceof AST_Return&&next.in_bool;// if (foo()) return x; return y; ---> return foo() ? x : y;
if(!stat.alternative&&next instanceof AST_Return&&(drop_return_void||!value==!next.value)){changed=true;stat=stat.clone();stat.alternative=make_node(AST_BlockStatement,next,{body:extract_functions(true,null,j+1)});statements[i]=stat;statements[i]=stat.transform(compressor);continue;}// if (foo()) return x; [ return ; ] ---> return foo() ? x : undefined;
// if (foo()) return bar() ? x : void 0; ---> return foo() && bar() ? x : void 0;
// if (foo()) return bar() ? void 0 : x; ---> return !foo() || bar() ? void 0 : x;
if(in_lambda&&declare_only&&!next&&!stat.alternative&&(in_bool||value&&multiple_if_returns||value instanceof AST_Conditional&&(is_undefined(value.consequent,compressor)||is_undefined(value.alternative,compressor)))){changed=true;stat=stat.clone();stat.alternative=make_node(AST_Return,stat,{value:null});statements[i]=stat;statements[i]=stat.transform(compressor);continue;}// if (a) return b; if (c) return d; e; ---> return a ? b : c ? d : void e;
//
// if sequences is not enabled, this can lead to an endless loop (issue #866).
// however, with sequences on this helps producing slightly better output for
// the example code.
var prev,prev_stat;if(chain_if_returns&&!stat.alternative&&(!(prev_stat=statements[prev=prev_index(i)])&&in_iife||prev_stat instanceof AST_If&&prev_stat.body instanceof AST_Return)&&(!next?!declare_only:next instanceof AST_SimpleStatement&&next_index(j)==statements.length)){changed=true;var exprs=[];stat=stat.clone();exprs.push(stat.condition);stat.condition=make_sequence(stat,exprs);stat.alternative=make_node(AST_BlockStatement,self,{body:extract_functions().concat(make_node(AST_Return,self,{value:null}))});statements[i]=stat.transform(compressor);i=prev+1;continue;}}if(stat instanceof AST_Break||stat instanceof AST_Exit){jump=stat;continue;}if(declare_only&&jump&&jump===next)eliminate_returns(stat);}return changed;function has_multiple_if_returns(statements){var n=0;for(var i=statements.length;--i>=0;){var stat=statements[i];if(stat instanceof AST_If&&stat.body instanceof AST_Return){if(++n>1)return true;}}return false;}function match_target(target){return last_of(compressor,function(node){return node===target;});}function match_return(ab,exact){if(!jump)return false;if(jump.TYPE!=ab.TYPE)return false;var value=ab.value;if(!value)return false;var equals=jump.equals(ab);if(!equals&&value instanceof AST_Sequence){value=value.tail_node();if(jump.value&&jump.value.equals(value))equals=2;}if(!equals&&!exact&&jump.value instanceof AST_Sequence){if(jump.value.tail_node().equals(value))equals=3;}return equals;}function can_drop_abort(ab){if(ab instanceof AST_Exit){if(merge_jump=match_return(ab))return true;if(!in_lambda)return false;if(!(ab instanceof AST_Return))return false;var value=ab.value;if(value){if(!drop_return_void)return false;if(!is_undefined(value.tail_node()))return false;}if(!(self instanceof AST_SwitchBranch))return true;if(!jump)return false;if(jump instanceof AST_Exit&&jump.value)return false;merge_jump=4;return true;}if(!(ab instanceof AST_LoopControl))return false;if(self instanceof AST_SwitchBranch){if(jump instanceof AST_Exit){if(!in_lambda)return false;if(jump.value)return false;merge_jump=true;}else if(jump){if(compressor.loopcontrol_target(jump)!==parent)return false;merge_jump=true;}else if(jump===false){return false;}}var lct=compressor.loopcontrol_target(ab);if(ab instanceof AST_Continue)return match_target(loop_body(lct));if(lct instanceof AST_IterationStatement)return false;return match_target(lct);}function can_merge_flow(ab){merge_jump=false;if(!can_drop_abort(ab))return false;for(var j=statements.length;--j>i;){var stat=statements[j];if(stat instanceof AST_DefClass){if(stat.name.definition().preinit)return false;}else if(stat instanceof AST_Const||stat instanceof AST_Let){if(!all(stat.definitions,function(defn){return !defn.name.match_symbol(function(node){return node instanceof AST_SymbolDeclaration&&node.definition().preinit;});}))return false;}}return true;}function extract_functions(mode,stop,end){var defuns=[];var lexical=false;var start=i+1;if(!mode){end=statements.length;jump=null;}else if(stop){end=statements.lastIndexOf(stop);}else {stop=statements[end];if(stop!==jump)jump=false;}var tail=statements.splice(start,end-start).filter(function(stat){if(stat instanceof AST_LambdaDefinition){defuns.push(stat);return false;}if(is_lexical_definition(stat))lexical=true;return true;});if(mode===3){tail.push(make_node(AST_SimpleStatement,stop.value,{body:make_sequence(stop.value,stop.value.expressions.slice(0,-1))}));stop.value=stop.value.tail_node();}[].push.apply(lexical?tail:statements,defuns);return tail;}function trim_return(value,mode){if(value)switch(mode){case 4:return value;case 3:if(!(value instanceof AST_Sequence))break;case 2:return make_sequence(value,value.expressions.slice(0,-1));}}function as_statement_array_with_return(node,ab){var body=as_statement_array(node);var block=body,last;while((last=block[block.length-1])!==ab){block=last.body;}block.pop();var value=ab.value;if(merge_jump)value=trim_return(value,merge_jump);if(value)block.push(make_node(AST_SimpleStatement,value,{body:value}));return body;}function adjust_refs(value,mode){if(!mode)return;if(!value)return;switch(mode){case 4:return;case 3:case 2:value=value.tail_node();}merge_expression(value,jump.value);}function next_index(i){declare_only=true;for(var j=i;++j<statements.length;){var stat=statements[j];if(is_declaration(stat))continue;if(stat instanceof AST_Var){declare_only=false;continue;}break;}return j;}function prev_index(i){for(var j=i;--j>=0;){var stat=statements[j];if(stat instanceof AST_Var)continue;if(is_declaration(stat))continue;break;}return j;}function eliminate_returns(stat,keep_throws,in_block){if(stat instanceof AST_Exit){var mode=!(keep_throws&&stat instanceof AST_Throw)&&match_return(stat,true);if(mode){changed=true;var value=trim_return(stat.value,mode);if(value)return make_node(AST_SimpleStatement,value,{body:value});return in_block?null:make_node(AST_EmptyStatement,stat);}}else if(stat instanceof AST_If){stat.body=eliminate_returns(stat.body,keep_throws);if(stat.alternative)stat.alternative=eliminate_returns(stat.alternative,keep_throws);}else if(stat instanceof AST_LabeledStatement){stat.body=eliminate_returns(stat.body,keep_throws);}else if(stat instanceof AST_Try){if(!stat.bfinally||!jump.value||jump.value.is_constant()){if(stat.bcatch)eliminate_returns(stat.bcatch,keep_throws);var trimmed=eliminate_returns(stat.body.pop(),true,true);if(trimmed)stat.body.push(trimmed);}}else if(stat instanceof AST_Block&&!(stat instanceof AST_Scope||stat instanceof AST_Switch)){var trimmed=eliminate_returns(stat.body.pop(),keep_throws,true);if(trimmed)stat.body.push(trimmed);}return stat;}}function eliminate_dead_code(statements,compressor){var has_quit;var self=compressor.self();if(self instanceof AST_Catch){self=compressor.parent();}else if(self instanceof AST_LabeledStatement){self=self.body;}for(var i=0,n=0,len=statements.length;i<len;i++){var stat=statements[i];if(stat instanceof AST_LoopControl){var lct=compressor.loopcontrol_target(stat);if(loop_body(lct)!==self||stat instanceof AST_Break&&lct instanceof AST_IterationStatement){statements[n++]=stat;}else if(stat.label){remove(stat.label.thedef.references,stat);}}else {statements[n++]=stat;}if(aborts(stat)){has_quit=statements.slice(i+1);break;}}statements.length=n;if(has_quit)has_quit.forEach(function(stat){extract_declarations_from_unreachable_code(compressor,stat,statements);});return statements.length!=len;}function trim_awaits(statements,compressor){if(!in_lambda||in_try&&in_try.bfinally)return;var changed=false;for(var index=statements.length;--index>=0;){var stat=statements[index];if(!(stat instanceof AST_SimpleStatement))break;var node=stat.body.tail_node();if(!(node instanceof AST_Await))break;var exp=node.expression;if(!needs_enqueuing(compressor,exp))break;changed=true;exp=exp.drop_side_effect_free(compressor,true);if(stat.body instanceof AST_Sequence){var expressions=stat.body.expressions.slice();expressions.pop();if(exp)expressions.push(exp);stat.body=make_sequence(stat.body,expressions);break;}if(exp){stat.body=exp;break;}}statements.length=index+1;return changed;}function inline_iife(statements,compressor){var changed=false;var index=statements.length-1;if(in_lambda&&index>=0){var no_return=in_try&&in_try.bfinally&&in_async_generator(scope);var inlined=statements[index].try_inline(compressor,block_scope,no_return);if(inlined){statements[index--]=inlined;changed=true;}}var loop=in_loop&&in_try?"try":in_loop;for(;index>=0;index--){var inlined=statements[index].try_inline(compressor,block_scope,true,loop);if(!inlined)continue;statements[index]=inlined;changed=true;}return changed;}function sequencesize(statements,compressor){if(statements.length<2)return;var seq=[],n=0;function push_seq(){if(!seq.length)return;var body=make_sequence(seq[0],seq);statements[n++]=make_node(AST_SimpleStatement,body,{body:body});seq=[];}for(var i=0,len=statements.length;i<len;i++){var stat=statements[i];if(stat instanceof AST_SimpleStatement){if(seq.length>=compressor.sequences_limit)push_seq();merge_sequence(seq,stat.body);}else if(is_declaration(stat)){statements[n++]=stat;}else {push_seq();statements[n++]=stat;}}push_seq();statements.length=n;return n!=len;}function to_simple_statement(block,decls){if(!(block instanceof AST_BlockStatement))return block;var stat=null;for(var i=0;i<block.body.length;i++){var line=block.body[i];if(line instanceof AST_Var&&declarations_only(line)){decls.push(line);}else if(stat||is_lexical_definition(line)){return false;}else {stat=line;}}return stat;}function sequencesize_2(statements,compressor){var changed=false,n=0,prev;for(var i=0;i<statements.length;i++){var stat=statements[i];if(prev){if(stat instanceof AST_Exit){if(stat.value||!in_async_generator(scope)){stat.value=cons_seq(stat.value||make_node(AST_Undefined,stat)).optimize(compressor);}}else if(stat instanceof AST_For){if(!(stat.init instanceof AST_Definitions)){var abort=false;prev.body.walk(new TreeWalker(function(node){if(abort||node instanceof AST_Scope)return true;if(node instanceof AST_Binary&&node.operator=="in"){abort=true;return true;}}));if(!abort){if(stat.init)stat.init=cons_seq(stat.init);else {stat.init=prev.body;n--;changed=true;}}}}else if(stat instanceof AST_ForIn){if(!is_lexical_definition(stat.init))stat.object=cons_seq(stat.object);}else if(stat instanceof AST_If){stat.condition=cons_seq(stat.condition);}else if(stat instanceof AST_Switch){stat.expression=cons_seq(stat.expression);}else if(stat instanceof AST_With){stat.expression=cons_seq(stat.expression);}}if(compressor.option("conditionals")&&stat instanceof AST_If){var decls=[];var body=to_simple_statement(stat.body,decls);var alt=to_simple_statement(stat.alternative,decls);if(body!==false&&alt!==false&&decls.length>0){var len=decls.length;decls.push(make_node(AST_If,stat,{condition:stat.condition,body:body||make_node(AST_EmptyStatement,stat.body),alternative:alt}));decls.unshift(n,1);[].splice.apply(statements,decls);i+=len;n+=len+1;prev=null;changed=true;continue;}}statements[n++]=stat;prev=stat instanceof AST_SimpleStatement?stat:null;}statements.length=n;return changed;function cons_seq(right){n--;changed=true;var left=prev.body;return make_sequence(left,[left,right]);}}function extract_exprs(body){if(body instanceof AST_Assign)return [body];if(body instanceof AST_Sequence)return body.expressions.slice();}function join_assigns(defn,body,keep){var exprs=extract_exprs(body);if(!exprs)return;keep=keep||0;var trimmed=false;for(var i=exprs.length-keep;--i>=0;){var expr=exprs[i];if(!can_trim(expr))continue;var tail;if(expr.left instanceof AST_SymbolRef){tail=exprs.slice(i+1);}else if(expr.left instanceof AST_PropAccess&&can_trim(expr.left.expression)){tail=exprs.slice(i+1);var flattened=expr.clone();expr=expr.left.expression;flattened.left=flattened.left.clone();flattened.left.expression=expr.left.clone();tail.unshift(flattened);}else {continue;}if(tail.length==0)continue;if(!trim_assigns(expr.left,expr.right,tail))continue;trimmed=true;exprs=exprs.slice(0,i).concat(expr,tail);}if(defn instanceof AST_Definitions){for(var i=defn.definitions.length;--i>=0;){var def=defn.definitions[i];if(!def.value)continue;if(trim_assigns(def.name,def.value,exprs))trimmed=true;if(merge_conditional_assignments(def,exprs,keep))trimmed=true;break;}if(defn instanceof AST_Var&&join_var_assign(defn.definitions,exprs,keep))trimmed=true;}return trimmed&&exprs;function can_trim(node){return node instanceof AST_Assign&&node.operator=="=";}}function merge_assigns(prev,defn){if(!(prev instanceof AST_SimpleStatement))return;if(declarations_only(defn))return;var exprs=extract_exprs(prev.body);if(!exprs)return;var definitions=[];if(!join_var_assign(definitions,exprs.reverse(),0))return;defn.definitions=definitions.reverse().concat(defn.definitions);return exprs.reverse();}function merge_conditional_assignments(var_def,exprs,keep){if(!compressor.option("conditionals"))return;if(var_def.name instanceof AST_Destructured)return;var trimmed=false;var def=var_def.name.definition();while(exprs.length>keep){var cond=to_conditional_assignment(compressor,def,var_def.value,exprs[0]);if(!cond)break;var_def.value=cond;exprs.shift();trimmed=true;}return trimmed;}function join_var_assign(definitions,exprs,keep){var trimmed=false;while(exprs.length>keep){var expr=exprs[0];if(!(expr instanceof AST_Assign))break;if(expr.operator!="=")break;var lhs=expr.left;if(!(lhs instanceof AST_SymbolRef))break;if(is_undeclared_ref(lhs))break;if(lhs.scope.resolve()!==scope)break;var def=lhs.definition();if(def.scope!==scope)break;if(def.orig.length>def.eliminated+1)break;if(def.orig[0].TYPE!="SymbolVar")break;var name=make_node(AST_SymbolVar,lhs);definitions.push(make_node(AST_VarDef,expr,{name:name,value:expr.right}));def.orig.push(name);def.replaced++;exprs.shift();trimmed=true;}return trimmed;}function trim_assigns(name,value,exprs){var names=new Dictionary();names.set(name.name,true);while(value instanceof AST_Assign&&value.operator=="="){if(value.left instanceof AST_SymbolRef)names.set(value.left.name,true);value=value.right;}if(value instanceof AST_Array){var trimmed=false;do{if(!try_join_array(exprs[0]))break;exprs.shift();trimmed=true;}while(exprs.length);return trimmed;}else if(value instanceof AST_Object){var trimmed=false;do{if(!try_join_object(exprs[0]))break;exprs.shift();trimmed=true;}while(exprs.length);return trimmed;}function try_join_array(node){if(!(node instanceof AST_Assign))return;if(node.operator!="=")return;if(!(node.left instanceof AST_PropAccess))return;var sym=node.left.expression;if(!(sym instanceof AST_SymbolRef))return;if(!names.has(sym.name))return;if(!node.right.is_constant_expression(scope))return;var prop=node.left.property;if(prop instanceof AST_Node){if(try_join_array(prop))prop=node.left.property=prop.right.clone();prop=prop.evaluate(compressor);}if(prop instanceof AST_Node)return;if(!RE_POSITIVE_INTEGER.test(""+prop))return;prop=+prop;var elements=value.elements;var len=elements.length;if(prop>len+4)return;for(var i=Math.min(len,prop+1);--i>=0;){if(elements[i]instanceof AST_Spread)return;}if(prop<len){var element=elements[prop].drop_side_effect_free(compressor);elements[prop]=element?make_sequence(node,[element,node.right]):node.right;}else {while(prop>len)elements[len++]=make_node(AST_Hole,value);elements[prop]=node.right;}return true;}function try_join_object(node){if(!(node instanceof AST_Assign))return;if(node.operator!="=")return;if(!(node.left instanceof AST_PropAccess))return;var sym=node.left.expression;if(!(sym instanceof AST_SymbolRef))return;if(!names.has(sym.name))return;if(!node.right.is_constant_expression(scope))return;var prop=node.left.property;if(prop instanceof AST_Node){if(try_join_object(prop))prop=node.left.property=prop.right.clone();prop=prop.evaluate(compressor);}if(prop instanceof AST_Node)return;prop=""+prop;var diff=prop=="__proto__"||compressor.has_directive("use strict")?function(node){var key=node.key;return typeof key=="string"&&key!=prop&&key!="__proto__";}:function(node){var key=node.key;if(node instanceof AST_ObjectGetter||node instanceof AST_ObjectSetter){return typeof key=="string"&&key!=prop;}return key!=="__proto__";};if(!all(value.properties,diff))return;value.properties.push(make_node(AST_ObjectKeyVal,node,{key:prop,value:node.right}));return true;}}function join_consecutive_vars(statements){var changed=false,defs,prev_defs;for(var i=0,j=-1;i<statements.length;i++){var stat=statements[i];var prev=statements[j];if(stat instanceof AST_Definitions){if(prev&&prev.TYPE==stat.TYPE){prev.definitions=prev.definitions.concat(stat.definitions);changed=true;}else if(stat&&prev instanceof AST_Let&&stat.can_letify(compressor)){prev.definitions=prev.definitions.concat(to_let(stat,block_scope).definitions);changed=true;}else if(prev&&stat instanceof AST_Let&&prev.can_letify(compressor)){defs=prev_defs;statements[j]=prev=to_let(prev,block_scope);prev.definitions=prev.definitions.concat(stat.definitions);changed=true;}else if(defs&&defs.TYPE==stat.TYPE&&declarations_only(stat)){defs.definitions=defs.definitions.concat(stat.definitions);changed=true;}else if(stat instanceof AST_Var){var exprs=merge_assigns(prev,stat);if(exprs){if(exprs.length){prev.body=make_sequence(prev,exprs);j++;}changed=true;}else {j++;}prev_defs=defs;statements[j]=defs=stat;}else {statements[++j]=stat;}continue;}else if(stat instanceof AST_Exit){stat.value=join_assigns_expr(stat.value);}else if(stat instanceof AST_For){var exprs=join_assigns(prev,stat.init);if(exprs){changed=true;stat.init=exprs.length?make_sequence(stat.init,exprs):null;}else if(prev instanceof AST_Var&&(!stat.init||stat.init.TYPE==prev.TYPE)){if(stat.init){prev.definitions=prev.definitions.concat(stat.init.definitions);}stat=stat.clone();prev_defs=defs;defs=stat.init=prev;statements[j]=merge_defns(stat);changed=true;continue;}else if(defs&&stat.init&&defs.TYPE==stat.init.TYPE&&declarations_only(stat.init)){defs.definitions=defs.definitions.concat(stat.init.definitions);stat.init=null;changed=true;}else if(stat.init instanceof AST_Var){prev_defs=defs;defs=stat.init;exprs=merge_assigns(prev,stat.init);if(exprs){changed=true;if(exprs.length==0){statements[j]=merge_defns(stat);continue;}prev.body=make_sequence(prev,exprs);}}}else if(stat instanceof AST_ForEnumeration){if(defs&&defs.TYPE==stat.init.TYPE){var defns=defs.definitions.slice();stat.init=stat.init.definitions[0].name.convert_symbol(AST_SymbolRef,function(ref,name){defns.push(make_node(AST_VarDef,name,{name:name,value:null}));name.definition().references.push(ref);});defs.definitions=defns;changed=true;}stat.object=join_assigns_expr(stat.object);}else if(stat instanceof AST_If){stat.condition=join_assigns_expr(stat.condition);}else if(stat instanceof AST_SimpleStatement){var exprs=join_assigns(prev,stat.body),next;if(exprs){changed=true;if(!exprs.length)continue;stat.body=make_sequence(stat.body,exprs);}else if(prev instanceof AST_Definitions&&(next=statements[i+1])&&prev.TYPE==next.TYPE&&(next=next.definitions[0]).value){changed=true;next.value=make_sequence(stat,[stat.body,next.value]);continue;}}else if(stat instanceof AST_Switch){stat.expression=join_assigns_expr(stat.expression);}else if(stat instanceof AST_With){stat.expression=join_assigns_expr(stat.expression);}statements[++j]=defs?merge_defns(stat):stat;}statements.length=j+1;return changed;function join_assigns_expr(value){var exprs=join_assigns(prev,value,1);if(!exprs)return value;changed=true;var tail=value.tail_node();if(exprs[exprs.length-1]!==tail)exprs.push(tail.left);return make_sequence(value,exprs);}function merge_defns(stat){return stat.transform(new TreeTransformer(function(node,descend,in_list){if(node instanceof AST_Definitions){if(defs===node)return node;if(defs.TYPE!=node.TYPE)return node;var parent=this.parent();if(parent instanceof AST_ForEnumeration&&parent.init===node)return node;if(!declarations_only(node))return node;defs.definitions=defs.definitions.concat(node.definitions);changed=true;if(parent instanceof AST_For&&parent.init===node)return null;return in_list?List.skip:make_node(AST_EmptyStatement,node);}if(node instanceof AST_ExportDeclaration)return node;if(node instanceof AST_Scope)return node;if(!is_statement(node))return node;}));}}}function extract_declarations_from_unreachable_code(compressor,stat,target){var block;var dropped=false;stat.walk(new TreeWalker(function(node,descend){if(node instanceof AST_DefClass){node.extends=null;node.properties=[];push(node);return true;}if(node instanceof AST_Definitions){var defns=[];if(node.remove_initializers(compressor,defns)){AST_Node.warn("Dropping initialization in unreachable code [{start}]",node);}if(defns.length>0){node.definitions=defns;push(node);}return true;}if(node instanceof AST_LambdaDefinition){push(node);return true;}if(node instanceof AST_Scope)return true;if(node instanceof AST_BlockScope){var save=block;block=[];descend();if(block.required){target.push(make_node(AST_BlockStatement,stat,{body:block}));}else if(block.length){[].push.apply(target,block);}block=save;return true;}if(!(node instanceof AST_LoopControl))dropped=true;}));if(dropped)AST_Node.warn("Dropping unreachable code [{start}]",stat);function push(node){if(block){block.push(node);if(!safe_to_trim(node))block.required=true;}else {target.push(node);}}}function is_undefined(node,compressor){return node==null||node.is_undefined||node instanceof AST_Undefined||node instanceof AST_UnaryPrefix&&node.operator=="void"&&!(compressor&&node.expression.has_side_effects(compressor));}// in_strict_mode()
// return true if scope executes in Strict Mode
(function(def){def(AST_Class,return_true);def(AST_Scope,function(compressor){var body=this.body;for(var i=0;i<body.length;i++){var stat=body[i];if(!(stat instanceof AST_Directive))break;if(stat.value=="use strict")return true;}var parent=this.parent_scope;if(!parent)return compressor.option("module");return parent.resolve(true).in_strict_mode(compressor);});})(function(node,func){node.DEFMETHOD("in_strict_mode",func);});// is_truthy()
// return true if `!!node === true`
(function(def){def(AST_Node,return_false);def(AST_Array,return_true);def(AST_Assign,function(){return this.operator=="="&&this.right.is_truthy();});def(AST_Lambda,return_true);def(AST_Object,return_true);def(AST_RegExp,return_true);def(AST_Sequence,function(){return this.tail_node().is_truthy();});def(AST_SymbolRef,function(){var fixed=this.fixed_value();if(!fixed)return false;this.is_truthy=return_false;var result=fixed.is_truthy();delete this.is_truthy;return result;});})(function(node,func){node.DEFMETHOD("is_truthy",func);});// is_negative_zero()
// return true if the node may represent -0
(function(def){def(AST_Node,return_true);def(AST_Array,return_false);function binary(op,left,right){switch(op){case"-":return left.is_negative_zero()&&(!(right instanceof AST_Constant)||right.value==0);case"&&":case"||":return left.is_negative_zero()||right.is_negative_zero();case"*":case"/":case"%":case"**":return true;default:return false;}}def(AST_Assign,function(){var op=this.operator;if(op=="=")return this.right.is_negative_zero();return binary(op.slice(0,-1),this.left,this.right);});def(AST_Binary,function(){return binary(this.operator,this.left,this.right);});def(AST_Constant,function(){return this.value==0&&1/this.value<0;});def(AST_Lambda,return_false);def(AST_Object,return_false);def(AST_RegExp,return_false);def(AST_Sequence,function(){return this.tail_node().is_negative_zero();});def(AST_SymbolRef,function(){var fixed=this.fixed_value();if(!fixed)return true;this.is_negative_zero=return_true;var result=fixed.is_negative_zero();delete this.is_negative_zero;return result;});def(AST_UnaryPrefix,function(){return this.operator=="+"&&this.expression.is_negative_zero()||this.operator=="-";});})(function(node,func){node.DEFMETHOD("is_negative_zero",func);});// may_throw_on_access()
// returns true if this node may be null, undefined or contain `AST_Accessor`
(function(def){AST_Node.DEFMETHOD("may_throw_on_access",function(compressor,force){return !compressor.option("pure_getters")||this._dot_throw(compressor,force);});function is_strict(compressor,force){return force||/strict/.test(compressor.option("pure_getters"));}def(AST_Node,is_strict);def(AST_Array,return_false);def(AST_Assign,function(compressor){var op=this.operator;var sym=this.left;var rhs=this.right;if(op!="="){return lazy_op[op.slice(0,-1)]&&(sym._dot_throw(compressor)||rhs._dot_throw(compressor));}if(!rhs._dot_throw(compressor))return false;if(!(sym instanceof AST_SymbolRef))return true;if(rhs instanceof AST_Binary&&rhs.operator=="||"&&sym.name==rhs.left.name){return rhs.right._dot_throw(compressor);}return true;});def(AST_Binary,function(compressor){return lazy_op[this.operator]&&(this.left._dot_throw(compressor)||this.right._dot_throw(compressor));});def(AST_Class,function(compressor,force){return is_strict(compressor,force)&&!all(this.properties,function(prop){if(prop.private)return true;if(!prop.static)return true;return !(prop instanceof AST_ClassGetter||prop instanceof AST_ClassSetter);});});def(AST_Conditional,function(compressor){return this.consequent._dot_throw(compressor)||this.alternative._dot_throw(compressor);});def(AST_Constant,return_false);def(AST_Dot,function(compressor,force){if(!is_strict(compressor,force))return false;var exp=this.expression;if(exp instanceof AST_SymbolRef)exp=exp.fixed_value();return !(this.property=="prototype"&&is_lambda(exp));});def(AST_Lambda,return_false);def(AST_Null,return_true);def(AST_Object,function(compressor,force){return is_strict(compressor,force)&&!all(this.properties,function(prop){if(prop instanceof AST_ObjectGetter||prop instanceof AST_ObjectSetter)return false;return !(prop.key==="__proto__"&&prop.value._dot_throw(compressor,force));});});def(AST_ObjectIdentity,function(compressor,force){return is_strict(compressor,force)&&!this.scope.resolve().new;});def(AST_Sequence,function(compressor){return this.tail_node()._dot_throw(compressor);});def(AST_SymbolRef,function(compressor,force){if(this.defined)return false;if(this.is_undefined)return true;if(!is_strict(compressor,force))return false;if(is_undeclared_ref(this)&&this.is_declared(compressor))return false;if(this.is_immutable())return false;var def=this.definition();if(is_arguments(def)&&!def.scope.rest&&all(def.scope.argnames,function(argname){return argname instanceof AST_SymbolFunarg;}))return def.scope.uses_arguments>2;var fixed=this.fixed_value(true);if(!fixed)return true;this._dot_throw=return_true;if(fixed._dot_throw(compressor)){delete this._dot_throw;return true;}this._dot_throw=return_false;return false;});def(AST_UnaryPrefix,function(){return this.operator=="void";});def(AST_UnaryPostfix,return_false);def(AST_Undefined,return_true);})(function(node,func){node.DEFMETHOD("_dot_throw",func);});(function(def){def(AST_Node,return_false);def(AST_Array,return_true);function is_binary_defined(compressor,op,node){switch(op){case"&&":return node.left.is_defined(compressor)&&node.right.is_defined(compressor);case"||":return node.left.is_truthy()||node.right.is_defined(compressor);case"??":return node.left.is_defined(compressor)||node.right.is_defined(compressor);default:return true;}}def(AST_Assign,function(compressor){var op=this.operator;if(op=="=")return this.right.is_defined(compressor);return is_binary_defined(compressor,op.slice(0,-1),this);});def(AST_Binary,function(compressor){return is_binary_defined(compressor,this.operator,this);});def(AST_Conditional,function(compressor){return this.consequent.is_defined(compressor)&&this.alternative.is_defined(compressor);});def(AST_Constant,return_true);def(AST_Hole,return_false);def(AST_Lambda,return_true);def(AST_Object,return_true);def(AST_Sequence,function(compressor){return this.tail_node().is_defined(compressor);});def(AST_SymbolRef,function(compressor){if(this.is_undefined)return false;if(is_undeclared_ref(this)&&this.is_declared(compressor))return true;if(this.is_immutable())return true;var fixed=this.fixed_value();if(!fixed)return false;this.is_defined=return_false;var result=fixed.is_defined(compressor);delete this.is_defined;return result;});def(AST_UnaryPrefix,function(){return this.operator!="void";});def(AST_UnaryPostfix,return_true);def(AST_Undefined,return_false);})(function(node,func){node.DEFMETHOD("is_defined",func);});/* -----[ boolean/negation helpers ]----- */// methods to determine whether an expression has a boolean result type
(function(def){def(AST_Node,return_false);def(AST_Assign,function(compressor){return this.operator=="="&&this.right.is_boolean(compressor);});var binary=makePredicate("in instanceof == != === !== < <= >= >");def(AST_Binary,function(compressor){return binary[this.operator]||lazy_op[this.operator]&&this.left.is_boolean(compressor)&&this.right.is_boolean(compressor);});def(AST_Boolean,return_true);var fn=makePredicate("every hasOwnProperty isPrototypeOf propertyIsEnumerable some");def(AST_Call,function(compressor){if(!compressor.option("unsafe"))return false;var exp=this.expression;return exp instanceof AST_Dot&&(fn[exp.property]||exp.property=="test"&&exp.expression instanceof AST_RegExp);});def(AST_Conditional,function(compressor){return this.consequent.is_boolean(compressor)&&this.alternative.is_boolean(compressor);});def(AST_New,return_false);def(AST_Sequence,function(compressor){return this.tail_node().is_boolean(compressor);});def(AST_SymbolRef,function(compressor){var fixed=this.fixed_value();if(!fixed)return false;this.is_boolean=return_false;var result=fixed.is_boolean(compressor);delete this.is_boolean;return result;});var unary=makePredicate("! delete");def(AST_UnaryPrefix,function(){return unary[this.operator];});})(function(node,func){node.DEFMETHOD("is_boolean",func);});// methods to determine if an expression has a numeric result type
(function(def){def(AST_Node,return_false);var binary=makePredicate("- * / % ** & | ^ << >> >>>");def(AST_Assign,function(compressor){return binary[this.operator.slice(0,-1)]||this.operator=="="&&this.right.is_number(compressor);});def(AST_Binary,function(compressor){if(binary[this.operator])return true;if(this.operator!="+")return false;return (this.left.is_boolean(compressor)||this.left.is_number(compressor))&&(this.right.is_boolean(compressor)||this.right.is_number(compressor));});var fn=makePredicate(["charCodeAt","getDate","getDay","getFullYear","getHours","getMilliseconds","getMinutes","getMonth","getSeconds","getTime","getTimezoneOffset","getUTCDate","getUTCDay","getUTCFullYear","getUTCHours","getUTCMilliseconds","getUTCMinutes","getUTCMonth","getUTCSeconds","getYear","indexOf","lastIndexOf","localeCompare","push","search","setDate","setFullYear","setHours","setMilliseconds","setMinutes","setMonth","setSeconds","setTime","setUTCDate","setUTCFullYear","setUTCHours","setUTCMilliseconds","setUTCMinutes","setUTCMonth","setUTCSeconds","setYear"]);def(AST_Call,function(compressor){if(!compressor.option("unsafe"))return false;var exp=this.expression;return exp instanceof AST_Dot&&(fn[exp.property]||is_undeclared_ref(exp.expression)&&exp.expression.name=="Math");});def(AST_Conditional,function(compressor){return this.consequent.is_number(compressor)&&this.alternative.is_number(compressor);});def(AST_New,return_false);def(AST_Number,return_true);def(AST_Sequence,function(compressor){return this.tail_node().is_number(compressor);});def(AST_SymbolRef,function(compressor,keep_unary){var fixed=this.fixed_value();if(!fixed)return false;if(keep_unary&&fixed instanceof AST_UnaryPrefix&&fixed.operator=="+"&&fixed.expression.equals(this)){return false;}this.is_number=return_false;var result=fixed.is_number(compressor);delete this.is_number;return result;});var unary=makePredicate("+ - ~ ++ --");def(AST_Unary,function(){return unary[this.operator];});})(function(node,func){node.DEFMETHOD("is_number",func);});// methods to determine if an expression has a string result type
(function(def){def(AST_Node,return_false);def(AST_Assign,function(compressor){switch(this.operator){case"+=":if(this.left.is_string(compressor))return true;case"=":return this.right.is_string(compressor);}});def(AST_Binary,function(compressor){return this.operator=="+"&&(this.left.is_string(compressor)||this.right.is_string(compressor));});var fn=makePredicate(["charAt","substr","substring","toExponential","toFixed","toLowerCase","toPrecision","toString","toUpperCase","trim"]);def(AST_Call,function(compressor){if(!compressor.option("unsafe"))return false;var exp=this.expression;return exp instanceof AST_Dot&&fn[exp.property];});def(AST_Conditional,function(compressor){return this.consequent.is_string(compressor)&&this.alternative.is_string(compressor);});def(AST_Sequence,function(compressor){return this.tail_node().is_string(compressor);});def(AST_String,return_true);def(AST_SymbolRef,function(compressor){var fixed=this.fixed_value();if(!fixed)return false;this.is_string=return_false;var result=fixed.is_string(compressor);delete this.is_string;return result;});def(AST_Template,function(compressor){return !this.tag||is_raw_tag(compressor,this.tag);});def(AST_UnaryPrefix,function(){return this.operator=="typeof";});})(function(node,func){node.DEFMETHOD("is_string",func);});var lazy_op=makePredicate("&& || ??");(function(def){function to_node(value,orig){if(value instanceof AST_Node)return value.clone(true);if(Array.isArray(value))return make_node(AST_Array,orig,{elements:value.map(function(value){return to_node(value,orig);})});if(value&&typeof value=="object"){var props=[];for(var key in value)if(HOP(value,key)){props.push(make_node(AST_ObjectKeyVal,orig,{key:key,value:to_node(value[key],orig)}));}return make_node(AST_Object,orig,{properties:props});}return make_node_from_constant(value,orig);}function warn(node){AST_Node.warn("global_defs {this} redefined [{start}]",node);}AST_Toplevel.DEFMETHOD("resolve_defines",function(compressor){if(!compressor.option("global_defs"))return this;this.figure_out_scope({ie:compressor.option("ie")});return this.transform(new TreeTransformer(function(node){var def=node._find_defs(compressor,"");if(!def)return;var level=0,child=node,parent;while(parent=this.parent(level++)){if(!(parent instanceof AST_PropAccess))break;if(parent.expression!==child)break;child=parent;}if(is_lhs(child,parent)){warn(node);return;}return def;}));});def(AST_Node,noop);def(AST_Dot,function(compressor,suffix){return this.expression._find_defs(compressor,"."+this.property+suffix);});def(AST_SymbolDeclaration,function(compressor){if(!this.definition().global)return;if(HOP(compressor.option("global_defs"),this.name))warn(this);});def(AST_SymbolRef,function(compressor,suffix){if(!this.definition().global)return;var defines=compressor.option("global_defs");var name=this.name+suffix;if(HOP(defines,name))return to_node(defines[name],this);});})(function(node,func){node.DEFMETHOD("_find_defs",func);});function best_of_expression(ast1,ast2,threshold){var delta=ast2.print_to_string().length-ast1.print_to_string().length;return delta<(threshold||0)?ast2:ast1;}function best_of_statement(ast1,ast2,threshold){return best_of_expression(make_node(AST_SimpleStatement,ast1,{body:ast1}),make_node(AST_SimpleStatement,ast2,{body:ast2}),threshold).body;}function best_of(compressor,ast1,ast2,threshold){return (first_in_statement(compressor)?best_of_statement:best_of_expression)(ast1,ast2,threshold);}function convert_to_predicate(obj){var map=Object.create(null);Object.keys(obj).forEach(function(key){map[key]=makePredicate(obj[key]);});return map;}function skip_directives(body){for(var i=0;i<body.length;i++){var stat=body[i];if(!(stat instanceof AST_Directive))return stat;}}function arrow_first_statement(){if(this.value)return make_node(AST_Return,this.value,{value:this.value});return skip_directives(this.body);}AST_Arrow.DEFMETHOD("first_statement",arrow_first_statement);AST_AsyncArrow.DEFMETHOD("first_statement",arrow_first_statement);AST_Lambda.DEFMETHOD("first_statement",function(){return skip_directives(this.body);});AST_Lambda.DEFMETHOD("length",function(){var argnames=this.argnames;for(var i=0;i<argnames.length;i++){if(argnames[i]instanceof AST_DefaultValue)break;}return i;});function try_evaluate(compressor,node){var ev=node.evaluate(compressor);if(ev===node)return node;ev=make_node_from_constant(ev,node).optimize(compressor);return best_of(compressor,node,ev,compressor.eval_threshold);}var object_fns=["constructor","toString","valueOf"];var native_fns=convert_to_predicate({Array:["indexOf","join","lastIndexOf","slice"].concat(object_fns),Boolean:object_fns,Function:object_fns,Number:["toExponential","toFixed","toPrecision"].concat(object_fns),Object:object_fns,RegExp:["exec","test"].concat(object_fns),String:["charAt","charCodeAt","concat","indexOf","italics","lastIndexOf","match","replace","search","slice","split","substr","substring","toLowerCase","toUpperCase","trim"].concat(object_fns)});var static_fns=convert_to_predicate({Array:["isArray"],Math:["abs","acos","asin","atan","ceil","cos","exp","floor","log","round","sin","sqrt","tan","atan2","pow","max","min"],Number:["isFinite","isNaN"],Object:["create","getOwnPropertyDescriptor","getOwnPropertyNames","getPrototypeOf","isExtensible","isFrozen","isSealed","keys"],String:["fromCharCode","raw"]});function is_static_fn(node){if(!(node instanceof AST_Dot))return false;var expr=node.expression;if(!is_undeclared_ref(expr))return false;var static_fn=static_fns[expr.name];return static_fn&&(static_fn[node.property]||expr.name=="Math"&&node.property=="random");}// Accommodate when compress option evaluate=false
// as well as the common constant expressions !0 and -1
(function(def){def(AST_Node,return_false);def(AST_Constant,return_true);def(AST_RegExp,return_false);var unaryPrefix=makePredicate("! ~ - + void");def(AST_UnaryPrefix,function(){return unaryPrefix[this.operator]&&this.expression instanceof AST_Constant;});})(function(node,func){node.DEFMETHOD("is_constant",func);});// methods to evaluate a constant expression
(function(def){// If the node has been successfully reduced to a constant,
// then its value is returned; otherwise the element itself
// is returned.
//
// They can be distinguished as constant value is never a
// descendant of AST_Node.
//
// When `ignore_side_effects` is `true`, inspect the constant value
// produced without worrying about any side effects caused by said
// expression.
AST_Node.DEFMETHOD("evaluate",function(compressor,ignore_side_effects){if(!compressor.option("evaluate"))return this;var cached=[];var val=this._eval(compressor,ignore_side_effects,cached,1);cached.forEach(function(node){delete node._eval;});if(ignore_side_effects)return val;if(!val||val instanceof RegExp)return val;if(typeof val=="function"||typeof val=="object")return this;return val;});var scan_modified=new TreeWalker(function(node){if(node instanceof AST_Assign)modified(node.left);if(node instanceof AST_ForEnumeration)modified(node.init);if(node instanceof AST_Unary&&UNARY_POSTFIX[node.operator])modified(node.expression);});function modified(node){if(node instanceof AST_DestructuredArray){node.elements.forEach(modified);}else if(node instanceof AST_DestructuredObject){node.properties.forEach(function(prop){modified(prop.value);});}else if(node instanceof AST_PropAccess){modified(node.expression);}else if(node instanceof AST_SymbolRef){node.definition().references.forEach(function(ref){delete ref._eval;});}}def(AST_Statement,function(){throw new Error(string_template("Cannot evaluate a statement [{start}]",this));});def(AST_Accessor,return_this);def(AST_BigInt,return_this);def(AST_Class,return_this);def(AST_Node,return_this);def(AST_Constant,function(){return this.value;});def(AST_Assign,function(compressor,ignore_side_effects,cached,depth){var lhs=this.left;if(!ignore_side_effects){if(!(lhs instanceof AST_SymbolRef))return this;if(!HOP(lhs,"_eval")){if(!lhs.fixed)return this;var def=lhs.definition();if(!def.fixed)return this;if(def.undeclared)return this;if(def.last_ref!==lhs)return this;if(def.single_use=="m")return this;if(this.right.has_side_effects(compressor))return this;}}var op=this.operator;var node;if(!HOP(lhs,"_eval")&&lhs instanceof AST_SymbolRef&&lhs.fixed&&lhs.definition().fixed){node=lhs;}else if(op=="="){node=this.right;}else {node=make_node(AST_Binary,this,{operator:op.slice(0,-1),left:lhs,right:this.right});}lhs.walk(scan_modified);var value=node._eval(compressor,ignore_side_effects,cached,depth);if(typeof value=="object")return this;modified(lhs);return value;});def(AST_Sequence,function(compressor,ignore_side_effects,cached,depth){if(!ignore_side_effects)return this;var exprs=this.expressions;for(var i=0,last=exprs.length-1;i<last;i++){exprs[i].walk(scan_modified);}var tail=exprs[last];var value=tail._eval(compressor,ignore_side_effects,cached,depth);return value===tail?this:value;});def(AST_Lambda,function(compressor){if(compressor.option("unsafe")){var fn=function(){};fn.node=this;fn.toString=function(){return "function(){}";};return fn;}return this;});def(AST_Array,function(compressor,ignore_side_effects,cached,depth){if(compressor.option("unsafe")){var elements=[];for(var i=0;i<this.elements.length;i++){var element=this.elements[i];if(element instanceof AST_Hole)return this;var value=element._eval(compressor,ignore_side_effects,cached,depth);if(element===value)return this;elements.push(value);}return elements;}return this;});def(AST_Object,function(compressor,ignore_side_effects,cached,depth){if(compressor.option("unsafe")){var val={};for(var i=0;i<this.properties.length;i++){var prop=this.properties[i];if(!(prop instanceof AST_ObjectKeyVal))return this;var key=prop.key;if(key instanceof AST_Node){key=key._eval(compressor,ignore_side_effects,cached,depth);if(key===prop.key)return this;}switch(key){case"__proto__":case"toString":case"valueOf":return this;}val[key]=prop.value._eval(compressor,ignore_side_effects,cached,depth);if(val[key]===prop.value)return this;}return val;}return this;});var non_converting_unary=makePredicate("! typeof void");def(AST_UnaryPrefix,function(compressor,ignore_side_effects,cached,depth){var e=this.expression;var op=this.operator;// Function would be evaluated to an array and so typeof would
// incorrectly return "object". Hence making is a special case.
if(compressor.option("typeofs")&&op=="typeof"&&(e instanceof AST_Lambda||e instanceof AST_SymbolRef&&e.fixed_value()instanceof AST_Lambda)){return typeof function(){};}var def=e instanceof AST_SymbolRef&&e.definition();if(!non_converting_unary[op]&&!(def&&def.fixed))depth++;e.walk(scan_modified);var v=e._eval(compressor,ignore_side_effects,cached,depth);if(v===e){if(ignore_side_effects&&op=="void")return;return this;}switch(op){case"!":return !v;case"typeof":// typeof <RegExp> returns "object" or "function" on different platforms
// so cannot evaluate reliably
if(v instanceof RegExp)return this;return typeof v;case"void":return;case"~":return ~v;case"-":return -v;case"+":return +v;case"++":case"--":if(!def)return this;if(!ignore_side_effects){if(def.undeclared)return this;if(def.last_ref!==e)return this;}if(HOP(e,"_eval"))v=+(op[0]+1)+ +v;modified(e);return v;}return this;});def(AST_UnaryPostfix,function(compressor,ignore_side_effects,cached,depth){var e=this.expression;if(!(e instanceof AST_SymbolRef)){if(!ignore_side_effects)return this;}else if(!HOP(e,"_eval")){if(!e.fixed)return this;if(!ignore_side_effects){var def=e.definition();if(!def.fixed)return this;if(def.undeclared)return this;if(def.last_ref!==e)return this;}}if(!(e instanceof AST_SymbolRef&&e.definition().fixed))depth++;e.walk(scan_modified);var v=e._eval(compressor,ignore_side_effects,cached,depth);if(v===e)return this;modified(e);return +v;});var non_converting_binary=makePredicate("&& || === !==");def(AST_Binary,function(compressor,ignore_side_effects,cached,depth){if(!non_converting_binary[this.operator])depth++;var left=this.left._eval(compressor,ignore_side_effects,cached,depth);if(left===this.left)return this;if(this.operator==(left?"||":"&&"))return left;var rhs_ignore_side_effects=ignore_side_effects&&!(left&&typeof left=="object");var right=this.right._eval(compressor,rhs_ignore_side_effects,cached,depth);if(right===this.right)return this;var result;switch(this.operator){case"&&":result=left&&right;break;case"||":result=left||right;break;case"??":result=left==null?right:left;break;case"|":result=left|right;break;case"&":result=left&right;break;case"^":result=left^right;break;case"+":result=left+right;break;case"-":result=left-right;break;case"*":result=left*right;break;case"/":result=left/right;break;case"%":result=left%right;break;case"<<":result=left<<right;break;case">>":result=left>>right;break;case">>>":result=left>>>right;break;case"==":result=left==right;break;case"===":result=left===right;break;case"!=":result=left!=right;break;case"!==":result=left!==right;break;case"<":result=left<right;break;case"<=":result=left<=right;break;case">":result=left>right;break;case">=":result=left>=right;break;case"**":result=Math.pow(left,right);break;case"in":if(right&&typeof right=="object"&&HOP(right,left)){result=true;break;}default:return this;}if(isNaN(result))return compressor.find_parent(AST_With)?this:result;if(compressor.option("unsafe_math")&&!ignore_side_effects&&result&&typeof result=="number"&&(this.operator=="+"||this.operator=="-")){var digits=Math.max(0,decimals(left),decimals(right));// 53-bit significand ---> 15.95 decimal places
if(digits<16)return +result.toFixed(digits);}return result;function decimals(operand){var match=/(\.[0-9]*)?(e[^e]+)?$/.exec(+operand);return (match[1]||".").length-1-(match[2]||"").slice(1);}});def(AST_Conditional,function(compressor,ignore_side_effects,cached,depth){var condition=this.condition._eval(compressor,ignore_side_effects,cached,depth);if(condition===this.condition)return this;var node=condition?this.consequent:this.alternative;var value=node._eval(compressor,ignore_side_effects,cached,depth);return value===node?this:value;});function verify_escaped(ref,depth){var escaped=ref.definition().escaped;switch(escaped.length){case 0:return true;case 1:var found=false;escaped[0].walk(new TreeWalker(function(node){if(found)return true;if(node===ref)return found=true;if(node instanceof AST_Scope)return true;}));return found;default:return depth<=escaped.depth;}}def(AST_SymbolRef,function(compressor,ignore_side_effects,cached,depth){this._eval=return_this;try{var fixed=this.fixed_value();if(!fixed)return this;var value;if(HOP(fixed,"_eval")){value=fixed._eval();}else {value=fixed._eval(compressor,ignore_side_effects,cached,depth);if(value===fixed)return this;fixed._eval=function(){return value;};cached.push(fixed);}return value&&typeof value=="object"&&!verify_escaped(this,depth)?this:value;}finally{delete this._eval;}});var global_objs={Array:Array,Math:Math,Number:Number,Object:Object,String:String};var static_values=convert_to_predicate({Math:["E","LN10","LN2","LOG2E","LOG10E","PI","SQRT1_2","SQRT2"],Number:["MAX_VALUE","MIN_VALUE","NaN","NEGATIVE_INFINITY","POSITIVE_INFINITY"]});var regexp_props=makePredicate("global ignoreCase multiline source");def(AST_PropAccess,function(compressor,ignore_side_effects,cached,depth){if(compressor.option("unsafe")){var val;var exp=this.expression;if(!is_undeclared_ref(exp)){val=exp._eval(compressor,ignore_side_effects,cached,depth+1);if(val==null||val===exp)return this;}var key=this.property;if(key instanceof AST_Node){key=key._eval(compressor,ignore_side_effects,cached,depth);if(key===this.property)return this;}if(val===undefined){var static_value=static_values[exp.name];if(!static_value||!static_value[key])return this;val=global_objs[exp.name];}else if(val instanceof RegExp){if(!regexp_props[key])return this;}else if(typeof val=="object"){if(!HOP(val,key))return this;}else if(typeof val=="function")switch(key){case"name":return val.node.name?val.node.name.name:"";case"length":return val.node.length();default:return this;}return val[key];}return this;});function eval_all(nodes,compressor,ignore_side_effects,cached,depth){var values=[];for(var i=0;i<nodes.length;i++){var node=nodes[i];var value=node._eval(compressor,ignore_side_effects,cached,depth);if(node===value)return;values.push(value);}return values;}def(AST_Call,function(compressor,ignore_side_effects,cached,depth){var exp=this.expression;var fn=exp instanceof AST_SymbolRef?exp.fixed_value():exp;if(fn instanceof AST_Arrow||fn instanceof AST_Defun||fn instanceof AST_Function){if(fn.evaluating)return this;if(fn.name&&fn.name.definition().recursive_refs>0)return this;if(this.is_expr_pure(compressor))return this;var args=eval_all(this.args,compressor,ignore_side_effects,cached,depth);if(!all(fn.argnames,function(sym,index){if(sym instanceof AST_DefaultValue){if(!args)return false;if(args[index]===undefined){var value=sym.value._eval(compressor,ignore_side_effects,cached,depth);if(value===sym.value)return false;args[index]=value;}sym=sym.name;}return !(sym instanceof AST_Destructured);}))return this;if(fn.rest instanceof AST_Destructured)return this;if(!args&&!ignore_side_effects)return this;var stat=fn.first_statement();if(!(stat instanceof AST_Return)){if(ignore_side_effects){fn.walk(scan_modified);var found=false;fn.evaluating=true;walk_body(fn,new TreeWalker(function(node){if(found)return true;if(node instanceof AST_Return){if(node.value&&node.value._eval(compressor,true,cached,depth)!==undefined){found=true;}return true;}if(node instanceof AST_Scope&&node!==fn)return true;}));fn.evaluating=false;if(!found)return;}return this;}var val=stat.value;if(!val)return;var cached_args=[];if(!args||all(fn.argnames,function(sym,i){return assign(sym,args[i]);})&&!(fn.rest&&!assign(fn.rest,args.slice(fn.argnames.length)))||ignore_side_effects){if(ignore_side_effects)fn.argnames.forEach(function(sym){if(sym instanceof AST_DefaultValue)sym.value.walk(scan_modified);});fn.evaluating=true;val=val._eval(compressor,ignore_side_effects,cached,depth);fn.evaluating=false;}cached_args.forEach(function(node){delete node._eval;});return val===stat.value?this:val;}else if(compressor.option("unsafe")&&exp instanceof AST_PropAccess){var key=exp.property;if(key instanceof AST_Node){key=key._eval(compressor,ignore_side_effects,cached,depth);if(key===exp.property)return this;}var val;var e=exp.expression;if(is_undeclared_ref(e)){var static_fn=static_fns[e.name];if(!static_fn||!static_fn[key])return this;val=global_objs[e.name];}else {val=e._eval(compressor,ignore_side_effects,cached,depth+1);if(val==null||val===e)return this;var native_fn=native_fns[val.constructor.name];if(!native_fn||!native_fn[key])return this;if(val instanceof RegExp&&val.global&&!(e instanceof AST_RegExp))return this;}var args=eval_all(this.args,compressor,ignore_side_effects,cached,depth);if(!args)return this;if(key=="replace"&&typeof args[1]=="function")return this;try{return val[key].apply(val,args);}catch(ex){AST_Node.warn("Error evaluating {this} [{start}]",this);}finally{if(val instanceof RegExp)val.lastIndex=0;}}return this;function assign(sym,arg){if(sym instanceof AST_DefaultValue)sym=sym.name;var def=sym.definition();if(def.orig[def.orig.length-1]!==sym)return false;var value=arg;def.references.forEach(function(node){node._eval=function(){return value;};cached_args.push(node);});return true;}});def(AST_New,return_this);def(AST_Template,function(compressor,ignore_side_effects,cached,depth){if(!compressor.option("templates"))return this;if(this.tag){if(!is_raw_tag(compressor,this.tag))return this;decode=function(str){return str;};}var exprs=eval_all(this.expressions,compressor,ignore_side_effects,cached,depth);if(!exprs)return this;var malformed=false;var ret=decode(this.strings[0]);for(var i=0;i<exprs.length;i++){ret+=exprs[i]+decode(this.strings[i+1]);}if(!malformed)return ret;this._eval=return_this;return this;function decode(str){str=decode_template(str);if(typeof str!="string")malformed=true;return str;}});})(function(node,func){node.DEFMETHOD("_eval",func);});// method to negate an expression
(function(def){function basic_negation(exp){return make_node(AST_UnaryPrefix,exp,{operator:"!",expression:exp});}function best(orig,alt,first_in_statement){var negated=basic_negation(orig);if(first_in_statement)return best_of_expression(negated,make_node(AST_SimpleStatement,alt,{body:alt}))===negated?negated:alt;return best_of_expression(negated,alt);}def(AST_Node,function(){return basic_negation(this);});def(AST_Statement,function(){throw new Error("Cannot negate a statement");});def(AST_Binary,function(compressor,first_in_statement){var self=this.clone(),op=this.operator;if(compressor.option("unsafe_comps")){switch(op){case"<=":self.operator=">";return self;case"<":self.operator=">=";return self;case">=":self.operator="<";return self;case">":self.operator="<=";return self;}}switch(op){case"==":self.operator="!=";return self;case"!=":self.operator="==";return self;case"===":self.operator="!==";return self;case"!==":self.operator="===";return self;case"&&":self.operator="||";self.left=self.left.negate(compressor,first_in_statement);self.right=self.right.negate(compressor);return best(this,self,first_in_statement);case"||":self.operator="&&";self.left=self.left.negate(compressor,first_in_statement);self.right=self.right.negate(compressor);return best(this,self,first_in_statement);}return basic_negation(this);});def(AST_ClassExpression,function(){return basic_negation(this);});def(AST_Conditional,function(compressor,first_in_statement){var self=this.clone();self.consequent=self.consequent.negate(compressor);self.alternative=self.alternative.negate(compressor);return best(this,self,first_in_statement);});def(AST_LambdaExpression,function(){return basic_negation(this);});def(AST_Sequence,function(compressor){var expressions=this.expressions.slice();expressions.push(expressions.pop().negate(compressor));return make_sequence(this,expressions);});def(AST_UnaryPrefix,function(){if(this.operator=="!")return this.expression;return basic_negation(this);});})(function(node,func){node.DEFMETHOD("negate",function(compressor,first_in_statement){return func.call(this,compressor,first_in_statement);});});var global_pure_fns=makePredicate("Boolean decodeURI decodeURIComponent Date encodeURI encodeURIComponent Error escape EvalError isFinite isNaN Number Object parseFloat parseInt RangeError ReferenceError String SyntaxError TypeError unescape URIError");var global_pure_constructors=makePredicate("Map Set WeakMap WeakSet");AST_Call.DEFMETHOD("is_expr_pure",function(compressor){if(compressor.option("unsafe")){var expr=this.expression;if(is_undeclared_ref(expr)){if(global_pure_fns[expr.name])return true;if(this instanceof AST_New&&global_pure_constructors[expr.name])return true;}if(is_static_fn(expr))return true;}return compressor.option("annotations")&&this.pure||!compressor.pure_funcs(this);});AST_Template.DEFMETHOD("is_expr_pure",function(compressor){var tag=this.tag;if(!tag)return true;if(compressor.option("unsafe")){if(is_undeclared_ref(tag)&&global_pure_fns[tag.name])return true;if(tag instanceof AST_Dot&&is_undeclared_ref(tag.expression)){var static_fn=static_fns[tag.expression.name];return static_fn&&(static_fn[tag.property]||tag.expression.name=="Math"&&tag.property=="random");}}return !compressor.pure_funcs(this);});AST_Node.DEFMETHOD("is_call_pure",return_false);AST_Call.DEFMETHOD("is_call_pure",function(compressor){if(!compressor.option("unsafe"))return false;var dot=this.expression;if(!(dot instanceof AST_Dot))return false;var exp=dot.expression;var map;var prop=dot.property;if(exp instanceof AST_Array){map=native_fns.Array;}else if(exp.is_boolean(compressor)){map=native_fns.Boolean;}else if(exp.is_number(compressor)){map=native_fns.Number;}else if(exp instanceof AST_RegExp){map=native_fns.RegExp;}else if(exp.is_string(compressor)){map=native_fns.String;if(prop=="replace"){var arg=this.args[1];if(arg&&!arg.is_string(compressor))return false;}}else if(!dot.may_throw_on_access(compressor)){map=native_fns.Object;}return map&&map[prop];});// determine if object spread syntax may cause runtime exception
(function(def){def(AST_Node,return_false);def(AST_Array,return_true);def(AST_Assign,function(){switch(this.operator){case"=":return this.right.safe_to_spread();case"&&=":case"||=":case"??=":return this.left.safe_to_spread()&&this.right.safe_to_spread();}return true;});def(AST_Binary,function(){return !lazy_op[this.operator]||this.left.safe_to_spread()&&this.right.safe_to_spread();});def(AST_Constant,return_true);def(AST_Lambda,return_true);def(AST_Object,function(){return all(this.properties,function(prop){return !(prop instanceof AST_ObjectGetter||prop instanceof AST_Spread);});});def(AST_Sequence,function(){return this.tail_node().safe_to_spread();});def(AST_SymbolRef,function(){var fixed=this.fixed_value();return fixed&&fixed.safe_to_spread();});def(AST_Unary,return_true);})(function(node,func){node.DEFMETHOD("safe_to_spread",func);});// determine if expression has side effects
(function(def){function any(list,compressor,spread){return !all(list,spread?function(node){return node instanceof AST_Spread?!spread(node,compressor):!node.has_side_effects(compressor);}:function(node){return !node.has_side_effects(compressor);});}function array_spread(node,compressor){var exp=node.expression;return !exp.is_string(compressor)||exp.has_side_effects(compressor);}def(AST_Node,return_true);def(AST_Array,function(compressor){return any(this.elements,compressor,array_spread);});def(AST_Assign,function(compressor){var lhs=this.left;if(!(lhs instanceof AST_PropAccess))return true;var node=lhs.expression;return !(node instanceof AST_ObjectIdentity)||!node.scope.resolve().new||lhs instanceof AST_Sub&&lhs.property.has_side_effects(compressor)||this.right.has_side_effects(compressor);});def(AST_Binary,function(compressor){return this.left.has_side_effects(compressor)||this.right.has_side_effects(compressor)||!can_drop_op(this,compressor);});def(AST_Block,function(compressor){return any(this.body,compressor);});def(AST_Call,function(compressor){if(!this.is_expr_pure(compressor)&&(!this.is_call_pure(compressor)||this.expression.has_side_effects(compressor))){return true;}return any(this.args,compressor,array_spread);});def(AST_Case,function(compressor){return this.expression.has_side_effects(compressor)||any(this.body,compressor);});def(AST_Class,function(compressor){var base=this.extends;if(base){if(base instanceof AST_SymbolRef)base=base.fixed_value();if(!safe_for_extends(base))return true;}return any(this.properties,compressor);});def(AST_ClassProperty,function(compressor){return this.key instanceof AST_Node&&this.key.has_side_effects(compressor)||this.static&&this.value&&this.value.has_side_effects(compressor);});def(AST_Conditional,function(compressor){return this.condition.has_side_effects(compressor)||this.consequent.has_side_effects(compressor)||this.alternative.has_side_effects(compressor);});def(AST_Constant,return_false);def(AST_Definitions,function(compressor){return any(this.definitions,compressor);});def(AST_DestructuredArray,function(compressor){return any(this.elements,compressor);});def(AST_DestructuredKeyVal,function(compressor){return this.key instanceof AST_Node&&this.key.has_side_effects(compressor)||this.value.has_side_effects(compressor);});def(AST_DestructuredObject,function(compressor){return any(this.properties,compressor);});def(AST_Dot,function(compressor){return this.expression.may_throw_on_access(compressor)||this.expression.has_side_effects(compressor);});def(AST_EmptyStatement,return_false);def(AST_If,function(compressor){return this.condition.has_side_effects(compressor)||this.body&&this.body.has_side_effects(compressor)||this.alternative&&this.alternative.has_side_effects(compressor);});def(AST_LabeledStatement,function(compressor){return this.body.has_side_effects(compressor);});def(AST_Lambda,return_false);def(AST_Object,function(compressor){return any(this.properties,compressor,function(node,compressor){var exp=node.expression;return !exp.safe_to_spread()||exp.has_side_effects(compressor);});});def(AST_ObjectIdentity,return_false);def(AST_ObjectProperty,function(compressor){return this.key instanceof AST_Node&&this.key.has_side_effects(compressor)||this.value.has_side_effects(compressor);});def(AST_Sequence,function(compressor){return any(this.expressions,compressor);});def(AST_SimpleStatement,function(compressor){return this.body.has_side_effects(compressor);});def(AST_Sub,function(compressor){return this.expression.may_throw_on_access(compressor)||this.expression.has_side_effects(compressor)||this.property.has_side_effects(compressor);});def(AST_Switch,function(compressor){return this.expression.has_side_effects(compressor)||any(this.body,compressor);});def(AST_SymbolDeclaration,return_false);def(AST_SymbolRef,function(compressor){return !this.is_declared(compressor)||!can_drop_symbol(this,compressor);});def(AST_Template,function(compressor){return !this.is_expr_pure(compressor)||any(this.expressions,compressor);});def(AST_Try,function(compressor){return any(this.body,compressor)||this.bcatch&&this.bcatch.has_side_effects(compressor)||this.bfinally&&this.bfinally.has_side_effects(compressor);});def(AST_Unary,function(compressor){return unary_side_effects[this.operator]||this.expression.has_side_effects(compressor);});def(AST_VarDef,function(){return this.value;});})(function(node,func){node.DEFMETHOD("has_side_effects",func);});// determine if expression may throw
(function(def){def(AST_Node,return_true);def(AST_Constant,return_false);def(AST_EmptyStatement,return_false);def(AST_Lambda,return_false);def(AST_ObjectIdentity,return_false);def(AST_SymbolDeclaration,return_false);function any(list,compressor){for(var i=list.length;--i>=0;)if(list[i].may_throw(compressor))return true;return false;}function call_may_throw(exp,compressor){if(exp.may_throw(compressor))return true;if(exp instanceof AST_SymbolRef)exp=exp.fixed_value();if(!(exp instanceof AST_Lambda))return true;if(any(exp.argnames,compressor))return true;if(any(exp.body,compressor))return true;return is_arrow(exp)&&exp.value&&exp.value.may_throw(compressor);}def(AST_Array,function(compressor){return any(this.elements,compressor);});def(AST_Assign,function(compressor){if(this.right.may_throw(compressor))return true;if(!compressor.has_directive("use strict")&&this.operator=="="&&this.left instanceof AST_SymbolRef){return false;}return this.left.may_throw(compressor);});def(AST_Await,function(compressor){return this.expression.may_throw(compressor);});def(AST_Binary,function(compressor){return this.left.may_throw(compressor)||this.right.may_throw(compressor)||!can_drop_op(this,compressor);});def(AST_Block,function(compressor){return any(this.body,compressor);});def(AST_Call,function(compressor){if(any(this.args,compressor))return true;if(this.is_expr_pure(compressor))return false;this.may_throw=return_true;var ret=call_may_throw(this.expression,compressor);delete this.may_throw;return ret;});def(AST_Case,function(compressor){return this.expression.may_throw(compressor)||any(this.body,compressor);});def(AST_Conditional,function(compressor){return this.condition.may_throw(compressor)||this.consequent.may_throw(compressor)||this.alternative.may_throw(compressor);});def(AST_DefaultValue,function(compressor){return this.name.may_throw(compressor)||this.value&&this.value.may_throw(compressor);});def(AST_Definitions,function(compressor){return any(this.definitions,compressor);});def(AST_Dot,function(compressor){return !this.optional&&this.expression.may_throw_on_access(compressor)||this.expression.may_throw(compressor);});def(AST_ForEnumeration,function(compressor){if(this.init.may_throw(compressor))return true;var obj=this.object;if(obj.may_throw(compressor))return true;obj=obj.tail_node();if(!(obj instanceof AST_Array||obj.is_string(compressor)))return true;return this.body.may_throw(compressor);});def(AST_If,function(compressor){return this.condition.may_throw(compressor)||this.body&&this.body.may_throw(compressor)||this.alternative&&this.alternative.may_throw(compressor);});def(AST_LabeledStatement,function(compressor){return this.body.may_throw(compressor);});def(AST_Object,function(compressor){return any(this.properties,compressor);});def(AST_ObjectProperty,function(compressor){return this.value.may_throw(compressor)||this.key instanceof AST_Node&&this.key.may_throw(compressor);});def(AST_Return,function(compressor){return this.value&&this.value.may_throw(compressor);});def(AST_Sequence,function(compressor){return any(this.expressions,compressor);});def(AST_SimpleStatement,function(compressor){return this.body.may_throw(compressor);});def(AST_Sub,function(compressor){return !this.optional&&this.expression.may_throw_on_access(compressor)||this.expression.may_throw(compressor)||this.property.may_throw(compressor);});def(AST_Switch,function(compressor){return this.expression.may_throw(compressor)||any(this.body,compressor);});def(AST_SymbolRef,function(compressor){return !this.is_declared(compressor)||!can_drop_symbol(this,compressor);});def(AST_Template,function(compressor){if(any(this.expressions,compressor))return true;if(this.is_expr_pure(compressor))return false;if(!this.tag)return false;this.may_throw=return_true;var ret=call_may_throw(this.tag,compressor);delete this.may_throw;return ret;});def(AST_Try,function(compressor){return (this.bcatch?this.bcatch.may_throw(compressor):any(this.body,compressor))||this.bfinally&&this.bfinally.may_throw(compressor);});def(AST_Unary,function(compressor){return this.expression.may_throw(compressor)&&!(this.operator=="typeof"&&this.expression instanceof AST_SymbolRef);});def(AST_VarDef,function(compressor){return this.name.may_throw(compressor)||this.value&&this.value.may_throw(compressor);});})(function(node,func){node.DEFMETHOD("may_throw",func);});// determine if expression is constant
(function(def){function all_constant(list,scope){for(var i=list.length;--i>=0;)if(!list[i].is_constant_expression(scope))return false;return true;}function walk_scoped(self,scope){var result=true;var scopes=[];self.walk(new TreeWalker(function(node,descend){if(!result)return true;if(node instanceof AST_BlockScope){if(node===self)return;scopes.push(node);descend();scopes.pop();return true;}if(node instanceof AST_SymbolRef){if(self.inlined||node.redef||node.in_arg){result=false;return true;}if(self.variables&&self.variables.has(node.name))return true;var def=node.definition();if(member(def.scope,scopes))return true;if(scope&&!def.redefined()){var scope_def=scope.find_variable(node.name);if(scope_def?scope_def===def:def.undeclared){result="f";return true;}}result=false;return true;}if(node instanceof AST_ObjectIdentity){if(is_arrow(self)&&all(scopes,function(s){return !(s instanceof AST_Scope)||is_arrow(s);}))result=false;return true;}}));return result;}def(AST_Node,return_false);def(AST_Array,function(scope){return all_constant(this.elements,scope);});def(AST_Binary,function(scope){return this.left.is_constant_expression(scope)&&this.right.is_constant_expression(scope)&&can_drop_op(this);});def(AST_Class,function(scope){var base=this.extends;if(base&&!safe_for_extends(base))return false;return all_constant(this.properties,scope);});def(AST_ClassProperty,function(scope){if(typeof this.key!="string")return false;var value=this.value;if(!value)return true;return this.static?value.is_constant_expression(scope):walk_scoped(value,scope);});def(AST_Constant,return_true);def(AST_Lambda,function(scope){return walk_scoped(this,scope);});def(AST_Object,function(scope){return all_constant(this.properties,scope);});def(AST_ObjectIdentity,function(scope){return this.scope.resolve()===scope;});def(AST_ObjectProperty,function(scope){return typeof this.key=="string"&&this.value.is_constant_expression(scope);});def(AST_Unary,function(scope){return this.expression.is_constant_expression(scope);});})(function(node,func){node.DEFMETHOD("is_constant_expression",func);});// tell me if a statement aborts
function aborts(thing){return thing&&thing.aborts();}(function(def){def(AST_Statement,return_null);def(AST_Jump,return_this);function block_aborts(){var n=this.body.length;return n>0&&aborts(this.body[n-1]);}def(AST_BlockStatement,block_aborts);def(AST_SwitchBranch,block_aborts);def(AST_If,function(){return this.alternative&&aborts(this.body)&&aborts(this.alternative)&&this;});})(function(node,func){node.DEFMETHOD("aborts",func);});/* -----[ optimizers ]----- */var directives=makePredicate(["use asm","use strict"]);OPT(AST_Directive,function(self,compressor){if(compressor.option("directives")&&(!directives[self.value]||compressor.has_directive(self.value)!==self)){return make_node(AST_EmptyStatement,self);}return self;});OPT(AST_Debugger,function(self,compressor){if(compressor.option("drop_debugger"))return make_node(AST_EmptyStatement,self);return self;});OPT(AST_LabeledStatement,function(self,compressor){if(self.body instanceof AST_If||self.body instanceof AST_Break){var body=tighten_body([self.body],compressor);switch(body.length){case 0:self.body=make_node(AST_EmptyStatement,self);break;case 1:self.body=body[0];break;default:self.body=make_node(AST_BlockStatement,self,{body:body});break;}}return compressor.option("unused")&&self.label.references.length==0?self.body:self;});OPT(AST_LoopControl,function(self,compressor){if(!compressor.option("dead_code"))return self;var label=self.label;if(label){var lct=compressor.loopcontrol_target(self);self.label=null;if(compressor.loopcontrol_target(self)===lct){remove(label.thedef.references,self);}else {self.label=label;}}return self;});OPT(AST_Block,function(self,compressor){self.body=tighten_body(self.body,compressor);return self;});function trim_block(node,parent,in_list){switch(node.body.length){case 0:return in_list?List.skip:make_node(AST_EmptyStatement,node);case 1:var stat=node.body[0];if(!safe_to_trim(stat))return node;if(parent instanceof AST_IterationStatement&&stat instanceof AST_LambdaDefinition)return node;return stat;}return node;}OPT(AST_BlockStatement,function(self,compressor){self.body=tighten_body(self.body,compressor);return trim_block(self,compressor.parent());});function drop_rest_farg(fn,compressor){if(!compressor.option("rests"))return;if(fn.uses_arguments)return;if(!(fn.rest instanceof AST_DestructuredArray))return;if(!compressor.drop_fargs(fn,compressor.parent()))return;fn.argnames=fn.argnames.concat(fn.rest.elements);fn.rest=fn.rest.rest;}OPT(AST_Lambda,function(self,compressor){drop_rest_farg(self,compressor);self.body=tighten_body(self.body,compressor);return self;});OPT(AST_Function,function(self,compressor){drop_rest_farg(self,compressor);self.body=tighten_body(self.body,compressor);var parent=compressor.parent();if(compressor.option("inline"))for(var i=0;i<self.body.length;i++){var stat=self.body[i];if(stat instanceof AST_Directive)continue;if(stat instanceof AST_Return){if(i!=self.body.length-1)break;var call=stat.value;if(!call||call.TYPE!="Call")break;if(call.is_expr_pure(compressor))break;var exp=call.expression,fn;if(!(exp instanceof AST_SymbolRef)){fn=exp;}else if(self.name&&self.name.definition()===exp.definition()){break;}else {fn=exp.fixed_value();}if(!(fn instanceof AST_Defun||fn instanceof AST_Function))break;if(fn.rest)break;if(fn.uses_arguments)break;if(fn===exp){if(fn.parent_scope!==self)break;if(!all(fn.enclosed,function(def){return def.scope!==self;}))break;}if((fn!==exp||fn.name)&&(parent instanceof AST_ClassMethod||parent instanceof AST_ObjectMethod)&&parent.value===compressor.self())break;if(fn.contains_this())break;var len=fn.argnames.length;if(len>0&&compressor.option("inline")<2)break;if(len>self.argnames.length)break;if(!all(self.argnames,function(argname){return argname instanceof AST_SymbolFunarg;}))break;if(!all(call.args,function(arg){return !(arg instanceof AST_Spread);}))break;for(var j=0;j<len;j++){var arg=call.args[j];if(!(arg instanceof AST_SymbolRef))break;if(arg.definition()!==self.argnames[j].definition())break;}if(j<len)break;for(;j<call.args.length;j++){if(call.args[j].has_side_effects(compressor))break;}if(j<call.args.length)break;if(len<self.argnames.length&&!compressor.drop_fargs(self,parent)){if(!compressor.drop_fargs(fn,call))break;do{fn.argnames.push(fn.make_var(AST_SymbolFunarg,fn,"argument_"+len));}while(++len<self.argnames.length);}return exp;}break;}return self;});var NO_MERGE=makePredicate("arguments await yield");AST_Scope.DEFMETHOD("merge_variables",function(compressor){if(!compressor.option("merge_vars"))return;var in_arg=[],in_try,root,segment={},self=this;var first=[],last=[],index=0;var declarations=new Dictionary();var references=Object.create(null);var prev=Object.create(null);var tw=new TreeWalker(function(node,descend){if(node instanceof AST_Assign){var lhs=node.left;var rhs=node.right;if(lhs instanceof AST_Destructured){rhs.walk(tw);walk_destructured(AST_SymbolRef,mark,lhs);return true;}if(lazy_op[node.operator.slice(0,-1)]){lhs.walk(tw);push();rhs.walk(tw);if(lhs instanceof AST_SymbolRef)mark(lhs);pop();return true;}if(lhs instanceof AST_SymbolRef){if(node.operator!="=")mark(lhs,true);rhs.walk(tw);mark(lhs);return true;}return;}if(node instanceof AST_Binary){if(!lazy_op[node.operator])return;walk_cond(node);return true;}if(node instanceof AST_Break){var target=tw.loopcontrol_target(node);if(!(target instanceof AST_IterationStatement))insert(target);return true;}if(node instanceof AST_Call){var exp=node.expression;if(exp instanceof AST_LambdaExpression){node.args.forEach(function(arg){arg.walk(tw);});exp.walk(tw);}else {descend();mark_expression(exp);}return true;}if(node instanceof AST_Class){if(node.name)node.name.walk(tw);if(node.extends)node.extends.walk(tw);node.properties.filter(function(prop){if(prop.key instanceof AST_Node)prop.key.walk(tw);return prop.value;}).forEach(function(prop){if(prop.static){prop.value.walk(tw);}else {push();segment.block=node;prop.value.walk(tw);pop();}});return true;}if(node instanceof AST_Conditional){walk_cond(node.condition,node.consequent,node.alternative);return true;}if(node instanceof AST_Continue){var target=tw.loopcontrol_target(node);if(target instanceof AST_Do)insert(target);return true;}if(node instanceof AST_Do){push();segment.block=node;segment.loop=true;var save=segment;node.body.walk(tw);if(segment.inserted===node)segment=save;node.condition.walk(tw);pop();return true;}if(node instanceof AST_For){if(node.init)node.init.walk(tw);push();segment.block=node;segment.loop=true;if(node.condition)node.condition.walk(tw);node.body.walk(tw);if(node.step)node.step.walk(tw);pop();return true;}if(node instanceof AST_ForEnumeration){node.object.walk(tw);push();segment.block=node;segment.loop=true;node.init.walk(tw);node.body.walk(tw);pop();return true;}if(node instanceof AST_If){walk_cond(node.condition,node.body,node.alternative);return true;}if(node instanceof AST_LabeledStatement){push();segment.block=node;var save=segment;node.body.walk(tw);if(segment.inserted===node)segment=save;pop();return true;}if(node instanceof AST_Scope){push();segment.block=node;if(node===self)root=segment;if(node instanceof AST_Lambda){if(node.name)references[node.name.definition().id]=false;var marker=node.uses_arguments&&!tw.has_directive("use strict")?function(node){references[node.definition().id]=false;}:function(node){mark(node);};in_arg.push(node);node.argnames.forEach(function(argname){walk_destructured(AST_SymbolFunarg,marker,argname);});if(node.rest)walk_destructured(AST_SymbolFunarg,marker,node.rest);in_arg.pop();}walk_lambda(node,tw);pop();return true;}if(node instanceof AST_Sub){var exp=node.expression;if(node.optional){exp.walk(tw);push();node.property.walk(tw);pop();}else {descend();}mark_expression(exp);return true;}if(node instanceof AST_Switch){node.expression.walk(tw);var save=segment;node.body.forEach(function(branch){if(branch instanceof AST_Default)return;branch.expression.walk(tw);if(save===segment)push();});segment=save;node.body.forEach(function(branch){push();segment.block=node;var save=segment;walk_body(branch,tw);if(segment.inserted===node)segment=save;pop();});return true;}if(node instanceof AST_SymbolDeclaration){references[node.definition().id]=false;return true;}if(node instanceof AST_SymbolRef){mark(node,true);return true;}if(node instanceof AST_Try){var save_try=in_try;in_try=node;walk_body(node,tw);if(node.bcatch){if(node.bcatch.argname)node.bcatch.argname.mark_symbol(function(node){if(node instanceof AST_SymbolCatch){var def=node.definition();references[def.id]=false;if(def=def.redefined())references[def.id]=false;}},tw);if(node.bfinally||(in_try=save_try)){walk_body(node.bcatch,tw);}else {push();walk_body(node.bcatch,tw);pop();}}in_try=save_try;if(node.bfinally)node.bfinally.walk(tw);return true;}if(node instanceof AST_Unary){if(!UNARY_POSTFIX[node.operator])return;var sym=node.expression;if(!(sym instanceof AST_SymbolRef))return;mark(sym,true);return true;}if(node instanceof AST_VarDef){var assigned=node.value;if(assigned){assigned.walk(tw);}else {assigned=segment.block instanceof AST_ForEnumeration&&segment.block.init===tw.parent();}walk_destructured(AST_SymbolDeclaration,assigned?function(node){if(node instanceof AST_SymbolVar){mark(node);}else {node.walk(tw);}}:function(node){if(node instanceof AST_SymbolVar){var id=node.definition().id;var refs=references[id];if(refs){refs.push(node);}else if(!(id in references)){declarations.add(id,node);}}else {node.walk(tw);}},node.name);return true;}if(node instanceof AST_While){push();segment.block=node;segment.loop=true;descend();pop();return true;}function mark_expression(exp){if(!compressor.option("ie"))return;var sym=root_expr(exp);if(sym instanceof AST_SymbolRef)sym.walk(tw);}function walk_cond(condition,consequent,alternative){var save=segment;var segments=scan_branches(1,condition,consequent,alternative);if(consequent){segment=segments.consequent.segment;for(var i=segments.consequent.level;--i>=0;)pop();if(segment!==save)return;}if(alternative){segment=segments.alternative.segment;for(var i=segments.alternative.level;--i>=0;)pop();if(segment!==save)return;}segment=save;}function scan_branches(level,condition,consequent,alternative){var segments={consequent:{segment:segment,level:level},alternative:{segment:segment,level:level}};if(condition instanceof AST_Binary)switch(condition.operator){case"&&":segments.consequent=scan_branches(level+1,condition.left,condition.right).consequent;break;case"||":segments.alternative=scan_branches(level+1,condition.left,null,condition.right).alternative;break;case"??":segments.alternative=scan_branches(level+1,condition.left,condition.right,condition.right).alternative;break;default:condition.walk(tw);break;}else if(condition instanceof AST_Conditional){scan_branches(level+1,condition.condition,condition.consequent,condition.alternative);}else {condition.walk(tw);}if(consequent){segment=segments.consequent.segment;push();consequent.walk(tw);segments.consequent.segment=segment;}if(alternative){segment=segments.alternative.segment;push();alternative.walk(tw);segments.alternative.segment=segment;}return segments;}});tw.directives=Object.create(compressor.directives);self.walk(tw);var changed=false;var merged=Object.create(null);while(first.length&&last.length){var tail=last.shift();if(!tail)continue;var def=tail.definition;var tail_refs=references[def.id];if(!tail_refs)continue;tail_refs={end:tail_refs.end};while(def.id in merged)def=merged[def.id];tail_refs.start=references[def.id].start;var skipped=[];do{var head=first.shift();if(tail.index>head.index)continue;var prev_def=head.definition;if(!(prev_def.id in prev))continue;var head_refs=references[prev_def.id];if(!head_refs)continue;if(head_refs.start.block!==tail_refs.start.block||!mergeable(head_refs,tail_refs)||(head_refs.start.loop||!same_scope(def))&&!mergeable(tail_refs,head_refs)||compressor.option("webkit")&&is_funarg(def)!==is_funarg(prev_def)||prev_def.const_redefs||!all(head_refs.scopes,function(scope){return scope.find_variable(def.name)===def;})){skipped.push(head);continue;}head_refs.forEach(function(sym){sym.thedef=def;sym.name=def.name;if(sym instanceof AST_SymbolRef){def.references.push(sym);prev_def.replaced++;}else {def.orig.push(sym);prev_def.eliminated++;}});if(!prev_def.fixed)def.fixed=false;merged[prev_def.id]=def;changed=true;break;}while(first.length);if(skipped.length)first=skipped.concat(first);}return changed;function push(){segment=Object.create(segment);}function pop(){segment=Object.getPrototypeOf(segment);}function walk_destructured(symbol_type,mark,lhs){var marker=new TreeWalker(function(node){if(node instanceof AST_Destructured)return;if(node instanceof AST_DefaultValue){push();node.value.walk(tw);pop();node.name.walk(marker);}else if(node instanceof AST_DestructuredKeyVal){if(!(node.key instanceof AST_Node)){node.value.walk(marker);}else if(node.value instanceof AST_PropAccess){push();segment.block=node;node.key.walk(tw);node.value.walk(marker);pop();}else {node.key.walk(tw);node.value.walk(marker);}}else if(node instanceof symbol_type){mark(node);}else {node.walk(tw);}return true;});lhs.walk(marker);}function mark(sym,read){var def=sym.definition(),ldef;if(read&&!all(in_arg,function(fn){ldef=fn.variables.get(sym.name);if(!ldef)return true;if(!is_funarg(ldef))return true;return ldef!==def&&!def.undeclared&&fn.parent_scope.find_variable(sym.name)!==def;}))return references[def.id]=references[ldef.id]=false;var seg=segment;if(in_try){push();seg=segment;pop();}if(def.id in references){var refs=references[def.id];if(!refs)return;if(refs.start.block!==seg.block)return references[def.id]=false;push_ref(sym);refs.end=seg;if(def.id in prev){last[prev[def.id]]=null;}else if(!read){return;}}else if((ldef=self.variables.get(def.name))!==def){if(ldef&&root===seg)references[ldef.id]=false;return references[def.id]=false;}else if(compressor.exposed(def)||NO_MERGE[sym.name]){return references[def.id]=false;}else {var refs=declarations.get(def.id)||[];refs.scopes=[];push_ref(sym);references[def.id]=refs;if(!read){refs.start=seg;return first.push({index:index++,definition:def});}if(seg.block!==self)return references[def.id]=false;refs.start=root;}prev[def.id]=last.length;last.push({index:index++,definition:def});function push_ref(sym){refs.push(sym);push_uniq(refs.scopes,sym.scope);var scope=find_scope(tw);if(scope!==sym.scope)push_uniq(refs.scopes,scope);}}function insert(target){var stack=[];while(true){if(HOP(segment,"block")){var block=segment.block;if(block instanceof AST_LabeledStatement)block=block.body;if(block===target)break;}stack.push(segment);pop();}segment.inserted=segment.block;push();while(stack.length){var seg=stack.pop();push();if(HOP(seg,"block"))segment.block=seg.block;if(HOP(seg,"loop"))segment.loop=seg.loop;}}function must_visit(base,segment){return base===segment||base.isPrototypeOf(segment);}function mergeable(head,tail){return must_visit(head.start,head.end)||must_visit(head.start,tail.start);}});function fill_holes(orig,elements){for(var i=elements.length;--i>=0;){if(!elements[i])elements[i]=make_node(AST_Hole,orig);}}function to_class_expr(defcl,drop_name){var cl=make_node(AST_ClassExpression,defcl);if(cl.name)cl.name=drop_name?null:make_node(AST_SymbolClass,cl.name);return cl;}function to_func_expr(defun,drop_name){var ctor;switch(defun.CTOR){case AST_AsyncDefun:ctor=AST_AsyncFunction;break;case AST_AsyncGeneratorDefun:ctor=AST_AsyncGeneratorFunction;break;case AST_Defun:ctor=AST_Function;break;case AST_GeneratorDefun:ctor=AST_GeneratorFunction;break;}var fn=make_node(ctor,defun);fn.name=drop_name?null:make_node(AST_SymbolLambda,defun.name);return fn;}AST_Scope.DEFMETHOD("drop_unused",function(compressor){if(!compressor.option("unused"))return;var self=this;var drop_funcs=!(self instanceof AST_Toplevel)||compressor.toplevel.funcs;var drop_vars=!(self instanceof AST_Toplevel)||compressor.toplevel.vars;var assign_as_unused=/keep_assign/.test(compressor.option("unused"))?return_false:function(node,props){var sym,nested=false;if(node instanceof AST_Assign){if(node.write_only||node.operator=="=")sym=extract_reference(node.left,props);}else if(node instanceof AST_Unary){if(node.write_only)sym=extract_reference(node.expression,props);}if(!(sym instanceof AST_SymbolRef))return;var def=sym.definition();if(export_defaults[def.id])return;if(compressor.exposed(def))return;if(!can_drop_symbol(sym,compressor,nested))return;return sym;function extract_reference(node,props){if(node instanceof AST_PropAccess){var expr=node.expression;if(!expr.may_throw_on_access(compressor,true)){nested=true;if(props&&node instanceof AST_Sub)props.unshift(node.property);return extract_reference(expr,props);}}else if(node instanceof AST_Assign&&node.operator=="="){node.write_only="p";var ref=extract_reference(node.right);if(!props)return ref;props.assign=node;return ref instanceof AST_SymbolRef?ref:node.left;}return node;}};var assign_in_use=Object.create(null);var export_defaults=Object.create(null);var find_variable=function(name){find_variable=compose(self,0,noop);return find_variable(name);function compose(child,level,find){var parent=compressor.parent(level);if(!parent)return find;var in_arg=parent instanceof AST_Lambda&&member(child,parent.argnames);return compose(parent,level+1,in_arg?function(name){var def=find(name);if(def)return def;def=parent.variables.get(name);if(def){var sym=def.orig[0];if(sym instanceof AST_SymbolFunarg||sym instanceof AST_SymbolLambda)return def;}}:parent.variables?function(name){return find(name)||parent.variables.get(name);}:find);}};var for_ins=Object.create(null);var in_use=[];var in_use_ids=Object.create(null);// avoid expensive linear scans of in_use
var lambda_ids=Object.create(null);var value_read=Object.create(null);var value_modified=Object.create(null);var var_defs=Object.create(null);if(self instanceof AST_Toplevel&&compressor.top_retain){self.variables.each(function(def){if(compressor.top_retain(def)&&!(def.id in in_use_ids)){AST_Node.info("Retaining variable {name}",def);in_use_ids[def.id]=true;in_use.push(def);}});}var assignments=new Dictionary();var initializations=new Dictionary();// pass 1: find out which symbols are directly used in
// this scope (not in nested scopes).
var scope=this;var tw=new TreeWalker(function(node,descend){if(node instanceof AST_Lambda&&node.uses_arguments&&!tw.has_directive("use strict")){node.each_argname(function(argname){var def=argname.definition();if(!(def.id in in_use_ids)){in_use_ids[def.id]=true;in_use.push(def);}});}if(node===self)return;if(scope===self){if(node instanceof AST_DefClass){var def=node.name.definition();var drop=drop_funcs&&!def.exported;if(!drop&&!(def.id in in_use_ids)){in_use_ids[def.id]=true;in_use.push(def);}var used=tw.parent()instanceof AST_ExportDefault;if(used){export_defaults[def.id]=true;}else if(drop&&!(def.id in lambda_ids)){lambda_ids[def.id]=1;}if(node.extends)node.extends.walk(tw);var values=[];node.properties.forEach(function(prop){if(prop.key instanceof AST_Node)prop.key.walk(tw);var value=prop.value;if(!value)return;if(is_static_field_or_init(prop)){if(!used&&value.contains_this())used=true;walk_class_prop(value);}else {values.push(value);}});values.forEach(drop&&used?walk_class_prop:function(value){initializations.add(def.id,value);});return true;}if(node instanceof AST_LambdaDefinition){var def=node.name.definition();var drop=drop_funcs&&!def.exported;if(!drop&&!(def.id in in_use_ids)){in_use_ids[def.id]=true;in_use.push(def);}initializations.add(def.id,node);if(tw.parent()instanceof AST_ExportDefault){export_defaults[def.id]=true;return scan_ref_scoped(node,descend,true);}if(drop&&!(def.id in lambda_ids))lambda_ids[def.id]=1;return true;}if(node instanceof AST_Definitions){node.definitions.forEach(function(defn){var value=defn.value;var side_effects=value&&(defn.name instanceof AST_Destructured||value.has_side_effects(compressor));var shared=side_effects&&value.tail_node().operator=="=";defn.name.mark_symbol(function(name){if(!(name instanceof AST_SymbolDeclaration))return;var def=name.definition();var_defs[def.id]=(var_defs[def.id]||0)+1;if(node instanceof AST_Var&&def.orig[0]instanceof AST_SymbolCatch){var redef=def.redefined();if(redef)var_defs[redef.id]=(var_defs[redef.id]||0)+1;}if(!(def.id in in_use_ids)&&(!drop_vars||def.exported||(node instanceof AST_Const?def.redefined():def.const_redefs)||!(node instanceof AST_Var||is_safe_lexical(def)))){in_use_ids[def.id]=true;in_use.push(def);}if(value){if(!side_effects){initializations.add(def.id,value);}else if(shared){verify_safe_usage(def,name,value_modified[def.id]);}assignments.add(def.id,defn);}unmark_lambda(def);return true;},tw);if(side_effects)value.walk(tw);});return true;}if(node instanceof AST_SymbolFunarg){var def=node.definition();var_defs[def.id]=(var_defs[def.id]||0)+1;assignments.add(def.id,node);var fixed=node.fixed_value(true);if(fixed&&fixed.tail_node().operator=="="){verify_safe_usage(def,node,value_modified[def.id]);}return true;}if(node instanceof AST_SymbolImport){var def=node.definition();if(!(def.id in in_use_ids)&&(!drop_vars||!is_safe_lexical(def))){in_use_ids[def.id]=true;in_use.push(def);}return true;}}return scan_ref_scoped(node,descend,true);function walk_class_prop(value){var save_scope=scope;scope=node;value.walk(tw);scope=save_scope;}});tw.directives=Object.create(compressor.directives);self.walk(tw);var drop_fn_name=compressor.option("keep_fnames")?return_false:compressor.option("ie")?function(def){return !compressor.exposed(def)&&def.references.length==def.replaced;}:function(def){if(!(def.id in in_use_ids))return true;if(def.orig.length-def.eliminated<2)return false;// function argument will always overshadow its name
if(def.orig[1]instanceof AST_SymbolFunarg)return true;// retain if referenced within destructured object of argument
return all(def.references,function(ref){return !ref.in_arg;});};if(compressor.option("ie"))initializations.each(function(init,id){if(id in in_use_ids)return;init.forEach(function(init){init.walk(new TreeWalker(function(node){if(node instanceof AST_Function&&node.name&&!drop_fn_name(node.name.definition())){node.walk(tw);return true;}if(node instanceof AST_Scope)return true;}));});});// pass 2: for every used symbol we need to walk its
// initialization code to figure out if it uses other
// symbols (that may not be in_use).
tw=new TreeWalker(scan_ref_scoped);for(var i=0;i<in_use.length;i++){var init=initializations.get(in_use[i].id);if(init)init.forEach(function(init){init.walk(tw);});}Object.keys(assign_in_use).forEach(function(id){var assigns=assign_in_use[id];if(!assigns){delete assign_in_use[id];return;}assigns=assigns.reduce(function(in_use,assigns){assigns.forEach(function(assign){push_uniq(in_use,assign);});return in_use;},[]);var in_use=(assignments.get(id)||[]).filter(function(node){return find_if(node instanceof AST_Unary?function(assign){return assign===node;}:function(assign){if(assign===node)return true;if(assign instanceof AST_Unary)return false;return get_rvalue(assign)===get_rvalue(node);},assigns);});if(assigns.length==in_use.length){assign_in_use[id]=in_use;}else {delete assign_in_use[id];}});// pass 3: we should drop declarations not in_use
var calls_to_drop_args=[];var fns_with_marked_args=[];var trimmer=new TreeTransformer(function(node){if(node instanceof AST_DefaultValue)return trim_default(trimmer,node);if(node instanceof AST_Destructured&&node.rest)node.rest=node.rest.transform(trimmer);if(node instanceof AST_DestructuredArray){var trim=!node.rest;for(var i=node.elements.length;--i>=0;){var element=node.elements[i].transform(trimmer);if(element){node.elements[i]=element;trim=false;}else if(trim){node.elements.pop();}else {node.elements[i]=make_node(AST_Hole,node.elements[i]);}}return node;}if(node instanceof AST_DestructuredObject){var properties=[];node.properties.forEach(function(prop){var retain=false;if(prop.key instanceof AST_Node){prop.key=prop.key.transform(tt);retain=prop.key.has_side_effects(compressor);}if((retain||node.rest)&&is_decl(prop.value)){prop.value=prop.value.transform(tt);properties.push(prop);}else {var value=prop.value.transform(trimmer);if(!value&&node.rest){if(prop.value instanceof AST_DestructuredArray){value=make_node(AST_DestructuredArray,prop.value,{elements:[]});}else {value=make_node(AST_DestructuredObject,prop.value,{properties:[]});}}if(value){prop.value=value;properties.push(prop);}}});node.properties=properties;return node;}if(node instanceof AST_SymbolDeclaration)return trim_decl(node);});var tt=new TreeTransformer(function(node,descend,in_list){var parent=tt.parent();if(drop_vars){var props=[],sym=assign_as_unused(node,props);if(sym){var value;if(can_drop_lhs(sym,node)){if(node instanceof AST_Assign){value=get_rhs(node);if(node.write_only===true)value=value.drop_side_effect_free(compressor);}if(!value)value=make_node(AST_Number,node,{value:0});}if(value){if(props.assign){var assign=props.assign.drop_side_effect_free(compressor);if(assign){assign.write_only=true;props.unshift(assign);}}if(!(parent instanceof AST_Sequence)||parent.tail_node()===node||value.has_side_effects(compressor)){props.push(value);}switch(props.length){case 0:return List.skip;case 1:return maintain_this_binding(parent,node,props[0].transform(tt));default:return make_sequence(node,props.map(function(prop){return prop.transform(tt);}));}}}else if(node instanceof AST_UnaryPostfix&&node.expression instanceof AST_SymbolRef&&indexOf_assign(node.expression.definition(),node)<0){return make_node(AST_UnaryPrefix,node,{operator:"+",expression:node.expression});}}if(node instanceof AST_Binary&&node.operator=="instanceof"){var sym=node.right;if(!(sym instanceof AST_SymbolRef))return;if(sym.definition().id in in_use_ids)return;var lhs=node.left.drop_side_effect_free(compressor);var value=make_node(AST_False,node).optimize(compressor);return lhs?make_sequence(node,[lhs,value]):value;}if(node instanceof AST_Call){calls_to_drop_args.push(node);node.args=node.args.map(function(arg){return arg.transform(tt);});node.expression=node.expression.transform(tt);return node;}if(scope!==self)return;if(drop_funcs&&node!==self&&node instanceof AST_DefClass){var def=node.name.definition();if(!(def.id in in_use_ids)){log(node.name,"Dropping unused class {name}");def.eliminated++;descend(node,tt);var trimmed=to_class_expr(node,true);if(parent instanceof AST_ExportDefault)return trimmed;trimmed=trimmed.drop_side_effect_free(compressor,true);if(trimmed)return make_node(AST_SimpleStatement,node,{body:trimmed});return in_list?List.skip:make_node(AST_EmptyStatement,node);}}if(node instanceof AST_ClassExpression&&node.name&&drop_fn_name(node.name.definition())){node.name=null;}if(node instanceof AST_Lambda){if(drop_funcs&&node!==self&&node instanceof AST_LambdaDefinition){var def=node.name.definition();if(!(def.id in in_use_ids)){log(node.name,"Dropping unused function {name}");def.eliminated++;if(parent instanceof AST_ExportDefault){descend_scope();return to_func_expr(node,true);}return in_list?List.skip:make_node(AST_EmptyStatement,node);}}descend_scope();if(node instanceof AST_LambdaExpression&&node.name&&drop_fn_name(node.name.definition())){node.name=null;}if(!(node instanceof AST_Accessor)){var args,spread,trim=compressor.drop_fargs(node,parent);if(trim&&parent instanceof AST_Call&&parent.expression===node){args=parent.args;for(spread=0;spread<args.length;spread++){if(args[spread]instanceof AST_Spread)break;}}var argnames=node.argnames;var rest=node.rest;var after=false,before=false;if(rest){before=true;if(!args||spread<argnames.length||rest instanceof AST_SymbolFunarg){rest=rest.transform(trimmer);}else {var trimmed=trim_destructured(rest,make_node(AST_Array,parent,{elements:args.slice(argnames.length)}),trim_decl,!node.uses_arguments,rest);rest=trimmed.name;args.length=argnames.length;if(trimmed.value.elements.length)[].push.apply(args,trimmed.value.elements);}if(rest instanceof AST_Destructured&&!rest.rest){if(rest instanceof AST_DestructuredArray){if(rest.elements.length==0)rest=null;}else if(rest.properties.length==0){rest=null;}}node.rest=rest;if(rest){trim=false;after=true;}}var default_length=trim?-1:node.length();var trim_value=args&&!node.uses_arguments&&parent!==compressor.parent();for(var i=argnames.length;--i>=0;){var sym=argnames[i];if(sym instanceof AST_SymbolFunarg){var def=sym.definition();if(def.id in in_use_ids){trim=false;if(indexOf_assign(def,sym)<0)sym.unused=null;}else if(trim){log(sym,"Dropping unused function argument {name}");argnames.pop();def.eliminated++;sym.unused=true;}else {sym.unused=true;}}else {before=true;var funarg;if(!args||spread<i){funarg=sym.transform(trimmer);}else {var trimmed=trim_destructured(sym,args[i],trim_decl,trim_value,sym);funarg=trimmed.name;if(trimmed.value)args[i]=trimmed.value;}if(funarg){trim=false;argnames[i]=funarg;if(!after)after=!(funarg instanceof AST_SymbolFunarg);}else if(trim){log_default(sym,"Dropping unused default argument {name}");argnames.pop();}else if(i>default_length){log_default(sym,"Dropping unused default argument assignment {name}");if(sym.name instanceof AST_SymbolFunarg){sym.name.unused=true;}else {after=true;}argnames[i]=sym.name;}else {log_default(sym,"Dropping unused default argument value {name}");argnames[i]=sym=sym.clone();sym.value=make_node(AST_Number,sym,{value:0});after=true;}}}if(before&&!after&&node.uses_arguments&&!tt.has_directive("use strict")){node.rest=make_node(AST_DestructuredArray,node,{elements:[]});}fns_with_marked_args.push(node);}return node;}if(node instanceof AST_Catch&&node.argname instanceof AST_Destructured){node.argname.transform(trimmer);}if(node instanceof AST_Definitions&&!(parent instanceof AST_ForEnumeration&&parent.init===node)){// place uninitialized names at the start
var body=[],head=[],tail=[];// for unused names whose initialization has
// side effects, we can cascade the init. code
// into the next one, or next statement.
var side_effects=[];var duplicated=0;var is_var=node instanceof AST_Var;node.definitions.forEach(function(def){if(def.value)def.value=def.value.transform(tt);var value=def.value;if(def.name instanceof AST_Destructured){var trimmed=trim_destructured(def.name,value,function(node){if(!drop_vars)return node;if(node.definition().id in in_use_ids)return node;if(is_catch(node))return node;if(is_var&&!can_drop_symbol(node))return node;return null;},true);if(trimmed.name){def=make_node(AST_VarDef,def,{name:trimmed.name,value:value=trimmed.value});flush();}else if(trimmed.value){side_effects.push(trimmed.value);}return;}var sym=def.name.definition();var drop_sym=is_var?can_drop_symbol(def.name):is_safe_lexical(sym);if(!drop_sym||!drop_vars||sym.id in in_use_ids){var index;if(value&&((index=indexOf_assign(sym,def))<0||self_assign(value.tail_node()))){def=def.clone();value=value.drop_side_effect_free(compressor);if(value)AST_Node.warn("Side effects in definition of variable {name} [{start}]",def.name);if(node instanceof AST_Const){def.value=value||make_node(AST_Number,def,{value:0});}else {def.value=null;if(value)side_effects.push(value);}value=null;if(index>=0)assign_in_use[sym.id][index]=def;}var old_def,fn;if(!value&&!(node instanceof AST_Let)){if(parent instanceof AST_ExportDeclaration){flush();}else if(drop_sym&&var_defs[sym.id]>1){AST_Node.info("Dropping declaration of variable {name} [{start}]",def.name);var_defs[sym.id]--;sym.eliminated++;}else {head.push(def);}}else if(compressor.option("functions")&&!compressor.option("ie")&&drop_sym&&value&&var_defs[sym.id]==1&&sym.assignments==0&&(fn=value.tail_node())instanceof AST_LambdaExpression&&!is_arguments(sym)&&!is_arrow(fn)&&assigned_once(fn,sym.references)&&can_declare_defun(fn)&&(old_def=rename_def(fn,def.name.name))!==false){AST_Node.warn("Declaring {name} as function [{start}]",def.name);var ctor;switch(fn.CTOR){case AST_AsyncFunction:ctor=AST_AsyncDefun;break;case AST_AsyncGeneratorFunction:ctor=AST_AsyncGeneratorDefun;break;case AST_Function:ctor=AST_Defun;break;case AST_GeneratorFunction:ctor=AST_GeneratorDefun;break;}var defun=make_node(ctor,fn);defun.name=make_node(AST_SymbolDefun,def.name);var name_def=def.name.scope.resolve().def_function(defun.name);if(old_def)old_def.forEach(function(node){node.name=name_def.name;node.thedef=name_def;node.reference();});body.push(defun);if(value!==fn)[].push.apply(side_effects,value.expressions.slice(0,-1));sym.eliminated++;}else {if(drop_sym&&var_defs[sym.id]>1&&!(parent instanceof AST_ExportDeclaration)&&sym.orig.indexOf(def.name)>sym.eliminated){var_defs[sym.id]--;duplicated++;}flush();}}else if(is_catch(def.name)){value=value&&value.drop_side_effect_free(compressor);if(value)side_effects.push(value);if(var_defs[sym.id]>1){AST_Node.warn("Dropping duplicated declaration of variable {name} [{start}]",def.name);var_defs[sym.id]--;sym.eliminated++;}else {def.value=null;head.push(def);}}else {value=value&&value.drop_side_effect_free(compressor);if(value){AST_Node.warn("Side effects in initialization of unused variable {name} [{start}]",def.name);side_effects.push(value);}else {log(def.name,"Dropping unused variable {name}");}sym.eliminated++;}function self_assign(ref){return ref instanceof AST_SymbolRef&&ref.definition()===sym;}function assigned_once(fn,refs){if(refs.length==0)return fn===def.name.fixed_value();return all(refs,function(ref){return fn===ref.fixed_value();});}function can_declare_defun(fn){if(!is_var||compressor.has_directive("use strict")||!(fn instanceof AST_Function)){return parent instanceof AST_Scope;}return parent instanceof AST_Block||parent instanceof AST_For&&parent.init===node||parent instanceof AST_If;}function rename_def(fn,name){if(!fn.name)return null;var def=fn.name.definition();if(def.orig.length>1)return null;if(def.assignments>0)return false;if(def.name==name)return def;if(compressor.option("keep_fnames"))return false;var forbidden;switch(name){case"await":forbidden=is_async;break;case"yield":forbidden=is_generator;break;}return all(def.references,function(ref){var scope=ref.scope;if(scope.find_variable(name)!==sym)return false;if(forbidden)do{scope=scope.resolve();if(forbidden(scope))return false;}while(scope!==fn&&(scope=scope.parent_scope));return true;})&&def;}function is_catch(node){var sym=node.definition();return sym.orig[0]instanceof AST_SymbolCatch&&sym.scope.resolve()===node.scope.resolve();}function flush(){if(side_effects.length>0){if(tail.length==0){body.push(make_node(AST_SimpleStatement,node,{body:make_sequence(node,side_effects)}));}else if(value){side_effects.push(value);def.value=make_sequence(value,side_effects);}else {def.value=make_node(AST_UnaryPrefix,def,{operator:"void",expression:make_sequence(def,side_effects)});}side_effects=[];}tail.push(def);}});switch(head.length){case 0:if(tail.length==0)break;if(tail.length==duplicated){[].unshift.apply(side_effects,tail.map(function(def){AST_Node.info("Dropping duplicated definition of variable {name} [{start}]",def.name);var sym=def.name.definition();var ref=make_node(AST_SymbolRef,def.name);sym.references.push(ref);var assign=make_node(AST_Assign,def,{operator:"=",left:ref,right:def.value});var index=indexOf_assign(sym,def);if(index>=0)assign_in_use[sym.id][index]=assign;sym.assignments++;sym.eliminated++;return assign;}));break;}case 1:if(tail.length==0){var id=head[0].name.definition().id;if(id in for_ins){node.definitions=head;for_ins[id].init=node;break;}}default:var seq;if(tail.length>0&&(seq=tail[0].value)instanceof AST_Sequence){tail[0].value=seq.tail_node();body.push(make_node(AST_SimpleStatement,node,{body:make_sequence(seq,seq.expressions.slice(0,-1))}));}node.definitions=head.concat(tail);body.push(node);}if(side_effects.length>0){body.push(make_node(AST_SimpleStatement,node,{body:make_sequence(node,side_effects)}));}return insert_statements(body,node,in_list);}if(node instanceof AST_Assign){descend(node,tt);if(!(node.left instanceof AST_Destructured))return node;var trimmed=trim_destructured(node.left,node.right,function(node){return node;},node.write_only===true);if(trimmed.name)return make_node(AST_Assign,node,{operator:node.operator,left:trimmed.name,right:trimmed.value});if(trimmed.value)return trimmed.value;if(parent instanceof AST_Sequence&&parent.tail_node()!==node)return List.skip;return make_node(AST_Number,node,{value:0});}if(node instanceof AST_LabeledStatement&&node.body instanceof AST_For){// Certain combination of unused name + side effect leads to invalid AST:
//    https://github.com/mishoo/UglifyJS/issues/1830
// We fix it at this stage by moving the label inwards, back to the `for`.
descend(node,tt);if(node.body instanceof AST_BlockStatement){var block=node.body;node.body=block.body.pop();block.body.push(node);return in_list?List.splice(block.body):block;}return node;}if(node instanceof AST_Scope){descend_scope();return node;}if(node instanceof AST_SymbolImport){if(!compressor.option("imports")||node.definition().id in in_use_ids)return node;return in_list?List.skip:null;}function descend_scope(){var save_scope=scope;scope=node;descend(node,tt);scope=save_scope;}},function(node,in_list){if(node instanceof AST_BlockStatement)return trim_block(node,tt.parent(),in_list);if(node instanceof AST_ExportDeclaration){var block=node.body;if(!(block instanceof AST_BlockStatement))return;node.body=block.body.pop();block.body.push(node);return in_list?List.splice(block.body):block;}if(node instanceof AST_For)return patch_for_init(node,in_list);if(node instanceof AST_ForIn){if(!drop_vars||!compressor.option("loops"))return;if(!is_empty(node.body))return;var sym=get_init_symbol(node);if(!sym)return;var def=sym.definition();if(def.id in in_use_ids)return;log(sym,"Dropping unused loop variable {name}");if(for_ins[def.id]===node)delete for_ins[def.id];var body=[];var value=node.object.drop_side_effect_free(compressor);if(value){AST_Node.warn("Side effects in object of for-in loop [{start}]",value);body.push(make_node(AST_SimpleStatement,node,{body:value}));}if(node.init instanceof AST_Definitions&&def.orig[0]instanceof AST_SymbolCatch){body.push(node.init);}return insert_statements(body,node,in_list);}if(node instanceof AST_Import){if(node.properties&&node.properties.length==0)node.properties=null;return node;}if(node instanceof AST_Sequence){if(node.expressions.length>1)return;return maintain_this_binding(tt.parent(),node,node.expressions[0]);}});tt.push(compressor.parent());tt.directives=Object.create(compressor.directives);self.transform(tt);if(self instanceof AST_Lambda&&self.body.length==1&&self.body[0]instanceof AST_Directive&&self.body[0].value=="use strict"){self.body.length=0;}calls_to_drop_args.forEach(function(call){drop_unused_call_args(call,compressor,fns_with_marked_args);});function log(sym,text){AST_Node[sym.definition().references.length>0?"info":"warn"](text+" [{start}]",sym);}function log_default(node,text){if(node.name instanceof AST_SymbolFunarg){log(node.name,text);}else {AST_Node.info(text+" [{start}]",node);}}function get_rvalue(expr){return expr[expr instanceof AST_Assign?"right":"value"];}function insert_statements(body,orig,in_list){switch(body.length){case 0:return in_list?List.skip:make_node(AST_EmptyStatement,orig);case 1:return body[0];default:return in_list?List.splice(body):make_node(AST_BlockStatement,orig,{body:body});}}function track_assigns(def,node){if(def.scope.resolve()!==self)return false;if(!def.fixed||!node.fixed)assign_in_use[def.id]=false;return assign_in_use[def.id]!==false;}function add_assigns(def,node){if(!assign_in_use[def.id])assign_in_use[def.id]=[];if(node.fixed.assigns)push_uniq(assign_in_use[def.id],node.fixed.assigns);}function indexOf_assign(def,node){var nodes=assign_in_use[def.id];return nodes&&nodes.indexOf(node);}function unmark_lambda(def){if(lambda_ids[def.id]>1&&!(def.id in in_use_ids)){in_use_ids[def.id]=true;in_use.push(def);}lambda_ids[def.id]=0;}function verify_safe_usage(def,read,modified){if(def.id in in_use_ids)return;if(read&&modified){in_use_ids[def.id]=read;in_use.push(def);}else {value_read[def.id]=read;value_modified[def.id]=modified;}}function can_drop_lhs(sym,node){var def=sym.definition();var in_use=in_use_ids[def.id];if(!in_use)return true;if(node[node instanceof AST_Assign?"left":"expression"]!==sym)return false;return in_use===sym&&def.references.length-def.replaced==1||indexOf_assign(def,node)<0;}function get_rhs(assign){var rhs=assign.right;if(!assign.write_only)return rhs;if(!(rhs instanceof AST_Binary&&lazy_op[rhs.operator]))return rhs;if(!(rhs.left instanceof AST_SymbolRef))return rhs;if(!(assign.left instanceof AST_SymbolRef))return rhs;var def=assign.left.definition();if(rhs.left.definition()!==def)return rhs;if(rhs.right.has_side_effects(compressor))return rhs;if(track_assigns(def,rhs.left))add_assigns(def,rhs.left);return rhs.right;}function get_init_symbol(for_in){var init=for_in.init;if(init instanceof AST_Definitions){init=init.definitions[0].name;return init instanceof AST_SymbolDeclaration&&init;}while(init instanceof AST_PropAccess)init=init.expression.tail_node();if(init instanceof AST_SymbolRef)return init;}function scan_ref_scoped(node,descend,init){if(node instanceof AST_Assign&&node.left instanceof AST_SymbolRef){var def=node.left.definition();if(def.scope.resolve()===self)assignments.add(def.id,node);}if(node instanceof AST_SymbolRef&&node.in_arg)var_defs[node.definition().id]=0;if(node instanceof AST_Unary&&node.expression instanceof AST_SymbolRef){var def=node.expression.definition();if(def.scope.resolve()===self)assignments.add(def.id,node);}var props=[],sym=assign_as_unused(node,props);if(sym){var node_def=sym.definition();if(node_def.scope.resolve()!==self&&self.variables.get(sym.name)!==node_def)return;if(is_arguments(node_def)&&!all(self.argnames,function(argname){return !argname.match_symbol(function(node){if(node instanceof AST_SymbolFunarg){var def=node.definition();return def.references.length>def.replaced;}},true);}))return;if(node.write_only==="p"&&node.right.may_throw_on_access(compressor,true))return;var assign=props.assign;if(assign){initializations.add(node_def.id,assign.left);assign.write_only=true;assign.walk(tw);}props.forEach(function(prop){prop.walk(tw);});if(node instanceof AST_Assign){var fixed=sym.fixed_value();var right=get_rhs(node);var safe=fixed&&fixed.is_constant();var shared=false;if(init&&node.write_only===true&&(safe||node.left===sym||right.equals(sym))&&!right.has_side_effects(compressor)){initializations.add(node_def.id,right);}else {right.walk(tw);shared=right.tail_node().operator=="=";}if(node.left===sym){if(!node.write_only||shared){verify_safe_usage(node_def,sym,value_modified[node_def.id]);}}else if(!safe){verify_safe_usage(node_def,value_read[node_def.id],true);}}if(track_assigns(node_def,sym)&&is_lhs(sym,node)!==sym)add_assigns(node_def,sym);unmark_lambda(node_def);return true;}if(node instanceof AST_Binary){if(node.operator!="instanceof")return;var sym=node.right;if(!(sym instanceof AST_SymbolRef))return;var id=sym.definition().id;if(!lambda_ids[id])return;node.left.walk(tw);lambda_ids[id]++;return true;}if(node instanceof AST_ForIn){if(node.init instanceof AST_SymbolRef&&scope===self){var id=node.init.definition().id;if(!(id in for_ins))for_ins[id]=node;}if(!drop_vars||!compressor.option("loops"))return;if(!is_empty(node.body))return;if(node.init.has_side_effects(compressor))return;var sym=get_init_symbol(node);if(!sym)return;var def=sym.definition();if(def.scope.resolve()!==self){var d=find_variable(sym.name);if(d===def||d&&d.redefined()===def)return;}node.object.walk(tw);return true;}if(node instanceof AST_SymbolRef){var node_def=node.definition();if(!(node_def.id in in_use_ids)){in_use_ids[node_def.id]=true;in_use.push(node_def);}if(cross_scope(node_def.scope,node.scope)){var redef=node_def.redefined();if(redef&&!(redef.id in in_use_ids)){in_use_ids[redef.id]=true;in_use.push(redef);}}if(track_assigns(node_def,node))add_assigns(node_def,node);return true;}if(node instanceof AST_Scope){var save_scope=scope;scope=node;descend();scope=save_scope;return true;}}function is_decl(node){return (node instanceof AST_DefaultValue?node.name:node)instanceof AST_SymbolDeclaration;}function trim_decl(node){if(node.definition().id in in_use_ids)return node;if(node instanceof AST_SymbolFunarg)node.unused=true;return null;}function trim_default(trimmer,node){node.value=node.value.transform(tt);var name=node.name.transform(trimmer);if(!name){if(node.name instanceof AST_Destructured)return null;var value=node.value.drop_side_effect_free(compressor);if(!value)return null;log(node.name,"Side effects in default value of unused variable {name}");node=node.clone();node.name.unused=null;node.value=value;}return node;}function trim_destructured(node,value,process,drop,root){var unwind=true;var trimmer=new TreeTransformer(function(node){if(node instanceof AST_DefaultValue){if(!(compressor.option("default_values")&&value&&value.is_defined(compressor))){var save_drop=drop;drop=false;var trimmed=trim_default(trimmer,node);drop=save_drop;if(!trimmed&&drop&&value)value=value.drop_side_effect_free(compressor);return trimmed;}else if(node===root){root=node=node.name;}else {node=node.name;}}if(node instanceof AST_DestructuredArray){var save_drop=drop;var save_unwind=unwind;var save_value=value;if(value instanceof AST_SymbolRef){drop=false;value=value.fixed_value();}var last_side_effects,native,values;if(value instanceof AST_Array){native=true;values=value.elements;if(save_unwind)for(last_side_effects=values.length;--last_side_effects>=0;){if(values[last_side_effects].has_side_effects(compressor))break;}}else {native=value&&value.is_string(compressor);values=false;last_side_effects=node.elements.length;}var elements=[],newValues=drop&&[],pos=0;node.elements.forEach(function(element,index){if(save_unwind)unwind=index>=last_side_effects;value=values&&values[index];if(value instanceof AST_Hole){value=null;}else if(value instanceof AST_Spread){if(drop){newValues.length=pos;fill_holes(save_value,newValues);[].push.apply(newValues,values.slice(index));save_value.elements=newValues;}value=values=false;}element=element.transform(trimmer);if(element)elements[pos]=element;if(drop&&value)newValues[pos]=value;if(element||value||!drop||!values)pos++;});value=values&&make_node(AST_Array,save_value,{elements:values.slice(node.elements.length)});if(node.rest){var was_drop=drop;drop=false;node.rest=node.rest.transform(compressor.option("rests")?trimmer:tt);drop=was_drop;if(node.rest)elements.length=pos;}if(drop){if(value&&!node.rest)value=value.drop_side_effect_free(compressor);if(value instanceof AST_Array){value=value.elements;}else if(value instanceof AST_Sequence){value=value.expressions;}else if(value){value=[value];}if(value&&value.length){newValues.length=pos;[].push.apply(newValues,value);}}value=save_value;unwind=save_unwind;drop=save_drop;if(values&&newValues){fill_holes(value,newValues);value=value.clone();value.elements=newValues;}if(!native){elements.length=node.elements.length;}else if(!node.rest)SHORTHAND:switch(elements.length){case 0:if(node===root)break;if(drop)value=value.drop_side_effect_free(compressor);return null;default:if(!drop)break;if(!unwind)break;if(node===root)break;var pos=elements.length,sym;while(--pos>=0){var element=elements[pos];if(element){sym=element;break;}}if(pos<0)break;for(var i=pos;--i>=0;){if(elements[i])break SHORTHAND;}if(sym.has_side_effects(compressor))break;if(value.has_side_effects(compressor)&&sym.match_symbol(function(node){return node instanceof AST_PropAccess;}))break;value=make_node(AST_Sub,node,{expression:value,property:make_node(AST_Number,node,{value:pos})});return sym;}fill_holes(node,elements);node.elements=elements;return node;}if(node instanceof AST_DestructuredObject){var save_drop=drop;var save_unwind=unwind;var save_value=value;if(value instanceof AST_SymbolRef){drop=false;value=value.fixed_value();}var last_side_effects,prop_keys,prop_map,values;if(value instanceof AST_Object){last_side_effects=-1;prop_keys=[];prop_map=new Dictionary();values=value.properties.map(function(prop,index){if(save_unwind&&prop.has_side_effects(compressor))last_side_effects=index;prop=prop.clone();if(prop instanceof AST_Spread){prop_map=false;}else {var key=prop.key;if(key instanceof AST_Node)key=key.evaluate(compressor,true);if(key instanceof AST_Node){prop_map=false;}else if(prop_map&&!(prop instanceof AST_ObjectSetter)){prop_map.set(key,prop);}prop_keys[index]=key;}return prop;});}else {last_side_effects=node.properties.length;}if(node.rest){value=false;node.rest=node.rest.transform(compressor.option("rests")?trimmer:tt);}var can_drop=new Dictionary();var drop_keys=drop&&new Dictionary();var properties=[];node.properties.map(function(prop){var key=prop.key;if(key instanceof AST_Node){prop.key=key=key.transform(tt);key=key.evaluate(compressor,true);}if(key instanceof AST_Node){drop_keys=false;}else {can_drop.set(key,!can_drop.has(key));}return key;}).forEach(function(key,index){var prop=node.properties[index],trimmed;if(save_unwind)unwind=index>=last_side_effects;if(key instanceof AST_Node){drop=false;value=false;trimmed=prop.value.transform(trimmer)||retain_lhs(prop.value);}else {drop=drop_keys&&can_drop.get(key);var mapped=prop_map&&prop_map.get(key);if(mapped){value=mapped.value;if(value instanceof AST_Accessor)value=false;}else {value=false;}trimmed=prop.value.transform(trimmer);if(!trimmed){if(node.rest||retain_key(prop))trimmed=retain_lhs(prop.value);if(drop_keys&&!drop_keys.has(key)){if(mapped){drop_keys.set(key,mapped);if(value===null){prop_map.set(key,retain_key(mapped)&&make_node(AST_ObjectKeyVal,mapped,{key:mapped.key,value:make_node(AST_Number,mapped,{value:0})}));}}else {drop_keys.set(key,true);}}}else if(drop_keys){drop_keys.set(key,false);}if(value)mapped.value=value;}if(trimmed){prop.value=trimmed;properties.push(prop);}});value=save_value;unwind=save_unwind;drop=save_drop;if(drop_keys&&prop_keys){value=value.clone();value.properties=List(values,function(prop,index){if(prop instanceof AST_Spread)return prop;var key=prop_keys[index];if(key instanceof AST_Node)return prop;if(key==="__proto__")return prop;if(drop_keys.has(key)){var mapped=drop_keys.get(key);if(!mapped)return prop;if(mapped===prop)return prop_map.get(key)||List.skip;}else if(node.rest){return prop;}var trimmed=prop.value.drop_side_effect_free(compressor);if(trimmed){prop.value=trimmed;return prop;}return retain_key(prop)?make_node(AST_ObjectKeyVal,prop,{key:prop.key,value:make_node(AST_Number,prop,{value:0})}):List.skip;});}if(value&&!node.rest)switch(properties.length){case 0:if(node===root)break;if(value.may_throw_on_access(compressor,true))break;if(drop)value=value.drop_side_effect_free(compressor);return null;case 1:if(!drop)break;if(!unwind)break;if(node===root)break;var prop=properties[0];if(prop.key instanceof AST_Node)break;if(prop.value.has_side_effects(compressor))break;if(value.has_side_effects(compressor)&&prop.value.match_symbol(function(node){return node instanceof AST_PropAccess;}))break;value=is_identifier_string(prop.key)?make_node(AST_Dot,node,{expression:value,property:prop.key}):make_node(AST_Sub,node,{expression:value,property:make_node_from_constant(prop.key,prop)});return prop.value;}node.properties=properties;return node;}if(node instanceof AST_Hole){node=null;}else {node=process(node);}if(!node&&drop&&value)value=value.drop_side_effect_free(compressor);return node;});return {name:node.transform(trimmer),value:value};function retain_key(prop){return prop.key instanceof AST_Node&&prop.key.has_side_effects(compressor);}function clear_write_only(node){if(node instanceof AST_Assign){node.write_only=false;clear_write_only(node.right);}else if(node instanceof AST_Binary){if(!lazy_op[node.operator])return;clear_write_only(node.left);clear_write_only(node.right);}else if(node instanceof AST_Conditional){clear_write_only(node.consequent);clear_write_only(node.alternative);}else if(node instanceof AST_Sequence){clear_write_only(node.tail_node());}else if(node instanceof AST_Unary){node.write_only=false;}}function retain_lhs(node){if(node instanceof AST_DefaultValue)return retain_lhs(node.name);if(node instanceof AST_Destructured){if(value===null){value=make_node(AST_Number,node,{value:0});}else if(value){if(value.may_throw_on_access(compressor,true)){value=make_node(AST_Array,node,{elements:value instanceof AST_Sequence?value.expressions:[value]});}else {clear_write_only(value);}}return make_node(AST_DestructuredObject,node,{properties:[]});}node.unused=null;return node;}}});AST_Scope.DEFMETHOD("hoist_declarations",function(compressor){if(compressor.has_directive("use asm"))return;var hoist_funs=compressor.option("hoist_funs");var hoist_vars=compressor.option("hoist_vars");var self=this;if(hoist_vars){// let's count var_decl first, we seem to waste a lot of
// space if we hoist `var` when there's only one.
var var_decl=0;self.walk(new TreeWalker(function(node){if(var_decl>1)return true;if(node instanceof AST_ExportDeclaration)return true;if(node instanceof AST_Scope&&node!==self)return true;if(node instanceof AST_Var){var_decl++;return true;}}));if(var_decl<=1)hoist_vars=false;}if(!hoist_funs&&!hoist_vars)return;var consts=new Dictionary();var dirs=[];var hoisted=[];var vars=new Dictionary();var tt=new TreeTransformer(function(node,descend,in_list){if(node===self)return;if(node instanceof AST_Directive){dirs.push(node);return in_list?List.skip:make_node(AST_EmptyStatement,node);}if(node instanceof AST_LambdaDefinition){if(!hoist_funs)return node;var p=tt.parent();if(p instanceof AST_ExportDeclaration)return node;if(p instanceof AST_ExportDefault)return node;if(p!==self&&compressor.has_directive("use strict"))return node;hoisted.push(node);return in_list?List.skip:make_node(AST_EmptyStatement,node);}if(node instanceof AST_Var){if(!hoist_vars)return node;var p=tt.parent();if(p instanceof AST_ExportDeclaration)return node;if(!all(node.definitions,function(defn){var sym=defn.name;return sym instanceof AST_SymbolVar&&!consts.has(sym.name)&&self.find_variable(sym.name)===sym.definition();}))return node;node.definitions.forEach(function(defn){var name=defn.name.name;if(!vars.has(name))vars.set(name,defn);});var seq=node.to_assignments();if(p instanceof AST_ForEnumeration&&p.init===node){if(seq)return seq;var sym=node.definitions[0].name;return make_node(AST_SymbolRef,sym);}if(p instanceof AST_For&&p.init===node)return seq;if(!seq)return in_list?List.skip:make_node(AST_EmptyStatement,node);return make_node(AST_SimpleStatement,node,{body:seq});}if(node instanceof AST_Scope)return node;if(node instanceof AST_SymbolConst){consts.set(node.name,true);return node;}});self.transform(tt);if(vars.size()>0){// collect only vars which don't show up in self's arguments list
var defns=[];if(self instanceof AST_Lambda)self.each_argname(function(argname){if(all(argname.definition().references,function(ref){return !ref.in_arg;}))vars.del(argname.name);});vars.each(function(defn){var name=defn.name;defn=defn.clone();defn.name=name.clone();defn.value=null;defns.push(defn);var orig=name.definition().orig;orig.splice(orig.indexOf(name),0,defn.name);});if(defns.length>0)hoisted.push(make_node(AST_Var,self,{definitions:defns}));}self.body=dirs.concat(hoisted,self.body);});function scan_local_returns(fn,transform){fn.walk(new TreeWalker(function(node){if(node instanceof AST_Return){transform(node);return true;}if(node instanceof AST_Scope&&node!==fn)return true;}));}function map_self_returns(fn){var map=Object.create(null);scan_local_returns(fn,function(node){var value=node.value;if(value)value=value.tail_node();if(value instanceof AST_SymbolRef){var id=value.definition().id;map[id]=(map[id]||0)+1;}});return map;}function can_trim_returns(def,self_returns,compressor){if(compressor.exposed(def))return false;switch(def.references.length-def.replaced-(self_returns[def.id]||0)){case def.drop_return:return "d";case def.bool_return:return true;}}function process_boolean_returns(fn,compressor){scan_local_returns(fn,function(node){node.in_bool=true;var value=node.value;if(value){var ev=fuzzy_eval(compressor,value);if(!ev){value=value.drop_side_effect_free(compressor);node.value=value?make_sequence(node.value,[value,make_node(AST_Number,node.value,{value:0})]):null;}else if(!(ev instanceof AST_Node)){value=value.drop_side_effect_free(compressor);node.value=value?make_sequence(node.value,[value,make_node(AST_Number,node.value,{value:1})]):make_node(AST_Number,node.value,{value:1});}}});}AST_Scope.DEFMETHOD("process_returns",noop);AST_Defun.DEFMETHOD("process_returns",function(compressor){if(!compressor.option("booleans"))return;if(compressor.parent()instanceof AST_ExportDefault)return;switch(can_trim_returns(this.name.definition(),map_self_returns(this),compressor)){case"d":drop_returns(compressor,this,true);break;case true:process_boolean_returns(this,compressor);break;}});AST_Function.DEFMETHOD("process_returns",function(compressor){if(!compressor.option("booleans"))return;var drop=true;var self_returns=map_self_returns(this);if(this.name&&!can_trim(this.name.definition()))return;var parent=compressor.parent();if(parent instanceof AST_Assign){if(parent.operator!="=")return;var sym=parent.left;if(!(sym instanceof AST_SymbolRef))return;if(!can_trim(sym.definition()))return;}else if(parent instanceof AST_Call&&parent.expression!==this){var exp=parent.expression;if(exp instanceof AST_SymbolRef)exp=exp.fixed_value();if(!(exp instanceof AST_Lambda))return;if(exp.uses_arguments||exp.pinned())return;var args=parent.args,sym;for(var i=0;i<args.length;i++){var arg=args[i];if(arg===this){sym=exp.argnames[i];if(!sym&&exp.rest)return;break;}if(arg instanceof AST_Spread)return;}if(sym instanceof AST_DefaultValue)sym=sym.name;if(sym instanceof AST_SymbolFunarg&&!can_trim(sym.definition()))return;}else if(parent.TYPE=="Call"){compressor.pop();var in_bool=compressor.in_boolean_context();compressor.push(this);switch(in_bool){case true:drop=false;case"d":break;default:return;}}else return;if(drop){drop_returns(compressor,this,true);}else {process_boolean_returns(this,compressor);}function can_trim(def){switch(can_trim_returns(def,self_returns,compressor)){case true:drop=false;case"d":return true;}}});AST_BlockScope.DEFMETHOD("var_names",function(){var var_names=this._var_names;if(!var_names){this._var_names=var_names=new Dictionary();this.enclosed.forEach(function(def){var_names.set(def.name,true);});this.variables.each(function(def,name){var_names.set(name,true);});}return var_names;});AST_Scope.DEFMETHOD("make_var",function(type,orig,prefix){var scopes=[this];if(orig instanceof AST_SymbolDeclaration)orig.definition().references.forEach(function(ref){var s=ref.scope;do{if(!push_uniq(scopes,s))return;s=s.parent_scope;}while(s&&s!==this);});prefix=prefix.replace(/^[^a-z_$]|[^a-z0-9_$]/gi,"_");var name=prefix;for(var i=0;!all(scopes,function(scope){return !scope.var_names().has(name);});i++)name=prefix+"$"+i;var sym=make_node(type,orig,{name:name,scope:this});var def=this.def_variable(sym);scopes.forEach(function(scope){scope.enclosed.push(def);scope.var_names().set(name,true);});return sym;});AST_Scope.DEFMETHOD("hoist_properties",function(compressor){if(!compressor.option("hoist_props")||compressor.has_directive("use asm"))return;var self=this;if(is_arrow(self)&&self.value)return;var top_retain=self instanceof AST_Toplevel&&compressor.top_retain||return_false;var defs_by_id=Object.create(null);var tt=new TreeTransformer(function(node,descend){if(node instanceof AST_Assign){if(node.operator!="=")return;if(!node.write_only)return;if(!can_hoist(node.left,node.right,1))return;descend(node,tt);var defs=new Dictionary();var assignments=[];var decls=[];node.right.properties.forEach(function(prop){var decl=make_sym(AST_SymbolVar,node.left,prop.key);decls.push(make_node(AST_VarDef,node,{name:decl,value:null}));var sym=make_node(AST_SymbolRef,node,{name:decl.name,scope:self,thedef:decl.definition()});sym.reference();assignments.push(make_node(AST_Assign,node,{operator:"=",left:sym,right:prop.value}));});defs.value=node.right;defs_by_id[node.left.definition().id]=defs;self.body.splice(self.body.indexOf(tt.stack[1])+1,0,make_node(AST_Var,node,{definitions:decls}));return make_sequence(node,assignments);}if(node instanceof AST_Scope){if(node===self)return;var parent=tt.parent();if(parent.TYPE=="Call"&&parent.expression===node)return;return node;}if(node instanceof AST_VarDef){if(!can_hoist(node.name,node.value,0))return;descend(node,tt);var defs=new Dictionary();var var_defs=[];var decl=node.clone();decl.value=node.name instanceof AST_SymbolConst?make_node(AST_Number,node,{value:0}):null;var_defs.push(decl);node.value.properties.forEach(function(prop){var_defs.push(make_node(AST_VarDef,node,{name:make_sym(node.name.CTOR,node.name,prop.key),value:prop.value}));});defs.value=node.value;defs_by_id[node.name.definition().id]=defs;return List.splice(var_defs);}function make_sym(type,sym,key){var new_var=self.make_var(type,sym,sym.name+"_"+key);defs.set(key,new_var.definition());return new_var;}});self.transform(tt);self.transform(new TreeTransformer(function(node,descend){if(node instanceof AST_PropAccess){if(!(node.expression instanceof AST_SymbolRef))return;var defs=defs_by_id[node.expression.definition().id];if(!defs)return;if(node.expression.fixed_value()!==defs.value)return;var def=defs.get(node.get_property());var sym=make_node(AST_SymbolRef,node,{name:def.name,scope:node.expression.scope,thedef:def});sym.reference();return sym;}if(node instanceof AST_SymbolRef){var defs=defs_by_id[node.definition().id];if(!defs)return;if(node.fixed_value()!==defs.value)return;return make_node(AST_Object,node,{properties:[]});}}));function can_hoist(sym,right,count){if(!(sym instanceof AST_Symbol))return;var def=sym.definition();if(def.assignments!=count)return;if(def.references.length-def.replaced==count)return;if(def.single_use)return;if(self.find_variable(sym.name)!==def)return;if(top_retain(def))return;if(sym.fixed_value()!==right)return;var fixed=sym.fixed||def.fixed;if(fixed.direct_access)return;if(fixed.escaped&&fixed.escaped.depth==1)return;return right instanceof AST_Object&&right.properties.length>0&&can_drop_symbol(sym,compressor)&&all(right.properties,function(prop){return can_hoist_property(prop)&&prop.key!=="__proto__";});}});function fn_name_unused(fn,compressor){if(!fn.name||!compressor.option("ie"))return true;var def=fn.name.definition();if(compressor.exposed(def))return false;return all(def.references,function(sym){return !(sym instanceof AST_SymbolRef);});}function drop_returns(compressor,exp,ignore_name){if(!(exp instanceof AST_Lambda))return;var arrow=is_arrow(exp);var async=is_async(exp);var changed=false;var drop_body=false;if(arrow&&compressor.option("arrows")){if(!exp.value){drop_body=true;}else if(!async||needs_enqueuing(compressor,exp.value)){var dropped=exp.value.drop_side_effect_free(compressor);if(dropped!==exp.value){changed=true;exp.value=dropped;}}}else if(!is_generator(exp)){if(!ignore_name&&exp.name){var def=exp.name.definition();drop_body=def.references.length==def.replaced;}else {drop_body=true;}}if(drop_body){exp.process_expression(false,function(node){var value=node.value;if(value){if(async&&!needs_enqueuing(compressor,value))return node;value=value.drop_side_effect_free(compressor,true);}changed=true;if(!value)return make_node(AST_EmptyStatement,node);return make_node(AST_SimpleStatement,node,{body:value});});scan_local_returns(exp,function(node){var value=node.value;if(value){if(async&&!needs_enqueuing(compressor,value))return;var dropped=value.drop_side_effect_free(compressor);if(dropped!==value){changed=true;if(dropped&&async&&!needs_enqueuing(compressor,dropped)){dropped=dropped.negate(compressor);}node.value=dropped;}}});}if(async&&compressor.option("awaits")){if(drop_body)exp.process_expression("awaits",function(node){var body=node.body;if(body instanceof AST_Await){if(needs_enqueuing(compressor,body.expression)){changed=true;body=body.expression.drop_side_effect_free(compressor,true);if(!body)return make_node(AST_EmptyStatement,node);node.body=body;}}else if(body instanceof AST_Sequence){var exprs=body.expressions;for(var i=exprs.length;--i>=0;){var tail=exprs[i];if(!(tail instanceof AST_Await))break;var value=tail.expression;if(!needs_enqueuing(compressor,value))break;changed=true;if(exprs[i]=value.drop_side_effect_free(compressor))break;}switch(i){case-1:return make_node(AST_EmptyStatement,node);case 0:node.body=exprs[0];break;default:exprs.length=i+1;break;}}return node;});var abort=!drop_body&&exp.name||arrow&&exp.value&&!needs_enqueuing(compressor,exp.value);var tw=new TreeWalker(function(node){if(abort)return true;if(tw.parent()===exp&&node.may_throw(compressor))return abort=true;if(node instanceof AST_Await)return abort=true;if(node instanceof AST_ForAwaitOf)return abort=true;if(node instanceof AST_Return){if(node.value&&!needs_enqueuing(compressor,node.value))return abort=true;return;}if(node instanceof AST_Scope&&node!==exp)return true;});exp.walk(tw);if(!abort){var ctor;switch(exp.CTOR){case AST_AsyncArrow:ctor=AST_Arrow;break;case AST_AsyncFunction:ctor=AST_Function;break;case AST_AsyncGeneratorFunction:ctor=AST_GeneratorFunction;break;}return make_node(ctor,exp);}}return changed&&exp.clone();}// drop_side_effect_free()
// remove side-effect-free parts which only affects return value
(function(def){// Drop side-effect-free elements from an array of expressions.
// Returns an array of expressions with side-effects or null
// if all elements were dropped. Note: original array may be
// returned if nothing changed.
function trim(nodes,compressor,first_in_statement,spread){var len=nodes.length;var ret=[],changed=false;for(var i=0;i<len;i++){var node=nodes[i];var trimmed;if(spread&&node instanceof AST_Spread){trimmed=spread(node,compressor,first_in_statement);}else {trimmed=node.drop_side_effect_free(compressor,first_in_statement);}if(trimmed!==node)changed=true;if(trimmed){ret.push(trimmed);first_in_statement=false;}}return ret.length?changed?ret:nodes:null;}function array_spread(node,compressor,first_in_statement){var exp=node.expression;if(!exp.is_string(compressor))return node;return exp.drop_side_effect_free(compressor,first_in_statement);}function convert_spread(node){return node instanceof AST_Spread?make_node(AST_Array,node,{elements:[node]}):node;}def(AST_Node,return_this);def(AST_Accessor,return_null);def(AST_Array,function(compressor,first_in_statement){var values=trim(this.elements,compressor,first_in_statement,array_spread);if(!values)return null;if(values===this.elements&&all(values,function(node){return node instanceof AST_Spread;}))return this;return make_sequence(this,values.map(convert_spread));});def(AST_Assign,function(compressor){var left=this.left;if(left instanceof AST_PropAccess){var expr=left.expression;if(expr.may_throw_on_access(compressor,true))return this;if(compressor.has_directive("use strict")&&expr.is_constant())return this;}if(left.has_side_effects(compressor))return this;if(lazy_op[this.operator.slice(0,-1)])return this;this.write_only=true;if(!root_expr(left).is_constant_expression(compressor.find_parent(AST_Scope)))return this;return this.right.drop_side_effect_free(compressor);});def(AST_Await,function(compressor){if(!compressor.option("awaits"))return this;var exp=this.expression;if(!needs_enqueuing(compressor,exp))return this;if(exp instanceof AST_UnaryPrefix&&exp.operator=="!")exp=exp.expression;var dropped=exp.drop_side_effect_free(compressor);if(dropped===exp)return this;if(!dropped){dropped=make_node(AST_Number,exp,{value:0});}else if(!needs_enqueuing(compressor,dropped)){dropped=dropped.negate(compressor);}var node=this.clone();node.expression=dropped;return node;});def(AST_Binary,function(compressor,first_in_statement){var left=this.left;var right=this.right;var op=this.operator;if(!can_drop_op(this,compressor)){var lhs=left.drop_side_effect_free(compressor,first_in_statement);if(lhs===left)return this;var node=this.clone();if(lhs){node.left=lhs;}else if(op=="instanceof"&&!left.is_constant()){node.left=make_node(AST_Array,left,{elements:[]});}else {node.left=make_node(AST_Number,left,{value:0});}return node;}var rhs=right.drop_side_effect_free(compressor,first_in_statement);if(!rhs)return left.drop_side_effect_free(compressor,first_in_statement);if(lazy_op[op]&&rhs.has_side_effects(compressor)){var node=this;if(rhs!==right){node=node.clone();node.right=rhs.drop_side_effect_free(compressor);}if(op=="??")return node;var negated=node.clone();negated.operator=op=="&&"?"||":"&&";negated.left=left.negate(compressor,first_in_statement);var negated_rhs=negated.right.tail_node();if(negated_rhs instanceof AST_Binary&&negated.operator==negated_rhs.operator)swap_chain(negated);var best=first_in_statement?best_of_statement:best_of_expression;return op=="&&"?best(node,negated):best(negated,node);}var lhs=left.drop_side_effect_free(compressor,first_in_statement);if(!lhs)return rhs;rhs=rhs.drop_side_effect_free(compressor);if(!rhs)return lhs;return make_sequence(this,[lhs,rhs]);});function assign_this_only(fn,compressor){fn.new=true;var result=all(fn.body,function(stat){return !stat.has_side_effects(compressor);})&&all(fn.argnames,function(argname){return !argname.match_symbol(return_false);})&&!(fn.rest&&fn.rest.match_symbol(return_false));fn.new=false;return result;}def(AST_Call,function(compressor,first_in_statement){var self=this;if(self.is_expr_pure(compressor)){if(self.pure)AST_Node.warn("Dropping __PURE__ call [{start}]",self);var args=trim(self.args,compressor,first_in_statement,array_spread);return args&&make_sequence(self,args.map(convert_spread));}var exp=self.expression;if(self.is_call_pure(compressor)){var exprs=self.args.slice();exprs.unshift(exp.expression);exprs=trim(exprs,compressor,first_in_statement,array_spread);return exprs&&make_sequence(self,exprs.map(convert_spread));}if(compressor.option("yields")&&is_generator(exp)&&fn_name_unused(exp,compressor)){var call=self.clone();call.expression=make_node(AST_Function,exp);call.expression.body=[];return call;}var dropped=drop_returns(compressor,exp);if(dropped){// always shallow clone to ensure stripping of negated IIFEs
self=self.clone();self.expression=dropped;// avoid extraneous traversal
if(exp._squeezed)self.expression._squeezed=true;}if(self instanceof AST_New){var fn=exp;if(fn instanceof AST_SymbolRef)fn=fn.fixed_value();if(fn instanceof AST_Lambda){if(assign_this_only(fn,compressor)){var exprs=self.args.slice();exprs.unshift(exp);exprs=trim(exprs,compressor,first_in_statement,array_spread);return exprs&&make_sequence(self,exprs.map(convert_spread));}if(!fn.contains_this()){self=make_node(AST_Call,self);self.expression=self.expression.clone();self.args=self.args.slice();}}}self.call_only=true;return self;});def(AST_ClassExpression,function(compressor,first_in_statement){var self=this;var exprs=[],values=[],init=0;var props=self.properties;for(var i=0;i<props.length;i++){var prop=props[i];if(prop.key instanceof AST_Node)exprs.push(prop.key);if(!is_static_field_or_init(prop))continue;var value=prop.value;if(!value.has_side_effects(compressor))continue;if(value.contains_this())return self;if(prop instanceof AST_ClassInit){init++;values.push(prop);}else {values.push(value);}}var base=self.extends;if(base){if(base instanceof AST_SymbolRef)base=base.fixed_value();base=!safe_for_extends(base);if(!base)exprs.unshift(self.extends);}exprs=trim(exprs,compressor,first_in_statement);if(exprs)first_in_statement=false;values=trim(values,compressor,first_in_statement);if(!exprs){if(!base&&!values&&!self.name)return null;exprs=[];}if(base||self.name||!compressor.has_directive("use strict")){var node=to_class_expr(self);if(!base)node.extends=null;node.properties=[];if(values){if(values.length==init){if(exprs.length)values.unshift(make_node(AST_ClassField,self,{key:make_sequence(self,exprs),value:null}));node.properties=values;}else node.properties.push(make_node(AST_ClassField,self,{static:true,key:exprs.length?make_sequence(self,exprs):"c",value:make_value()}));}else if(exprs.length)node.properties.push(make_node(AST_ClassMethod,self,{key:make_sequence(self,exprs),value:make_node(AST_Function,self,{argnames:[],body:[]}).init_vars(node)}));return node;}if(values)exprs.push(make_node(AST_Call,self,{expression:make_node(AST_Arrow,self,{argnames:[],body:[],value:make_value()}).init_vars(self.parent_scope,self),args:[]}));return make_sequence(self,exprs);function make_value(){return make_sequence(self,values.map(function(node){if(!(node instanceof AST_ClassInit))return node;var fn=make_node(AST_Arrow,node.value);fn.argnames=[];return make_node(AST_Call,node,{expression:fn,args:[]});}));}});def(AST_Conditional,function(compressor){var consequent=this.consequent.drop_side_effect_free(compressor);var alternative=this.alternative.drop_side_effect_free(compressor);if(consequent===this.consequent&&alternative===this.alternative)return this;var exprs;if(compressor.option("ie")){exprs=[];if(consequent instanceof AST_Function){exprs.push(consequent);consequent=null;}if(alternative instanceof AST_Function){exprs.push(alternative);alternative=null;}}var node;if(!consequent){node=alternative?make_node(AST_Binary,this,{operator:"||",left:this.condition,right:alternative}):this.condition.drop_side_effect_free(compressor);}else if(!alternative){node=make_node(AST_Binary,this,{operator:"&&",left:this.condition,right:consequent});}else {node=this.clone();node.consequent=consequent;node.alternative=alternative;}if(!exprs)return node;if(node)exprs.push(node);return exprs.length==0?null:make_sequence(this,exprs);});def(AST_Constant,return_null);def(AST_Dot,function(compressor,first_in_statement){var expr=this.expression;if(expr.may_throw_on_access(compressor))return this;return expr.drop_side_effect_free(compressor,first_in_statement);});def(AST_Function,function(compressor){return fn_name_unused(this,compressor)?null:this;});def(AST_LambdaExpression,return_null);def(AST_Object,function(compressor,first_in_statement){var exprs=[];this.properties.forEach(function(prop){if(prop instanceof AST_Spread){exprs.push(prop);}else {if(prop.key instanceof AST_Node)exprs.push(prop.key);exprs.push(prop.value);}});var values=trim(exprs,compressor,first_in_statement,function(node,compressor,first_in_statement){var exp=node.expression;return exp.safe_to_spread()?exp.drop_side_effect_free(compressor,first_in_statement):node;});if(!values)return null;if(values===exprs&&!all(values,function(node){return !(node instanceof AST_Spread);}))return this;return make_sequence(this,values.map(function(node){return node instanceof AST_Spread?make_node(AST_Object,node,{properties:[node]}):node;}));});def(AST_ObjectIdentity,return_null);def(AST_Sequence,function(compressor,first_in_statement){var expressions=trim(this.expressions,compressor,first_in_statement);if(!expressions)return null;var end=expressions.length-1;var last=expressions[end];if(compressor.option("awaits")&&end>0&&last instanceof AST_Await&&last.expression.is_constant()){expressions=expressions.slice(0,-1);end--;var expr=expressions[end];last.expression=needs_enqueuing(compressor,expr)?expr:expr.negate(compressor);expressions[end]=last;}var assign,cond,lhs;if(compressor.option("conditionals")&&end>0&&(assign=expressions[end-1])instanceof AST_Assign&&assign.operator=="="&&(lhs=assign.left)instanceof AST_SymbolRef&&(cond=to_conditional_assignment(compressor,lhs.definition(),assign.right,last))){assign=assign.clone();assign.right=cond;expressions=expressions.slice(0,-2);expressions.push(assign.drop_side_effect_free(compressor,first_in_statement));}return expressions===this.expressions?this:make_sequence(this,expressions);});def(AST_Sub,function(compressor,first_in_statement){var self=this;var expr=self.expression;if(expr.may_throw_on_access(compressor))return self;var prop=self.property;if(self.optional){prop=prop.drop_side_effect_free(compressor);if(!prop)return expr.drop_side_effect_free(compressor,first_in_statement);self=self.clone();self.property=prop;return self;}expr=expr.drop_side_effect_free(compressor,first_in_statement);if(!expr)return prop.drop_side_effect_free(compressor,first_in_statement);prop=prop.drop_side_effect_free(compressor);if(!prop)return expr;return make_sequence(self,[expr,prop]);});def(AST_SymbolRef,function(compressor){return this.is_declared(compressor)&&can_drop_symbol(this,compressor)?null:this;});def(AST_Template,function(compressor,first_in_statement){var self=this;if(self.is_expr_pure(compressor)){var expressions=self.expressions;if(expressions.length==0)return null;return make_sequence(self,expressions).drop_side_effect_free(compressor,first_in_statement);}var tag=self.tag;var dropped=drop_returns(compressor,tag);if(dropped){// always shallow clone to signal internal changes
self=self.clone();self.tag=dropped;// avoid extraneous traversal
if(tag._squeezed)self.tag._squeezed=true;}return self;});def(AST_Unary,function(compressor,first_in_statement){var exp=this.expression;if(unary_side_effects[this.operator]){this.write_only=!exp.has_side_effects(compressor);return this;}if(this.operator=="typeof"&&exp instanceof AST_SymbolRef&&can_drop_symbol(exp,compressor)){return null;}var node=exp.drop_side_effect_free(compressor,first_in_statement);if(first_in_statement&&node&&is_iife_call(node)){if(node===exp&&this.operator=="!")return this;return node.negate(compressor,first_in_statement);}return node;});})(function(node,func){node.DEFMETHOD("drop_side_effect_free",func);});OPT(AST_SimpleStatement,function(self,compressor){if(compressor.option("side_effects")){var body=self.body;var node=body.drop_side_effect_free(compressor,true);if(!node){AST_Node.warn("Dropping side-effect-free statement [{start}]",self);return make_node(AST_EmptyStatement,self);}if(node!==body){return make_node(AST_SimpleStatement,self,{body:node});}}return self;});OPT(AST_While,function(self,compressor){return compressor.option("loops")?make_node(AST_For,self).optimize(compressor):self;});function has_loop_control(loop,parent,type){if(!type)type=AST_LoopControl;var found=false;var tw=new TreeWalker(function(node){if(found||node instanceof AST_Scope)return true;if(node instanceof type&&tw.loopcontrol_target(node)===loop){return found=true;}});if(parent instanceof AST_LabeledStatement)tw.push(parent);tw.push(loop);loop.body.walk(tw);return found;}OPT(AST_Do,function(self,compressor){if(!compressor.option("loops"))return self;var cond=fuzzy_eval(compressor,self.condition);if(!(cond instanceof AST_Node)){if(cond&&!has_loop_control(self,compressor.parent(),AST_Continue))return make_node(AST_For,self,{body:make_node(AST_BlockStatement,self.body,{body:[self.body,make_node(AST_SimpleStatement,self.condition,{body:self.condition})]})}).optimize(compressor);if(!has_loop_control(self,compressor.parent()))return make_node(AST_BlockStatement,self.body,{body:[self.body,make_node(AST_SimpleStatement,self.condition,{body:self.condition})]}).optimize(compressor);}if(self.body instanceof AST_BlockStatement&&!has_loop_control(self,compressor.parent(),AST_Continue)){var body=self.body.body;for(var i=body.length;--i>=0;){var stat=body[i];if(stat instanceof AST_If&&!stat.alternative&&stat.body instanceof AST_Break&&compressor.loopcontrol_target(stat.body)===self){if(has_block_scope_refs(stat.condition))break;self.condition=make_node(AST_Binary,self,{operator:"&&",left:stat.condition.negate(compressor),right:self.condition});body.splice(i,1);}else if(stat instanceof AST_SimpleStatement){if(has_block_scope_refs(stat.body))break;self.condition=make_sequence(self,[stat.body,self.condition]);body.splice(i,1);}else if(!is_declaration(stat,true)){break;}}self.body=trim_block(self.body,compressor.parent());}if(self.body instanceof AST_EmptyStatement)return make_node(AST_For,self).optimize(compressor);if(self.body instanceof AST_SimpleStatement)return make_node(AST_For,self,{condition:make_sequence(self.condition,[self.body.body,self.condition]),body:make_node(AST_EmptyStatement,self)}).optimize(compressor);return self;function has_block_scope_refs(node){var found=false;node.walk(new TreeWalker(function(node){if(found)return true;if(node instanceof AST_SymbolRef){if(!member(node.definition(),self.enclosed))found=true;return true;}}));return found;}});function if_break_in_loop(self,compressor){var first=first_statement(self.body);if(compressor.option("dead_code")&&(first instanceof AST_Break||first instanceof AST_Continue&&external_target(first)||first instanceof AST_Exit)){var body=[];if(is_statement(self.init)){body.push(self.init);}else if(self.init){body.push(make_node(AST_SimpleStatement,self.init,{body:self.init}));}var retain=external_target(first)||first instanceof AST_Exit;if(self.condition&&retain){body.push(make_node(AST_If,self,{condition:self.condition,body:first,alternative:null}));}else if(self.condition){body.push(make_node(AST_SimpleStatement,self.condition,{body:self.condition}));}else if(retain){body.push(first);}extract_declarations_from_unreachable_code(compressor,self.body,body);return make_node(AST_BlockStatement,self,{body:body});}if(first instanceof AST_If){var ab=first_statement(first.body);if(ab instanceof AST_Break&&!external_target(ab)){if(self.condition){self.condition=make_node(AST_Binary,self.condition,{left:self.condition,operator:"&&",right:first.condition.negate(compressor)});}else {self.condition=first.condition.negate(compressor);}var body=as_statement_array(first.alternative);extract_declarations_from_unreachable_code(compressor,first.body,body);return drop_it(body);}ab=first_statement(first.alternative);if(ab instanceof AST_Break&&!external_target(ab)){if(self.condition){self.condition=make_node(AST_Binary,self.condition,{left:self.condition,operator:"&&",right:first.condition});}else {self.condition=first.condition;}var body=as_statement_array(first.body);extract_declarations_from_unreachable_code(compressor,first.alternative,body);return drop_it(body);}}return self;function first_statement(body){return body instanceof AST_BlockStatement?body.body[0]:body;}function external_target(node){return compressor.loopcontrol_target(node)!==compressor.self();}function drop_it(rest){if(self.body instanceof AST_BlockStatement){self.body=self.body.clone();self.body.body=rest.concat(self.body.body.slice(1));self.body=self.body.transform(compressor);}else {self.body=make_node(AST_BlockStatement,self.body,{body:rest}).transform(compressor);}return if_break_in_loop(self,compressor);}}OPT(AST_For,function(self,compressor){if(!compressor.option("loops"))return self;if(compressor.option("side_effects")){if(self.init)self.init=self.init.drop_side_effect_free(compressor);if(self.step)self.step=self.step.drop_side_effect_free(compressor);}if(self.condition){var cond=fuzzy_eval(compressor,self.condition);if(!cond){if(compressor.option("dead_code")){var body=[];if(is_statement(self.init)){body.push(self.init);}else if(self.init){body.push(make_node(AST_SimpleStatement,self.init,{body:self.init}));}body.push(make_node(AST_SimpleStatement,self.condition,{body:self.condition}));extract_declarations_from_unreachable_code(compressor,self.body,body);return make_node(AST_BlockStatement,self,{body:body}).optimize(compressor);}}else if(!(cond instanceof AST_Node)){self.body=make_node(AST_BlockStatement,self.body,{body:[make_node(AST_SimpleStatement,self.condition,{body:self.condition}),self.body]});self.condition=null;}}return if_break_in_loop(self,compressor);});OPT(AST_ForEnumeration,function(self,compressor){if(compressor.option("varify")&&is_lexical_definition(self.init)){var name=self.init.definitions[0].name;if((compressor.option("module")||name instanceof AST_Destructured||name instanceof AST_SymbolLet)&&!name.match_symbol(function(node){if(node instanceof AST_SymbolDeclaration){var def=node.definition();return !same_scope(def)||may_overlap(compressor,def);}},true)){self.init=to_var(self.init,self.resolve());}else if(self.init.can_letify(compressor,true)){self.init=to_let(self.init,self);}}return self;});function mark_locally_defined(condition,consequent,alternative){if(condition instanceof AST_Sequence)condition=condition.tail_node();if(!(condition instanceof AST_Binary))return;if(!(condition.left instanceof AST_String)){switch(condition.operator){case"&&":mark_locally_defined(condition.left,consequent);mark_locally_defined(condition.right,consequent);break;case"||":mark_locally_defined(negate(condition.left),alternative);mark_locally_defined(negate(condition.right),alternative);break;}return;}if(!(condition.right instanceof AST_UnaryPrefix))return;if(condition.right.operator!="typeof")return;var sym=condition.right.expression;if(!is_undeclared_ref(sym))return;var body;var undef=condition.left.value=="undefined";switch(condition.operator){case"==":body=undef?alternative:consequent;break;case"!=":body=undef?consequent:alternative;break;default:return;}if(!body)return;var abort=false;var def=sym.definition();var fn;var refs=[];var scanned=[];var tw=new TreeWalker(function(node,descend){if(abort)return true;if(node instanceof AST_Assign){var ref=node.left;if(!(ref instanceof AST_SymbolRef&&ref.definition()===def))return;node.right.walk(tw);switch(node.operator){case"=":case"&&=":abort=true;}return true;}if(node instanceof AST_Call){descend();fn=node.expression.tail_node();var save;if(fn instanceof AST_SymbolRef){fn=fn.fixed_value();save=refs.length;}if(!(fn instanceof AST_Lambda)){abort=true;}else if(push_uniq(scanned,fn)){fn.walk(tw);}if(save>=0)refs.length=save;return true;}if(node instanceof AST_DWLoop){var save=refs.length;descend();if(abort)refs.length=save;return true;}if(node instanceof AST_For){if(node.init)node.init.walk(tw);var save=refs.length;if(node.condition)node.condition.walk(tw);node.body.walk(tw);if(node.step)node.step.walk(tw);if(abort)refs.length=save;return true;}if(node instanceof AST_ForEnumeration){node.object.walk(tw);var save=refs.length;node.init.walk(tw);node.body.walk(tw);if(abort)refs.length=save;return true;}if(node instanceof AST_Scope){if(node===fn)return;return true;}if(node instanceof AST_SymbolRef){if(node.definition()===def)refs.push(node);return true;}});body.walk(tw);refs.forEach(function(ref){ref.defined=true;});function negate(node){if(!(node instanceof AST_Binary))return;switch(node.operator){case"==":node=node.clone();node.operator="!=";return node;case"!=":node=node.clone();node.operator="==";return node;}}}function fuzzy_eval(compressor,node,nullish){if(node.truthy)return true;if(is_undefined(node))return undefined;if(node.falsy&&!nullish)return false;if(node.is_truthy())return true;return node.evaluate(compressor,true);}function mark_duplicate_condition(compressor,node){var child;var level=0;var negated=false;var parent=compressor.self();if(!is_statement(parent))while(true){child=parent;parent=compressor.parent(level++);if(parent instanceof AST_Binary){switch(child){case parent.left:if(lazy_op[parent.operator])continue;break;case parent.right:if(match(parent.left))switch(parent.operator){case"&&":node[negated?"falsy":"truthy"]=true;break;case"||":case"??":node[negated?"truthy":"falsy"]=true;break;}break;}}else if(parent instanceof AST_Conditional){var cond=parent.condition;if(cond===child)continue;if(match(cond))switch(child){case parent.consequent:node[negated?"falsy":"truthy"]=true;break;case parent.alternative:node[negated?"truthy":"falsy"]=true;break;}}else if(parent instanceof AST_Exit){break;}else if(parent instanceof AST_If){break;}else if(parent instanceof AST_Sequence){if(parent.expressions[0]===child)continue;}else if(parent instanceof AST_SimpleStatement){break;}return;}while(true){child=parent;parent=compressor.parent(level++);if(parent instanceof AST_BlockStatement){if(parent.body[0]===child)continue;}else if(parent instanceof AST_If){if(match(parent.condition))switch(child){case parent.body:node[negated?"falsy":"truthy"]=true;break;case parent.alternative:node[negated?"truthy":"falsy"]=true;break;}}return;}function match(cond){if(node.equals(cond))return true;if(!(cond instanceof AST_UnaryPrefix))return false;if(cond.operator!="!")return false;if(!node.equals(cond.expression))return false;negated=true;return true;}}OPT(AST_If,function(self,compressor){if(is_empty(self.alternative))self.alternative=null;if(!compressor.option("conditionals"))return self;if(compressor.option("booleans")&&!self.condition.has_side_effects(compressor)){mark_duplicate_condition(compressor,self.condition);}// if condition can be statically determined, warn and drop
// one of the blocks.  note, statically determined implies
// has no side effects; also it doesn't work for cases like
// `x && true`, though it probably should.
if(compressor.option("dead_code")){var cond=fuzzy_eval(compressor,self.condition);if(!cond){AST_Node.warn("Condition always false [{start}]",self.condition);var body=[make_node(AST_SimpleStatement,self.condition,{body:self.condition}).transform(compressor)];extract_declarations_from_unreachable_code(compressor,self.body,body);if(self.alternative)body.push(self.alternative);return make_node(AST_BlockStatement,self,{body:body}).optimize(compressor);}else if(!(cond instanceof AST_Node)){AST_Node.warn("Condition always true [{start}]",self.condition);var body=[make_node(AST_SimpleStatement,self.condition,{body:self.condition}).transform(compressor),self.body];if(self.alternative)extract_declarations_from_unreachable_code(compressor,self.alternative,body);return make_node(AST_BlockStatement,self,{body:body}).optimize(compressor);}}var negated=self.condition.negate(compressor);var self_condition_length=self.condition.print_to_string().length;var negated_length=negated.print_to_string().length;var negated_is_best=negated_length<self_condition_length;if(self.alternative&&negated_is_best){negated_is_best=false;// because we already do the switch here.
// no need to swap values of self_condition_length and negated_length
// here because they are only used in an equality comparison later on.
self.condition=negated;var tmp=self.body;self.body=self.alternative;self.alternative=is_empty(tmp)?null:tmp;}var body_defuns=[];var body_var_defs=[];var body_refs=[];var body_exprs=sequencesize(self.body,body_defuns,body_var_defs,body_refs);var alt_defuns=[];var alt_var_defs=[];var alt_refs=[];var alt_exprs=sequencesize(self.alternative,alt_defuns,alt_var_defs,alt_refs);if(body_exprs instanceof AST_BlockStatement||alt_exprs instanceof AST_BlockStatement){var body=[],var_defs=[];if(body_exprs){[].push.apply(body,body_defuns);[].push.apply(var_defs,body_var_defs);if(body_exprs instanceof AST_BlockStatement){self.body=body_exprs;}else if(body_exprs.length==0){self.body=make_node(AST_EmptyStatement,self.body);}else {self.body=make_node(AST_SimpleStatement,self.body,{body:make_sequence(self.body,body_exprs)});}body_refs.forEach(process_to_assign);}if(alt_exprs){[].push.apply(body,alt_defuns);[].push.apply(var_defs,alt_var_defs);if(alt_exprs instanceof AST_BlockStatement){self.alternative=alt_exprs;}else if(alt_exprs.length==0){self.alternative=null;}else {self.alternative=make_node(AST_SimpleStatement,self.alternative,{body:make_sequence(self.alternative,alt_exprs)});}alt_refs.forEach(process_to_assign);}if(var_defs.length>0)body.push(make_node(AST_Var,self,{definitions:var_defs}));if(body.length>0){body.push(self.transform(compressor));return make_node(AST_BlockStatement,self,{body:body}).optimize(compressor);}}else if(body_exprs&&alt_exprs){var body=body_defuns.concat(alt_defuns);if(body_var_defs.length>0||alt_var_defs.length>0)body.push(make_node(AST_Var,self,{definitions:body_var_defs.concat(alt_var_defs)}));if(body_exprs.length==0){body.push(make_node(AST_SimpleStatement,self.condition,{body:alt_exprs.length>0?make_node(AST_Binary,self,{operator:"||",left:self.condition,right:make_sequence(self.alternative,alt_exprs)}).transform(compressor):self.condition.clone()}).optimize(compressor));}else if(alt_exprs.length==0){if(self_condition_length===negated_length&&!negated_is_best&&self.condition instanceof AST_Binary&&self.condition.operator=="||"){// although the code length of self.condition and negated are the same,
// negated does not require additional surrounding parentheses.
// see https://github.com/mishoo/UglifyJS/issues/979
negated_is_best=true;}body.push(make_node(AST_SimpleStatement,self,{body:make_node(AST_Binary,self,{operator:negated_is_best?"||":"&&",left:negated_is_best?negated:self.condition,right:make_sequence(self.body,body_exprs)}).transform(compressor)}).optimize(compressor));}else {body.push(make_node(AST_SimpleStatement,self,{body:make_node(AST_Conditional,self,{condition:self.condition,consequent:make_sequence(self.body,body_exprs),alternative:make_sequence(self.alternative,alt_exprs)})}).optimize(compressor));}body_refs.forEach(process_to_assign);alt_refs.forEach(process_to_assign);return make_node(AST_BlockStatement,self,{body:body}).optimize(compressor);}if(is_empty(self.body))self=make_node(AST_If,self,{condition:negated,body:self.alternative,alternative:null});if(self.alternative instanceof AST_Exit&&self.body.TYPE==self.alternative.TYPE){var cons_value=self.body.value;var alt_value=self.alternative.value;if(!cons_value&&!alt_value)return make_node(AST_BlockStatement,self,{body:[make_node(AST_SimpleStatement,self,{body:self.condition}),self.body]}).optimize(compressor);if(cons_value&&alt_value||!keep_return_void()){var exit=make_node(self.body.CTOR,self,{value:make_node(AST_Conditional,self,{condition:self.condition,consequent:cons_value||make_node(AST_Undefined,self.body).transform(compressor),alternative:alt_value||make_node(AST_Undefined,self.alternative).transform(compressor)})});if(exit instanceof AST_Return)exit.in_bool=self.body.in_bool||self.alternative.in_bool;return exit;}}if(self.body instanceof AST_If&&!self.body.alternative&&!self.alternative){self=make_node(AST_If,self,{condition:make_node(AST_Binary,self.condition,{operator:"&&",left:self.condition,right:self.body.condition}),body:self.body.body,alternative:null});}if(aborts(self.body)&&self.alternative){var alt=self.alternative;self.alternative=null;return make_node(AST_BlockStatement,self,{body:[self,alt]}).optimize(compressor);}if(aborts(self.alternative)){var body=self.body;self.body=self.alternative;self.condition=negated_is_best?negated:self.condition.negate(compressor);self.alternative=null;return make_node(AST_BlockStatement,self,{body:[self,body]}).optimize(compressor);}if(self.alternative){var body_stats=as_array(self.body);var body_index=last_index(body_stats);var alt_stats=as_array(self.alternative);var alt_index=last_index(alt_stats);for(var stats=[];body_index>=0&&alt_index>=0;){var stat=body_stats[body_index];var alt_stat=alt_stats[alt_index];if(stat.equals(alt_stat)){body_stats.splice(body_index--,1);alt_stats.splice(alt_index--,1);stats.unshift(merge_expression(stat,alt_stat));}else {if(!(stat instanceof AST_SimpleStatement))break;if(!(alt_stat instanceof AST_SimpleStatement))break;var expr1=stat.body.tail_node();var expr2=alt_stat.body.tail_node();if(!expr1.equals(expr2))break;body_index=pop_expr(body_stats,stat.body,body_index);alt_index=pop_expr(alt_stats,alt_stat.body,alt_index);stats.unshift(make_node(AST_SimpleStatement,expr1,{body:merge_expression(expr1,expr2)}));}}if(stats.length>0){self.body=body_stats.length>0?make_node(AST_BlockStatement,self,{body:body_stats}):make_node(AST_EmptyStatement,self);self.alternative=alt_stats.length>0?make_node(AST_BlockStatement,self,{body:alt_stats}):null;stats.unshift(self);return make_node(AST_BlockStatement,self,{body:stats}).optimize(compressor);}}if(compressor.option("typeofs"))mark_locally_defined(self.condition,self.body,self.alternative);return self;function as_array(node){return node instanceof AST_BlockStatement?node.body:[node];}function keep_return_void(){var has_finally=false,level=0,node=compressor.self();do{if(node instanceof AST_Catch){if(compressor.parent(level).bfinally)has_finally=true;level++;}else if(node instanceof AST_Finally){level++;}else if(node instanceof AST_Scope){return has_finally&&in_async_generator(node);}else if(node instanceof AST_Try){if(node.bfinally)has_finally=true;}}while(node=compressor.parent(level++));}function last_index(stats){for(var index=stats.length;--index>=0;){if(!is_declaration(stats[index],true))break;}return index;}function pop_expr(stats,body,index){if(body instanceof AST_Sequence){stats[index]=make_node(AST_SimpleStatement,body,{body:make_sequence(body,body.expressions.slice(0,-1))});}else {stats.splice(index--,1);}return index;}function sequencesize(stat,defuns,var_defs,refs){if(stat==null)return [];if(stat instanceof AST_BlockStatement){var exprs=[];for(var i=0;i<stat.body.length;i++){var line=stat.body[i];if(line instanceof AST_EmptyStatement)continue;if(line instanceof AST_Exit){if(i==0)return;if(exprs.length>0){line=line.clone();exprs.push(line.value||make_node(AST_Undefined,line).transform(compressor));line.value=make_sequence(stat,exprs);}var block=stat.clone();block.body=block.body.slice(i+1);block.body.unshift(line);return block;}if(line instanceof AST_LambdaDefinition){defuns.push(line);}else if(line instanceof AST_SimpleStatement){if(!compressor.option("sequences")&&exprs.length>0)return;exprs.push(line.body);}else if(line instanceof AST_Var){if(!compressor.option("sequences")&&exprs.length>0)return;line.remove_initializers(compressor,var_defs);line.definitions.forEach(process_var_def);}else {return;}}return exprs;}if(stat instanceof AST_LambdaDefinition){defuns.push(stat);return [];}if(stat instanceof AST_EmptyStatement)return [];if(stat instanceof AST_SimpleStatement)return [stat.body];if(stat instanceof AST_Var){var exprs=[];stat.remove_initializers(compressor,var_defs);stat.definitions.forEach(process_var_def);return exprs;}function process_var_def(var_def){if(!var_def.value)return;exprs.push(make_node(AST_Assign,var_def,{operator:"=",left:var_def.name.convert_symbol(AST_SymbolRef,function(ref){refs.push(ref);}),right:var_def.value}));}}});OPT(AST_Switch,function(self,compressor){if(!compressor.option("switches"))return self;if(!compressor.option("dead_code"))return self;var body=[];var branch;var decl=[];var default_branch;var exact_match;var side_effects=[];for(var i=0,len=self.body.length;i<len;i++){branch=self.body[i];if(branch instanceof AST_Default){var prev=body[body.length-1];if(default_branch||is_break(branch.body[0],compressor)&&(!prev||aborts(prev))){eliminate_branch(branch,prev);continue;}else {default_branch=branch;}}else {var exp=branch.expression;var equals=make_node(AST_Binary,self,{operator:"===",left:self.expression,right:exp}).evaluate(compressor,true);if(!equals){if(exp.has_side_effects(compressor))side_effects.push(exp);eliminate_branch(branch,body[body.length-1]);continue;}if(!(equals instanceof AST_Node)){if(default_branch){var default_index=body.indexOf(default_branch);body.splice(default_index,1);eliminate_branch(default_branch,body[default_index-1]);default_branch=null;}if(exp.has_side_effects(compressor)){exact_match=branch;}else {default_branch=branch=make_node(AST_Default,branch);}while(++i<len)eliminate_branch(self.body[i],branch);}}if(i+1>=len||aborts(branch)){var prev=body[body.length-1];var statements=branch.body;if(aborts(prev))switch(prev.body.length-statements.length){case 1:var stat=prev.body[prev.body.length-1];if(!is_break(stat,compressor))break;statements=statements.concat(stat);case 0:var prev_block=make_node(AST_BlockStatement,prev);var next_block=make_node(AST_BlockStatement,branch,{body:statements});if(prev_block.equals(next_block))prev.body=[];}}if(side_effects.length){if(branch instanceof AST_Default){body.push(make_node(AST_Case,self,{expression:make_sequence(self,side_effects),body:[]}));}else {side_effects.push(branch.expression);branch.expression=make_sequence(self,side_effects);}side_effects=[];}body.push(branch);}if(side_effects.length&&!exact_match){body.push(make_node(AST_Case,self,{expression:make_sequence(self,side_effects),body:[]}));}while(branch=body[body.length-1]){var stat=branch.body[branch.body.length-1];if(is_break(stat,compressor))branch.body.pop();if(branch===default_branch){if(!has_declarations_only(branch))break;}else if(branch.expression.has_side_effects(compressor)){break;}else if(default_branch){if(!has_declarations_only(default_branch))break;if(body[body.length-2]!==default_branch)break;default_branch.body=default_branch.body.concat(branch.body);branch.body=[];}else if(!has_declarations_only(branch))break;eliminate_branch(branch);if(body.pop()===default_branch)default_branch=null;}if(!branch){decl.push(make_node(AST_SimpleStatement,self.expression,{body:self.expression}));if(side_effects.length)decl.push(make_node(AST_SimpleStatement,self,{body:make_sequence(self,side_effects)}));return make_node(AST_BlockStatement,self,{body:decl}).optimize(compressor);}if(branch===default_branch)while(branch=body[body.length-2]){if(branch instanceof AST_Default)break;if(!has_declarations_only(branch))break;var exp=branch.expression;if(exp.has_side_effects(compressor)){var prev=body[body.length-3];if(prev&&!aborts(prev))break;default_branch.body.unshift(make_node(AST_SimpleStatement,self,{body:exp}));}eliminate_branch(branch);body.splice(-2,1);}body[0].body=decl.concat(body[0].body);self.body=body;if(compressor.option("conditionals"))switch(body.length){case 1:if(!no_break(body[0]))break;var exp=body[0].expression;var statements=body[0].body.slice();if(body[0]!==default_branch&&body[0]!==exact_match)return make_node(AST_If,self,{condition:make_node(AST_Binary,self,{operator:"===",left:self.expression,right:exp}),body:make_node(AST_BlockStatement,self,{body:statements}),alternative:null}).optimize(compressor);if(exp)statements.unshift(make_node(AST_SimpleStatement,exp,{body:exp}));statements.unshift(make_node(AST_SimpleStatement,self.expression,{body:self.expression}));return make_node(AST_BlockStatement,self,{body:statements}).optimize(compressor);case 2:if(!member(default_branch,body)||!no_break(body[1]))break;var statements=body[0].body.slice();var exclusive=statements.length&&is_break(statements[statements.length-1],compressor);if(exclusive)statements.pop();if(!all(statements,no_break))break;var alternative=body[1].body.length&&make_node(AST_BlockStatement,body[1]);var node=make_node(AST_If,self,{condition:make_node(AST_Binary,self,body[0]===default_branch?{operator:"!==",left:self.expression,right:body[1].expression}:{operator:"===",left:self.expression,right:body[0].expression}),body:make_node(AST_BlockStatement,body[0],{body:statements}),alternative:exclusive&&alternative||null});if(!exclusive&&alternative)node=make_node(AST_BlockStatement,self,{body:[node,alternative]});return node.optimize(compressor);}return self;function is_break(node,tw){return node instanceof AST_Break&&tw.loopcontrol_target(node)===self;}function no_break(node){var found=false;var tw=new TreeWalker(function(node){if(found||node instanceof AST_Lambda||node instanceof AST_SimpleStatement)return true;if(is_break(node,tw))found=true;});tw.push(self);node.walk(tw);return !found;}function eliminate_branch(branch,prev){if(prev&&!aborts(prev)){prev.body=prev.body.concat(branch.body);}else {extract_declarations_from_unreachable_code(compressor,branch,decl);}}});OPT(AST_Try,function(self,compressor){self.body=tighten_body(self.body,compressor);if(compressor.option("dead_code")){if(has_declarations_only(self)&&!(self.bcatch&&self.bcatch.argname&&self.bcatch.argname.match_symbol(function(node){return node instanceof AST_SymbolCatch&&!can_drop_symbol(node);},true))){var body=[];if(self.bcatch){extract_declarations_from_unreachable_code(compressor,self.bcatch,body);body.forEach(function(stat){if(!(stat instanceof AST_Var))return;stat.definitions.forEach(function(var_def){var def=var_def.name.definition().redefined();if(!def)return;var_def.name=var_def.name.clone();var_def.name.thedef=def;});});}body.unshift(make_node(AST_BlockStatement,self).optimize(compressor));if(self.bfinally){body.push(make_node(AST_BlockStatement,self.bfinally).optimize(compressor));}return make_node(AST_BlockStatement,self,{body:body}).optimize(compressor);}if(self.bfinally&&has_declarations_only(self.bfinally)){var body=make_node(AST_BlockStatement,self.bfinally).optimize(compressor);body=self.body.concat(body);if(!self.bcatch)return make_node(AST_BlockStatement,self,{body:body}).optimize(compressor);self.body=body;self.bfinally=null;}}return self;});function remove_initializers(make_value){return function(compressor,defns){var dropped=false;this.definitions.forEach(function(defn){if(defn.value)dropped=true;defn.name.match_symbol(function(node){if(node instanceof AST_SymbolDeclaration)defns.push(make_node(AST_VarDef,node,{name:node,value:make_value(compressor,node)}));},true);});return dropped;};}AST_Const.DEFMETHOD("remove_initializers",remove_initializers(function(compressor,node){return make_node(AST_Undefined,node).optimize(compressor);}));AST_Let.DEFMETHOD("remove_initializers",remove_initializers(return_null));AST_Var.DEFMETHOD("remove_initializers",remove_initializers(return_null));AST_Definitions.DEFMETHOD("to_assignments",function(){var assignments=this.definitions.reduce(function(a,defn){var def=defn.name.definition();var value=defn.value;if(value){if(value instanceof AST_Sequence)value=value.clone();var name=make_node(AST_SymbolRef,defn.name);var assign=make_node(AST_Assign,defn,{operator:"=",left:name,right:value});a.push(assign);var fixed=function(){return assign.right;};fixed.assigns=[assign];fixed.direct_access=def.direct_access;fixed.escaped=def.escaped;name.fixed=fixed;def.references.forEach(function(ref){if(!ref.fixed)return;var assigns=ref.fixed.assigns;if(!assigns)return;if(assigns[0]!==defn)return;if(assigns.length>1||ref.fixed.to_binary||ref.fixed.to_prefix){assigns[0]=assign;}else {ref.fixed=fixed;if(def.fixed===ref.fixed)def.fixed=fixed;}});def.references.push(name);def.assignments++;}def.eliminated++;return a;},[]);if(assignments.length==0)return null;return make_sequence(this,assignments);});function is_safe_lexical(def){return def.name!="arguments"&&def.orig.length<(def.orig[0]instanceof AST_SymbolLambda?3:2);}function may_overlap(compressor,def){if(compressor.exposed(def))return true;var scope=def.scope.resolve();for(var s=def.scope;s!==scope;){s=s.parent_scope;if(s.var_names().has(def.name))return true;}}function to_let(stat,scope){return make_node(AST_Let,stat,{definitions:stat.definitions.map(function(defn){return make_node(AST_VarDef,defn,{name:defn.name.convert_symbol(AST_SymbolLet,function(name,node){var def=name.definition();def.orig[def.orig.indexOf(node)]=name;for(var s=scope;s!==def.scope&&(s=s.parent_scope);){remove(s.enclosed,def);}def.scope=scope;scope.variables.set(def.name,def);}),value:defn.value});})});}function to_var(stat,scope){return make_node(AST_Var,stat,{definitions:stat.definitions.map(function(defn){return make_node(AST_VarDef,defn,{name:defn.name.convert_symbol(AST_SymbolVar,function(name,node){var def=name.definition();def.orig[def.orig.indexOf(node)]=name;if(def.scope===scope)return;def.scope=scope;scope.variables.set(def.name,def);scope.enclosed.push(def);scope.var_names().set(def.name,true);}),value:defn.value});})});}(function(def){def(AST_Node,return_false);def(AST_Const,function(compressor,assigned){assigned=assigned?1:0;var defns=this.definitions;if(!compressor.option("module")&&all(defns,function(defn){return defn.name instanceof AST_SymbolConst;}))return false;return all(defns,function(defn){return !defn.name.match_symbol(function(node){if(node instanceof AST_SymbolDeclaration)return node.definition().assignments!=assigned;},true);});});def(AST_Var,function(compressor){return all(this.definitions,function(defn){return !defn.name.match_symbol(function(node){if(!(node instanceof AST_SymbolDeclaration))return false;var def=node.definition();if(def.first_decl!==node)return true;if(!safe_from_tdz(compressor,node))return true;var defn_scope=node.scope;if(defn_scope instanceof AST_Scope)return false;return !all(def.references,function(ref){var scope=ref.scope;do{if(scope===defn_scope)return true;}while(scope=scope.parent_scope);return false;});},true);});});})(function(node,func){node.DEFMETHOD("can_letify",func);});function safe_from_tdz(compressor,sym){var def=sym.definition();return (def.fixed||def.fixed===0)&&is_safe_lexical(def)&&same_scope(def)&&!may_overlap(compressor,def);}AST_Definitions.DEFMETHOD("can_varify",function(compressor){return all(this.definitions,function(defn){return !defn.name.match_symbol(function(node){if(node instanceof AST_SymbolDeclaration)return !safe_from_tdz(compressor,node);},true);});});OPT(AST_Const,function(self,compressor){if(!compressor.option("varify"))return self;if(self.can_varify(compressor))return to_var(self,compressor.find_parent(AST_Scope));if(self.can_letify(compressor))return to_let(self,find_scope(compressor));return self;});OPT(AST_Let,function(self,compressor){if(!compressor.option("varify"))return self;if(self.can_varify(compressor))return to_var(self,compressor.find_parent(AST_Scope));return self;});function trim_optional_chain(node,compressor){if(!compressor.option("optional_chains"))return;if(node.terminal)do{var expr=node.expression;if(node.optional){var ev=fuzzy_eval(compressor,expr,true);if(ev==null)return make_node(AST_UnaryPrefix,node,{operator:"void",expression:expr}).optimize(compressor);if(!(ev instanceof AST_Node))node.optional=false;}node=expr;}while((node.TYPE=="Call"||node instanceof AST_PropAccess)&&!node.terminal);}function lift_sequence_in_expression(node,compressor){var exp=node.expression;if(!(exp instanceof AST_Sequence))return node;var x=exp.expressions.slice();var e=node.clone();e.expression=x.pop();x.push(e);return make_sequence(node,x);}function drop_unused_call_args(call,compressor,fns_with_marked_args){var exp=call.expression;var fn=exp instanceof AST_SymbolRef?exp.fixed_value():exp;if(!(fn instanceof AST_Lambda))return;if(fn.uses_arguments)return;if(fn.pinned())return;if(fns_with_marked_args&&fns_with_marked_args.indexOf(fn)<0)return;var args=call.args;if(!all(args,function(arg){return !(arg instanceof AST_Spread);}))return;var argnames=fn.argnames;var is_iife=fn===exp&&!fn.name;if(fn.rest){if(!(is_iife&&compressor.option("rests")))return;var insert=argnames.length;args=args.slice(0,insert);while(args.length<insert)args.push(make_node(AST_Undefined,call).optimize(compressor));args.push(make_node(AST_Array,call,{elements:call.args.slice(insert)}));argnames=argnames.concat(fn.rest);fn.rest=null;}else {args=args.slice();argnames=argnames.slice();}var pos=0,last=0;var drop_defaults=is_iife&&compressor.option("default_values");var drop_fargs=is_iife&&compressor.drop_fargs(fn,call)?function(argname,arg){if(!argname)return true;if(argname instanceof AST_DestructuredArray){return argname.elements.length==0&&!argname.rest&&arg instanceof AST_Array;}if(argname instanceof AST_DestructuredObject){return argname.properties.length==0&&!argname.rest&&arg&&!arg.may_throw_on_access(compressor);}return argname.unused;}:return_false;var side_effects=[];for(var i=0;i<args.length;i++){var argname=argnames[i];if(drop_defaults&&argname instanceof AST_DefaultValue&&args[i].is_defined(compressor)){argnames[i]=argname=argname.name;}if(!argname||argname.unused!==undefined){var node=args[i].drop_side_effect_free(compressor);if(drop_fargs(argname)){if(argname)argnames.splice(i,1);args.splice(i,1);if(node)side_effects.push(node);i--;continue;}else if(node){side_effects.push(node);args[pos++]=make_sequence(call,side_effects);side_effects=[];}else if(argname){if(side_effects.length){args[pos++]=make_sequence(call,side_effects);side_effects=[];}else {args[pos++]=make_node(AST_Number,args[i],{value:0});continue;}}}else if(drop_fargs(argname,args[i])){var node=args[i].drop_side_effect_free(compressor);argnames.splice(i,1);args.splice(i,1);if(node)side_effects.push(node);i--;continue;}else {side_effects.push(args[i]);args[pos++]=make_sequence(call,side_effects);side_effects=[];}last=pos;}for(;i<argnames.length;i++){if(drop_fargs(argnames[i]))argnames.splice(i--,1);}fn.argnames=argnames;args.length=last;call.args=args;if(!side_effects.length)return;var arg=make_sequence(call,side_effects);args.push(args.length<argnames.length?make_node(AST_UnaryPrefix,call,{operator:"void",expression:arg}):arg);}function avoid_await_yield(compressor,parent_scope){if(!parent_scope)parent_scope=compressor.find_parent(AST_Scope);var avoid=[];if(is_async(parent_scope)||parent_scope instanceof AST_Toplevel&&compressor.option("module")){avoid.push("await");}if(is_generator(parent_scope))avoid.push("yield");return avoid.length&&makePredicate(avoid);}function safe_from_await_yield(fn,avoid){if(!avoid)return true;var safe=true;var tw=new TreeWalker(function(node){if(!safe)return true;if(node instanceof AST_Scope){if(node===fn)return;if(is_arrow(node)){for(var i=0;safe&&i<node.argnames.length;i++)node.argnames[i].walk(tw);}else if(node instanceof AST_LambdaDefinition&&avoid[node.name.name]){safe=false;}return true;}if(node instanceof AST_Symbol&&avoid[node.name]&&node!==fn.name)safe=false;});fn.walk(tw);return safe;}function safe_from_strict_mode(fn,compressor){return fn.in_strict_mode(compressor)||!compressor.has_directive("use strict");}OPT(AST_Call,function(self,compressor){var exp=self.expression;var terminated=trim_optional_chain(self,compressor);if(terminated)return terminated;if(compressor.option("sequences")){if(exp instanceof AST_PropAccess){var seq=lift_sequence_in_expression(exp);if(seq!==exp){var call=self.clone();call.expression=seq.expressions.pop();seq.expressions.push(call);return seq.optimize(compressor);}}else if(!needs_unbinding(exp.tail_node())){var seq=lift_sequence_in_expression(self);if(seq!==self)return seq.optimize(compressor);}}if(compressor.option("unused"))drop_unused_call_args(self,compressor);if(compressor.option("unsafe")){if(is_undeclared_ref(exp))switch(exp.name){case"Array":// Array(n) ---> [ , , ... , ]
if(self.args.length==1){var first=self.args[0];if(first instanceof AST_Number)try{var length=first.value;if(length>6)break;var elements=Array(length);for(var i=0;i<length;i++)elements[i]=make_node(AST_Hole,self);return make_node(AST_Array,self,{elements:elements});}catch(ex){AST_Node.warn("Invalid array length: {length} [{start}]",{length:length,start:self.start});break;}if(!first.is_boolean(compressor)&&!first.is_string(compressor))break;}// Array(...) ---> [ ... ]
return make_node(AST_Array,self,{elements:self.args});case"Object":// Object() ---> {}
if(self.args.length==0)return make_node(AST_Object,self,{properties:[]});break;case"String":// String() ---> ""
if(self.args.length==0)return make_node(AST_String,self,{value:""});// String(x) ---> "" + x
if(self.args.length==1)return make_node(AST_Binary,self,{operator:"+",left:make_node(AST_String,self,{value:""}),right:self.args[0]}).optimize(compressor);break;case"Number":// Number() ---> 0
if(self.args.length==0)return make_node(AST_Number,self,{value:0});// Number(x) ---> +("" + x)
if(self.args.length==1)return make_node(AST_UnaryPrefix,self,{operator:"+",expression:make_node(AST_Binary,self,{operator:"+",left:make_node(AST_String,self,{value:""}),right:self.args[0]})}).optimize(compressor);break;case"Boolean":// Boolean() ---> false
if(self.args.length==0)return make_node(AST_False,self).optimize(compressor);// Boolean(x) ---> !!x
if(self.args.length==1)return make_node(AST_UnaryPrefix,self,{operator:"!",expression:make_node(AST_UnaryPrefix,self,{operator:"!",expression:self.args[0]})}).optimize(compressor);break;case"RegExp":// attempt to convert RegExp(...) to literal
var params=[];if(all(self.args,function(arg){var value=arg.evaluate(compressor);params.unshift(value);return arg!==value;}))try{return best_of(compressor,self,make_node(AST_RegExp,self,{value:RegExp.apply(RegExp,params)}));}catch(ex){AST_Node.warn("Error converting {this} [{start}]",self);}break;}else if(exp instanceof AST_Dot)switch(exp.property){case"toString":// x.toString() ---> "" + x
var expr=exp.expression;if(self.args.length==0&&!(expr.may_throw_on_access(compressor)||expr instanceof AST_Super)){return make_node(AST_Binary,self,{operator:"+",left:make_node(AST_String,self,{value:""}),right:expr}).optimize(compressor);}break;case"join":if(exp.expression instanceof AST_Array&&self.args.length<2)EXIT:{var separator=self.args[0];// [].join() ---> ""
// [].join(x) ---> (x, "")
if(exp.expression.elements.length==0&&!(separator instanceof AST_Spread)){return separator?make_sequence(self,[separator,make_node(AST_String,self,{value:""})]).optimize(compressor):make_node(AST_String,self,{value:""});}if(separator){separator=separator.evaluate(compressor);if(separator instanceof AST_Node)break EXIT;// not a constant
}var elements=[];var consts=[];for(var i=0;i<exp.expression.elements.length;i++){var el=exp.expression.elements[i];var value=el.evaluate(compressor);if(value!==el){consts.push(value);}else if(el instanceof AST_Spread){break EXIT;}else {if(consts.length>0){elements.push(make_node(AST_String,self,{value:consts.join(separator)}));consts.length=0;}elements.push(el);}}if(consts.length>0)elements.push(make_node(AST_String,self,{value:consts.join(separator)}));// [ x ].join() ---> "" + x
// [ x ].join(".") ---> "" + x
// [ 1, 2, 3 ].join() ---> "1,2,3"
// [ 1, 2, 3 ].join(".") ---> "1.2.3"
if(elements.length==1){if(elements[0].is_string(compressor))return elements[0];return make_node(AST_Binary,elements[0],{operator:"+",left:make_node(AST_String,self,{value:""}),right:elements[0]});}// [ 1, 2, a, 3 ].join("") ---> "12" + a + "3"
if(separator==""){var first;if(elements[0].is_string(compressor)||elements[1].is_string(compressor)){first=elements.shift();}else {first=make_node(AST_String,self,{value:""});}return elements.reduce(function(prev,el){return make_node(AST_Binary,el,{operator:"+",left:prev,right:el});},first).optimize(compressor);}// [ x, "foo", "bar", y ].join() ---> [ x, "foo,bar", y ].join()
// [ x, "foo", "bar", y ].join("-") ---> [ x, "foo-bar", y ].join("-")
// need this awkward cloning to not affect original element
// best_of will decide which one to get through.
var node=self.clone();node.expression=node.expression.clone();node.expression.expression=node.expression.expression.clone();node.expression.expression.elements=elements;return best_of(compressor,self,node);}break;case"charAt":if(self.args.length<2){var node=make_node(AST_Binary,self,{operator:"||",left:make_node(AST_Sub,self,{expression:exp.expression,property:self.args.length?make_node(AST_Binary,self.args[0],{operator:"|",left:make_node(AST_Number,self,{value:0}),right:self.args[0]}):make_node(AST_Number,self,{value:0})}).optimize(compressor),right:make_node(AST_String,self,{value:""})});node.is_string=return_true;return node.optimize(compressor);}break;case"apply":if(self.args.length==2&&self.args[1]instanceof AST_Array){var args=self.args[1].elements.slice();args.unshift(self.args[0]);return make_node(AST_Call,self,{expression:make_node(AST_Dot,exp,{expression:exp.expression,property:"call"}),args:args}).optimize(compressor);}break;case"call":var func=exp.expression;if(func instanceof AST_SymbolRef){func=func.fixed_value();}if(func instanceof AST_Lambda&&!func.contains_this()){return (self.args.length?make_sequence(self,[self.args[0],make_node(AST_Call,self,{expression:exp.expression,args:self.args.slice(1)})]):make_node(AST_Call,self,{expression:exp.expression,args:[]})).optimize(compressor);}break;}else if(compressor.option("side_effects")&&exp instanceof AST_Call&&exp.args.length==1&&is_undeclared_ref(exp.expression)&&exp.expression.name=="Object"){var call=self.clone();call.expression=maintain_this_binding(self,exp,exp.args[0]);return call.optimize(compressor);}}if(compressor.option("unsafe_Function")&&is_undeclared_ref(exp)&&exp.name=="Function"){// new Function() ---> function(){}
if(self.args.length==0)return make_node(AST_Function,self,{argnames:[],body:[]}).init_vars(exp.scope);if(all(self.args,function(x){return x instanceof AST_String;})){// quite a corner-case, but we can handle it:
//   https://github.com/mishoo/UglifyJS/issues/203
// if the code argument is a constant, then we can minify it.
try{var code="n(function("+self.args.slice(0,-1).map(function(arg){return arg.value;}).join()+"){"+self.args[self.args.length-1].value+"})";var ast=parse(code);var mangle={ie:compressor.option("ie")};ast.figure_out_scope(mangle);var comp=new Compressor(compressor.options);ast=ast.transform(comp);ast.figure_out_scope(mangle);ast.compute_char_frequency(mangle);ast.mangle_names(mangle);var fun;ast.walk(new TreeWalker(function(node){if(fun)return true;if(node instanceof AST_Lambda){fun=node;return true;}}));var code=OutputStream();AST_BlockStatement.prototype._codegen.call(fun,code);self.args=[make_node(AST_String,self,{value:fun.argnames.map(function(arg){return arg.print_to_string();}).join()}),make_node(AST_String,self.args[self.args.length-1],{value:code.get().replace(/^\{|\}$/g,"")})];return self;}catch(ex){if(ex instanceof JS_Parse_Error){AST_Node.warn("Error parsing code passed to new Function [{start}]",self.args[self.args.length-1]);AST_Node.warn(ex.toString());}else {throw ex;}}}}var fn=exp instanceof AST_SymbolRef?exp.fixed_value():exp;var parent=compressor.parent(),current=compressor.self();var is_func=fn instanceof AST_Lambda&&(!is_async(fn)||compressor.option("awaits")&&parent instanceof AST_Await)&&(!is_generator(fn)||compressor.option("yields")&&current instanceof AST_Yield&&current.nested);var stat=is_func&&fn.first_statement();var has_default=0,has_destructured=false;var has_spread=!all(self.args,function(arg){return !(arg instanceof AST_Spread);});var can_drop=is_func&&all(fn.argnames,function(argname,index){if(has_default==1&&self.args[index]instanceof AST_Spread)has_default=2;if(argname instanceof AST_DefaultValue){if(!has_default)has_default=1;var arg=has_default==1&&self.args[index];if(!is_undefined(arg))has_default=2;if(has_arg_refs(fn,argname.value))return false;argname=argname.name;}if(argname instanceof AST_Destructured){has_destructured=true;if(has_arg_refs(fn,argname))return false;}return true;})&&!(fn.rest instanceof AST_Destructured&&has_arg_refs(fn,fn.rest));var can_inline=can_drop&&compressor.option("inline")&&!self.is_expr_pure(compressor)&&(exp===fn||safe_from_strict_mode(fn,compressor));if(can_inline&&stat instanceof AST_Return){var value=stat.value;if(exp===fn&&!fn.name&&(!value||value.is_constant_expression())&&safe_from_await_yield(fn,avoid_await_yield(compressor))){return make_sequence(self,convert_args(value)).optimize(compressor);}}if(is_func&&!fn.contains_this()){var def,value,var_assigned=false;if(can_inline&&!fn.uses_arguments&&!fn.pinned()&&!(fn.name&&fn instanceof AST_LambdaExpression)&&(exp===fn||!recursive_ref(compressor,def=exp.definition(),fn)&&fn.is_constant_expression(find_scope(compressor)))&&(value=can_flatten_body(stat))){var replacing=exp===fn||def.single_use&&def.references.length-def.replaced==1;if(can_substitute_directly()){self._optimized=true;var retValue=value.optimize(compressor).clone(true);var args=self.args.slice();var refs=[];retValue=retValue.transform(new TreeTransformer(function(node){if(node instanceof AST_SymbolRef){var def=node.definition();if(fn.variables.get(node.name)!==def){refs.push(node);return node;}var index=resolve_index(def);var arg=args[index];if(!arg)return make_node(AST_Undefined,self);args[index]=null;var parent=this.parent();return parent?maintain_this_binding(parent,node,arg):arg;}}));var save_inlined=fn.inlined;if(exp!==fn)fn.inlined=true;var exprs=[];args.forEach(function(arg){if(!arg)return;arg=arg.clone(true);arg.walk(new TreeWalker(function(node){if(node instanceof AST_SymbolRef)refs.push(node);}));exprs.push(arg);},[]);exprs.push(retValue);var node=make_sequence(self,exprs).optimize(compressor);fn.inlined=save_inlined;node=maintain_this_binding(parent,current,node);self.inlined_node=node;if(replacing||best_of_expression(node,self)===node){refs.forEach(function(ref){ref.scope=exp===fn?fn.parent_scope:exp.scope;ref.reference();var def=ref.definition();if(replacing)def.replaced++;def.single_use=false;});return node;}else if(!node.has_side_effects(compressor)){self.drop_side_effect_free=function(compressor,first_in_statement){var self=this;var exprs=self.args.slice();exprs.unshift(self.expression);return make_sequence(self,exprs).drop_side_effect_free(compressor,first_in_statement);};self.has_side_effects=function(compressor){var self=this;var exprs=self.args.slice();exprs.unshift(self.expression);return make_sequence(self,exprs).has_side_effects(compressor);};}}var arg_used,insert,in_loop,scope;if(replacing&&can_inject_symbols()){fn._squeezed=true;if(exp!==fn)fn.parent_scope=exp.scope;var node=make_sequence(self,flatten_fn()).optimize(compressor);return maintain_this_binding(parent,current,node);}}if(compressor.option("side_effects")&&can_drop&&all(fn.body,is_empty)&&(fn===exp?fn_name_unused(fn,compressor):!has_default&&!has_destructured&&!fn.rest)&&!(is_arrow(fn)&&fn.value)&&safe_from_await_yield(fn,avoid_await_yield(compressor))){return make_sequence(self,convert_args()).optimize(compressor);}}if(compressor.option("arrows")&&compressor.option("module")&&(exp instanceof AST_AsyncFunction||exp instanceof AST_Function)&&!exp.name&&!exp.uses_arguments&&!exp.pinned()&&!exp.contains_this()){var arrow=make_node(is_async(exp)?AST_AsyncArrow:AST_Arrow,exp,exp);arrow.init_vars(exp.parent_scope,exp);arrow.variables.del("arguments");self.expression=arrow.transform(compressor);return self;}if(compressor.option("drop_console")){if(exp instanceof AST_PropAccess){var name=exp.expression;while(name.expression){name=name.expression;}if(is_undeclared_ref(name)&&name.name=="console"){return make_node(AST_Undefined,self).optimize(compressor);}}}if(compressor.option("negate_iife")&&parent instanceof AST_SimpleStatement&&is_iife_call(current)){return self.negate(compressor,true);}return try_evaluate(compressor,self);function make_void_lhs(orig){return make_node(AST_Sub,orig,{expression:make_node(AST_Array,orig,{elements:[]}),property:make_node(AST_Number,orig,{value:0})});}function convert_args(value){var args=self.args.slice();var destructured=has_default>1||has_destructured||fn.rest;if(destructured||has_spread)args=[make_node(AST_Array,self,{elements:args})];if(destructured){var tt=new TreeTransformer(function(node,descend){if(node instanceof AST_DefaultValue)return make_node(AST_DefaultValue,node,{name:node.name.transform(tt)||make_void_lhs(node),value:node.value});if(node instanceof AST_DestructuredArray){var elements=[];node.elements.forEach(function(node,index){node=node.transform(tt);if(node)elements[index]=node;});fill_holes(node,elements);return make_node(AST_DestructuredArray,node,{elements:elements});}if(node instanceof AST_DestructuredObject){var properties=[],side_effects=[];node.properties.forEach(function(prop){var key=prop.key;var value=prop.value.transform(tt);if(value){if(side_effects.length){if(!(key instanceof AST_Node))key=make_node_from_constant(key,prop);side_effects.push(key);key=make_sequence(node,side_effects);side_effects=[];}properties.push(make_node(AST_DestructuredKeyVal,prop,{key:key,value:value}));}else if(key instanceof AST_Node){side_effects.push(key);}});if(side_effects.length)properties.push(make_node(AST_DestructuredKeyVal,node,{key:make_sequence(node,side_effects),value:make_void_lhs(node)}));return make_node(AST_DestructuredObject,node,{properties:properties});}if(node instanceof AST_SymbolFunarg)return null;});var lhs=[];fn.argnames.forEach(function(argname,index){argname=argname.transform(tt);if(argname)lhs[index]=argname;});var rest=fn.rest&&fn.rest.transform(tt);if(rest)lhs.length=fn.argnames.length;fill_holes(fn,lhs);args[0]=make_node(AST_Assign,self,{operator:"=",left:make_node(AST_DestructuredArray,fn,{elements:lhs,rest:rest}),right:args[0]});}else fn.argnames.forEach(function(argname){if(argname instanceof AST_DefaultValue)args.push(argname.value);});args.push(value||make_node(AST_Undefined,self));return args;}function noop_value(){return self.call_only?make_node(AST_Number,self,{value:0}):make_node(AST_Undefined,self);}function return_value(stat){if(!stat)return noop_value();if(stat instanceof AST_Return)return stat.value||noop_value();if(stat instanceof AST_SimpleStatement){return self.call_only?stat.body:make_node(AST_UnaryPrefix,stat,{operator:"void",expression:stat.body});}}function can_flatten_body(stat){var len=fn.body.length;if(len<2){stat=return_value(stat);if(stat)return stat;}if(compressor.option("inline")<3)return false;stat=null;for(var i=0;i<len;i++){var line=fn.body[i];if(line instanceof AST_Var){if(var_assigned){if(!stat)continue;if(!(stat instanceof AST_SimpleStatement))return false;if(!declarations_only(line))stat=null;}else if(!declarations_only(line)){if(stat&&!(stat instanceof AST_SimpleStatement))return false;stat=null;var_assigned=true;}}else if(line instanceof AST_AsyncDefun||line instanceof AST_Defun||line instanceof AST_EmptyStatement){continue;}else if(stat){return false;}else {stat=line;}}return return_value(stat);}function resolve_index(def){for(var i=fn.argnames.length;--i>=0;){if(fn.argnames[i].definition()===def)return i;}}function can_substitute_directly(){if(has_default||has_destructured||has_spread||var_assigned||fn.rest)return;if(compressor.option("inline")<2&&fn.argnames.length)return;if(!fn.variables.all(function(def){return def.references.length-def.replaced<2&&def.orig[0]instanceof AST_SymbolFunarg;}))return;var scope=compressor.find_parent(AST_Scope);var abort=false;var avoid=avoid_await_yield(compressor,scope);var begin;var in_order=[];var side_effects=false;var tw=new TreeWalker(function(node,descend){if(abort)return true;if(node instanceof AST_Binary&&lazy_op[node.operator]||node instanceof AST_Conditional){in_order=null;return;}if(node instanceof AST_Class)return abort=true;if(node instanceof AST_Destructured){side_effects=true;return;}if(node instanceof AST_Scope)return abort=true;if(avoid&&node instanceof AST_Symbol&&avoid[node.name])return abort=true;if(node instanceof AST_SymbolRef){var def=node.definition();if(fn.variables.get(node.name)!==def){in_order=null;return;}if(def.init instanceof AST_LambdaDefinition)return abort=true;if(is_lhs(node,tw.parent()))return abort=true;var index=resolve_index(def);if(!(begin<index))begin=index;if(!in_order)return;if(side_effects){in_order=null;}else {in_order.push(fn.argnames[index]);}return;}if(side_effects)return;if(node instanceof AST_Assign&&node.left instanceof AST_PropAccess){node.left.expression.walk(tw);if(node.left instanceof AST_Sub)node.left.property.walk(tw);node.right.walk(tw);side_effects=true;return true;}if(node.has_side_effects(compressor)){descend();side_effects=true;return true;}});value.walk(tw);if(abort)return;var end=self.args.length;if(in_order&&fn.argnames.length>=end){end=fn.argnames.length;while(end-->begin&&fn.argnames[end]===in_order.pop());end++;}return end<=begin||all(self.args.slice(begin,end),side_effects&&!in_order?function(funarg){return funarg.is_constant_expression(scope);}:function(funarg){return !funarg.has_side_effects(compressor);});}function var_exists(defined,name){return defined.has(name)||identifier_atom[name]||scope.var_names().has(name);}function can_inject_args(defined,safe_to_inject){var abort=false;fn.each_argname(function(arg){if(abort)return;if(arg.unused)return;if(!safe_to_inject||var_exists(defined,arg.name))return abort=true;arg_used.set(arg.name,true);if(in_loop)in_loop.push(arg.definition());});return !abort;}function can_inject_vars(defined,safe_to_inject){for(var i=0;i<fn.body.length;i++){var stat=fn.body[i];if(stat instanceof AST_LambdaDefinition){var name=stat.name;if(!safe_to_inject)return false;if(arg_used.has(name.name))return false;if(var_exists(defined,name.name))return false;if(!all(stat.enclosed,function(def){return def.scope===scope||def.scope===stat||!defined.has(def.name);}))return false;if(in_loop)in_loop.push(name.definition());continue;}if(!(stat instanceof AST_Var))continue;if(!safe_to_inject)return false;for(var j=stat.definitions.length;--j>=0;){var name=stat.definitions[j].name;if(var_exists(defined,name.name))return false;if(in_loop)in_loop.push(name.definition());}}return true;}function can_inject_symbols(){var defined=new Dictionary();var level=0,child;scope=current;do{if(scope.variables)scope.variables.each(function(def){defined.set(def.name,true);});child=scope;scope=compressor.parent(level++);if(scope instanceof AST_ClassField){if(!scope.static)return false;}else if(scope instanceof AST_DWLoop){in_loop=[];}else if(scope instanceof AST_For){if(scope.init===child)continue;in_loop=[];}else if(scope instanceof AST_ForEnumeration){if(scope.init===child)continue;if(scope.object===child)continue;in_loop=[];}}while(!(scope instanceof AST_Scope));insert=scope.body.indexOf(child)+1;if(!insert)return false;if(!safe_from_await_yield(fn,avoid_await_yield(compressor,scope)))return false;var safe_to_inject=(exp!==fn||fn.parent_scope.resolve()===scope)&&!scope.pinned();if(scope instanceof AST_Toplevel){if(compressor.toplevel.vars){defined.set("arguments",true);}else {safe_to_inject=false;}}arg_used=new Dictionary();var inline=compressor.option("inline");if(!can_inject_args(defined,inline>=2&&safe_to_inject))return false;if(!can_inject_vars(defined,inline>=3&&safe_to_inject))return false;return !in_loop||in_loop.length==0||!is_reachable(fn,in_loop);}function append_var(decls,expressions,name,value){var def=name.definition();if(!scope.var_names().has(name.name)){def.first_decl=null;scope.var_names().set(name.name,true);decls.push(make_node(AST_VarDef,name,{name:name,value:null}));}scope.variables.set(name.name,def);scope.enclosed.push(def);if(!value)return;var sym=make_node(AST_SymbolRef,name);def.assignments++;def.references.push(sym);expressions.push(make_node(AST_Assign,self,{operator:"=",left:sym,right:value}));}function flatten_args(decls,expressions){var len=fn.argnames.length;for(var i=self.args.length;--i>=len;){expressions.push(self.args[i]);}var default_args=[];for(i=len;--i>=0;){var argname=fn.argnames[i];var name;if(argname instanceof AST_DefaultValue){default_args.push(argname);name=argname.name;}else {name=argname;}var value=self.args[i];if(name.unused||scope.var_names().has(name.name)){if(value)expressions.push(value);}else {var symbol=make_node(AST_SymbolVar,name);var def=name.definition();def.orig.push(symbol);def.eliminated++;if(name.unused!==undefined){append_var(decls,expressions,symbol);if(value)expressions.push(value);}else {if(!value&&argname===name&&(in_loop||name.name=="arguments"&&!is_arrow(fn)&&is_arrow(scope))){value=make_node(AST_Undefined,self);}append_var(decls,expressions,symbol,value);}}}decls.reverse();expressions.reverse();for(i=default_args.length;--i>=0;){var node=default_args[i];if(node.name.unused!==undefined){expressions.push(node.value);}else {var sym=make_node(AST_SymbolRef,node.name);node.name.definition().references.push(sym);expressions.push(make_node(AST_Assign,node,{operator:"=",left:sym,right:node.value}));}}}function flatten_destructured(decls,expressions){expressions.push(make_node(AST_Assign,self,{operator:"=",left:make_node(AST_DestructuredArray,self,{elements:fn.argnames.map(function(argname){if(argname.unused)return make_node(AST_Hole,argname);return argname.convert_symbol(AST_SymbolRef,process);}),rest:fn.rest&&fn.rest.convert_symbol(AST_SymbolRef,process)}),right:make_node(AST_Array,self,{elements:self.args.slice()})}));function process(ref,name){if(name.unused)return make_void_lhs(name);var def=name.definition();def.assignments++;def.references.push(ref);var symbol=make_node(AST_SymbolVar,name);def.orig.push(symbol);def.eliminated++;append_var(decls,expressions,symbol);}}function flatten_vars(decls,expressions){var args=[insert,0];var decl_var=[],expr_fn=[],expr_var=[],expr_loop=[],exprs=[];fn.body.filter(in_loop?function(stat){if(!(stat instanceof AST_LambdaDefinition))return true;var name=make_node(AST_SymbolVar,flatten_var(stat.name));var def=name.definition();def.fixed=false;def.orig.push(name);def.eliminated++;append_var(decls,expr_fn,name,to_func_expr(stat,true));return false;}:function(stat){if(!(stat instanceof AST_LambdaDefinition))return true;var def=stat.name.definition();scope.functions.set(def.name,def);scope.variables.set(def.name,def);scope.enclosed.push(def);scope.var_names().set(def.name,true);args.push(stat);return false;}).forEach(function(stat){if(!(stat instanceof AST_Var)){if(stat instanceof AST_SimpleStatement)exprs.push(stat.body);return;}for(var j=0;j<stat.definitions.length;j++){var var_def=stat.definitions[j];var name=flatten_var(var_def.name);var value=var_def.value;if(value&&exprs.length>0){exprs.push(value);value=make_sequence(var_def,exprs);exprs=[];}append_var(decl_var,expr_var,name,value);if(!in_loop)continue;if(arg_used.has(name.name))continue;if(name.definition().orig.length==1&&fn.functions.has(name.name))continue;expr_loop.push(init_ref(compressor,name));}});[].push.apply(decls,decl_var);[].push.apply(expressions,expr_loop);[].push.apply(expressions,expr_fn);[].push.apply(expressions,expr_var);return args;}function flatten_fn(){var decls=[];var expressions=[];if(has_default>1||has_destructured||has_spread||fn.rest){flatten_destructured(decls,expressions);}else {flatten_args(decls,expressions);}var args=flatten_vars(decls,expressions);expressions.push(value);if(decls.length)args.push(make_node(AST_Var,fn,{definitions:decls}));[].splice.apply(scope.body,args);fn.enclosed.forEach(function(def){if(scope.var_names().has(def.name))return;scope.enclosed.push(def);scope.var_names().set(def.name,true);});return expressions;}});OPT(AST_New,function(self,compressor){if(compressor.option("unsafe")){var exp=self.expression;if(is_undeclared_ref(exp))switch(exp.name){case"Array":case"Error":case"Function":case"Object":case"RegExp":return make_node(AST_Call,self).transform(compressor);}}if(compressor.option("sequences")){var seq=lift_sequence_in_expression(self);if(seq!==self)return seq.optimize(compressor);}if(compressor.option("unused"))drop_unused_call_args(self,compressor);return self;});// (a = b, x && a = c) ---> a = x ? c : b
// (a = b, x || a = c) ---> a = x ? b : c
function to_conditional_assignment(compressor,def,value,node){if(!(node instanceof AST_Binary))return;if(!(node.operator=="&&"||node.operator=="||"))return;if(!(node.right instanceof AST_Assign))return;if(node.right.operator!="=")return;if(!(node.right.left instanceof AST_SymbolRef))return;if(node.right.left.definition()!==def)return;if(value.has_side_effects(compressor))return;if(!safe_from_assignment(node.left))return;if(!safe_from_assignment(node.right.right))return;def.replaced++;return node.operator=="&&"?make_node(AST_Conditional,node,{condition:node.left,consequent:node.right.right,alternative:value}):make_node(AST_Conditional,node,{condition:node.left,consequent:value,alternative:node.right.right});function safe_from_assignment(node){if(node.has_side_effects(compressor))return;var hit=false;node.walk(new TreeWalker(function(node){if(hit)return true;if(node instanceof AST_SymbolRef&&node.definition()===def)return hit=true;}));return !hit;}}OPT(AST_Sequence,function(self,compressor){var expressions=filter_for_side_effects();var end=expressions.length-1;merge_assignments();trim_right_for_undefined();if(end==0){self=maintain_this_binding(compressor.parent(),compressor.self(),expressions[0]);if(!(self instanceof AST_Sequence))self=self.optimize(compressor);return self;}self.expressions=expressions;return self;function filter_for_side_effects(){if(!compressor.option("side_effects"))return self.expressions;var expressions=[];var first=first_in_statement(compressor);var last=self.expressions.length-1;self.expressions.forEach(function(expr,index){if(index<last)expr=expr.drop_side_effect_free(compressor,first);if(expr){merge_sequence(expressions,expr);first=false;}});return expressions;}function trim_right_for_undefined(){if(!compressor.option("side_effects"))return;while(end>0&&is_undefined(expressions[end],compressor))end--;if(end<expressions.length-1){expressions[end]=make_node(AST_UnaryPrefix,self,{operator:"void",expression:expressions[end]});expressions.length=end+1;}}function is_simple_assign(node){return node instanceof AST_Assign&&node.operator=="="&&node.left instanceof AST_SymbolRef&&node.left.definition();}function merge_assignments(){for(var i=1;i<end;i++){var prev=expressions[i-1];var def=is_simple_assign(prev);if(!def)continue;var expr=expressions[i];if(compressor.option("conditionals")){var cond=to_conditional_assignment(compressor,def,prev.right,expr);if(cond){prev.right=cond;expressions.splice(i--,1);end--;continue;}}if(compressor.option("dead_code")&&is_simple_assign(expr)===def&&expr.right.is_constant_expression(def.scope.resolve())){expressions[--i]=prev.right;}}}});OPT(AST_UnaryPostfix,function(self,compressor){if(compressor.option("sequences")){var seq=lift_sequence_in_expression(self);if(seq!==self)return seq.optimize(compressor);}return try_evaluate(compressor,self);});var SIGN_OPS=makePredicate("+ -");var MULTIPLICATIVE_OPS=makePredicate("* / %");OPT(AST_UnaryPrefix,function(self,compressor){var op=self.operator;var exp=self.expression;if(compressor.option("sequences")&&can_lift()){var seq=lift_sequence_in_expression(self);if(seq!==self)return seq.optimize(compressor);}switch(op){case"+":if(!compressor.option("evaluate"))break;if(!exp.is_number(compressor,true))break;var parent=compressor.parent();if(parent instanceof AST_UnaryPrefix&&parent.operator=="delete")break;return exp;case"-":if(exp instanceof AST_Infinity)exp=exp.transform(compressor);// avoids infinite recursion of numerals
if(exp instanceof AST_Number||exp instanceof AST_Infinity)return self;break;case"!":if(!compressor.option("booleans"))break;if(exp.is_truthy())return make_sequence(self,[exp,make_node(AST_False,self)]).optimize(compressor);if(compressor.in_boolean_context()){// !!foo ---> foo, if we're in boolean context
if(exp instanceof AST_UnaryPrefix&&exp.operator=="!")return exp.expression;if(exp instanceof AST_Binary){var first=first_in_statement(compressor);self=(first?best_of_statement:best_of_expression)(self,exp.negate(compressor,first));}}break;case"delete":if(!compressor.option("evaluate"))break;if(may_not_delete(exp))break;return make_sequence(self,[exp,make_node(AST_True,self)]).optimize(compressor);case"typeof":if(!compressor.option("booleans"))break;if(!compressor.in_boolean_context())break;// typeof always returns a non-empty string, thus always truthy
AST_Node.warn("Boolean expression always true [{start}]",self);var exprs=[make_node(AST_True,self)];if(!(exp instanceof AST_SymbolRef&&can_drop_symbol(exp,compressor)))exprs.unshift(exp);return make_sequence(self,exprs).optimize(compressor);case"void":if(!compressor.option("side_effects"))break;exp=exp.drop_side_effect_free(compressor);if(!exp)return make_node(AST_Undefined,self).optimize(compressor);self.expression=exp;return self;}if(compressor.option("evaluate")&&exp instanceof AST_Binary&&SIGN_OPS[op]&&MULTIPLICATIVE_OPS[exp.operator]&&(exp.left.is_constant()||!exp.right.has_side_effects(compressor))){return make_node(AST_Binary,self,{operator:exp.operator,left:make_node(AST_UnaryPrefix,exp.left,{operator:op,expression:exp.left}),right:exp.right});}return try_evaluate(compressor,self);function may_not_delete(node){return node instanceof AST_Infinity||node instanceof AST_NaN||node instanceof AST_NewTarget||node instanceof AST_PropAccess||node instanceof AST_SymbolRef||node instanceof AST_Undefined;}function can_lift(){switch(op){case"delete":return !may_not_delete(exp.tail_node());case"typeof":return !is_undeclared_ref(exp.tail_node());default:return true;}}});OPT(AST_Await,function(self,compressor){if(!compressor.option("awaits"))return self;if(compressor.option("sequences")){var seq=lift_sequence_in_expression(self);if(seq!==self)return seq.optimize(compressor);}if(compressor.option("side_effects")){var exp=self.expression;if(exp instanceof AST_Await)return exp.optimize(compressor);if(exp instanceof AST_UnaryPrefix&&exp.expression instanceof AST_Await)return exp.optimize(compressor);for(var level=0,node=self,parent;parent=compressor.parent(level++);node=parent){if(is_arrow(parent)){if(parent.value===node)return exp.optimize(compressor);}else if(parent instanceof AST_Return){var drop=true;do{node=parent;parent=compressor.parent(level++);if(parent instanceof AST_Try&&(parent.bfinally||parent.bcatch)!==node){drop=false;break;}}while(parent&&!(parent instanceof AST_Scope));if(drop)return exp.optimize(compressor);}else if(parent instanceof AST_Sequence){if(parent.tail_node()===node)continue;}break;}}return self;});OPT(AST_Yield,function(self,compressor){if(!compressor.option("yields"))return self;if(compressor.option("sequences")){var seq=lift_sequence_in_expression(self);if(seq!==self)return seq.optimize(compressor);}var exp=self.expression;if(self.nested&&exp.TYPE=="Call"){var inlined=exp.clone().optimize(compressor);if(inlined.TYPE!="Call")return inlined;}return self;});AST_Binary.DEFMETHOD("lift_sequences",function(compressor){if(this.left instanceof AST_PropAccess){if(!(this.left.expression instanceof AST_Sequence))return this;var x=this.left.expression.expressions.slice();var e=this.clone();e.left=e.left.clone();e.left.expression=x.pop();x.push(e);return make_sequence(this,x);}if(this.left instanceof AST_Sequence){var x=this.left.expressions.slice();var e=this.clone();e.left=x.pop();x.push(e);return make_sequence(this,x);}if(this.right instanceof AST_Sequence){if(this.left.has_side_effects(compressor))return this;var assign=this.operator=="="&&this.left instanceof AST_SymbolRef;var x=this.right.expressions;var last=x.length-1;for(var i=0;i<last;i++){if(!assign&&x[i].has_side_effects(compressor))break;}if(i==last){x=x.slice();var e=this.clone();e.right=x.pop();x.push(e);return make_sequence(this,x);}if(i>0){var e=this.clone();e.right=make_sequence(this.right,x.slice(i));x=x.slice(0,i);x.push(e);return make_sequence(this,x);}}return this;});var indexFns=makePredicate("indexOf lastIndexOf");var commutativeOperators=makePredicate("== === != !== * & | ^");function is_object(node,plain){if(node instanceof AST_Assign)return !plain&&node.operator=="="&&is_object(node.right);if(node instanceof AST_New)return !plain;if(node instanceof AST_Sequence)return is_object(node.tail_node(),plain);if(node instanceof AST_SymbolRef)return !plain&&is_object(node.fixed_value());return node instanceof AST_Array||node instanceof AST_Class||node instanceof AST_Lambda||node instanceof AST_Object;}function can_drop_op(node,compressor){var rhs=node.right;switch(node.operator){case"in":return is_object(rhs)||compressor&&compressor.option("unsafe_comps");case"instanceof":if(rhs instanceof AST_SymbolRef)rhs=rhs.fixed_value();if(rhs instanceof AST_Defun||rhs instanceof AST_Function||is_generator(rhs))return true;if(is_lambda(rhs)&&node.left.is_constant())return true;return compressor&&compressor.option("unsafe_comps");default:return true;}}function needs_enqueuing(compressor,node){if(node.is_constant())return true;if(node instanceof AST_Assign)return node.operator!="="||needs_enqueuing(compressor,node.right);if(node instanceof AST_Binary){return !lazy_op[node.operator]||needs_enqueuing(compressor,node.left)&&needs_enqueuing(compressor,node.right);}if(node instanceof AST_Call){if(!is_async(node.expression))return false;var has_await=false;walk_body(node.expression,new TreeWalker(function(expr){if(has_await)return true;if(expr instanceof AST_Await)return has_await=true;if(expr!==node&&expr instanceof AST_Scope)return true;}));return !has_await;}if(node instanceof AST_Conditional){return needs_enqueuing(compressor,node.consequent)&&needs_enqueuing(compressor,node.alternative);}if(node instanceof AST_Sequence)return needs_enqueuing(compressor,node.tail_node());if(node instanceof AST_SymbolRef){var fixed=node.fixed_value();return fixed&&needs_enqueuing(compressor,fixed);}if(node instanceof AST_Template)return !node.tag||is_raw_tag(compressor,node.tag);if(node instanceof AST_Unary)return true;}function extract_lhs(node,compressor){if(node instanceof AST_Assign)return is_lhs_read_only(node.left,compressor)?node:node.left;if(node instanceof AST_Sequence)return extract_lhs(node.tail_node(),compressor);if(node instanceof AST_UnaryPrefix&&UNARY_POSTFIX[node.operator]){return is_lhs_read_only(node.expression,compressor)?node:node.expression;}return node;}function repeatable(compressor,node){if(node instanceof AST_Dot)return repeatable(compressor,node.expression);if(node instanceof AST_Sub){return repeatable(compressor,node.expression)&&repeatable(compressor,node.property);}if(node instanceof AST_Symbol)return true;return !node.has_side_effects(compressor);}function swap_chain(self,compressor){var rhs=self.right.tail_node();if(rhs!==self.right){var exprs=self.right.expressions.slice(0,-1);exprs.push(rhs.left);rhs=rhs.clone();rhs.left=make_sequence(self.right,exprs);self.right=rhs;}self.left=make_node(AST_Binary,self,{operator:self.operator,left:self.left,right:rhs.left,start:self.left.start,end:rhs.left.end});self.right=rhs.right;if(compressor){var left=self.left.transform(compressor);if(left!==self.left){self=self.clone();self.left=left;}return self;}if(self.operator==rhs.left.operator)swap_chain(self.left);}OPT(AST_Binary,function(self,compressor){if(commutativeOperators[self.operator]&&self.right.is_constant()&&!self.left.is_constant()&&!(self.left instanceof AST_Binary&&PRECEDENCE[self.left.operator]>=PRECEDENCE[self.operator])){// if right is a constant, whatever side effects the
// left side might have could not influence the
// result.  hence, force switch.
reverse();}if(compressor.option("sequences")){var seq=self.lift_sequences(compressor);if(seq!==self)return seq.optimize(compressor);}if(compressor.option("assignments")&&lazy_op[self.operator]){var lhs=extract_lhs(self.left,compressor);var right=self.right;// a || (a = x) ---> a = a || x
// (a = x) && (a = y) ---> a = (a = x) && y
if(lhs instanceof AST_SymbolRef&&right instanceof AST_Assign&&right.operator=="="&&lhs.equals(right.left)){lhs=lhs.clone();var assign=make_node(AST_Assign,self,{operator:"=",left:lhs,right:make_node(AST_Binary,self,{operator:self.operator,left:self.left,right:right.right})});if(lhs.fixed){lhs.fixed=function(){return assign.right;};lhs.fixed.assigns=[assign];}var def=lhs.definition();def.references.push(lhs);def.replaced++;return assign.optimize(compressor);}}if(compressor.option("comparisons"))switch(self.operator){case"===":case"!==":if(is_undefined(self.left,compressor)&&self.right.is_defined(compressor)){AST_Node.warn("Expression always defined [{start}]",self);return make_sequence(self,[self.right,make_node(self.operator=="==="?AST_False:AST_True,self)]).optimize(compressor);}var is_strict_comparison=true;if(self.left.is_string(compressor)&&self.right.is_string(compressor)||self.left.is_number(compressor)&&self.right.is_number(compressor)||self.left.is_boolean(compressor)&&self.right.is_boolean(compressor)||repeatable(compressor,self.left)&&self.left.equals(self.right)){self.operator=self.operator.slice(0,2);}// XXX: intentionally falling down to the next case
case"==":case"!=":// void 0 == x ---> null == x
if(!is_strict_comparison&&is_undefined(self.left,compressor)){self.left=make_node(AST_Null,self.left);}// "undefined" == typeof x ---> undefined === x
else if(compressor.option("typeofs")&&self.left instanceof AST_String&&self.left.value=="undefined"&&self.right instanceof AST_UnaryPrefix&&self.right.operator=="typeof"){var expr=self.right.expression;if(expr instanceof AST_SymbolRef?expr.is_declared(compressor):!(expr instanceof AST_PropAccess&&compressor.option("ie"))){self.right=expr;self.left=make_node(AST_Undefined,self.left).optimize(compressor);if(self.operator.length==2)self.operator+="=";}}// obj !== obj ---> false
else if(self.left instanceof AST_SymbolRef&&self.right instanceof AST_SymbolRef&&self.left.definition()===self.right.definition()&&is_object(self.left)){return make_node(self.operator[0]=="="?AST_True:AST_False,self).optimize(compressor);}break;case"&&":case"||":// void 0 !== x && null !== x ---> null != x
// void 0 === x.a || null === x.a ---> null == x.a
var left=self.left;if(left.inlined_node)left=left.inlined_node;if(!(left instanceof AST_Binary))break;if(left.operator!=(self.operator=="&&"?"!==":"==="))break;var right=self.right;if(right.inlined_node)right=right.inlined_node;if(!(right instanceof AST_Binary))break;if(left.operator!=right.operator)break;if(is_undefined(left.left,compressor)&&right.left instanceof AST_Null||left.left instanceof AST_Null&&is_undefined(right.left,compressor)){var expr=extract_lhs(left.right,compressor);if(!repeatable(compressor,expr))break;if(!expr.equals(right.right))break;left.operator=left.operator.slice(0,-1);left.left=make_node(AST_Null,self);return left;}break;}var in_bool=false;var parent=compressor.parent();if(compressor.option("booleans")){var lhs=extract_lhs(self.left,compressor);if(lazy_op[self.operator]&&repeatable(compressor,lhs)){// a || a ---> a
// (a = x) && a --> a = x
if(lhs.equals(self.right)){return maintain_this_binding(parent,compressor.self(),self.left).optimize(compressor);}mark_duplicate_condition(compressor,lhs);}in_bool=compressor.in_boolean_context();}if(in_bool)switch(self.operator){case"+":var ev=self.left.evaluate(compressor,true);if(ev&&typeof ev=="string"||(ev=self.right.evaluate(compressor,true))&&typeof ev=="string"){AST_Node.warn("+ in boolean context always true [{start}]",self);var exprs=[];if(self.left.evaluate(compressor)instanceof AST_Node)exprs.push(self.left);if(self.right.evaluate(compressor)instanceof AST_Node)exprs.push(self.right);switch(exprs.length){case 0:return make_node(AST_True,self).optimize(compressor);case 1:exprs[0]=exprs[0].clone();exprs.push(make_node(AST_True,self));return make_sequence(self,exprs).optimize(compressor);}self.truthy=true;}break;case"==":if(self.left instanceof AST_String&&self.left.value==""&&self.right.is_string(compressor)){return make_node(AST_UnaryPrefix,self,{operator:"!",expression:self.right}).optimize(compressor);}break;case"!=":if(self.left instanceof AST_String&&self.left.value==""&&self.right.is_string(compressor)){return self.right.optimize(compressor);}break;}if(compressor.option("comparisons")&&self.is_boolean(compressor)){if(parent.TYPE!="Binary"){var negated=make_node(AST_UnaryPrefix,self,{operator:"!",expression:self.negate(compressor)});if(best_of(compressor,self,negated)===negated)return negated;}switch(self.operator){case">":reverse("<");break;case">=":reverse("<=");break;}}if(compressor.option("conditionals")&&lazy_op[self.operator]){if(self.left instanceof AST_Binary&&self.operator==self.left.operator){var before=make_node(AST_Binary,self,{operator:self.operator,left:self.left.right,right:self.right});var after=before.transform(compressor);if(before!==after){self.left=self.left.left;self.right=after;}}// x && (y && z) ---> x && y && z
// w || (x, y || z) ---> w || (x, y) || z
var rhs=self.right.tail_node();if(rhs instanceof AST_Binary&&self.operator==rhs.operator)self=swap_chain(self,compressor);}if(compressor.option("strings")&&self.operator=="+"){// "foo" + 42 + "" ---> "foo" + 42
if(self.right instanceof AST_String&&self.right.value==""&&self.left.is_string(compressor)){return self.left.optimize(compressor);}// "" + ("foo" + 42) ---> "foo" + 42
if(self.left instanceof AST_String&&self.left.value==""&&self.right.is_string(compressor)){return self.right.optimize(compressor);}// "" + 42 + "foo" ---> 42 + "foo"
if(self.left instanceof AST_Binary&&self.left.operator=="+"&&self.left.left instanceof AST_String&&self.left.left.value==""&&self.right.is_string(compressor)&&(self.left.right.is_constant()||!self.right.has_side_effects(compressor))){self.left=self.left.right;return self.optimize(compressor);}// "x" + (y + "z") ---> "x" + y + "z"
// w + (x, "y" + z) ---> w + (x, "y") + z
var rhs=self.right.tail_node();if(rhs instanceof AST_Binary&&self.operator==rhs.operator&&(self.left.is_string(compressor)&&rhs.is_string(compressor)||rhs.left.is_string(compressor)&&(self.left.is_constant()||!rhs.right.has_side_effects(compressor)))){self=swap_chain(self,compressor);}}if(compressor.option("evaluate")){var associative=true;switch(self.operator){case"&&":var ll=fuzzy_eval(compressor,self.left);if(!ll){AST_Node.warn("Condition left of && always false [{start}]",self);return maintain_this_binding(parent,compressor.self(),self.left).optimize(compressor);}else if(!(ll instanceof AST_Node)){AST_Node.warn("Condition left of && always true [{start}]",self);return make_sequence(self,[self.left,self.right]).optimize(compressor);}if(!self.right.evaluate(compressor,true)){if(in_bool&&!(self.right.evaluate(compressor)instanceof AST_Node)){AST_Node.warn("Boolean && always false [{start}]",self);return make_sequence(self,[self.left,make_node(AST_False,self)]).optimize(compressor);}else self.falsy=true;}else if((in_bool||parent.operator=="&&"&&parent.left===compressor.self())&&!(self.right.evaluate(compressor)instanceof AST_Node)){AST_Node.warn("Dropping side-effect-free && [{start}]",self);return self.left.optimize(compressor);}// (x || false) && y ---> x ? y : false
if(self.left.operator=="||"){var lr=fuzzy_eval(compressor,self.left.right);if(!lr)return make_node(AST_Conditional,self,{condition:self.left.left,consequent:self.right,alternative:self.left.right}).optimize(compressor);}break;case"??":var nullish=true;case"||":var ll=fuzzy_eval(compressor,self.left,nullish);if(nullish?ll==null:!ll){AST_Node.warn("Condition left of {operator} always {value} [{start}]",{operator:self.operator,value:nullish?"nullish":"false",start:self.start});return make_sequence(self,[self.left,self.right]).optimize(compressor);}else if(!(ll instanceof AST_Node)){AST_Node.warn("Condition left of {operator} always {value} [{start}]",{operator:self.operator,value:nullish?"defined":"true",start:self.start});return maintain_this_binding(parent,compressor.self(),self.left).optimize(compressor);}var rr;if(!nullish&&(rr=self.right.evaluate(compressor,true))&&!(rr instanceof AST_Node)){if(in_bool&&!(self.right.evaluate(compressor)instanceof AST_Node)){AST_Node.warn("Boolean || always true [{start}]",self);return make_sequence(self,[self.left,make_node(AST_True,self)]).optimize(compressor);}else self.truthy=true;}else if((in_bool||parent.operator=="||"&&parent.left===compressor.self())&&!self.right.evaluate(compressor)){AST_Node.warn("Dropping side-effect-free {operator} [{start}]",self);return self.left.optimize(compressor);}// x && true || y ---> x ? true : y
if(!nullish&&self.left.operator=="&&"){var lr=fuzzy_eval(compressor,self.left.right);if(lr&&!(lr instanceof AST_Node))return make_node(AST_Conditional,self,{condition:self.left.left,consequent:self.left.right,alternative:self.right}).optimize(compressor);}break;case"+":// "foo" + ("bar" + x) ---> "foobar" + x
if(self.left instanceof AST_Constant&&self.right instanceof AST_Binary&&self.right.operator=="+"&&self.right.left instanceof AST_Constant&&self.right.is_string(compressor)){self=make_node(AST_Binary,self,{operator:"+",left:make_node(AST_String,self.left,{value:""+self.left.value+self.right.left.value,start:self.left.start,end:self.right.left.end}),right:self.right.right});}// (x + "foo") + "bar" ---> x + "foobar"
if(self.right instanceof AST_Constant&&self.left instanceof AST_Binary&&self.left.operator=="+"&&self.left.right instanceof AST_Constant&&self.left.is_string(compressor)){self=make_node(AST_Binary,self,{operator:"+",left:self.left.left,right:make_node(AST_String,self.right,{value:""+self.left.right.value+self.right.value,start:self.left.right.start,end:self.right.end})});}// a + -b ---> a - b
if(self.right instanceof AST_UnaryPrefix&&self.right.operator=="-"&&self.left.is_number(compressor)){self=make_node(AST_Binary,self,{operator:"-",left:self.left,right:self.right.expression});break;}// -a + b ---> b - a
if(self.left instanceof AST_UnaryPrefix&&self.left.operator=="-"&&reversible()&&self.right.is_number(compressor)){self=make_node(AST_Binary,self,{operator:"-",left:self.right,right:self.left.expression});break;}// (a + b) + 3 ---> 3 + (a + b)
if(compressor.option("unsafe_math")&&self.left instanceof AST_Binary&&PRECEDENCE[self.left.operator]==PRECEDENCE[self.operator]&&self.right.is_constant()&&(self.right.is_boolean(compressor)||self.right.is_number(compressor))&&self.left.is_number(compressor)&&!self.left.right.is_constant()&&(self.left.left.is_boolean(compressor)||self.left.left.is_number(compressor))){self=make_node(AST_Binary,self,{operator:self.left.operator,left:make_node(AST_Binary,self,{operator:self.operator,left:self.right,right:self.left.left}),right:self.left.right});break;}case"-":// a - -b ---> a + b
if(self.right instanceof AST_UnaryPrefix&&self.right.operator=="-"&&self.left.is_number(compressor)&&self.right.expression.is_number(compressor)){self=make_node(AST_Binary,self,{operator:"+",left:self.left,right:self.right.expression});break;}case"*":case"/":associative=compressor.option("unsafe_math");// +a - b ---> a - b
// a - +b ---> a - b
if(self.operator!="+")["left","right"].forEach(function(operand){var node=self[operand];if(node instanceof AST_UnaryPrefix&&node.operator=="+"){var exp=node.expression;if(exp.is_boolean(compressor)||exp.is_number(compressor)||exp.is_string(compressor)){self[operand]=exp;}}});case"&":case"|":case"^":// a + +b ---> +b + a
if(self.operator!="-"&&self.operator!="/"&&(self.left.is_boolean(compressor)||self.left.is_number(compressor))&&(self.right.is_boolean(compressor)||self.right.is_number(compressor))&&reversible()&&!(self.left instanceof AST_Binary&&self.left.operator!=self.operator&&PRECEDENCE[self.left.operator]>=PRECEDENCE[self.operator])){self=best_of(compressor,self,make_node(AST_Binary,self,{operator:self.operator,left:self.right,right:self.left}),self.right instanceof AST_Constant&&!(self.left instanceof AST_Constant));}if(!associative||!self.is_number(compressor))break;// a + (b + c) ---> (a + b) + c
if(self.right instanceof AST_Binary&&self.right.operator!="%"&&PRECEDENCE[self.right.operator]==PRECEDENCE[self.operator]&&self.right.is_number(compressor)&&(self.operator!="+"||self.right.left.is_boolean(compressor)||self.right.left.is_number(compressor))&&(self.operator!="-"||!self.left.is_negative_zero())&&(self.right.left.is_constant_expression()||!self.right.right.has_side_effects(compressor))&&!is_modify_array(self.right.right)){self=make_node(AST_Binary,self,{operator:align(self.operator,self.right.operator),left:make_node(AST_Binary,self.left,{operator:self.operator,left:self.left,right:self.right.left,start:self.left.start,end:self.right.left.end}),right:self.right.right});if(self.operator=="+"&&!self.right.is_boolean(compressor)&&!self.right.is_number(compressor)){self.right=make_node(AST_UnaryPrefix,self.right,{operator:"+",expression:self.right});}}// (2 * n) * 3 ---> 6 * n
// (n + 2) + 3 ---> n + 5
if(self.right instanceof AST_Constant&&self.left instanceof AST_Binary&&self.left.operator!="%"&&PRECEDENCE[self.left.operator]==PRECEDENCE[self.operator]&&self.left.is_number(compressor)){if(self.left.left instanceof AST_Constant){var lhs=make_binary(self.operator,self.left.left,self.right,{start:self.left.left.start,end:self.right.end});self=make_binary(self.left.operator,try_evaluate(compressor,lhs),self.left.right,self);}else if(self.left.right instanceof AST_Constant){var op=align(self.left.operator,self.operator);var rhs=try_evaluate(compressor,make_binary(op,self.left.right,self.right,self.left));if(rhs.is_constant()&&!(self.left.operator=="-"&&self.right.value!=0&&+rhs.value==0&&self.left.left.is_negative_zero())){self=make_binary(self.left.operator,self.left.left,rhs,self);}}}break;case"instanceof":if(!can_drop_op(self,compressor))break;if(is_lambda(self.right))return make_sequence(self,[self.left,self.right,make_node(AST_False,self)]).optimize(compressor);break;}if(!(parent instanceof AST_UnaryPrefix&&parent.operator=="delete")){if(self.left instanceof AST_Number&&!self.right.is_constant())switch(self.operator){// 0 + n ---> n
case"+":if(self.left.value==0){if(self.right.is_boolean(compressor))return make_node(AST_UnaryPrefix,self,{operator:"+",expression:self.right}).optimize(compressor);if(self.right.is_number(compressor)&&!self.right.is_negative_zero())return self.right;}break;// 1 * n ---> n
case"*":if(self.left.value==1)return make_node(AST_UnaryPrefix,self,{operator:"+",expression:self.right}).optimize(compressor);break;}if(self.right instanceof AST_Number&&!self.left.is_constant())switch(self.operator){// n + 0 ---> n
case"+":if(self.right.value==0){if(self.left.is_boolean(compressor))return make_node(AST_UnaryPrefix,self,{operator:"+",expression:self.left}).optimize(compressor);if(self.left.is_number(compressor)&&!self.left.is_negative_zero())return self.left;}break;// n - 0 ---> n
case"-":if(self.right.value==0)return make_node(AST_UnaryPrefix,self,{operator:"+",expression:self.left}).optimize(compressor);break;// n / 1 ---> n
case"/":if(self.right.value==1)return make_node(AST_UnaryPrefix,self,{operator:"+",expression:self.left}).optimize(compressor);break;}}}if(compressor.option("typeofs"))switch(self.operator){case"&&":mark_locally_defined(self.left,self.right,null);break;case"||":mark_locally_defined(self.left,null,self.right);break;}if(compressor.option("unsafe")){var indexRight=is_indexFn(self.right);if(in_bool&&indexRight&&(self.operator=="=="||self.operator=="!=")&&self.left instanceof AST_Number&&self.left.value==0){return (self.operator=="=="?make_node(AST_UnaryPrefix,self,{operator:"!",expression:self.right}):self.right).optimize(compressor);}var indexLeft=is_indexFn(self.left);if(compressor.option("comparisons")&&is_indexOf_match_pattern()){var node=make_node(AST_UnaryPrefix,self,{operator:"!",expression:make_node(AST_UnaryPrefix,self,{operator:"~",expression:indexLeft?self.left:self.right})});switch(self.operator){case"<":if(indexLeft)break;case"<=":case"!=":node=make_node(AST_UnaryPrefix,self,{operator:"!",expression:node});break;}return node.optimize(compressor);}}return try_evaluate(compressor,self);function is_modify_array(node){var found=false;node.walk(new TreeWalker(function(node){if(found)return true;if(node instanceof AST_Assign){if(node.left instanceof AST_PropAccess)return found=true;}else if(node instanceof AST_Unary){if(unary_side_effects[node.operator]&&node.expression instanceof AST_PropAccess){return found=true;}}}));return found;}function align(ref,op){switch(ref){case"-":return op=="+"?"-":"+";case"/":return op=="*"?"/":"*";default:return op;}}function make_binary(op,left,right,orig){if(op=="+"){if(!left.is_boolean(compressor)&&!left.is_number(compressor)){left=make_node(AST_UnaryPrefix,left,{operator:"+",expression:left});}if(!right.is_boolean(compressor)&&!right.is_number(compressor)){right=make_node(AST_UnaryPrefix,right,{operator:"+",expression:right});}}return make_node(AST_Binary,orig,{operator:op,left:left,right:right});}function is_indexFn(node){while(node instanceof AST_Assign&&node.operator=="=")node=node.right;return node.TYPE=="Call"&&node.expression instanceof AST_Dot&&indexFns[node.expression.property];}function is_indexOf_match_pattern(){switch(self.operator){case"<=":// 0 <= array.indexOf(string) ---> !!~array.indexOf(string)
return indexRight&&self.left instanceof AST_Number&&self.left.value==0;case"<":// array.indexOf(string) < 0 ---> !~array.indexOf(string)
if(indexLeft&&self.right instanceof AST_Number&&self.right.value==0)return true;// -1 < array.indexOf(string) ---> !!~array.indexOf(string)
case"==":case"!=":// -1 == array.indexOf(string) ---> !~array.indexOf(string)
// -1 != array.indexOf(string) ---> !!~array.indexOf(string)
if(!indexRight)return false;return self.left instanceof AST_Number&&self.left.value==-1||self.left instanceof AST_UnaryPrefix&&self.left.operator=="-"&&self.left.expression instanceof AST_Number&&self.left.expression.value==1;}}function reversible(){return self.left.is_constant()||self.right.is_constant()||!self.left.has_side_effects(compressor)&&!self.right.has_side_effects(compressor);}function reverse(op){if(reversible()){if(op)self.operator=op;var tmp=self.left;self.left=self.right;self.right=tmp;}}});OPT(AST_SymbolExport,function(self){return self;});function recursive_ref(compressor,def,fn){var level=0,node=compressor.self();do{if(node===fn)return node;if(is_lambda(node)&&node.name&&node.name.definition()===def)return node;}while(node=compressor.parent(level++));}function same_scope(def){var scope=def.scope.resolve();return all(def.references,function(ref){return scope===ref.scope.resolve();});}OPT(AST_SymbolRef,function(self,compressor){if(!compressor.option("ie")&&is_undeclared_ref(self)// testing against `self.scope.uses_with` is an optimization
&&!(self.scope.resolve().uses_with&&compressor.find_parent(AST_With))){switch(self.name){case"undefined":return make_node(AST_Undefined,self).optimize(compressor);case"NaN":return make_node(AST_NaN,self).optimize(compressor);case"Infinity":return make_node(AST_Infinity,self).optimize(compressor);}}var parent=compressor.parent();if(compressor.option("reduce_vars")&&is_lhs(compressor.self(),parent)!==compressor.self()){var def=self.definition();var fixed=self.fixed_value();var single_use=def.single_use&&!(parent instanceof AST_Call&&parent.is_expr_pure(compressor));if(single_use){if(is_lambda(fixed)){if((def.scope!==self.scope.resolve(true)||def.in_loop)&&(!compressor.option("reduce_funcs")||def.escaped.depth==1||fixed.inlined)){single_use=false;}else if(def.redefined()){single_use=false;}else if(recursive_ref(compressor,def,fixed)){single_use=false;}else if(fixed.name&&fixed.name.definition()!==def){single_use=false;}else if(fixed.parent_scope!==self.scope||is_funarg(def)){if(!safe_from_strict_mode(fixed,compressor)){single_use=false;}else if((single_use=fixed.is_constant_expression(self.scope))=="f"){var scope=self.scope;do{if(scope instanceof AST_LambdaDefinition||scope instanceof AST_LambdaExpression){scope.inlined=true;}}while(scope=scope.parent_scope);}}else if(fixed.name&&(fixed.name.name=="await"&&is_async(fixed)||fixed.name.name=="yield"&&is_generator(fixed))){single_use=false;}else if(fixed.has_side_effects(compressor)){single_use=false;}else if(fixed instanceof AST_Class&&(compressor.option("ie")||!fixed.is_constant_expression(self.scope))){single_use=false;}if(single_use)fixed.parent_scope=self.scope;}else if(!fixed||def.recursive_refs>0||!fixed.is_constant_expression()||fixed.drop_side_effect_free(compressor)){single_use=false;}}if(single_use){def.single_use=false;fixed._squeezed=true;fixed.single_use=true;if(fixed instanceof AST_DefClass)fixed=to_class_expr(fixed);if(fixed instanceof AST_LambdaDefinition)fixed=to_func_expr(fixed);if(is_lambda(fixed)){var scopes=[];var scope=self.scope;do{scopes.push(scope);if(scope===def.scope)break;}while(scope=scope.parent_scope);fixed.enclosed.forEach(function(def){if(fixed.variables.has(def.name))return;for(var i=0;i<scopes.length;i++){var scope=scopes[i];if(!push_uniq(scope.enclosed,def))return;scope.var_names().set(def.name,true);}});}var value;if(def.recursive_refs>0){value=fixed.clone(true);var defun_def=value.name.definition();var lambda_def=value.variables.get(value.name.name);var name=lambda_def&&lambda_def.orig[0];var def_fn_name,symbol_type;if(value instanceof AST_Class){def_fn_name="def_function";symbol_type=AST_SymbolClass;}else {def_fn_name="def_variable";symbol_type=AST_SymbolLambda;}if(!(name instanceof symbol_type)){name=make_node(symbol_type,value.name);name.scope=value;value.name=name;lambda_def=value[def_fn_name](name);lambda_def.recursive_refs=def.recursive_refs;}value.walk(new TreeWalker(function(node){if(node instanceof AST_SymbolDeclaration){if(node!==name){var def=node.definition();def.orig.push(node);def.eliminated++;}return;}if(!(node instanceof AST_SymbolRef))return;var def=node.definition();if(def===defun_def){node.thedef=def=lambda_def;}else {def.single_use=false;var fn=node.fixed_value();if(is_lambda(fn)&&fn.name&&fn.name.definition()===def&&def.scope===fn.name.scope&&fixed.variables.get(fn.name.name)===def){fn.name=fn.name.clone();node.thedef=def=value.variables.get(fn.name.name)||value[def_fn_name](fn.name);}}def.references.push(node);}));}else {if(fixed instanceof AST_Scope){compressor.push(fixed);value=fixed.optimize(compressor);compressor.pop();}else {value=fixed.optimize(compressor);}value=value.transform(new TreeTransformer(function(node,descend){if(node instanceof AST_Scope)return node;node=node.clone();descend(node,this);return node;}));}def.replaced++;return value;}var state;if(fixed&&(state=self.fixed||def.fixed).should_replace!==false){var ev,init;if(fixed instanceof AST_This){if(!is_funarg(def)&&same_scope(def)&&!cross_class(def))init=fixed;}else if((ev=fixed.evaluate(compressor,true))!==fixed&&typeof ev!="function"&&(ev===null||typeof ev!="object"||compressor.option("unsafe_regexp")&&ev instanceof RegExp&&!def.cross_loop&&same_scope(def))){init=make_node_from_constant(ev,fixed);}if(init){if(state.should_replace===undefined){var value_length=init.optimize(compressor).print_to_string().length;if(!has_symbol_ref(fixed)){value_length=Math.min(value_length,fixed.print_to_string().length);}var name_length=def.name.length;if(compressor.option("unused")&&!compressor.exposed(def)){var refs=def.references.length-def.replaced-def.assignments;refs=Math.min(refs,def.references.filter(function(ref){return ref.fixed===state;}).length);name_length+=(name_length+2+value_length)/Math.max(1,refs);}state.should_replace=value_length-Math.floor(name_length)<compressor.eval_threshold;}if(state.should_replace){var value;if(has_symbol_ref(fixed)){value=init.optimize(compressor);if(value===init)value=value.clone(true);}else {value=best_of_expression(init.optimize(compressor),fixed);if(value===init||value===fixed)value=value.clone(true);}def.replaced++;return value;}}}}return self;function cross_class(def){var scope=self.scope;while(scope!==def.scope){if(scope instanceof AST_Class)return true;scope=scope.parent_scope;}}function has_symbol_ref(value){var found;value.walk(new TreeWalker(function(node){if(node instanceof AST_SymbolRef)found=true;if(found)return true;}));return found;}});function is_raw_tag(compressor,tag){return compressor.option("unsafe")&&tag instanceof AST_Dot&&tag.property=="raw"&&is_undeclared_ref(tag.expression)&&tag.expression.name=="String";}function decode_template(str){var malformed=false;str=str.replace(/\\(u\{[^{}]*\}?|u[\s\S]{0,4}|x[\s\S]{0,2}|[0-9]+|[\s\S])/g,function(match,seq){var ch=decode_escape_sequence(seq);if(typeof ch=="string")return ch;malformed=true;});if(!malformed)return str;}OPT(AST_Template,function(self,compressor){if(!compressor.option("templates"))return self;var tag=self.tag;if(!tag||is_raw_tag(compressor,tag)){var exprs=[];var strs=[];for(var i=0,status;i<self.strings.length;i++){var str=self.strings[i];if(!tag){var trimmed=decode_template(str);if(trimmed)str=escape_literal(trimmed);}if(i>0){var node=self.expressions[i-1];var value=should_join(node);if(value){var prev=strs[strs.length-1];var joined=prev+value+str;var decoded;if(tag||typeof(decoded=decode_template(joined))==status){strs[strs.length-1]=decoded?escape_literal(decoded):joined;continue;}}exprs.push(node);}strs.push(str);if(!tag)status=typeof trimmed;}if(!tag&&strs.length>1){if(strs[strs.length-1]=="")return make_node(AST_Binary,self,{operator:"+",left:make_node(AST_Template,self,{expressions:exprs.slice(0,-1),strings:strs.slice(0,-1)}).transform(compressor),right:exprs[exprs.length-1]}).optimize(compressor);if(strs[0]==""){var left=make_node(AST_Binary,self,{operator:"+",left:make_node(AST_String,self,{value:""}),right:exprs[0]});for(var i=1;strs[i]==""&&i<exprs.length;i++){left=make_node(AST_Binary,self,{operator:"+",left:left,right:exprs[i]});}return best_of(compressor,self,make_node(AST_Binary,self,{operator:"+",left:left.transform(compressor),right:make_node(AST_Template,self,{expressions:exprs.slice(i),strings:strs.slice(i)}).transform(compressor)}).optimize(compressor));}}self.expressions=exprs;self.strings=strs;}return try_evaluate(compressor,self);function escape_literal(str){return str.replace(/\r|\\|`|\${/g,function(s){return "\\"+(s=="\r"?"r":s);});}function should_join(node){var ev=node.evaluate(compressor);if(ev===node)return;if(tag&&/\r|\\|`/.test(ev))return;ev=escape_literal(""+ev);if(ev.length>node.print_to_string().length+"${}".length)return;return ev;}});function is_atomic(lhs,self){return lhs instanceof AST_SymbolRef||lhs.TYPE===self.TYPE;}OPT(AST_Undefined,function(self,compressor){if(compressor.option("unsafe_undefined")){var undef=find_scope(compressor).find_variable("undefined");if(undef){var ref=make_node(AST_SymbolRef,self,{name:"undefined",scope:undef.scope,thedef:undef});ref.is_undefined=true;return ref;}}var lhs=is_lhs(compressor.self(),compressor.parent());if(lhs&&is_atomic(lhs,self))return self;return make_node(AST_UnaryPrefix,self,{operator:"void",expression:make_node(AST_Number,self,{value:0})});});OPT(AST_Infinity,function(self,compressor){var lhs=is_lhs(compressor.self(),compressor.parent());if(lhs&&is_atomic(lhs,self))return self;if(compressor.option("keep_infinity")&&!lhs&&!find_scope(compressor).find_variable("Infinity")){return self;}return make_node(AST_Binary,self,{operator:"/",left:make_node(AST_Number,self,{value:1}),right:make_node(AST_Number,self,{value:0})});});OPT(AST_NaN,function(self,compressor){var lhs=is_lhs(compressor.self(),compressor.parent());if(lhs&&is_atomic(lhs,self))return self;if(!lhs&&!find_scope(compressor).find_variable("NaN"))return self;return make_node(AST_Binary,self,{operator:"/",left:make_node(AST_Number,self,{value:0}),right:make_node(AST_Number,self,{value:0})});});function is_reachable(self,defs){var reachable=false;var find_ref=new TreeWalker(function(node){if(reachable)return true;if(node instanceof AST_SymbolRef&&member(node.definition(),defs))return reachable=true;});var scan_scope=new TreeWalker(function(node){if(reachable)return true;if(node instanceof AST_Lambda&&node!==self){if(!(node.name||is_async(node)||is_generator(node))){var parent=scan_scope.parent();if(parent instanceof AST_Call&&parent.expression===node)return;}node.walk(find_ref);return true;}});self.walk(scan_scope);return reachable;}var ASSIGN_OPS=makePredicate("+ - * / % >> << >>> | ^ &");var ASSIGN_OPS_COMMUTATIVE=makePredicate("* | ^ &");OPT(AST_Assign,function(self,compressor){if(compressor.option("dead_code")){if(self.left instanceof AST_PropAccess){if(self.operator=="="){var exp=self.left.expression;if(self.left.equals(self.right)){var defined=exp.defined;exp.defined=false;var drop_lhs=!self.left.has_side_effects(compressor);exp.defined=defined;if(drop_lhs)return self.right;}if(exp instanceof AST_Lambda||!compressor.has_directive("use strict")&&exp instanceof AST_Constant&&!exp.may_throw_on_access(compressor)){var value=self.left instanceof AST_Dot?self.right:make_sequence(self,[self.left.property,self.right]);return maintain_this_binding(compressor.parent(),self,value).optimize(compressor);}}}else if(self.left instanceof AST_SymbolRef&&can_drop_symbol(self.left,compressor)){var parent;if(self.operator=="="&&self.left.equals(self.right)&&!((parent=compressor.parent())instanceof AST_UnaryPrefix&&parent.operator=="delete")){return self.right;}if(self.left.is_immutable())return strip_assignment();var def=self.left.definition();var scope=def.scope.resolve();var local=scope===compressor.find_parent(AST_Lambda);var level=0,node;parent=compressor.self();if(!(scope.uses_arguments&&is_funarg(def))||compressor.has_directive("use strict"))do{node=parent;parent=compressor.parent(level++);if(parent instanceof AST_Assign){if(parent.left instanceof AST_SymbolRef&&parent.left.definition()===def){if(in_try(level,parent,!local))break;return strip_assignment(def);}if(parent.left.match_symbol(function(node){if(node instanceof AST_PropAccess)return true;}))break;continue;}if(parent instanceof AST_Exit){if(!local)break;if(in_try(level,parent))break;if(is_reachable(scope,[def]))break;return strip_assignment(def);}if(parent instanceof AST_SimpleStatement){if(!local)break;if(is_reachable(scope,[def]))break;var stat;do{stat=parent;parent=compressor.parent(level++);if(parent===scope&&is_last_statement(parent.body,stat))return strip_assignment(def);}while(is_tail_block(stat,parent));break;}if(parent instanceof AST_VarDef){if(!(parent.name instanceof AST_SymbolDeclaration))continue;if(parent.name.definition()!==def)continue;if(in_try(level,parent))break;return strip_assignment(def);}}while(is_tail(node,parent));}}if(compressor.option("sequences")){var seq=self.lift_sequences(compressor);if(seq!==self)return seq.optimize(compressor);}if(compressor.option("assignments")){if(self.operator=="="&&self.left instanceof AST_SymbolRef&&self.right instanceof AST_Binary){// x = expr1 OP expr2
if(self.right.left instanceof AST_SymbolRef&&self.right.left.name==self.left.name&&ASSIGN_OPS[self.right.operator]){// x = x - 2 ---> x -= 2
return make_compound(self.right.right);}if(self.right.right instanceof AST_SymbolRef&&self.right.right.name==self.left.name&&ASSIGN_OPS_COMMUTATIVE[self.right.operator]&&!self.right.left.has_side_effects(compressor)){// x = 2 & x ---> x &= 2
return make_compound(self.right.left);}}if((self.operator=="-="||self.operator=="+="&&(self.left.is_boolean(compressor)||self.left.is_number(compressor)))&&self.right instanceof AST_Number&&self.right.value==1){var op=self.operator.slice(0,-1);return make_node(AST_UnaryPrefix,self,{operator:op+op,expression:self.left});}}return try_evaluate(compressor,self);function is_tail(node,parent){if(parent instanceof AST_Binary)switch(node){case parent.left:return parent.right.is_constant_expression(scope);case parent.right:return true;default:return false;}if(parent instanceof AST_Conditional)switch(node){case parent.condition:return parent.consequent.is_constant_expression(scope)&&parent.alternative.is_constant_expression(scope);case parent.consequent:case parent.alternative:return true;default:return false;}if(parent instanceof AST_Sequence){var exprs=parent.expressions;var stop=exprs.indexOf(node);if(stop<0)return false;for(var i=exprs.length;--i>stop;){if(!exprs[i].is_constant_expression(scope))return false;}return true;}return parent instanceof AST_UnaryPrefix;}function is_tail_block(stat,parent){if(parent instanceof AST_BlockStatement)return is_last_statement(parent.body,stat);if(parent instanceof AST_Catch)return is_last_statement(parent.body,stat);if(parent instanceof AST_Finally)return is_last_statement(parent.body,stat);if(parent instanceof AST_If)return parent.body===stat||parent.alternative===stat;if(parent instanceof AST_Try)return parent.bfinally?parent.bfinally===stat:parent.bcatch===stat;}function in_try(level,node,sync){var right=self.right;self.right=make_node(AST_Null,right);var may_throw=node.may_throw(compressor);self.right=right;return find_try(compressor,level,node,scope,may_throw,sync);}function make_compound(rhs){var fixed=self.left.fixed;if(fixed)fixed.to_binary=replace_ref(function(node){return node.left;},fixed);return make_node(AST_Assign,self,{operator:self.right.operator+"=",left:self.left,right:rhs});}function strip_assignment(def){if(def)def.fixed=false;return (self.operator!="="?make_node(AST_Binary,self,{operator:self.operator.slice(0,-1),left:self.left,right:self.right}):maintain_this_binding(compressor.parent(),self,self.right)).optimize(compressor);}});OPT(AST_Conditional,function(self,compressor){if(compressor.option("sequences")&&self.condition instanceof AST_Sequence){var expressions=self.condition.expressions.slice();var node=self.clone();node.condition=expressions.pop();expressions.push(node);return make_sequence(self,expressions).optimize(compressor);}if(!compressor.option("conditionals"))return self;var condition=self.condition;if(compressor.option("booleans")&&!condition.has_side_effects(compressor)){mark_duplicate_condition(compressor,condition);}condition=fuzzy_eval(compressor,condition);if(!condition){AST_Node.warn("Condition always false [{start}]",self);return make_sequence(self,[self.condition,self.alternative]).optimize(compressor);}else if(!(condition instanceof AST_Node)){AST_Node.warn("Condition always true [{start}]",self);return make_sequence(self,[self.condition,self.consequent]).optimize(compressor);}var first=first_in_statement(compressor);var negated=condition.negate(compressor,first);if((first?best_of_statement:best_of_expression)(condition,negated)===negated){self=make_node(AST_Conditional,self,{condition:negated,consequent:self.alternative,alternative:self.consequent});negated=condition;condition=self.condition;}var consequent=self.consequent;var alternative=self.alternative;var cond_lhs=extract_lhs(condition,compressor);if(repeatable(compressor,cond_lhs)){// x ? x : y ---> x || y
if(cond_lhs.equals(consequent))return make_node(AST_Binary,self,{operator:"||",left:condition,right:alternative}).optimize(compressor);// x ? y : x ---> x && y
if(cond_lhs.equals(alternative))return make_node(AST_Binary,self,{operator:"&&",left:condition,right:consequent}).optimize(compressor);}// if (foo) exp = something; else exp = something_else;
//                   |
//                   v
// exp = foo ? something : something_else;
var seq_tail=consequent.tail_node();if(seq_tail instanceof AST_Assign){var is_eq=seq_tail.operator=="=";var alt_tail=is_eq?alternative.tail_node():alternative;if((is_eq||consequent===seq_tail)&&alt_tail instanceof AST_Assign&&seq_tail.operator==alt_tail.operator&&seq_tail.left.equals(alt_tail.left)&&(is_eq&&seq_tail.left instanceof AST_SymbolRef||!condition.has_side_effects(compressor)&&can_shift_lhs_of_tail(consequent)&&can_shift_lhs_of_tail(alternative))){return make_node(AST_Assign,self,{operator:seq_tail.operator,left:seq_tail.left,right:make_node(AST_Conditional,self,{condition:condition,consequent:pop_lhs(consequent),alternative:pop_lhs(alternative)})});}}var alt_tail=alternative.tail_node();// x ? y : y ---> x, y
// x ? (a, c) : (b, c) ---> x ? a : b, c
if(seq_tail.equals(alt_tail))return make_sequence(self,consequent.equals(alternative)?[condition,consequent]:[make_node(AST_Conditional,self,{condition:condition,consequent:pop_seq(consequent),alternative:pop_seq(alternative)}),alt_tail]).optimize(compressor);// x ? y.p : z.p ---> (x ? y : z).p
// x ? y(a) : z(a) ---> (x ? y : z)(a)
// x ? y.f(a) : z.f(a) ---> (x ? y : z).f(a)
var combined=combine_tail(consequent,alternative,true);if(combined)return combined;// x ? y(a) : y(b) ---> y(x ? a : b)
var arg_index;if(consequent instanceof AST_Call&&alternative.TYPE==consequent.TYPE&&(arg_index=arg_diff(consequent,alternative))>=0&&consequent.expression.equals(alternative.expression)&&!condition.has_side_effects(compressor)&&!consequent.expression.has_side_effects(compressor)){var node=consequent.clone();var arg=consequent.args[arg_index];node.args[arg_index]=arg instanceof AST_Spread?make_node(AST_Spread,self,{expression:make_node(AST_Conditional,self,{condition:condition,consequent:arg.expression,alternative:alternative.args[arg_index].expression})}):make_node(AST_Conditional,self,{condition:condition,consequent:arg,alternative:alternative.args[arg_index]});return node;}// x ? (y ? a : b) : b ---> x && y ? a : b
if(seq_tail instanceof AST_Conditional&&seq_tail.alternative.equals(alternative)){return make_node(AST_Conditional,self,{condition:make_node(AST_Binary,self,{left:condition,operator:"&&",right:fuse(consequent,seq_tail,"condition")}),consequent:seq_tail.consequent,alternative:merge_expression(seq_tail.alternative,alternative)});}// x ? (y ? a : b) : a ---> !x || y ? a : b
if(seq_tail instanceof AST_Conditional&&seq_tail.consequent.equals(alternative)){return make_node(AST_Conditional,self,{condition:make_node(AST_Binary,self,{left:negated,operator:"||",right:fuse(consequent,seq_tail,"condition")}),consequent:merge_expression(seq_tail.consequent,alternative),alternative:seq_tail.alternative});}// x ? a : (y ? a : b) ---> x || y ? a : b
if(alt_tail instanceof AST_Conditional&&consequent.equals(alt_tail.consequent)){return make_node(AST_Conditional,self,{condition:make_node(AST_Binary,self,{left:condition,operator:"||",right:fuse(alternative,alt_tail,"condition")}),consequent:merge_expression(consequent,alt_tail.consequent),alternative:alt_tail.alternative});}// x ? b : (y ? a : b) ---> !x && y ? a : b
if(alt_tail instanceof AST_Conditional&&consequent.equals(alt_tail.alternative)){return make_node(AST_Conditional,self,{condition:make_node(AST_Binary,self,{left:negated,operator:"&&",right:fuse(alternative,alt_tail,"condition")}),consequent:alt_tail.consequent,alternative:merge_expression(consequent,alt_tail.alternative)});}// x ? y && a : a ---> (!x || y) && a
if(seq_tail instanceof AST_Binary&&seq_tail.operator=="&&"&&seq_tail.right.equals(alternative)){return make_node(AST_Binary,self,{operator:"&&",left:make_node(AST_Binary,self,{operator:"||",left:negated,right:fuse(consequent,seq_tail,"left")}),right:merge_expression(seq_tail.right,alternative)}).optimize(compressor);}// x ? y || a : a ---> x && y || a
if(seq_tail instanceof AST_Binary&&seq_tail.operator=="||"&&seq_tail.right.equals(alternative)){return make_node(AST_Binary,self,{operator:"||",left:make_node(AST_Binary,self,{operator:"&&",left:condition,right:fuse(consequent,seq_tail,"left")}),right:merge_expression(seq_tail.right,alternative)}).optimize(compressor);}// x ? a : y && a ---> (x || y) && a
if(alt_tail instanceof AST_Binary&&alt_tail.operator=="&&"&&alt_tail.right.equals(consequent)){return make_node(AST_Binary,self,{operator:"&&",left:make_node(AST_Binary,self,{operator:"||",left:condition,right:fuse(alternative,alt_tail,"left")}),right:merge_expression(consequent,alt_tail.right)}).optimize(compressor);}// x ? a : y || a ---> !x && y || a
if(alt_tail instanceof AST_Binary&&alt_tail.operator=="||"&&alt_tail.right.equals(consequent)){return make_node(AST_Binary,self,{operator:"||",left:make_node(AST_Binary,self,{operator:"&&",left:negated,right:fuse(alternative,alt_tail,"left")}),right:merge_expression(consequent,alt_tail.right)}).optimize(compressor);}var in_bool=compressor.option("booleans")&&compressor.in_boolean_context();if(is_true(consequent)){// c ? true : false ---> !!c
if(is_false(alternative))return booleanize(condition);// c ? true : x ---> !!c || x
return make_node(AST_Binary,self,{operator:"||",left:booleanize(condition),right:alternative}).optimize(compressor);}if(is_false(consequent)){// c ? false : true ---> !c
if(is_true(alternative))return booleanize(condition.negate(compressor));// c ? false : x ---> !c && x
return make_node(AST_Binary,self,{operator:"&&",left:booleanize(condition.negate(compressor)),right:alternative}).optimize(compressor);}// c ? x : true ---> !c || x
if(is_true(alternative))return make_node(AST_Binary,self,{operator:"||",left:booleanize(condition.negate(compressor)),right:consequent}).optimize(compressor);// c ? x : false ---> !!c && x
if(is_false(alternative))return make_node(AST_Binary,self,{operator:"&&",left:booleanize(condition),right:consequent}).optimize(compressor);if(compressor.option("typeofs"))mark_locally_defined(condition,consequent,alternative);return self;function booleanize(node){if(node.is_boolean(compressor))return node;// !!expression
return make_node(AST_UnaryPrefix,node,{operator:"!",expression:node.negate(compressor)});}// AST_True or !0
function is_true(node){return node instanceof AST_True||in_bool&&node instanceof AST_Constant&&node.value||node instanceof AST_UnaryPrefix&&node.operator=="!"&&node.expression instanceof AST_Constant&&!node.expression.value;}// AST_False or !1 or void 0
function is_false(node){return node instanceof AST_False||in_bool&&(node instanceof AST_Constant&&!node.value||node instanceof AST_UnaryPrefix&&node.operator=="void"&&!node.expression.has_side_effects(compressor))||node instanceof AST_UnaryPrefix&&node.operator=="!"&&node.expression instanceof AST_Constant&&node.expression.value;}function arg_diff(consequent,alternative){var a=consequent.args;var b=alternative.args;var len=a.length;if(len!=b.length)return -2;for(var i=0;i<len;i++){if(!a[i].equals(b[i])){if(a[i]instanceof AST_Spread!==b[i]instanceof AST_Spread)return -3;for(var j=i+1;j<len;j++){if(!a[j].equals(b[j]))return -2;}return i;}}return -1;}function fuse(node,tail,prop){if(node===tail)return tail[prop];var exprs=node.expressions.slice(0,-1);exprs.push(tail[prop]);return make_sequence(node,exprs);}function is_tail_equivalent(consequent,alternative){if(consequent.TYPE!=alternative.TYPE)return;if(consequent.optional!=alternative.optional)return;if(consequent instanceof AST_Call){if(arg_diff(consequent,alternative)!=-1)return;return consequent.TYPE!="Call"||!(consequent.expression instanceof AST_PropAccess||alternative.expression instanceof AST_PropAccess)||is_tail_equivalent(consequent.expression,alternative.expression);}if(!(consequent instanceof AST_PropAccess))return;var p=consequent.property;var q=alternative.property;return (p instanceof AST_Node?p.equals(q):p==q)&&!(consequent.expression instanceof AST_Super||alternative.expression instanceof AST_Super);}function combine_tail(consequent,alternative,top){var seq_tail=consequent.tail_node();var alt_tail=alternative.tail_node();if(!is_tail_equivalent(seq_tail,alt_tail))return !top&&make_node(AST_Conditional,self,{condition:condition,consequent:consequent,alternative:alternative});var node=seq_tail.clone();var seq_expr=fuse(consequent,seq_tail,"expression");var alt_expr=fuse(alternative,alt_tail,"expression");var combined=combine_tail(seq_expr,alt_expr);if(seq_tail.expression instanceof AST_Sequence){combined=maintain_this_binding(seq_tail,seq_tail.expression,combined);}node.expression=combined;return node;}function can_shift_lhs_of_tail(node){return node===node.tail_node()||all(node.expressions.slice(0,-1),function(expr){return !expr.has_side_effects(compressor);});}function pop_lhs(node){if(!(node instanceof AST_Sequence))return node.right;var exprs=node.expressions.slice();exprs.push(exprs.pop().right);return make_sequence(node,exprs);}function pop_seq(node){if(!(node instanceof AST_Sequence))return make_node(AST_Number,node,{value:0});return make_sequence(node,node.expressions.slice(0,-1));}});OPT(AST_Boolean,function(self,compressor){if(!compressor.option("booleans"))return self;if(compressor.in_boolean_context())return make_node(AST_Number,self,{value:+self.value});var p=compressor.parent();if(p instanceof AST_Binary&&(p.operator=="=="||p.operator=="!=")){AST_Node.warn("Non-strict equality against boolean: {operator} {value} [{start}]",{operator:p.operator,value:self.value,start:p.start});return make_node(AST_Number,self,{value:+self.value});}return make_node(AST_UnaryPrefix,self,{operator:"!",expression:make_node(AST_Number,self,{value:1-self.value})});});OPT(AST_Spread,function(self,compressor){var exp=self.expression;if(compressor.option("spreads")&&exp instanceof AST_Array&&!(compressor.parent()instanceof AST_Object)){return List.splice(exp.elements.map(function(node){return node instanceof AST_Hole?make_node(AST_Undefined,node).optimize(compressor):node;}));}return self;});function safe_to_flatten(value,compressor){if(!value)return false;var parent=compressor.parent();if(parent.TYPE!="Call")return true;if(parent.expression!==compressor.self())return true;if(value instanceof AST_SymbolRef){value=value.fixed_value();if(!value)return false;}return value instanceof AST_Lambda&&!value.contains_this();}OPT(AST_Sub,function(self,compressor){var expr=self.expression;var prop=self.property;var terminated=trim_optional_chain(self,compressor);if(terminated)return terminated;if(compressor.option("properties")){var key=prop.evaluate(compressor);if(key!==prop){if(typeof key=="string"){if(key=="undefined"){key=undefined;}else {var value=parseFloat(key);if(value.toString()==key){key=value;}}}prop=self.property=best_of_expression(prop,make_node_from_constant(key,prop).transform(compressor));var property=""+key;if(is_identifier_string(property)&&property.length<=prop.print_to_string().length+1){return make_node(AST_Dot,self,{optional:self.optional,expression:expr,property:property,quoted:true}).optimize(compressor);}}}var parent=compressor.parent();var assigned=is_lhs(compressor.self(),parent);var def,fn,fn_parent,index;if(compressor.option("arguments")&&expr instanceof AST_SymbolRef&&is_arguments(def=expr.definition())&&!expr.in_arg&&prop instanceof AST_Number&&Math.floor(index=prop.value)==index&&(fn=def.scope)===find_lambda()&&fn.uses_arguments<(assigned?2:3)){if(parent instanceof AST_UnaryPrefix&&parent.operator=="delete"){if(!def.deleted)def.deleted=[];def.deleted[index]=true;}var argname=fn.argnames[index];if(def.deleted&&def.deleted[index]){argname=null;}else if(argname){var arg_def;if(!(argname instanceof AST_SymbolFunarg)||argname.name=="await"||expr.scope.find_variable(argname.name)!==(arg_def=argname.definition())){argname=null;}else if(compressor.has_directive("use strict")||fn.name||fn.rest||!(fn_parent instanceof AST_Call&&index<fn_parent.args.length&&all(fn_parent.args.slice(0,index+1),function(arg){return !(arg instanceof AST_Spread);}))||!all(fn.argnames,function(argname){return argname instanceof AST_SymbolFunarg;})){if(has_reassigned()||arg_def.assignments||arg_def.orig.length>1)argname=null;}}else if((assigned||!has_reassigned())&&index<fn.argnames.length+5&&compressor.drop_fargs(fn,fn_parent)&&!fn.rest){while(index>=fn.argnames.length){argname=fn.make_var(AST_SymbolFunarg,fn,"argument_"+fn.argnames.length);fn.argnames.push(argname);}}if(argname&&find_if(function(node){return node.name===argname.name;},fn.argnames)===argname){if(assigned)def.reassigned--;var sym=make_node(AST_SymbolRef,argname);sym.reference();argname.unused=undefined;return sym;}}if(assigned)return self;if(compressor.option("sequences")&&parent.TYPE!="Call"&&!(parent instanceof AST_ForEnumeration&&parent.init===self)){var seq=lift_sequence_in_expression(self);if(seq!==self)return seq.optimize(compressor);}if(key!==prop){var sub=self.flatten_object(property,compressor);if(sub){expr=self.expression=sub.expression;prop=self.property=sub.property;}}var elements;if(compressor.option("properties")&&compressor.option("side_effects")&&prop instanceof AST_Number&&expr instanceof AST_Array&&all(elements=expr.elements,function(value){return !(value instanceof AST_Spread);})){var index=prop.value;var retValue=elements[index];if(safe_to_flatten(retValue,compressor)){var is_hole=retValue instanceof AST_Hole;var flatten=!is_hole;var values=[];for(var i=elements.length;--i>index;){var value=elements[i].drop_side_effect_free(compressor);if(value){values.unshift(value);if(flatten&&value.has_side_effects(compressor))flatten=false;}}if(!flatten)values.unshift(retValue);while(--i>=0){var value=elements[i].drop_side_effect_free(compressor);if(value){values.unshift(value);}else if(is_hole){values.unshift(make_node(AST_Hole,elements[i]));}else {index--;}}if(flatten){values.push(retValue);return make_sequence(self,values).optimize(compressor);}return make_node(AST_Sub,self,{expression:make_node(AST_Array,expr,{elements:values}),property:make_node(AST_Number,prop,{value:index})});}}return try_evaluate(compressor,self);function find_lambda(){var i=0,p;while(p=compressor.parent(i++)){if(p instanceof AST_Lambda){if(p instanceof AST_Accessor)return;if(is_arrow(p))continue;fn_parent=compressor.parent(i);return p;}}}function has_reassigned(){return !compressor.option("reduce_vars")||def.reassigned;}});AST_LambdaExpression.DEFMETHOD("contains_super",function(){var result=false;var self=this;self.walk(new TreeWalker(function(node){if(result)return true;if(node instanceof AST_Super)return result=true;if(node!==self&&node instanceof AST_Scope&&!is_arrow(node))return true;}));return result;});// contains_this()
// returns false only if context bound by the specified scope (or scope
// containing the specified expression) is not referenced by `this`
(function(def){// scope of arrow function cannot bind to any context
def(AST_Arrow,return_false);def(AST_AsyncArrow,return_false);def(AST_Node,function(){var result=false;var self=this;self.walk(new TreeWalker(function(node){if(result)return true;if(node instanceof AST_This)return result=true;if(node!==self&&node instanceof AST_Scope&&!is_arrow(node))return true;}));return result;});})(function(node,func){node.DEFMETHOD("contains_this",func);});function can_hoist_property(prop){return prop instanceof AST_ObjectKeyVal&&typeof prop.key=="string"&&!(prop instanceof AST_ObjectMethod&&prop.value.contains_super());}AST_PropAccess.DEFMETHOD("flatten_object",function(key,compressor){if(!compressor.option("properties"))return;if(key==="__proto__")return;var self=this;var expr=self.expression;if(!(expr instanceof AST_Object))return;var props=expr.properties;for(var i=props.length;--i>=0;){var prop=props[i];if(prop.key!==key)continue;if(!all(props,can_hoist_property))return;if(!safe_to_flatten(prop.value,compressor))return;var call,scope,values=[];for(var j=0;j<props.length;j++){var value=props[j].value;if(props[j]instanceof AST_ObjectMethod){var arrow=!(value.uses_arguments||is_generator(value)||value.contains_this());if(arrow){if(!scope)scope=compressor.find_parent(AST_Scope);var avoid=avoid_await_yield(compressor,scope);value.each_argname(function(argname){if(avoid[argname.name])arrow=false;});}var ctor;if(arrow){ctor=is_async(value)?AST_AsyncArrow:AST_Arrow;}else if(i!=j||(call=compressor.parent())instanceof AST_Call&&call.expression===self){ctor=value.CTOR;}else {return;}value=make_node(ctor,value);}values.push(value);}return make_node(AST_Sub,self,{expression:make_node(AST_Array,expr,{elements:values}),property:make_node(AST_Number,self,{value:i})});}});OPT(AST_Dot,function(self,compressor){if(self.property=="arguments"||self.property=="caller"){AST_Node.warn("Function.prototype.{property} not supported [{start}]",self);}var parent=compressor.parent();if(is_lhs(compressor.self(),parent))return self;var terminated=trim_optional_chain(self,compressor);if(terminated)return terminated;if(compressor.option("sequences")&&parent.TYPE!="Call"&&!(parent instanceof AST_ForEnumeration&&parent.init===self)){var seq=lift_sequence_in_expression(self);if(seq!==self)return seq.optimize(compressor);}if(compressor.option("unsafe_proto")&&self.expression instanceof AST_Dot&&self.expression.property=="prototype"){var exp=self.expression.expression;if(is_undeclared_ref(exp))switch(exp.name){case"Array":self.expression=make_node(AST_Array,self.expression,{elements:[]});break;case"Function":self.expression=make_node(AST_Function,self.expression,{argnames:[],body:[]}).init_vars(exp.scope);break;case"Number":self.expression=make_node(AST_Number,self.expression,{value:0});break;case"Object":self.expression=make_node(AST_Object,self.expression,{properties:[]});break;case"RegExp":self.expression=make_node(AST_RegExp,self.expression,{value:/t/});break;case"String":self.expression=make_node(AST_String,self.expression,{value:""});break;}}var sub=self.flatten_object(self.property,compressor);if(sub)return sub.optimize(compressor);return try_evaluate(compressor,self);});OPT(AST_DestructuredArray,function(self,compressor){if(compressor.option("rests")&&self.rest instanceof AST_DestructuredArray){return make_node(AST_DestructuredArray,self,{elements:self.elements.concat(self.rest.elements),rest:self.rest.rest});}return self;});OPT(AST_DestructuredKeyVal,function(self,compressor){if(compressor.option("objects")){var key=self.key;if(key instanceof AST_Node){key=key.evaluate(compressor);if(key!==self.key)self.key=""+key;}}return self;});OPT(AST_Object,function(self,compressor){if(!compressor.option("objects"))return self;var changed=false;var found=false;var generated=false;var keep_duplicate=compressor.has_directive("use strict");var keys=[];var map=new Dictionary();var values=[];self.properties.forEach(function(prop){if(!(prop instanceof AST_Spread))return process(prop);found=true;var exp=prop.expression;if(compressor.option("spreads")&&exp instanceof AST_Object&&all(exp.properties,function(prop){if(prop instanceof AST_ObjectGetter)return false;if(prop instanceof AST_Spread)return false;if(prop.key!=="__proto__")return true;if(prop instanceof AST_ObjectSetter)return true;return !prop.value.has_side_effects(compressor);})){changed=true;exp.properties.forEach(function(prop){var key=prop.key;var setter=prop instanceof AST_ObjectSetter;if(key==="__proto__"){if(!setter)return;key=make_node_from_constant(key,prop);}process(setter?make_node(AST_ObjectKeyVal,prop,{key:key,value:make_node(AST_Undefined,prop).optimize(compressor)}):prop);});}else {generated=true;flush();values.push(prop);}});flush();if(!changed)return self;if(found&&generated&&values.length==1){var value=values[0];if(value instanceof AST_ObjectProperty&&value.key instanceof AST_Number){value.key=""+value.key.value;}}return make_node(AST_Object,self,{properties:values});function flush(){keys.forEach(function(key){var props=map.get(key);switch(props.length){case 0:return;case 1:return values.push(props[0]);}changed=true;var tail=keep_duplicate&&!generated&&props.pop();values.push(props.length==1?props[0]:make_node(AST_ObjectKeyVal,self,{key:props[0].key,value:make_sequence(self,props.map(function(prop){return prop.value;}))}));if(tail)values.push(tail);props.length=0;});keys=[];map=new Dictionary();}function process(prop){var key=prop.key;if(key instanceof AST_Node){found=true;key=key.evaluate(compressor);if(key===prop.key||key==="__proto__"){generated=true;}else {key=prop.key=""+key;}}if(can_hoist_property(prop)){if(prop.value.has_side_effects(compressor))flush();keys.push(key);map.add(key,prop);}else {flush();values.push(prop);}if(found&&!generated&&typeof key=="string"&&RE_POSITIVE_INTEGER.test(key)){generated=true;if(map.has(key))prop=map.get(key)[0];prop.key=make_node(AST_Number,prop,{value:+key});}}});function flatten_var(name){var redef=name.definition().redefined();if(redef){name=name.clone();name.thedef=redef;}return name;}function has_arg_refs(fn,node){var found=false;node.walk(new TreeWalker(function(node){if(found)return true;if(node instanceof AST_SymbolRef&&fn.variables.get(node.name)===node.definition()){return found=true;}}));return found;}function insert_assign(def,assign){var visited=[];def.references.forEach(function(ref){var fixed=ref.fixed;if(!fixed||!push_uniq(visited,fixed))return;if(fixed.assigns){fixed.assigns.unshift(assign);}else {fixed.assigns=[assign];}});}function init_ref(compressor,name){var sym=make_node(AST_SymbolRef,name);var assign=make_node(AST_Assign,name,{operator:"=",left:sym,right:make_node(AST_Undefined,name).transform(compressor)});var def=name.definition();if(def.fixed){sym.fixed=function(){return assign.right;};sym.fixed.assigns=[assign];insert_assign(def,assign);}def.assignments++;def.references.push(sym);return assign;}(function(def){def(AST_Node,noop);def(AST_Assign,noop);def(AST_Await,function(compressor,scope,no_return,in_loop){if(!compressor.option("awaits"))return;var self=this;var inlined=self.expression.try_inline(compressor,scope,no_return,in_loop,true);if(!inlined)return;if(!no_return)scan_local_returns(inlined,function(node){node.in_bool=false;var value=node.value;if(value instanceof AST_Await)return;node.value=make_node(AST_Await,self,{expression:value||make_node(AST_Undefined,node).transform(compressor)});});return aborts(inlined)?inlined:make_node(AST_BlockStatement,self,{body:[inlined,make_node(AST_SimpleStatement,self,{body:make_node(AST_Await,self,{expression:make_node(AST_Number,self,{value:0})})})]});});def(AST_Binary,function(compressor,scope,no_return,in_loop,in_await){if(no_return===undefined)return;var self=this;var op=self.operator;if(!lazy_op[op])return;var inlined=self.right.try_inline(compressor,scope,no_return,in_loop,in_await);if(!inlined)return;return make_node(AST_If,self,{condition:make_condition(self.left),body:inlined,alternative:no_return?null:make_node(AST_Return,self,{value:make_node(AST_Undefined,self).transform(compressor)})});function make_condition(cond){switch(op){case"&&":return cond;case"||":return cond.negate(compressor);case"??":return make_node(AST_Binary,self,{operator:"==",left:make_node(AST_Null,self),right:cond});}}});def(AST_BlockStatement,function(compressor,scope,no_return,in_loop){if(no_return)return;if(!this.variables)return;var body=this.body;var last=body.length-1;if(last<0)return;var inlined=body[last].try_inline(compressor,this,no_return,in_loop);if(!inlined)return;body[last]=inlined;return this;});def(AST_Call,function(compressor,scope,no_return,in_loop,in_await){if(compressor.option("inline")<4)return;var call=this;if(call.is_expr_pure(compressor))return;var fn=call.expression;if(!(fn instanceof AST_LambdaExpression))return;if(fn.name)return;if(fn.single_use)return;if(fn.uses_arguments)return;if(fn.pinned())return;if(is_generator(fn))return;var arrow=is_arrow(fn);var fn_body=arrow&&fn.value?[fn.first_statement()]:fn.body;if(fn_body[0]instanceof AST_Directive)return;if(fn.contains_this())return;if(!scope)scope=find_scope(compressor);var defined=new Dictionary();defined.set("NaN",true);while(!(scope instanceof AST_Scope)){scope.variables.each(function(def){defined.set(def.name,true);});scope=scope.parent_scope;}if(!member(scope,compressor.stack))return;if(scope.pinned()&&fn.variables.size()>(arrow?0:1))return;if(scope instanceof AST_Toplevel){if(fn.variables.size()>(arrow?0:1)){if(!compressor.toplevel.vars)return;if(fn.functions.size()>0&&!compressor.toplevel.funcs)return;}defined.set("arguments",true);}var async=!in_await&&is_async(fn);if(async){if(!compressor.option("awaits"))return;if(!is_async(scope))return;if(call.may_throw(compressor))return;}var names=scope.var_names();if(in_loop)in_loop=[];if(!fn.variables.all(function(def,name){if(in_loop)in_loop.push(def);if(!defined.has(name)&&!names.has(name))return true;return !arrow&&name=="arguments"&&def.orig.length==1;}))return;if(in_loop&&in_loop.length>0&&is_reachable(fn,in_loop))return;var simple_argnames=true;if(!all(fn.argnames,function(argname){var abort=false;var tw=new TreeWalker(function(node){if(abort)return true;if(node instanceof AST_DefaultValue){if(has_arg_refs(fn,node.value))return abort=true;node.name.walk(tw);return true;}if(node instanceof AST_DestructuredKeyVal){if(node.key instanceof AST_Node&&has_arg_refs(fn,node.key))return abort=true;node.value.walk(tw);return true;}if(node instanceof AST_SymbolFunarg&&!all(node.definition().orig,function(sym){return !(sym instanceof AST_SymbolDefun);}))return abort=true;});argname.walk(tw);if(abort)return false;if(!(argname instanceof AST_SymbolFunarg))simple_argnames=false;return true;}))return;if(fn.rest){if(has_arg_refs(fn,fn.rest))return;simple_argnames=false;}var verify_body;if(no_return){verify_body=function(stat){var abort=false;stat.walk(new TreeWalker(function(node){if(abort)return true;if(async&&(node instanceof AST_Await||node instanceof AST_ForAwaitOf)||node instanceof AST_Return){return abort=true;}if(node instanceof AST_Scope)return true;}));return !abort;};}else if(in_await||is_async(fn)||in_async_generator(scope)){verify_body=function(stat){var abort=false;var find_return=new TreeWalker(function(node){if(abort)return true;if(node instanceof AST_Return)return abort=true;if(node instanceof AST_Scope)return true;});stat.walk(new TreeWalker(function(node){if(abort)return true;if(node instanceof AST_Try){if(!node.bfinally)return;if(all(node.body,function(stat){stat.walk(find_return);return !abort;})&&node.bcatch)node.bcatch.walk(find_return);return true;}if(node instanceof AST_Scope)return true;}));return !abort;};}if(verify_body&&!all(fn_body,verify_body))return;if(!safe_from_await_yield(fn,avoid_await_yield(compressor,scope)))return;fn.functions.each(function(def,name){scope.functions.set(name,def);});var body=[];fn.variables.each(function(def,name){if(!arrow&&name=="arguments"&&def.orig.length==1)return;names.set(name,true);scope.enclosed.push(def);scope.variables.set(name,def);def.single_use=false;if(!in_loop)return;if(def.references.length==def.replaced)return;switch(def.orig.length-def.eliminated){case 0:return;case 1:if(fn.functions.has(name))return;}if(!all(def.orig,function(sym){if(sym instanceof AST_SymbolConst)return false;if(sym instanceof AST_SymbolFunarg)return !sym.unused&&def.scope.resolve()!==fn;if(sym instanceof AST_SymbolLet)return false;return true;}))return;var sym=def.orig[0];if(sym instanceof AST_SymbolCatch)return;body.push(make_node(AST_SimpleStatement,sym,{body:init_ref(compressor,flatten_var(sym))}));def.first_decl=null;});var defs=Object.create(null),syms=new Dictionary();if(simple_argnames&&all(call.args,function(arg){return !(arg instanceof AST_Spread);})){var values=call.args.slice();fn.argnames.forEach(function(argname){var value=values.shift();if(argname.unused){if(value)body.push(make_node(AST_SimpleStatement,call,{body:value}));return;}var defn=make_node(AST_VarDef,call,{name:argname.convert_symbol(AST_SymbolVar,process),value:value||make_node(AST_Undefined,call).transform(compressor)});if(argname instanceof AST_SymbolFunarg)insert_assign(argname.definition(),defn);body.push(make_node(AST_Var,call,{definitions:[defn]}));});if(values.length)body.push(make_node(AST_SimpleStatement,call,{body:make_sequence(call,values)}));}else {body.push(make_node(AST_Var,call,{definitions:[make_node(AST_VarDef,call,{name:make_node(AST_DestructuredArray,call,{elements:fn.argnames.map(function(argname){if(argname.unused)return make_node(AST_Hole,argname);return argname.convert_symbol(AST_SymbolVar,process);}),rest:fn.rest&&fn.rest.convert_symbol(AST_SymbolVar,process)}),value:make_node(AST_Array,call,{elements:call.args.slice()})})]}));}syms.each(function(orig,id){var def=defs[id];[].unshift.apply(def.orig,orig);def.eliminated+=orig.length;});[].push.apply(body,in_loop?fn_body.filter(function(stat){if(!(stat instanceof AST_LambdaDefinition))return true;var name=make_node(AST_SymbolVar,flatten_var(stat.name));var def=name.definition();def.fixed=false;def.orig.push(name);def.eliminated++;body.push(make_node(AST_Var,stat,{definitions:[make_node(AST_VarDef,stat,{name:name,value:to_func_expr(stat,true)})]}));return false;}):fn_body);var inlined=make_node(AST_BlockStatement,call,{body:body});if(!no_return){if(async)scan_local_returns(inlined,function(node){var value=node.value;if(is_undefined(value))return;node.value=make_node(AST_Await,call,{expression:value});});body.push(make_node(AST_Return,call,{value:in_async_generator(scope)?make_node(AST_Undefined,call).transform(compressor):null}));}return inlined;function process(sym,argname){var def=argname.definition();defs[def.id]=def;syms.add(def.id,sym);}});def(AST_Conditional,function(compressor,scope,no_return,in_loop,in_await){var self=this;var body=self.consequent.try_inline(compressor,scope,no_return,in_loop,in_await);var alt=self.alternative.try_inline(compressor,scope,no_return,in_loop,in_await);if(!body&&!alt)return;return make_node(AST_If,self,{condition:self.condition,body:body||make_body(self.consequent),alternative:alt||make_body(self.alternative)});function make_body(value){if(no_return)return make_node(AST_SimpleStatement,value,{body:value});return make_node(AST_Return,value,{value:value});}});def(AST_For,function(compressor,scope,no_return,in_loop){var body=this.body.try_inline(compressor,scope,true,true);if(body)this.body=body;var inlined=this.init;if(inlined){inlined=inlined.try_inline(compressor,scope,true,in_loop);if(inlined){this.init=null;if(inlined instanceof AST_BlockStatement){inlined.body.push(this);return inlined;}return make_node(AST_BlockStatement,inlined,{body:[inlined,this]});}}return body&&this;});def(AST_ForEnumeration,function(compressor,scope,no_return,in_loop){var body=this.body.try_inline(compressor,scope,true,true);if(body)this.body=body;var obj=this.object;if(obj instanceof AST_Sequence){var inlined=inline_sequence(compressor,scope,true,in_loop,false,obj,1);if(inlined){this.object=obj.tail_node();inlined.body.push(this);return inlined;}}return body&&this;});def(AST_If,function(compressor,scope,no_return,in_loop){var body=this.body.try_inline(compressor,scope,no_return,in_loop);if(body)this.body=body;var alt=this.alternative;if(alt){alt=alt.try_inline(compressor,scope,no_return,in_loop);if(alt)this.alternative=alt;}var cond=this.condition;if(cond instanceof AST_Sequence){var inlined=inline_sequence(compressor,scope,true,in_loop,false,cond,1);if(inlined){this.condition=cond.tail_node();inlined.body.push(this);return inlined;}}return (body||alt)&&this;});def(AST_IterationStatement,function(compressor,scope,no_return,in_loop){var body=this.body.try_inline(compressor,scope,true,true);if(!body)return;this.body=body;return this;});def(AST_LabeledStatement,function(compressor,scope,no_return,in_loop){var body=this.body.try_inline(compressor,scope,no_return,in_loop);if(!body)return;if(this.body instanceof AST_IterationStatement&&body instanceof AST_BlockStatement){var loop=body.body.pop();this.body=loop;body.body.push(this);return body;}this.body=body;return this;});def(AST_New,noop);def(AST_Return,function(compressor,scope,no_return,in_loop){var value=this.value;return value&&value.try_inline(compressor,scope,undefined,in_loop==="try");});function inline_sequence(compressor,scope,no_return,in_loop,in_await,node,skip){var body=[],exprs=node.expressions,no_ret=no_return;for(var i=exprs.length-(skip||0),j=i;--i>=0;no_ret=true,in_await=false){var inlined=exprs[i].try_inline(compressor,scope,no_ret,in_loop,in_await);if(!inlined)continue;flush();body.push(inlined);}if(body.length==0)return;flush();if(!no_return&&body[0]instanceof AST_SimpleStatement){body[0]=make_node(AST_Return,node,{value:body[0].body});}return make_node(AST_BlockStatement,node,{body:body.reverse()});function flush(){if(j>i+1)body.push(make_node(AST_SimpleStatement,node,{body:make_sequence(node,exprs.slice(i+1,j))}));j=i;}}def(AST_Sequence,function(compressor,scope,no_return,in_loop,in_await){return inline_sequence(compressor,scope,no_return,in_loop,in_await,this);});def(AST_SimpleStatement,function(compressor,scope,no_return,in_loop){var body=this.body;while(body instanceof AST_UnaryPrefix){var op=body.operator;if(unary_side_effects[op])break;if(op=="void")break;body=body.expression;}if(!no_return&&!is_undefined(body))body=make_node(AST_UnaryPrefix,this,{operator:"void",expression:body});return body.try_inline(compressor,scope,no_return||false,in_loop);});def(AST_UnaryPrefix,function(compressor,scope,no_return,in_loop,in_await){var self=this;var op=self.operator;if(unary_side_effects[op])return;if(!no_return&&op=="void")no_return=false;var inlined=self.expression.try_inline(compressor,scope,no_return,in_loop,in_await);if(!inlined)return;if(!no_return)scan_local_returns(inlined,function(node){node.in_bool=false;var value=node.value;if(op=="void"&&is_undefined(value))return;node.value=make_node(AST_UnaryPrefix,self,{operator:op,expression:value||make_node(AST_Undefined,node).transform(compressor)});});return inlined;});def(AST_With,function(compressor,scope,no_return,in_loop){var body=this.body.try_inline(compressor,scope,no_return,in_loop);if(body)this.body=body;var exp=this.expression;if(exp instanceof AST_Sequence){var inlined=inline_sequence(compressor,scope,true,in_loop,false,exp,1);if(inlined){this.expression=exp.tail_node();inlined.body.push(this);return inlined;}}return body&&this;});def(AST_Yield,function(compressor,scope,no_return,in_loop){if(!compressor.option("yields"))return;if(!this.nested)return;var call=this.expression;if(call.TYPE!="Call")return;var fn=call.expression;switch(fn.CTOR){case AST_AsyncGeneratorFunction:fn=make_node(AST_AsyncFunction,fn);break;case AST_GeneratorFunction:fn=make_node(AST_Function,fn);break;default:return;}call=call.clone();call.expression=fn;return call.try_inline(compressor,scope,no_return,in_loop);});})(function(node,func){node.DEFMETHOD("try_inline",func);});OPT(AST_Return,function(self,compressor){var value=self.value;if(value&&compressor.option("side_effects")&&is_undefined(value,compressor)&&!in_async_generator(compressor.find_parent(AST_Scope))){self.value=null;}return self;});})(function(node,optimizer){node.DEFMETHOD("optimize",function(compressor){var self=this;if(self._optimized)return self;if(compressor.has_directive("use asm"))return self;var opt=optimizer(self,compressor);opt._optimized=true;return opt;});});function is_some_comments(comment){// multiline comment
return comment.type=="comment2"&&/@preserve|@license|@cc_on/i.test(comment.value);}function OutputStream(options){options=defaults(options,{annotations:false,ascii_only:false,beautify:false,braces:false,comments:false,extendscript:false,galio:false,ie:false,indent_level:4,indent_start:0,inline_script:true,keep_quoted_props:false,max_line_len:false,module:false,preamble:null,preserve_line:false,quote_keys:false,quote_style:0,semicolons:true,shebang:true,source_map:null,v8:false,webkit:false,width:80,wrap_iife:false},true);// Convert comment option to RegExp if necessary and set up comments filter
var comment_filter=return_false;// Default case, throw all comments away
if(options.comments){var comments=options.comments;if(typeof options.comments==="string"&&/^\/.*\/[a-zA-Z]*$/.test(options.comments)){var regex_pos=options.comments.lastIndexOf("/");comments=new RegExp(options.comments.substr(1,regex_pos-1),options.comments.substr(regex_pos+1));}if(comments instanceof RegExp){comment_filter=function(comment){return comment.type!="comment5"&&comments.test(comment.value);};}else if(typeof comments==="function"){comment_filter=function(comment){return comment.type!="comment5"&&comments(this,comment);};}else if(comments==="some"){comment_filter=is_some_comments;}else {// NOTE includes "all" option
comment_filter=return_true;}}function make_indent(value){if(typeof value=="number")return new Array(value+1).join(" ");if(!value)return "";if(!/^\s*$/.test(value))throw new Error("unsupported indentation: "+JSON.stringify(""+value));return value;}var current_col=0;var current_line=1;var current_indent=make_indent(options.indent_start);var full_indent=make_indent(options.indent_level);var half_indent=full_indent.length+1>>1;var last;var line_end=0;var line_fixed=true;var mappings=options.source_map&&[];var mapping_name;var mapping_token;var might_need_space;var might_need_semicolon;var need_newline_indented=false;var need_space=false;var output;var stack;var stored="";function reset(){last="";might_need_space=false;might_need_semicolon=false;stack=[];var str=output;output="";return str;}reset();var to_utf8=options.ascii_only?function(str,identifier){if(identifier||options.module)str=str.replace(/[\ud800-\udbff][\udc00-\udfff]/g,function(ch){return "\\u{"+(ch.charCodeAt(0)-0xd7c0<<10|ch.charCodeAt(1)-0xdc00).toString(16)+"}";});return str.replace(/[\u0000-\u001f\u007f-\uffff]/g,function(s,i){var code=s.charCodeAt(0).toString(16);if(code.length<=2&&!identifier){switch(s){case"\n":return "\\n";case"\r":return "\\r";case"\t":return "\\t";case"\b":return "\\b";case"\f":return "\\f";case"\x0B":return options.ie?"\\x0B":"\\v";case"\0":return /[0-9]/.test(str.charAt(i+1))?"\\x00":"\\0";}while(code.length<2)code="0"+code;return "\\x"+code;}else {while(code.length<4)code="0"+code;return "\\u"+code;}});}:function(str){var s="";for(var i=0,j=0;i<str.length;i++){var code=str.charCodeAt(i);if(is_surrogate_pair_head(code)){if(is_surrogate_pair_tail(str.charCodeAt(i+1))){i++;continue;}}else if(!is_surrogate_pair_tail(code)){continue;}s+=str.slice(j,i)+"\\u"+code.toString(16);j=i+1;}return j==0?str:s+str.slice(j);};function quote_single(str){return "'"+str.replace(/\x27/g,"\\'")+"'";}function quote_double(str){return '"'+str.replace(/\x22/g,'\\"')+'"';}var quote_string=[null,quote_single,quote_double,function(str,quote){return quote=="'"?quote_single(str):quote_double(str);}][options.quote_style]||function(str,quote,dq,sq){return dq>sq?quote_single(str):quote_double(str);};function make_string(str,quote){var dq=0,sq=0;str=str.replace(/[\\\b\f\n\r\v\t\x22\x27\u2028\u2029\0\ufeff]/g,function(s,i){switch(s){case'"':++dq;return '"';case"'":++sq;return "'";case"\\":return "\\\\";case"\n":return "\\n";case"\r":return "\\r";case"\t":return "\\t";case"\b":return "\\b";case"\f":return "\\f";case"\x0B":return options.ie?"\\x0B":"\\v";case"\u2028":return "\\u2028";case"\u2029":return "\\u2029";case"\ufeff":return "\\ufeff";case"\0":return /[0-9]/.test(str.charAt(i+1))?"\\x00":"\\0";}return s;});return quote_string(to_utf8(str),quote,dq,sq);}/* -----[ beautification/minification ]----- */var adjust_mappings=mappings?function(line,col){mappings.forEach(function(mapping){mapping.line+=line;mapping.col+=col;});}:noop;var flush_mappings=mappings?function(){mappings.forEach(function(mapping){options.source_map.add(mapping.token.file,mapping.line,mapping.col,mapping.token.line,mapping.token.col,!mapping.name&&mapping.token.type=="name"?mapping.token.value:mapping.name);});mappings=[];}:noop;function insert_newlines(count){stored+=output.slice(0,line_end);output=output.slice(line_end);var new_col=output.length;adjust_mappings(count,new_col-current_col);current_line+=count;current_col=new_col;while(count--)stored+="\n";}var fix_line=options.max_line_len?function(flush){if(line_fixed){if(current_col>options.max_line_len){AST_Node.warn("Output exceeds {max_line_len} characters",options);}return;}if(current_col>options.max_line_len){insert_newlines(1);line_fixed=true;}if(line_fixed||flush)flush_mappings();}:noop;var stat_end_chars=makePredicate("; }");var asi_skip_chars=makePredicate("( [ + * / - , . `");var asi_skip_words=makePredicate("in instanceof");function require_space(prev,ch,str){return is_identifier_char(prev)&&(is_identifier_char(ch)||ch=="\\")||ch=="/"&&ch==prev||(ch=="+"||ch=="-")&&ch==last||last=="--"&&ch==">"||last=="!"&&str=="--"||prev=="/"&&(str=="in"||str=="instanceof");}var print=options.beautify||options.comments||options.max_line_len||options.preserve_line||options.shebang||!options.semicolons||options.source_map||options.width?function(str){var ch=str.charAt(0);if(need_newline_indented&&ch){need_newline_indented=false;if(ch!="\n"){print("\n");indent();}}if(need_space&&ch){need_space=false;if(!/[\s;})]/.test(ch)){space();}}var prev=last.slice(-1);if(might_need_semicolon){might_need_semicolon=false;if(prev!=";"&&!stat_end_chars[ch]){var need_semicolon=asi_skip_chars[ch]||asi_skip_words[str];if(need_semicolon||options.semicolons){output+=";";current_col++;if(!line_fixed){fix_line();if(line_fixed&&!need_semicolon&&output==";"){output="";current_col=0;}}if(line_end==output.length-1)line_end++;}else {fix_line();output+="\n";current_line++;current_col=0;// reset the semicolon flag, since we didn't print one
// now and might still have to later
if(/^\s+$/.test(str))might_need_semicolon=true;}if(!options.beautify)might_need_space=false;}}if(might_need_space){if(require_space(prev,ch,str)){output+=" ";current_col++;}if(prev!="<"||str!="!")might_need_space=false;}if(mapping_token){mappings.push({token:mapping_token,name:mapping_name,line:current_line,col:current_col});mapping_token=false;if(line_fixed)flush_mappings();}output+=str;var a=str.split(/\r?\n/),n=a.length-1;current_line+=n;current_col+=a[0].length;if(n>0){fix_line();current_col=a[n].length;}last=str;}:function(str){var ch=str.charAt(0);var prev=last.slice(-1);if(might_need_semicolon){might_need_semicolon=false;if(prev==":"&&ch=="}"||(!ch||";}".indexOf(ch)<0)&&prev!=";"){output+=";";might_need_space=false;}}if(might_need_space){if(require_space(prev,ch,str))output+=" ";if(prev!="<"||str!="!")might_need_space=false;}output+=str;last=str;};var space=options.beautify?function(){print(" ");}:function(){might_need_space=true;};var indent=options.beautify?function(half){if(need_newline_indented)print("\n");print(half?current_indent.slice(0,-half_indent):current_indent);}:noop;var with_indent=options.beautify?function(cont){var save_indentation=current_indent;current_indent+=full_indent;cont();current_indent=save_indentation;}:function(cont){cont();};var may_add_newline=options.max_line_len||options.preserve_line?function(){fix_line();line_end=output.length;line_fixed=false;}:noop;var newline=options.beautify?function(){print("\n");line_end=output.length;}:may_add_newline;var semicolon=options.beautify?function(){print(";");}:function(){might_need_semicolon=true;};function force_semicolon(){if(might_need_semicolon)print(";");print(";");}function with_block(cont,end){print("{");newline();with_indent(cont);add_mapping(end);indent();print("}");}function with_parens(cont){print("(");may_add_newline();cont();may_add_newline();print(")");}function with_square(cont){print("[");may_add_newline();cont();may_add_newline();print("]");}function comma(){may_add_newline();print(",");may_add_newline();space();}function colon(){print(":");space();}var add_mapping=mappings?function(token,name){mapping_token=token;mapping_name=name;}:noop;function get(){if(!line_fixed)fix_line(true);return stored+output;}function has_nlb(){return /(^|\n) *$/.test(output);}function pad_comment(token,force){if(need_newline_indented)return;if(token.nlb&&(force||!has_nlb())){need_newline_indented=true;}else if(force){need_space=true;}}function print_comment(comment){var value=comment.value.replace(/[@#]__PURE__/g," ");if(/^\s*$/.test(value)&&!/^\s*$/.test(comment.value))return false;if(/comment[134]/.test(comment.type)){print("//"+value);need_newline_indented=true;}else if(comment.type=="comment2"){print("/*"+value+"*/");}return true;}function should_merge_comments(node,parent){if(parent instanceof AST_Binary)return parent.left===node;if(parent.TYPE=="Call")return parent.expression===node;if(parent instanceof AST_Conditional)return parent.condition===node;if(parent instanceof AST_Dot)return parent.expression===node;if(parent instanceof AST_Exit)return true;if(parent instanceof AST_Sequence)return parent.expressions[0]===node;if(parent instanceof AST_Sub)return parent.expression===node;if(parent instanceof AST_UnaryPostfix)return true;if(parent instanceof AST_Yield)return true;}function prepend_comments(node){var self=this;var scan;if(node instanceof AST_Exit){scan=node.value;}else if(node instanceof AST_Yield){scan=node.expression;}var comments=dump(node);if(!comments)comments=[];if(scan){var tw=new TreeWalker(function(node){if(!should_merge_comments(node,tw.parent()))return true;var before=dump(node);if(before)comments=comments.concat(before);});tw.push(node);scan.walk(tw);}if(current_line==1&&current_col==0){if(comments.length>0&&options.shebang&&comments[0].type=="comment5"){print("#!"+comments.shift().value+"\n");indent();}var preamble=options.preamble;if(preamble)print(preamble.replace(/\r\n?|\u2028|\u2029|(^|\S)\s*$/g,"$1\n"));}comments=comments.filter(comment_filter,node);var printed=false;comments.forEach(function(comment,index){pad_comment(comment,index);if(print_comment(comment))printed=true;});if(printed)pad_comment(node.start,true);function dump(node){var token=node.start;if(!token){if(!scan)return;node.start=token=new AST_Token();}var comments=token.comments_before;if(!comments){if(!scan)return;token.comments_before=comments=[];}if(comments._dumped===self)return;comments._dumped=self;return comments;}}function append_comments(node,tail){var self=this;var token=node.end;if(!token)return;var comments=token[tail?"comments_before":"comments_after"];if(!comments||comments._dumped===self)return;if(!(node instanceof AST_Statement||all(comments,function(c){return !/comment[134]/.test(c.type);})))return;comments._dumped=self;comments.filter(comment_filter,node).forEach(function(comment,index){pad_comment(comment,index||!tail);print_comment(comment);});}return {get:get,reset:reset,indent:indent,should_break:options.beautify&&options.width?function(){return current_col>=options.width;}:return_false,has_parens:function(){return last.slice(-1)=="(";},newline:newline,print:print,space:space,comma:comma,colon:colon,last:function(){return last;},semicolon:semicolon,force_semicolon:force_semicolon,to_utf8:to_utf8,print_name:function(name){print(to_utf8(name.toString(),true));},print_string:options.inline_script?function(str,quote){str=make_string(str,quote).replace(/<\x2f(script)([>\/\t\n\f\r ])/gi,"<\\/$1$2");print(str.replace(/\x3c!--/g,"\\x3c!--").replace(/--\x3e/g,"--\\x3e"));}:function(str,quote){print(make_string(str,quote));},with_indent:with_indent,with_block:with_block,with_parens:with_parens,with_square:with_square,add_mapping:add_mapping,option:function(opt){return options[opt];},prepend_comments:options.comments||options.shebang?prepend_comments:noop,append_comments:options.comments?append_comments:noop,push_node:function(node){stack.push(node);},pop_node:options.preserve_line?function(){var node=stack.pop();if(node.start&&node.start.line>current_line){insert_newlines(node.start.line-current_line);}}:function(){stack.pop();},parent:function(n){return stack[stack.length-2-(n||0)];}};}/* -----[ code generators ]----- */(function(){/* -----[ utils ]----- */function DEFPRINT(nodetype,generator){nodetype.DEFMETHOD("_codegen",generator);}var use_asm=false;AST_Node.DEFMETHOD("print",function(stream,force_parens){var self=this;stream.push_node(self);if(force_parens||self.needs_parens(stream)){stream.with_parens(doit);}else {doit();}stream.pop_node();function doit(){stream.prepend_comments(self);self.add_source_map(stream);self._codegen(stream);stream.append_comments(self);}});var readonly=OutputStream({inline_script:false,shebang:false,width:false});AST_Node.DEFMETHOD("print_to_string",function(options){if(options){var stream=OutputStream(options);this.print(stream);return stream.get();}this.print(readonly);return readonly.reset();});/* -----[ PARENTHESES ]----- */function PARENS(nodetype,func){nodetype.DEFMETHOD("needs_parens",func);}PARENS(AST_Node,return_false);// a function expression needs parens around it when it's provably
// the first token to appear in a statement.
function needs_parens_function(output){var p=output.parent();if(!output.has_parens()&&first_in_statement(output,false,true)){// export default function() {}
// export default (function foo() {});
// export default (function() {})(foo);
// export default (function() {})`foo`;
// export default (function() {}) ? foo : bar;
return this.name||!(p instanceof AST_ExportDefault);}if(output.option("webkit")&&p instanceof AST_PropAccess&&p.expression===this)return true;if(output.option("wrap_iife")&&p instanceof AST_Call&&p.expression===this)return true;}PARENS(AST_AsyncFunction,needs_parens_function);PARENS(AST_AsyncGeneratorFunction,needs_parens_function);PARENS(AST_ClassExpression,needs_parens_function);PARENS(AST_Function,needs_parens_function);PARENS(AST_GeneratorFunction,needs_parens_function);// same goes for an object literal, because otherwise it would be
// interpreted as a block of code.
function needs_parens_obj(output){return !output.has_parens()&&first_in_statement(output,true);}PARENS(AST_Object,needs_parens_obj);function needs_parens_unary(output){var p=output.parent();// (-x) ** y
if(p instanceof AST_Binary)return p.operator=="**"&&p.left===this;// (await x)(y)
// new (await x)
if(p instanceof AST_Call)return p.expression===this;// class extends (x++) {}
// class x extends (typeof y) {}
if(p instanceof AST_Class)return true;// (x++)[y]
// (typeof x).y
// https://github.com/mishoo/UglifyJS/issues/115
if(p instanceof AST_PropAccess)return p.expression===this;// (~x)`foo`
if(p instanceof AST_Template)return p.tag===this;}PARENS(AST_Await,needs_parens_unary);PARENS(AST_Unary,needs_parens_unary);PARENS(AST_Sequence,function(output){var p=output.parent();// [ 1, (2, 3), 4 ] ---> [ 1, 3, 4 ]
return p instanceof AST_Array// () ---> (foo, bar)
||is_arrow(p)&&p.value===this// await (foo, bar)
||p instanceof AST_Await// 1 + (2, 3) + 4 ---> 8
||p instanceof AST_Binary// new (foo, bar) or foo(1, (2, 3), 4)
||p instanceof AST_Call// class extends (foo, bar) {}
// class foo extends (bar, baz) {}
||p instanceof AST_Class// class { foo = (bar, baz) }
// class { [(foo, bar)]() {} }
||p instanceof AST_ClassProperty// (false, true) ? (a = 10, b = 20) : (c = 30)
// ---> 20 (side effect, set a := 10 and b := 20)
||p instanceof AST_Conditional// [ a = (1, 2) ] = [] ---> a == 2
||p instanceof AST_DefaultValue// { [(1, 2)]: foo } = bar
// { 1: (2, foo) } = bar
||p instanceof AST_DestructuredKeyVal// export default (foo, bar)
||p instanceof AST_ExportDefault// for (foo of (bar, baz));
||p instanceof AST_ForOf// { [(1, 2)]: 3 }[2] ---> 3
// { foo: (1, 2) }.foo ---> 2
||p instanceof AST_ObjectProperty// (1, {foo:2}).foo or (1, {foo:2})["foo"] ---> 2
||p instanceof AST_PropAccess&&p.expression===this// ...(foo, bar, baz)
||p instanceof AST_Spread// (foo, bar)`baz`
||p instanceof AST_Template&&p.tag===this// !(foo, bar, baz)
||p instanceof AST_Unary// var a = (1, 2), b = a + a; ---> b == 4
||p instanceof AST_VarDef// yield (foo, bar)
||p instanceof AST_Yield;});PARENS(AST_Binary,function(output){var p=output.parent();// await (foo && bar)
if(p instanceof AST_Await)return true;// this deals with precedence:
//   3 * (2 + 1)
//   3 - (2 - 1)
//   (1 ** 2) ** 3
if(p instanceof AST_Binary){var po=p.operator,pp=PRECEDENCE[po];var so=this.operator,sp=PRECEDENCE[so];return pp>sp||po=="??"&&(so=="&&"||so=="||")||pp==sp&&this===p[po=="**"?"left":"right"];}// (foo && bar)()
if(p instanceof AST_Call)return p.expression===this;// class extends (foo && bar) {}
// class foo extends (bar || null) {}
if(p instanceof AST_Class)return true;// (foo && bar)["prop"], (foo && bar).prop
if(p instanceof AST_PropAccess)return p.expression===this;// (foo && bar)``
if(p instanceof AST_Template)return p.tag===this;// typeof (foo && bar)
if(p instanceof AST_Unary)return true;});function need_chain_parens(node,parent){if(!node.terminal)return false;if(!(parent instanceof AST_Call||parent instanceof AST_PropAccess))return false;return parent.expression===node;}PARENS(AST_PropAccess,function(output){var node=this;var p=output.parent();// i.e. new (foo().bar)
//
// if there's one call into this subtree, then we need
// parens around it too, otherwise the call will be
// interpreted as passing the arguments to the upper New
// expression.
if(p instanceof AST_New&&p.expression===node&&root_expr(node).TYPE=="Call")return true;// (foo?.bar)()
// (foo?.bar).baz
// new (foo?.bar)()
return need_chain_parens(node,p);});PARENS(AST_Call,function(output){var node=this;var p=output.parent();if(p instanceof AST_New)return p.expression===node;// https://bugs.webkit.org/show_bug.cgi?id=123506
if(output.option("webkit")&&node.expression instanceof AST_Function&&p instanceof AST_PropAccess&&p.expression===node){var g=output.parent(1);if(g instanceof AST_Assign&&g.left===p)return true;}// (foo?.())()
// (foo?.()).bar
// new (foo?.())()
return need_chain_parens(node,p);});PARENS(AST_New,function(output){if(need_constructor_parens(this,output))return false;var p=output.parent();// (new foo)(bar)
if(p instanceof AST_Call)return p.expression===this;// (new Date).getTime(), (new Date)["getTime"]()
if(p instanceof AST_PropAccess)return true;// (new foo)`bar`
if(p instanceof AST_Template)return p.tag===this;});PARENS(AST_Number,function(output){if(!output.option("galio"))return false;// https://github.com/mishoo/UglifyJS/pull/1009
var p=output.parent();return p instanceof AST_PropAccess&&p.expression===this&&/^0/.test(make_num(this.value));});function needs_parens_assign_cond(self,output){var p=output.parent();// await (a = foo)
if(p instanceof AST_Await)return true;// 1 + (a = 2) + 3  6, side effect setting a = 2
if(p instanceof AST_Binary)return !(p instanceof AST_Assign);// (a = func)() or new (a = Object)()
if(p instanceof AST_Call)return p.expression===self;// class extends (a = foo) {}
// class foo extends (bar ? baz : moo) {}
if(p instanceof AST_Class)return true;// (a = foo) ? bar : baz
if(p instanceof AST_Conditional)return p.condition===self;// (a = foo)["prop"] or (a = foo).prop
if(p instanceof AST_PropAccess)return p.expression===self;// (a = foo)`bar`
if(p instanceof AST_Template)return p.tag===self;// !(a = false)  true
if(p instanceof AST_Unary)return true;}PARENS(AST_Arrow,function(output){return needs_parens_assign_cond(this,output);});PARENS(AST_Assign,function(output){if(needs_parens_assign_cond(this,output))return true;//  v8 parser bug   --->     workaround
// f([1], [a] = []) ---> f([1], ([a] = []))
if(output.option("v8"))return this.left instanceof AST_Destructured;// ({ p: a } = o);
if(this.left instanceof AST_DestructuredObject)return needs_parens_obj(output);});PARENS(AST_AsyncArrow,function(output){return needs_parens_assign_cond(this,output);});PARENS(AST_Conditional,function(output){return needs_parens_assign_cond(this,output)// https://github.com/mishoo/UglifyJS/issues/1144
||output.option("extendscript")&&output.parent()instanceof AST_Conditional;});PARENS(AST_Yield,function(output){return needs_parens_assign_cond(this,output);});/* -----[ PRINTERS ]----- */DEFPRINT(AST_Directive,function(output){var quote=this.quote;var value=this.value;switch(output.option("quote_style")){case 0:case 2:if(value.indexOf('"')==-1)quote='"';break;case 1:if(value.indexOf("'")==-1)quote="'";break;}output.print(quote+value+quote);output.semicolon();});DEFPRINT(AST_Debugger,function(output){output.print("debugger");output.semicolon();});/* -----[ statements ]----- */function display_body(body,is_toplevel,output,allow_directives){var last=body.length-1;var in_directive=allow_directives;var was_asm=use_asm;body.forEach(function(stmt,i){if(in_directive){if(stmt instanceof AST_Directive){if(stmt.value=="use asm")use_asm=true;}else if(!(stmt instanceof AST_EmptyStatement)){if(stmt instanceof AST_SimpleStatement&&stmt.body instanceof AST_String){output.force_semicolon();}in_directive=false;}}if(stmt instanceof AST_EmptyStatement)return;output.indent();stmt.print(output);if(i==last&&is_toplevel)return;output.newline();if(is_toplevel)output.newline();});use_asm=was_asm;}DEFPRINT(AST_Toplevel,function(output){display_body(this.body,true,output,true);output.print("");});DEFPRINT(AST_LabeledStatement,function(output){this.label.print(output);output.colon();var body=this.body;if(body instanceof AST_EmptyStatement){output.force_semicolon();}else {body.print(output);}});DEFPRINT(AST_SimpleStatement,function(output){this.body.print(output);output.semicolon();});function print_braced_empty(self,output){output.print("{");output.with_indent(function(){output.append_comments(self,true);});output.print("}");}function print_braced(self,output,allow_directives){if(self.body.length>0){output.with_block(function(){display_body(self.body,false,output,allow_directives);},self.end);}else print_braced_empty(self,output);}DEFPRINT(AST_BlockStatement,function(output){print_braced(this,output);});DEFPRINT(AST_EmptyStatement,function(output){output.semicolon();});DEFPRINT(AST_Do,function(output){var self=this;output.print("do");make_block(self.body,output);output.space();output.print("while");output.space();output.with_parens(function(){self.condition.print(output);});output.semicolon();});DEFPRINT(AST_While,function(output){var self=this;output.print("while");output.space();output.with_parens(function(){self.condition.print(output);});force_statement(self.body,output);});DEFPRINT(AST_For,function(output){var self=this;output.print("for");output.space();output.with_parens(function(){if(self.init){if(self.init instanceof AST_Definitions){self.init.print(output);}else {parenthesize_for_no_in(self.init,output,true);}output.print(";");output.space();}else {output.print(";");}if(self.condition){self.condition.print(output);output.print(";");output.space();}else {output.print(";");}if(self.step){self.step.print(output);}});force_statement(self.body,output);});function print_for_enum(prefix,infix){return function(output){var self=this;output.print(prefix);output.space();output.with_parens(function(){self.init.print(output);output.space();output.print(infix);output.space();self.object.print(output);});force_statement(self.body,output);};}DEFPRINT(AST_ForAwaitOf,print_for_enum("for await","of"));DEFPRINT(AST_ForIn,print_for_enum("for","in"));DEFPRINT(AST_ForOf,print_for_enum("for","of"));DEFPRINT(AST_With,function(output){var self=this;output.print("with");output.space();output.with_parens(function(){self.expression.print(output);});force_statement(self.body,output);});DEFPRINT(AST_ExportDeclaration,function(output){output.print("export");output.space();this.body.print(output);});DEFPRINT(AST_ExportDefault,function(output){output.print("export");output.space();output.print("default");output.space();var body=this.body;body.print(output);if(body instanceof AST_ClassExpression){if(!body.name)return;}if(body instanceof AST_DefClass)return;if(body instanceof AST_LambdaDefinition)return;if(body instanceof AST_LambdaExpression){if(!body.name&&!is_arrow(body))return;}output.semicolon();});function print_alias(alias,output){var value=alias.value;if(value=="*"||is_identifier_string(value)){output.print_name(value);}else {output.print_string(value,alias.quote);}}DEFPRINT(AST_ExportForeign,function(output){var self=this;output.print("export");output.space();var len=self.keys.length;if(len==0){print_braced_empty(self,output);}else if(self.keys[0].value=="*"){print_entry(0);}else output.with_block(function(){output.indent();print_entry(0);for(var i=1;i<len;i++){output.print(",");output.newline();output.indent();print_entry(i);}output.newline();},self.end);output.space();output.print("from");output.space();self.path.print(output);output.semicolon();function print_entry(index){var alias=self.aliases[index];var key=self.keys[index];print_alias(key,output);if(alias.value!=key.value){output.space();output.print("as");output.space();print_alias(alias,output);}}});DEFPRINT(AST_ExportReferences,function(output){var self=this;output.print("export");output.space();print_properties(self,output);output.semicolon();});DEFPRINT(AST_Import,function(output){var self=this;output.print("import");output.space();if(self.default)self.default.print(output);if(self.all){if(self.default)output.comma();self.all.print(output);}if(self.properties){if(self.default)output.comma();print_properties(self,output);}if(self.all||self.default||self.properties){output.space();output.print("from");output.space();}self.path.print(output);output.semicolon();});/* -----[ functions ]----- */function print_funargs(self,output){output.with_parens(function(){self.argnames.forEach(function(arg,i){if(i)output.comma();arg.print(output);});if(self.rest){if(self.argnames.length)output.comma();output.print("...");self.rest.print(output);}});}function print_arrow(self,output){var argname=self.argnames.length==1&&!self.rest&&self.argnames[0];if(argname instanceof AST_SymbolFunarg&&argname.name!="yield"){argname.print(output);}else {print_funargs(self,output);}output.space();output.print("=>");output.space();if(self.value){self.value.print(output);}else {print_braced(self,output,true);}}DEFPRINT(AST_Arrow,function(output){print_arrow(this,output);});DEFPRINT(AST_AsyncArrow,function(output){output.print("async");output.space();print_arrow(this,output);});function print_lambda(self,output){if(self.name){output.space();self.name.print(output);}print_funargs(self,output);output.space();print_braced(self,output,true);}DEFPRINT(AST_Lambda,function(output){output.print("function");print_lambda(this,output);});function print_async(output){output.print("async");output.space();output.print("function");print_lambda(this,output);}DEFPRINT(AST_AsyncDefun,print_async);DEFPRINT(AST_AsyncFunction,print_async);function print_async_generator(output){output.print("async");output.space();output.print("function*");print_lambda(this,output);}DEFPRINT(AST_AsyncGeneratorDefun,print_async_generator);DEFPRINT(AST_AsyncGeneratorFunction,print_async_generator);function print_generator(output){output.print("function*");print_lambda(this,output);}DEFPRINT(AST_GeneratorDefun,print_generator);DEFPRINT(AST_GeneratorFunction,print_generator);/* -----[ classes ]----- */DEFPRINT(AST_Class,function(output){var self=this;output.print("class");if(self.name){output.space();self.name.print(output);}if(self.extends){output.space();output.print("extends");output.space();self.extends.print(output);}output.space();print_properties(self,output,true);});DEFPRINT(AST_ClassField,function(output){var self=this;if(self.static){output.print("static");output.space();}print_property_key(self,output);if(self.value){output.space();output.print("=");output.space();self.value.print(output);}else switch(self.key){case"get":case"set":case"static":output.force_semicolon();return;}output.semicolon();});DEFPRINT(AST_ClassGetter,print_accessor("get"));DEFPRINT(AST_ClassSetter,print_accessor("set"));function print_method(self,output){var fn=self.value;if(is_async(fn)){output.print("async");output.space();}if(is_generator(fn))output.print("*");print_property_key(self,output);print_lambda(self.value,output);}DEFPRINT(AST_ClassMethod,function(output){var self=this;if(self.static){output.print("static");output.space();}print_method(self,output);});DEFPRINT(AST_ClassInit,function(output){output.print("static");output.space();print_braced(this.value,output);});/* -----[ jumps ]----- */function print_jump(kind,prop){return function(output){output.print(kind);var target=this[prop];if(target){output.space();target.print(output);}output.semicolon();};}DEFPRINT(AST_Return,print_jump("return","value"));DEFPRINT(AST_Throw,print_jump("throw","value"));DEFPRINT(AST_Break,print_jump("break","label"));DEFPRINT(AST_Continue,print_jump("continue","label"));/* -----[ if ]----- */function make_then(self,output){var b=self.body;if(output.option("braces")&&!(b instanceof AST_Const||b instanceof AST_Let)||output.option("ie")&&b instanceof AST_Do)return make_block(b,output);// The squeezer replaces "block"-s that contain only a single
// statement with the statement itself; technically, the AST
// is correct, but this can create problems when we output an
// IF having an ELSE clause where the THEN clause ends in an
// IF *without* an ELSE block (then the outer ELSE would refer
// to the inner IF).  This function checks for this case and
// adds the block braces if needed.
if(!b)return output.force_semicolon();while(true){if(b instanceof AST_If){if(!b.alternative){make_block(self.body,output);return;}b=b.alternative;}else if(b instanceof AST_StatementWithBody){b=b.body;}else break;}force_statement(self.body,output);}DEFPRINT(AST_If,function(output){var self=this;output.print("if");output.space();output.with_parens(function(){self.condition.print(output);});if(self.alternative){make_then(self,output);output.space();output.print("else");if(self.alternative instanceof AST_If){output.space();self.alternative.print(output);}else {force_statement(self.alternative,output);}}else {force_statement(self.body,output);}});/* -----[ switch ]----- */DEFPRINT(AST_Switch,function(output){var self=this;output.print("switch");output.space();output.with_parens(function(){self.expression.print(output);});output.space();var last=self.body.length-1;if(last<0)print_braced_empty(self,output);else output.with_block(function(){self.body.forEach(function(branch,i){output.indent(true);branch.print(output);if(i<last&&branch.body.length>0)output.newline();});},self.end);});function print_branch_body(self,output){output.newline();self.body.forEach(function(stmt){output.indent();stmt.print(output);output.newline();});}DEFPRINT(AST_Default,function(output){output.print("default:");print_branch_body(this,output);});DEFPRINT(AST_Case,function(output){var self=this;output.print("case");output.space();self.expression.print(output);output.print(":");print_branch_body(self,output);});/* -----[ exceptions ]----- */DEFPRINT(AST_Try,function(output){var self=this;output.print("try");output.space();print_braced(self,output);if(self.bcatch){output.space();self.bcatch.print(output);}if(self.bfinally){output.space();self.bfinally.print(output);}});DEFPRINT(AST_Catch,function(output){var self=this;output.print("catch");if(self.argname){output.space();output.with_parens(function(){self.argname.print(output);});}output.space();print_braced(self,output);});DEFPRINT(AST_Finally,function(output){output.print("finally");output.space();print_braced(this,output);});function print_definitions(type){return function(output){var self=this;output.print(type);output.space();self.definitions.forEach(function(def,i){if(i)output.comma();def.print(output);});var p=output.parent();if(!(p instanceof AST_IterationStatement&&p.init===self))output.semicolon();};}DEFPRINT(AST_Const,print_definitions("const"));DEFPRINT(AST_Let,print_definitions("let"));DEFPRINT(AST_Var,print_definitions("var"));function parenthesize_for_no_in(node,output,no_in){var parens=false;// need to take some precautions here:
//    https://github.com/mishoo/UglifyJS/issues/60
if(no_in)node.walk(new TreeWalker(function(node){if(parens)return true;if(node instanceof AST_Binary&&node.operator=="in")return parens=true;if(node instanceof AST_Scope&&!(is_arrow(node)&&node.value))return true;}));node.print(output,parens);}DEFPRINT(AST_VarDef,function(output){var self=this;self.name.print(output);if(self.value){output.space();output.print("=");output.space();var p=output.parent(1);var no_in=p instanceof AST_For||p instanceof AST_ForEnumeration;parenthesize_for_no_in(self.value,output,no_in);}});DEFPRINT(AST_DefaultValue,function(output){var self=this;self.name.print(output);output.space();output.print("=");output.space();self.value.print(output);});/* -----[ other expressions ]----- */function print_annotation(self,output){if(!output.option("annotations"))return;if(!self.pure)return;var level=0,parent=self,node;do{node=parent;parent=output.parent(level++);if(parent instanceof AST_Call&&parent.expression===node)return;}while(parent instanceof AST_PropAccess&&parent.expression===node);output.print("/*@__PURE__*/");}function print_call_args(self,output){output.with_parens(function(){self.args.forEach(function(expr,i){if(i)output.comma();expr.print(output);});output.add_mapping(self.end);});}DEFPRINT(AST_Call,function(output){var self=this;print_annotation(self,output);self.expression.print(output);if(self.optional)output.print("?.");print_call_args(self,output);});DEFPRINT(AST_New,function(output){var self=this;print_annotation(self,output);output.print("new");output.space();self.expression.print(output);if(need_constructor_parens(self,output))print_call_args(self,output);});DEFPRINT(AST_Sequence,function(output){this.expressions.forEach(function(node,index){if(index>0){output.comma();if(output.should_break()){output.newline();output.indent();}}node.print(output);});});DEFPRINT(AST_Dot,function(output){var self=this;var expr=self.expression;expr.print(output);var prop=self.property;if(output.option("ie")&&RESERVED_WORDS[prop]||self.quoted&&output.option("keep_quoted_props")){if(self.optional)output.print("?.");output.with_square(function(){output.add_mapping(self.end);output.print_string(prop);});}else {if(expr instanceof AST_Number&&!/[ex.)]/i.test(output.last()))output.print(".");output.print(self.optional?"?.":".");// the name after dot would be mapped about here.
output.add_mapping(self.end);output.print_name(prop);}});DEFPRINT(AST_Sub,function(output){var self=this;self.expression.print(output);if(self.optional)output.print("?.");output.with_square(function(){self.property.print(output);});});DEFPRINT(AST_Spread,function(output){output.print("...");this.expression.print(output);});DEFPRINT(AST_UnaryPrefix,function(output){var op=this.operator;var exp=this.expression;output.print(op);if(/^[a-z]/i.test(op)||/[+-]$/.test(op)&&exp instanceof AST_UnaryPrefix&&/^[+-]/.test(exp.operator)){output.space();}exp.print(output);});DEFPRINT(AST_UnaryPostfix,function(output){var self=this;self.expression.print(output);output.add_mapping(self.end);output.print(self.operator);});DEFPRINT(AST_Binary,function(output){var self=this;self.left.print(output);output.space();output.print(self.operator);output.space();self.right.print(output);});DEFPRINT(AST_Conditional,function(output){var self=this;self.condition.print(output);output.space();output.print("?");output.space();self.consequent.print(output);output.space();output.colon();self.alternative.print(output);});DEFPRINT(AST_Await,function(output){output.print("await");output.space();this.expression.print(output);});DEFPRINT(AST_Yield,function(output){output.print(this.nested?"yield*":"yield");if(this.expression){output.space();this.expression.print(output);}});/* -----[ literals ]----- */DEFPRINT(AST_Array,function(output){var a=this.elements,len=a.length;output.with_square(len>0?function(){output.space();a.forEach(function(exp,i){if(i)output.comma();exp.print(output);// If the final element is a hole, we need to make sure it
// doesn't look like a trailing comma, by inserting an actual
// trailing comma.
if(i===len-1&&exp instanceof AST_Hole)output.comma();});output.space();}:noop);});DEFPRINT(AST_DestructuredArray,function(output){var a=this.elements,len=a.length,rest=this.rest;output.with_square(len||rest?function(){output.space();a.forEach(function(exp,i){if(i)output.comma();exp.print(output);});if(rest){if(len)output.comma();output.print("...");rest.print(output);}else if(a[len-1]instanceof AST_Hole){// If the final element is a hole, we need to make sure it
// doesn't look like a trailing comma, by inserting an actual
// trailing comma.
output.comma();}output.space();}:noop);});DEFPRINT(AST_DestructuredKeyVal,function(output){var self=this;var key=print_property_key(self,output);var value=self.value;if(key){if(value instanceof AST_DefaultValue){if(value.name instanceof AST_Symbol&&key==get_symbol_name(value.name)){output.space();output.print("=");output.space();value.value.print(output);return;}}else if(value instanceof AST_Symbol){if(key==get_symbol_name(value))return;}}output.colon();value.print(output);});DEFPRINT(AST_DestructuredObject,function(output){var self=this;var props=self.properties,len=props.length,rest=self.rest;if(len||rest)output.with_block(function(){props.forEach(function(prop,i){if(i){output.print(",");output.newline();}output.indent();prop.print(output);});if(rest){if(len){output.print(",");output.newline();}output.indent();output.print("...");rest.print(output);}output.newline();},self.end);else print_braced_empty(self,output);});function print_properties(self,output,no_comma){var props=self.properties;if(props.length>0)output.with_block(function(){props.forEach(function(prop,i){if(i){if(!no_comma)output.print(",");output.newline();}output.indent();prop.print(output);});output.newline();},self.end);else print_braced_empty(self,output);}DEFPRINT(AST_Object,function(output){print_properties(this,output);});function print_property_key(self,output){var key=self.key;if(key instanceof AST_Node)return output.with_square(function(){key.print(output);});var quote=self.start&&self.start.quote;if(output.option("quote_keys")||quote&&output.option("keep_quoted_props")){output.print_string(key,quote);}else if(""+ +key==key&&key>=0){output.print(make_num(key));}else if(self.private){output.print_name(key);}else if(RESERVED_WORDS[key]?!output.option("ie"):is_identifier_string(key)){output.print_name(key);return key;}else {output.print_string(key,quote);}}DEFPRINT(AST_ObjectKeyVal,function(output){var self=this;print_property_key(self,output);output.colon();self.value.print(output);});DEFPRINT(AST_ObjectMethod,function(output){print_method(this,output);});function print_accessor(type){return function(output){var self=this;if(self.static){output.print("static");output.space();}output.print(type);output.space();print_property_key(self,output);print_lambda(self.value,output);};}DEFPRINT(AST_ObjectGetter,print_accessor("get"));DEFPRINT(AST_ObjectSetter,print_accessor("set"));function get_symbol_name(sym){var def=sym.definition();return def&&def.mangled_name||sym.name;}DEFPRINT(AST_Symbol,function(output){output.print_name(get_symbol_name(this));});DEFPRINT(AST_SymbolExport,function(output){var self=this;var name=get_symbol_name(self);output.print_name(name);var alias=self.alias;if(alias.value!=name){output.space();output.print("as");output.space();print_alias(alias,output);}});DEFPRINT(AST_SymbolImport,function(output){var self=this;var name=get_symbol_name(self);var key=self.key;if(key.value&&key.value!=name){print_alias(key,output);output.space();output.print("as");output.space();}output.print_name(name);});DEFPRINT(AST_Hole,noop);DEFPRINT(AST_Template,function(output){var self=this;if(self.tag)self.tag.print(output);output.print("`");for(var i=0;i<self.expressions.length;i++){output.print(output.to_utf8(self.strings[i]));output.print("${");self.expressions[i].print(output);output.print("}");}output.print(output.to_utf8(self.strings[i]));output.print("`");});DEFPRINT(AST_BigInt,function(output){output.print(this.value+"n");});DEFPRINT(AST_Constant,function(output){output.print(""+this.value);});DEFPRINT(AST_String,function(output){output.print_string(this.value,this.quote);});DEFPRINT(AST_Number,function(output){var start=this.start;if(use_asm&&start&&start.raw!=null){output.print(start.raw);}else {output.print(make_num(this.value));}});DEFPRINT(AST_RegExp,function(output){var regexp=this.value;var str=regexp.toString();var end=str.lastIndexOf("/");if(regexp.raw_source){str="/"+regexp.raw_source+str.slice(end);}else if(end==1){str="/(?:)"+str.slice(end);}else if(str.indexOf("/",1)<end){str="/"+str.slice(1,end).replace(/\\\\|[^/]?\//g,function(match){return match[0]=="\\"?match:match.slice(0,-1)+"\\/";})+str.slice(end);}output.print(output.to_utf8(str).replace(/\\(?:\0(?![0-9])|[^\0])/g,function(match){switch(match[1]){case"\n":return "\\n";case"\r":return "\\r";case"\t":return "\t";case"\b":return "\b";case"\f":return "\f";case"\0":return "\0";case"\x0B":return "\v";case"\u2028":return "\\u2028";case"\u2029":return "\\u2029";default:return match;}}).replace(/[\n\r\u2028\u2029]/g,function(c){switch(c){case"\n":return "\\n";case"\r":return "\\r";case"\u2028":return "\\u2028";case"\u2029":return "\\u2029";}}));});function force_statement(stat,output){if(output.option("braces")&&!(stat instanceof AST_Const||stat instanceof AST_Let)){make_block(stat,output);}else if(stat instanceof AST_EmptyStatement){output.force_semicolon();}else {output.space();stat.print(output);}}// self should be AST_New.  decide if we want to show parens or not.
function need_constructor_parens(self,output){// Always print parentheses with arguments
if(self.args.length>0)return true;return output.option("beautify");}function best_of(a){var best=a[0],len=best.length;for(var i=1;i<a.length;++i){if(a[i].length<len){best=a[i];len=best.length;}}return best;}function make_num(num){var str=num.toString(10).replace(/^0\./,".").replace("e+","e");var candidates=[str];if(Math.floor(num)===num){if(num<0){candidates.push("-0x"+(-num).toString(16).toLowerCase());}else {candidates.push("0x"+num.toString(16).toLowerCase());}}var match,len,digits;if(match=/^\.0+/.exec(str)){len=match[0].length;digits=str.slice(len);candidates.push(digits+"e-"+(digits.length+len-1));}else if(match=/[^0]0+$/.exec(str)){len=match[0].length-1;candidates.push(str.slice(0,-len)+"e"+len);}else if(match=/^(\d)\.(\d+)e(-?\d+)$/.exec(str)){candidates.push(match[1]+match[2]+"e"+(match[3]-match[2].length));}return best_of(candidates);}function make_block(stmt,output){output.space();if(stmt instanceof AST_EmptyStatement){print_braced_empty(stmt,output);}else if(stmt instanceof AST_BlockStatement){stmt.print(output);}else output.with_block(function(){output.indent();stmt.print(output);output.newline();},stmt.end);}/* -----[ source map generators ]----- */function DEFMAP(nodetype,generator){nodetype.forEach(function(nodetype){nodetype.DEFMETHOD("add_source_map",generator);});}DEFMAP([// We could easily add info for ALL nodes, but it seems to me that
// would be quite wasteful, hence this noop in the base class.
AST_Node,// since the label symbol will mark it
AST_LabeledStatement],noop);// XXX: I'm not exactly sure if we need it for all of these nodes,
// or if we should add even more.
DEFMAP([AST_Array,AST_Await,AST_BlockStatement,AST_Catch,AST_Constant,AST_Debugger,AST_Definitions,AST_Destructured,AST_Directive,AST_Finally,AST_Jump,AST_Lambda,AST_New,AST_Object,AST_Spread,AST_StatementWithBody,AST_Symbol,AST_Switch,AST_SwitchBranch,AST_Try,AST_UnaryPrefix,AST_Yield],function(output){output.add_mapping(this.start);});DEFMAP([AST_ClassProperty,AST_DestructuredKeyVal,AST_ObjectProperty],function(output){if(typeof this.key=="string")output.add_mapping(this.start,this.key);});})();var vlq_char=characters("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");var vlq_bits=vlq_char.reduce(function(map,ch,bits){map[ch]=bits;return map;},Object.create(null));function vlq_decode(indices,str){var value=0;var shift=0;for(var i=0,j=0;i<str.length;i++){var bits=vlq_bits[str[i]];value+=(bits&31)<<shift;if(bits&32){shift+=5;}else {indices[j++]+=value&1?0x80000000|-(value>>1):value>>1;value=shift=0;}}return j;}function vlq_encode(num){var result="";num=Math.abs(num)<<1|num>>>31;do{var bits=num&31;if(num>>>=5)bits|=32;result+=vlq_char[bits];}while(num);return result;}function create_array_map(){var map=new Dictionary();var array=[];array.index=function(name){var index=map.get(name);if(!(index>=0)){index=array.length;array.push(name);map.set(name,index);}return index;};return array;}function SourceMap(options){var sources=create_array_map();var sources_content=options.includeSources&&new Dictionary();var names=create_array_map();var mappings="";if(options.orig)Object.keys(options.orig).forEach(function(name){var map=options.orig[name];var indices=[0,0,1,0,0];options.orig[name]={names:map.names,mappings:map.mappings.split(/;/).map(function(line){indices[0]=0;return line.split(/,/).map(function(segment){return indices.slice(0,vlq_decode(indices,segment));});}),sources:map.sources};if(!sources_content||!map.sourcesContent)return;for(var i=0;i<map.sources.length;i++){var content=map.sourcesContent[i];if(content)sources_content.set(map.sources[i],content);}});var prev_source;var generated_line=1;var generated_column=0;var source_index=0;var original_line=1;var original_column=0;var name_index=0;return {add:options.orig?function(source,gen_line,gen_col,orig_line,orig_col,name){var map=options.orig[source];if(map){var segments=map.mappings[orig_line-1];if(!segments)return;var indices;for(var i=0;i<segments.length;i++){var col=segments[i][0];if(orig_col>=col)indices=segments[i];if(orig_col<=col)break;}if(!indices||indices.length<4){source=null;}else {source=map.sources[indices[1]];orig_line=indices[2];orig_col=indices[3];if(indices.length>4)name=map.names[indices[4]];}}add(source,gen_line,gen_col,orig_line,orig_col,name);}:add,setSourceContent:sources_content?function(source,content){if(!sources_content.has(source)){sources_content.set(source,content);}}:noop,toString:function(){return JSON.stringify({version:3,file:options.filename||undefined,sourceRoot:options.root||undefined,sources:sources,sourcesContent:sources_content?sources.map(function(source){return sources_content.get(source)||null;}):undefined,names:names,mappings:mappings});}};function add(source,gen_line,gen_col,orig_line,orig_col,name){if(prev_source==null&&source==null)return;prev_source=source;if(generated_line<gen_line){generated_column=0;do{mappings+=";";}while(++generated_line<gen_line);}else if(mappings){mappings+=",";}mappings+=vlq_encode(gen_col-generated_column);generated_column=gen_col;if(source==null)return;var src_idx=sources.index(source);mappings+=vlq_encode(src_idx-source_index);source_index=src_idx;mappings+=vlq_encode(orig_line-original_line);original_line=orig_line;mappings+=vlq_encode(orig_col-original_column);original_column=orig_col;if(options.names&&name!=null){var name_idx=names.index(name);mappings+=vlq_encode(name_idx-name_index);name_index=name_idx;}}}(function(){var MOZ_TO_ME={Program:function(M){return new AST_Toplevel({start:my_start_token(M),end:my_end_token(M),body:normalize_directives(M.body.map(from_moz))});},ArrowFunctionExpression:function(M){var argnames=[],rest=null;M.params.forEach(function(param){if(param.type=="RestElement"){rest=from_moz(param.argument);}else {argnames.push(from_moz(param));}});var fn=new(M.async?AST_AsyncArrow:AST_Arrow)({start:my_start_token(M),end:my_end_token(M),argnames:argnames,rest:rest});var node=from_moz(M.body);if(node instanceof AST_BlockStatement){fn.body=normalize_directives(node.body);fn.value=null;}else {fn.body=[];fn.value=node;}return fn;},FunctionDeclaration:function(M){var ctor;if(M.async){ctor=M.generator?AST_AsyncGeneratorDefun:AST_AsyncDefun;}else {ctor=M.generator?AST_GeneratorDefun:AST_Defun;}var argnames=[],rest=null;M.params.forEach(function(param){if(param.type=="RestElement"){rest=from_moz(param.argument);}else {argnames.push(from_moz(param));}});return new ctor({start:my_start_token(M),end:my_end_token(M),name:from_moz(M.id),argnames:argnames,rest:rest,body:normalize_directives(from_moz(M.body).body)});},FunctionExpression:function(M){var ctor;if(M.async){ctor=M.generator?AST_AsyncGeneratorFunction:AST_AsyncFunction;}else {ctor=M.generator?AST_GeneratorFunction:AST_Function;}var argnames=[],rest=null;M.params.forEach(function(param){if(param.type=="RestElement"){rest=from_moz(param.argument);}else {argnames.push(from_moz(param));}});return new ctor({start:my_start_token(M),end:my_end_token(M),name:from_moz(M.id),argnames:argnames,rest:rest,body:normalize_directives(from_moz(M.body).body)});},CallExpression:function(M){return new AST_Call({start:my_start_token(M),end:my_end_token(M),expression:from_moz(M.callee),args:M.arguments.map(from_moz),optional:M.optional,pure:M.pure});},ClassDeclaration:function(M){return new AST_DefClass({start:my_start_token(M),end:my_end_token(M),name:from_moz(M.id),extends:from_moz(M.superClass),properties:M.body.body.map(from_moz)});},ClassExpression:function(M){return new AST_ClassExpression({start:my_start_token(M),end:my_end_token(M),name:from_moz(M.id),extends:from_moz(M.superClass),properties:M.body.body.map(from_moz)});},MethodDefinition:function(M){var key=M.key,internal=false;if(M.computed){key=from_moz(key);}else if(key.type=="PrivateIdentifier"){internal=true;key="#"+key.name;}else {key=read_name(key);}var ctor=AST_ClassMethod,value=from_moz(M.value);switch(M.kind){case"get":ctor=AST_ClassGetter;value=new AST_Accessor(value);break;case"set":ctor=AST_ClassSetter;value=new AST_Accessor(value);break;}return new ctor({start:my_start_token(M),end:my_end_token(M),key:key,private:internal,static:M.static,value:value});},PropertyDefinition:function(M){var key=M.key,internal=false;if(M.computed){key=from_moz(key);}else if(key.type=="PrivateIdentifier"){internal=true;key="#"+key.name;}else {key=read_name(key);}return new AST_ClassField({start:my_start_token(M),end:my_end_token(M),key:key,private:internal,static:M.static,value:from_moz(M.value)});},StaticBlock:function(M){var start=my_start_token(M);var end=my_end_token(M);return new AST_ClassInit({start:start,end:end,value:new AST_ClassInitBlock({start:start,end:end,body:normalize_directives(M.body.map(from_moz))})});},ForOfStatement:function(M){return new(M.await?AST_ForAwaitOf:AST_ForOf)({start:my_start_token(M),end:my_end_token(M),init:from_moz(M.left),object:from_moz(M.right),body:from_moz(M.body)});},TryStatement:function(M){var handlers=M.handlers||[M.handler];if(handlers.length>1||M.guardedHandlers&&M.guardedHandlers.length){throw new Error("Multiple catch clauses are not supported.");}return new AST_Try({start:my_start_token(M),end:my_end_token(M),body:from_moz(M.block).body,bcatch:from_moz(handlers[0]),bfinally:M.finalizer?new AST_Finally(from_moz(M.finalizer)):null});},Property:function(M){var key=M.computed?from_moz(M.key):read_name(M.key);var args={start:my_start_token(M),end:my_end_token(M),key:key,value:from_moz(M.value)};if(M.kind=="init")return new(M.method?AST_ObjectMethod:AST_ObjectKeyVal)(args);args.value=new AST_Accessor(args.value);if(M.kind=="get")return new AST_ObjectGetter(args);if(M.kind=="set")return new AST_ObjectSetter(args);},ArrayExpression:function(M){return new AST_Array({start:my_start_token(M),end:my_end_token(M),elements:M.elements.map(function(elem){return elem===null?new AST_Hole():from_moz(elem);})});},ArrayPattern:function(M){var elements=[],rest=null;M.elements.forEach(function(el){if(el===null){elements.push(new AST_Hole());}else if(el.type=="RestElement"){rest=from_moz(el.argument);}else {elements.push(from_moz(el));}});return new AST_DestructuredArray({start:my_start_token(M),end:my_end_token(M),elements:elements,rest:rest});},ObjectPattern:function(M){var props=[],rest=null;M.properties.forEach(function(prop){if(prop.type=="RestElement"){rest=from_moz(prop.argument);}else {props.push(new AST_DestructuredKeyVal(from_moz(prop)));}});return new AST_DestructuredObject({start:my_start_token(M),end:my_end_token(M),properties:props,rest:rest});},MemberExpression:function(M){return new(M.computed?AST_Sub:AST_Dot)({start:my_start_token(M),end:my_end_token(M),optional:M.optional,expression:from_moz(M.object),property:M.computed?from_moz(M.property):M.property.name});},MetaProperty:function(M){var expr=from_moz(M.meta);var prop=read_name(M.property);if(expr.name=="new"&&prop=="target")return new AST_NewTarget({start:my_start_token(M),end:my_end_token(M),name:"new.target"});return new AST_Dot({start:my_start_token(M),end:my_end_token(M),expression:expr,property:prop});},SwitchCase:function(M){return new(M.test?AST_Case:AST_Default)({start:my_start_token(M),end:my_end_token(M),expression:from_moz(M.test),body:M.consequent.map(from_moz)});},ExportAllDeclaration:function(M){var start=my_start_token(M);var end=my_end_token(M);return new AST_ExportForeign({start:start,end:end,aliases:[M.exported?from_moz_alias(M.exported):new AST_String({start:start,value:"*",end:end})],keys:[new AST_String({start:start,value:"*",end:end})],path:from_moz(M.source)});},ExportDefaultDeclaration:function(M){var decl=from_moz(M.declaration);if(!decl.name)switch(decl.CTOR){case AST_AsyncDefun:decl=new AST_AsyncFunction(decl);break;case AST_AsyncGeneratorDefun:decl=new AST_AsyncGeneratorFunction(decl);break;case AST_DefClass:decl=new AST_ClassExpression(decl);break;case AST_Defun:decl=new AST_Function(decl);break;case AST_GeneratorDefun:decl=new AST_GeneratorFunction(decl);break;}return new AST_ExportDefault({start:my_start_token(M),end:my_end_token(M),body:decl});},ExportNamedDeclaration:function(M){if(M.declaration)return new AST_ExportDeclaration({start:my_start_token(M),end:my_end_token(M),body:from_moz(M.declaration)});if(M.source){var aliases=[],keys=[];M.specifiers.forEach(function(prop){aliases.push(from_moz_alias(prop.exported));keys.push(from_moz_alias(prop.local));});return new AST_ExportForeign({start:my_start_token(M),end:my_end_token(M),aliases:aliases,keys:keys,path:from_moz(M.source)});}return new AST_ExportReferences({start:my_start_token(M),end:my_end_token(M),properties:M.specifiers.map(function(prop){var sym=new AST_SymbolExport(from_moz(prop.local));sym.alias=from_moz_alias(prop.exported);return sym;})});},ImportDeclaration:function(M){var start=my_start_token(M);var end=my_end_token(M);var all=null,def=null,props=null;M.specifiers.forEach(function(prop){var sym=new AST_SymbolImport(from_moz(prop.local));switch(prop.type){case"ImportDefaultSpecifier":def=sym;def.key=new AST_String({start:start,value:"",end:end});break;case"ImportNamespaceSpecifier":all=sym;all.key=new AST_String({start:start,value:"*",end:end});break;default:sym.key=from_moz_alias(prop.imported);if(!props)props=[];props.push(sym);break;}});return new AST_Import({start:start,end:end,all:all,default:def,properties:props,path:from_moz(M.source)});},ImportExpression:function(M){var start=my_start_token(M);var arg=from_moz(M.source);return new AST_Call({start:start,end:my_end_token(M),expression:new AST_SymbolRef({start:start,end:arg.start,name:"import"}),args:[arg]});},VariableDeclaration:function(M){return new({const:AST_Const,let:AST_Let}[M.kind]||AST_Var)({start:my_start_token(M),end:my_end_token(M),definitions:M.declarations.map(from_moz)});},Literal:function(M){var args={start:my_start_token(M),end:my_end_token(M)};if(M.bigint){args.value=M.bigint.toLowerCase();return new AST_BigInt(args);}var val=M.value;if(val===null)return new AST_Null(args);var rx=M.regex;if(rx&&rx.pattern){// RegExpLiteral as per ESTree AST spec
args.value=new RegExp(rx.pattern,rx.flags);args.value.raw_source=rx.pattern;return new AST_RegExp(args);}else if(rx){// support legacy RegExp
args.value=M.regex&&M.raw?M.raw:val;return new AST_RegExp(args);}switch(typeof val){case"string":args.value=val;return new AST_String(args);case"number":if(isNaN(val))return new AST_NaN(args);var negate,node;if(isFinite(val)){negate=1/val<0;args.value=negate?-val:val;node=new AST_Number(args);}else {negate=val<0;node=new AST_Infinity(args);}return negate?new AST_UnaryPrefix({start:args.start,end:args.end,operator:"-",expression:node}):node;case"boolean":return new(val?AST_True:AST_False)(args);}},TemplateLiteral:function(M){return new AST_Template({start:my_start_token(M),end:my_end_token(M),expressions:M.expressions.map(from_moz),strings:M.quasis.map(function(el){return el.value.raw;})});},TaggedTemplateExpression:function(M){var tmpl=from_moz(M.quasi);tmpl.start=my_start_token(M);tmpl.end=my_end_token(M);tmpl.tag=from_moz(M.tag);return tmpl;},Identifier:function(M){var p,level=FROM_MOZ_STACK.length-1;do{p=FROM_MOZ_STACK[--level];}while(p.type=="ArrayPattern"||p.type=="AssignmentPattern"&&p.left===FROM_MOZ_STACK[level+1]||p.type=="ObjectPattern"||p.type=="Property"&&p.value===FROM_MOZ_STACK[level+1]||p.type=="VariableDeclarator"&&p.id===FROM_MOZ_STACK[level+1]);var ctor=AST_SymbolRef;switch(p.type){case"ArrowFunctionExpression":if(p.body!==FROM_MOZ_STACK[level+1])ctor=AST_SymbolFunarg;break;case"BreakStatement":case"ContinueStatement":ctor=AST_LabelRef;break;case"CatchClause":ctor=AST_SymbolCatch;break;case"ClassDeclaration":if(p.id===FROM_MOZ_STACK[level+1])ctor=AST_SymbolDefClass;break;case"ClassExpression":if(p.id===FROM_MOZ_STACK[level+1])ctor=AST_SymbolClass;break;case"FunctionDeclaration":ctor=p.id===FROM_MOZ_STACK[level+1]?AST_SymbolDefun:AST_SymbolFunarg;break;case"FunctionExpression":ctor=p.id===FROM_MOZ_STACK[level+1]?AST_SymbolLambda:AST_SymbolFunarg;break;case"LabeledStatement":ctor=AST_Label;break;case"VariableDeclaration":ctor={const:AST_SymbolConst,let:AST_SymbolLet}[p.kind]||AST_SymbolVar;break;}return new ctor({start:my_start_token(M),end:my_end_token(M),name:M.name});},Super:function(M){return new AST_Super({start:my_start_token(M),end:my_end_token(M),name:"super"});},ThisExpression:function(M){return new AST_This({start:my_start_token(M),end:my_end_token(M),name:"this"});},ParenthesizedExpression:function(M){var node=from_moz(M.expression);if(!node.start.parens)node.start.parens=[];node.start.parens.push(my_start_token(M));if(!node.end.parens)node.end.parens=[];node.end.parens.push(my_end_token(M));return node;},ChainExpression:function(M){var node=from_moz(M.expression);node.terminal=true;return node;}};MOZ_TO_ME.UpdateExpression=MOZ_TO_ME.UnaryExpression=function To_Moz_Unary(M){var prefix="prefix"in M?M.prefix:M.type=="UnaryExpression"?true:false;return new(prefix?AST_UnaryPrefix:AST_UnaryPostfix)({start:my_start_token(M),end:my_end_token(M),operator:M.operator,expression:from_moz(M.argument)});};map("EmptyStatement",AST_EmptyStatement);map("ExpressionStatement",AST_SimpleStatement,"expression>body");map("BlockStatement",AST_BlockStatement,"body@body");map("IfStatement",AST_If,"test>condition, consequent>body, alternate>alternative");map("LabeledStatement",AST_LabeledStatement,"label>label, body>body");map("BreakStatement",AST_Break,"label>label");map("ContinueStatement",AST_Continue,"label>label");map("WithStatement",AST_With,"object>expression, body>body");map("SwitchStatement",AST_Switch,"discriminant>expression, cases@body");map("ReturnStatement",AST_Return,"argument>value");map("ThrowStatement",AST_Throw,"argument>value");map("WhileStatement",AST_While,"test>condition, body>body");map("DoWhileStatement",AST_Do,"test>condition, body>body");map("ForStatement",AST_For,"init>init, test>condition, update>step, body>body");map("ForInStatement",AST_ForIn,"left>init, right>object, body>body");map("DebuggerStatement",AST_Debugger);map("VariableDeclarator",AST_VarDef,"id>name, init>value");map("CatchClause",AST_Catch,"param>argname, body%body");map("BinaryExpression",AST_Binary,"operator=operator, left>left, right>right");map("LogicalExpression",AST_Binary,"operator=operator, left>left, right>right");map("AssignmentExpression",AST_Assign,"operator=operator, left>left, right>right");map("AssignmentPattern",AST_DefaultValue,"left>name, right>value");map("ConditionalExpression",AST_Conditional,"test>condition, consequent>consequent, alternate>alternative");map("NewExpression",AST_New,"callee>expression, arguments@args, pure=pure");map("SequenceExpression",AST_Sequence,"expressions@expressions");map("SpreadElement",AST_Spread,"argument>expression");map("ObjectExpression",AST_Object,"properties@properties");map("AwaitExpression",AST_Await,"argument>expression");map("YieldExpression",AST_Yield,"argument>expression, delegate=nested");def_to_moz(AST_Toplevel,function To_Moz_Program(M){return to_moz_scope("Program",M);});def_to_moz(AST_LambdaDefinition,function To_Moz_FunctionDeclaration(M){var params=M.argnames.map(to_moz);if(M.rest)params.push({type:"RestElement",argument:to_moz(M.rest)});return {type:"FunctionDeclaration",id:to_moz(M.name),async:is_async(M),generator:is_generator(M),params:params,body:to_moz_scope("BlockStatement",M)};});def_to_moz(AST_Lambda,function To_Moz_FunctionExpression(M){var params=M.argnames.map(to_moz);if(M.rest)params.push({type:"RestElement",argument:to_moz(M.rest)});if(is_arrow(M))return {type:"ArrowFunctionExpression",async:is_async(M),params:params,expression:!!M.value,body:M.value?to_moz(M.value):to_moz_scope("BlockStatement",M)};return {type:"FunctionExpression",id:to_moz(M.name),async:is_async(M),generator:is_generator(M),params:params,body:to_moz_scope("BlockStatement",M)};});def_to_moz(AST_Call,function To_Moz_CallExpression(M){var expr=M.expression;if(M.args.length==1&&expr instanceof AST_SymbolRef&&expr.name=="import")return {type:"ImportExpression",source:to_moz(M.args[0])};return {type:"CallExpression",callee:to_moz(expr),arguments:M.args.map(to_moz),optional:M.optional,pure:M.pure};});def_to_moz(AST_DefClass,function To_Moz_ClassDeclaration(M){return {type:"ClassDeclaration",id:to_moz(M.name),superClass:to_moz(M.extends),body:{type:"ClassBody",body:M.properties.map(to_moz)}};});def_to_moz(AST_ClassExpression,function To_Moz_ClassExpression(M){return {type:"ClassExpression",id:to_moz(M.name),superClass:to_moz(M.extends),body:{type:"ClassBody",body:M.properties.map(to_moz)}};});function To_Moz_MethodDefinition(kind){return function(M){var computed=M.key instanceof AST_Node;var key=computed?to_moz(M.key):M.private?{type:"PrivateIdentifier",name:M.key.slice(1)}:{type:"Literal",value:M.key};return {type:"MethodDefinition",kind:kind,computed:computed,key:key,static:M.static,value:to_moz(M.value)};};}def_to_moz(AST_ClassGetter,To_Moz_MethodDefinition("get"));def_to_moz(AST_ClassSetter,To_Moz_MethodDefinition("set"));def_to_moz(AST_ClassMethod,To_Moz_MethodDefinition("method"));def_to_moz(AST_ClassField,function To_Moz_PropertyDefinition(M){var computed=M.key instanceof AST_Node;var key=computed?to_moz(M.key):M.private?{type:"PrivateIdentifier",name:M.key.slice(1)}:{type:"Literal",value:M.key};return {type:"PropertyDefinition",computed:computed,key:key,static:M.static,value:to_moz(M.value)};});def_to_moz(AST_ClassInit,function To_Moz_StaticBlock(M){return to_moz_scope("StaticBlock",M.value);});function To_Moz_ForOfStatement(is_await){return function(M){return {type:"ForOfStatement",await:is_await,left:to_moz(M.init),right:to_moz(M.object),body:to_moz(M.body)};};}def_to_moz(AST_ForAwaitOf,To_Moz_ForOfStatement(true));def_to_moz(AST_ForOf,To_Moz_ForOfStatement(false));def_to_moz(AST_Directive,function To_Moz_Directive(M){return {type:"ExpressionStatement",directive:M.value,expression:set_moz_loc(M,{type:"Literal",value:M.value})};});def_to_moz(AST_SwitchBranch,function To_Moz_SwitchCase(M){return {type:"SwitchCase",test:to_moz(M.expression),consequent:M.body.map(to_moz)};});def_to_moz(AST_Try,function To_Moz_TryStatement(M){return {type:"TryStatement",block:to_moz_block(M),handler:to_moz(M.bcatch),finalizer:to_moz(M.bfinally)};});def_to_moz(AST_Catch,function To_Moz_CatchClause(M){return {type:"CatchClause",param:to_moz(M.argname),body:to_moz_block(M)};});def_to_moz(AST_ExportDeclaration,function To_Moz_ExportNamedDeclaration_declaration(M){return {type:"ExportNamedDeclaration",declaration:to_moz(M.body),specifiers:[]};});def_to_moz(AST_ExportDefault,function To_Moz_ExportDefaultDeclaration(M){return {type:"ExportDefaultDeclaration",declaration:to_moz(M.body)};});def_to_moz(AST_ExportForeign,function To_Moz_ExportAllDeclaration_ExportNamedDeclaration(M){if(M.keys[0].value=="*")return {type:"ExportAllDeclaration",exported:M.aliases[0].value=="*"?null:to_moz_alias(M.aliases[0]),source:to_moz(M.path)};var specifiers=[];for(var i=0;i<M.aliases.length;i++){specifiers.push(set_moz_loc({start:M.keys[i].start,end:M.aliases[i].end},{type:"ExportSpecifier",local:to_moz_alias(M.keys[i]),exported:to_moz_alias(M.aliases[i])}));}return {type:"ExportNamedDeclaration",specifiers:specifiers,source:to_moz(M.path)};});def_to_moz(AST_ExportReferences,function To_Moz_ExportNamedDeclaration_specifiers(M){return {type:"ExportNamedDeclaration",specifiers:M.properties.map(function(prop){return set_moz_loc({start:prop.start,end:prop.alias.end},{type:"ExportSpecifier",local:to_moz(prop),exported:to_moz_alias(prop.alias)});})};});def_to_moz(AST_Import,function To_Moz_ImportDeclaration(M){var specifiers=M.properties?M.properties.map(function(prop){return set_moz_loc({start:prop.key.start,end:prop.end},{type:"ImportSpecifier",local:to_moz(prop),imported:to_moz_alias(prop.key)});}):[];if(M.all)specifiers.unshift(set_moz_loc(M.all,{type:"ImportNamespaceSpecifier",local:to_moz(M.all)}));if(M.default)specifiers.unshift(set_moz_loc(M.default,{type:"ImportDefaultSpecifier",local:to_moz(M.default)}));return {type:"ImportDeclaration",specifiers:specifiers,source:to_moz(M.path)};});def_to_moz(AST_Definitions,function To_Moz_VariableDeclaration(M){return {type:"VariableDeclaration",kind:M.TYPE.toLowerCase(),declarations:M.definitions.map(to_moz)};});def_to_moz(AST_PropAccess,function To_Moz_MemberExpression(M){var computed=M instanceof AST_Sub;var expr={type:"MemberExpression",object:to_moz(M.expression),computed:computed,optional:M.optional,property:computed?to_moz(M.property):{type:"Identifier",name:M.property}};return M.terminal?{type:"ChainExpression",expression:expr}:expr;});def_to_moz(AST_Unary,function To_Moz_Unary(M){return {type:M.operator=="++"||M.operator=="--"?"UpdateExpression":"UnaryExpression",operator:M.operator,prefix:M instanceof AST_UnaryPrefix,argument:to_moz(M.expression)};});def_to_moz(AST_Binary,function To_Moz_BinaryExpression(M){return {type:M.operator=="&&"||M.operator=="||"?"LogicalExpression":"BinaryExpression",left:to_moz(M.left),operator:M.operator,right:to_moz(M.right)};});def_to_moz(AST_Array,function To_Moz_ArrayExpression(M){return {type:"ArrayExpression",elements:M.elements.map(to_moz)};});def_to_moz(AST_DestructuredArray,function To_Moz_ArrayPattern(M){var elements=M.elements.map(to_moz);if(M.rest)elements.push({type:"RestElement",argument:to_moz(M.rest)});return {type:"ArrayPattern",elements:elements};});def_to_moz(AST_DestructuredKeyVal,function To_Moz_Property(M){var computed=M.key instanceof AST_Node;var key=computed?to_moz(M.key):{type:"Literal",value:M.key};return {type:"Property",kind:"init",computed:computed,method:false,shorthand:false,key:key,value:to_moz(M.value)};});def_to_moz(AST_DestructuredObject,function To_Moz_ObjectPattern(M){var props=M.properties.map(to_moz);if(M.rest)props.push({type:"RestElement",argument:to_moz(M.rest)});return {type:"ObjectPattern",properties:props};});def_to_moz(AST_ObjectProperty,function To_Moz_Property(M){var computed=M.key instanceof AST_Node;var key=computed?to_moz(M.key):{type:"Literal",value:M.key};var kind;if(M instanceof AST_ObjectKeyVal){kind="init";}else if(M instanceof AST_ObjectGetter){kind="get";}else if(M instanceof AST_ObjectSetter){kind="set";}return {type:"Property",kind:kind,computed:computed,method:M instanceof AST_ObjectMethod,shorthand:false,key:key,value:to_moz(M.value)};});def_to_moz(AST_Symbol,function To_Moz_Identifier(M){var def=M.definition();return {type:"Identifier",name:def&&def.mangled_name||M.name};});def_to_moz(AST_Super,function To_Moz_Super(){return {type:"Super"};});def_to_moz(AST_This,function To_Moz_ThisExpression(){return {type:"ThisExpression"};});def_to_moz(AST_NewTarget,function To_Moz_MetaProperty(){return {type:"MetaProperty",meta:{type:"Identifier",name:"new"},property:{type:"Identifier",name:"target"}};});def_to_moz(AST_RegExp,function To_Moz_RegExpLiteral(M){var flags=M.value.toString().match(/\/([gimuy]*)$/)[1];var value="/"+M.value.raw_source+"/"+flags;return {type:"Literal",value:value,raw:value,regex:{pattern:M.value.raw_source,flags:flags}};});def_to_moz(AST_BigInt,function To_Moz_BigInt(M){var value=M.value;return {type:"Literal",bigint:value,raw:value+"n"};});function To_Moz_Literal(M){var value=M.value;if(typeof value==="number"&&(value<0||value===0&&1/value<0)){return {type:"UnaryExpression",operator:"-",prefix:true,argument:{type:"Literal",value:-value,raw:M.start.raw}};}return {type:"Literal",value:value,raw:M.start.raw};}def_to_moz(AST_Boolean,To_Moz_Literal);def_to_moz(AST_Constant,To_Moz_Literal);def_to_moz(AST_Null,To_Moz_Literal);def_to_moz(AST_Atom,function To_Moz_Atom(M){return {type:"Identifier",name:String(M.value)};});def_to_moz(AST_Template,function To_Moz_TemplateLiteral_TaggedTemplateExpression(M){var last=M.strings.length-1;var tmpl={type:"TemplateLiteral",expressions:M.expressions.map(to_moz),quasis:M.strings.map(function(str,index){return {type:"TemplateElement",tail:index==last,value:{raw:str}};})};if(!M.tag)return tmpl;return {type:"TaggedTemplateExpression",tag:to_moz(M.tag),quasi:tmpl};});AST_Block.DEFMETHOD("to_mozilla_ast",AST_BlockStatement.prototype.to_mozilla_ast);AST_Hole.DEFMETHOD("to_mozilla_ast",return_null);AST_Node.DEFMETHOD("to_mozilla_ast",function(){throw new Error("Cannot convert AST_"+this.TYPE);});/* -----[ tools ]----- */function normalize_directives(body){for(var i=0;i<body.length;i++){var stat=body[i];if(!(stat instanceof AST_SimpleStatement))break;var node=stat.body;if(!(node instanceof AST_String))break;if(stat.start.pos!==node.start.pos)break;body[i]=new AST_Directive(node);}return body;}function raw_token(moznode){if(moznode.type=="Literal"){return moznode.raw!=null?moznode.raw:moznode.value+"";}}function my_start_token(moznode){var loc=moznode.loc,start=loc&&loc.start;var range=moznode.range;return new AST_Token({file:loc&&loc.source,line:start&&start.line,col:start&&start.column,pos:range?range[0]:moznode.start,endline:start&&start.line,endcol:start&&start.column,endpos:range?range[0]:moznode.start,raw:raw_token(moznode)});}function my_end_token(moznode){var loc=moznode.loc,end=loc&&loc.end;var range=moznode.range;return new AST_Token({file:loc&&loc.source,line:end&&end.line,col:end&&end.column,pos:range?range[1]:moznode.end,endline:end&&end.line,endcol:end&&end.column,endpos:range?range[1]:moznode.end,raw:raw_token(moznode)});}function read_name(M){return ""+M[M.type=="Identifier"?"name":"value"];}function map(moztype,mytype,propmap){var moz_to_me=["start: my_start_token(M)","end: my_end_token(M)"];var me_to_moz=["type: "+JSON.stringify(moztype)];if(propmap)propmap.split(/\s*,\s*/).forEach(function(prop){var m=/([a-z0-9$_]+)(=|@|>|%)([a-z0-9$_]+)/i.exec(prop);if(!m)throw new Error("Can't understand property map: "+prop);var moz=m[1],how=m[2],my=m[3];switch(how){case"@":moz_to_me.push(my+": M."+moz+".map(from_moz)");me_to_moz.push(moz+": M."+my+".map(to_moz)");break;case">":moz_to_me.push(my+": from_moz(M."+moz+")");me_to_moz.push(moz+": to_moz(M."+my+")");break;case"=":moz_to_me.push(my+": M."+moz);me_to_moz.push(moz+": M."+my);break;case"%":moz_to_me.push(my+": from_moz(M."+moz+").body");me_to_moz.push(moz+": to_moz_block(M)");break;default:throw new Error("Can't understand operator in propmap: "+prop);}});MOZ_TO_ME[moztype]=new Function("U2","my_start_token","my_end_token","from_moz",["return function From_Moz_"+moztype+"(M) {","    return new U2.AST_"+mytype.TYPE+"({",moz_to_me.join(",\n"),"    });","};"].join("\n"))(exports,my_start_token,my_end_token,from_moz);def_to_moz(mytype,new Function("to_moz","to_moz_block","to_moz_scope",["return function To_Moz_"+moztype+"(M) {","    return {",me_to_moz.join(",\n"),"    };","};"].join("\n"))(to_moz,to_moz_block,to_moz_scope));}var FROM_MOZ_STACK=null;function from_moz(moz){FROM_MOZ_STACK.push(moz);var node=null;if(moz){if(!HOP(MOZ_TO_ME,moz.type))throw new Error("Unsupported type: "+moz.type);node=MOZ_TO_ME[moz.type](moz);}FROM_MOZ_STACK.pop();return node;}function from_moz_alias(moz){return new AST_String({start:my_start_token(moz),value:read_name(moz),end:my_end_token(moz)});}AST_Node.from_mozilla_ast=function(node){var save_stack=FROM_MOZ_STACK;FROM_MOZ_STACK=[];var ast=from_moz(node);FROM_MOZ_STACK=save_stack;ast.walk(new TreeWalker(function(node){if(node instanceof AST_LabelRef){for(var level=0,parent;parent=this.parent(level);level++){if(parent instanceof AST_Scope)break;if(parent instanceof AST_LabeledStatement&&parent.label.name==node.name){node.thedef=parent.label;break;}}if(!node.thedef){var s=node.start;js_error("Undefined label "+node.name,s.file,s.line,s.col,s.pos);}}}));return ast;};function set_moz_loc(mynode,moznode){var start=mynode.start;var end=mynode.end;if(start.pos!=null&&end.endpos!=null){moznode.range=[start.pos,end.endpos];}if(start.line){moznode.loc={start:{line:start.line,column:start.col},end:end.endline?{line:end.endline,column:end.endcol}:null};if(start.file){moznode.loc.source=start.file;}}return moznode;}function def_to_moz(mytype,handler){mytype.DEFMETHOD("to_mozilla_ast",function(){return set_moz_loc(this,handler(this));});}function to_moz(node){return node!=null?node.to_mozilla_ast():null;}function to_moz_alias(alias){return is_identifier_string(alias.value)?set_moz_loc(alias,{type:"Identifier",name:alias.value}):to_moz(alias);}function to_moz_block(node){return {type:"BlockStatement",body:node.body.map(to_moz)};}function to_moz_scope(type,node){var body=node.body.map(to_moz);if(node.body[0]instanceof AST_SimpleStatement&&node.body[0].body instanceof AST_String){body.unshift(to_moz(new AST_EmptyStatement(node.body[0])));}return {type:type,body:body};}})();function get_builtins(){var names=new Dictionary();// constants
["NaN","null","true","false","Infinity","-Infinity","undefined"].forEach(add);// global functions
["encodeURI","encodeURIComponent","escape","eval","decodeURI","decodeURIComponent","isFinite","isNaN","parseFloat","parseInt","unescape"].forEach(add);// global constructors & objects
var global=Function("return this")();["Array","ArrayBuffer","Atomics","BigInt","Boolean","console","DataView","Date","Error","Function","Int8Array","Intl","JSON","Map","Math","Number","Object","Promise","Proxy","Reflect","RegExp","Set","String","Symbol","WebAssembly"].forEach(function(name){add(name);var ctor=global[name];if(!ctor)return;Object.getOwnPropertyNames(ctor).map(add);if(typeof ctor!="function")return;if(ctor.__proto__)Object.getOwnPropertyNames(ctor.__proto__).map(add);if(ctor.prototype)Object.getOwnPropertyNames(ctor.prototype).map(add);try{Object.getOwnPropertyNames(new ctor()).map(add);}catch(e){try{Object.getOwnPropertyNames(ctor()).map(add);}catch(e){}}});return (get_builtins=function(){return names.clone();})();function add(name){names.set(name,true);}}function reserve_quoted_keys(ast,reserved){ast.walk(new TreeWalker(function(node){if(node instanceof AST_ClassProperty||node instanceof AST_DestructuredKeyVal||node instanceof AST_ObjectProperty){if(node.key instanceof AST_Node){addStrings(node.key,add);}else if(node.start&&node.start.quote){add(node.key);}}else if(node instanceof AST_Dot){if(node.quoted)add(node.property);}else if(node instanceof AST_Sub){addStrings(node.property,add);}}));function add(name){push_uniq(reserved,name);}}function addStrings(node,add){if(node instanceof AST_Conditional){addStrings(node.consequent,add);addStrings(node.alternative,add);}else if(node instanceof AST_Sequence){addStrings(node.tail_node(),add);}else if(node instanceof AST_String){add(node.value);}}function mangle_properties(ast,options){options=defaults(options,{builtins:false,cache:null,debug:false,domprops:false,keep_quoted:false,regex:null,reserved:null},true);var reserved=options.builtins?new Dictionary():get_builtins();if(!options.domprops&&typeof domprops!=="undefined")domprops.forEach(function(name){reserved.set(name,true);});if(Array.isArray(options.reserved))options.reserved.forEach(function(name){reserved.set(name,true);});var cname=-1;var cache;if(options.cache){cache=options.cache.props;cache.each(function(name){reserved.set(name,true);});}else {cache=new Dictionary();}var regex=options.regex;// note debug is either false (disabled), or a string of the debug suffix to use (enabled).
// note debug may be enabled as an empty string, which is falsy. Also treat passing 'true'
// the same as passing an empty string.
var debug=options.debug!==false;var debug_suffix;if(debug)debug_suffix=options.debug===true?"":options.debug;var names_to_mangle=new Dictionary();var unmangleable=reserved.clone();// step 1: find candidates to mangle
ast.walk(new TreeWalker(function(node){if(node.TYPE=="Call"){var exp=node.expression;if(exp instanceof AST_Dot)switch(exp.property){case"defineProperty":case"getOwnPropertyDescriptor":if(node.args.length<2)break;exp=exp.expression;if(!(exp instanceof AST_SymbolRef))break;if(exp.name!="Object")break;if(!exp.definition().undeclared)break;addStrings(node.args[1],add);break;case"hasOwnProperty":if(node.args.length<1)break;addStrings(node.args[0],add);break;}}else if(node instanceof AST_ClassProperty||node instanceof AST_DestructuredKeyVal||node instanceof AST_ObjectProperty){if(node.key instanceof AST_Node){addStrings(node.key,add);}else {add(node.key);}}else if(node instanceof AST_Dot){if(is_lhs(node,this.parent()))add(node.property);}else if(node instanceof AST_Sub){if(is_lhs(node,this.parent()))addStrings(node.property,add);}}));// step 2: renaming properties
ast.walk(new TreeWalker(function(node){if(node instanceof AST_Binary){if(node.operator=="in")mangleStrings(node.left);}else if(node.TYPE=="Call"){var exp=node.expression;if(exp instanceof AST_Dot)switch(exp.property){case"defineProperty":case"getOwnPropertyDescriptor":if(node.args.length<2)break;exp=exp.expression;if(!(exp instanceof AST_SymbolRef))break;if(exp.name!="Object")break;if(!exp.definition().undeclared)break;mangleStrings(node.args[1]);break;case"hasOwnProperty":if(node.args.length<1)break;mangleStrings(node.args[0]);break;}}else if(node instanceof AST_ClassProperty||node instanceof AST_DestructuredKeyVal||node instanceof AST_ObjectProperty){if(node.key instanceof AST_Node){mangleStrings(node.key);}else {node.key=mangle(node.key);}}else if(node instanceof AST_Dot){node.property=mangle(node.property);}else if(node instanceof AST_Sub){if(!options.keep_quoted)mangleStrings(node.property);}}));// only function declarations after this line
function can_mangle(name){if(unmangleable.has(name))return false;if(/^-?[0-9]+(\.[0-9]+)?(e[+-][0-9]+)?$/.test(name))return false;return true;}function should_mangle(name){if(reserved.has(name)){AST_Node.info("Preserving reserved property {this}",name);return false;}if(regex&&!regex.test(name)){AST_Node.info("Preserving excluded property {this}",name);return false;}return cache.has(name)||names_to_mangle.has(name);}function add(name){if(can_mangle(name))names_to_mangle.set(name,true);if(!should_mangle(name))unmangleable.set(name,true);}function mangle(name){if(!should_mangle(name))return name;var mangled=cache.get(name);if(!mangled){if(debug){// debug mode: use a prefix and suffix to preserve readability, e.g. o.foo ---> o._$foo$NNN_.
var debug_mangled="_$"+name+"$"+debug_suffix+"_";if(can_mangle(debug_mangled))mangled=debug_mangled;}// either debug mode is off, or it is on and we could not use the mangled name
if(!mangled)do{mangled=base54(++cname);}while(!can_mangle(mangled));if(/^#/.test(name))mangled="#"+mangled;cache.set(name,mangled);}AST_Node.info("Mapping property {name} to {mangled}",{mangled:mangled,name:name});return mangled;}function mangleStrings(node){if(node instanceof AST_Sequence){mangleStrings(node.tail_node());}else if(node instanceof AST_String){node.value=mangle(node.value);}else if(node instanceof AST_Conditional){mangleStrings(node.consequent);mangleStrings(node.alternative);}}}var to_ascii,to_base64;if(typeof Buffer=="undefined"){to_ascii=atob;to_base64=btoa;}else if(typeof Buffer.alloc=="undefined"){to_ascii=function(b64){return new Buffer(b64,"base64").toString();};to_base64=function(str){return new Buffer(str).toString("base64");};}else {to_ascii=function(b64){return Buffer.from(b64,"base64").toString();};to_base64=function(str){return Buffer.from(str).toString("base64");};}function read_source_map(name,toplevel){var comments=toplevel.end.comments_after;for(var i=comments.length;--i>=0;){var comment=comments[i];if(comment.type!="comment1")break;var match=/^# ([^\s=]+)=(\S+)\s*$/.exec(comment.value);if(!match)break;if(match[1]=="sourceMappingURL"){match=/^data:application\/json(;.*?)?;base64,([^,]+)$/.exec(match[2]);if(!match)break;return to_ascii(match[2]);}}AST_Node.warn("inline source map not found: {name}",{name:name});}function parse_source_map(content){try{return JSON.parse(content);}catch(ex){throw new Error("invalid input source map: "+content);}}function set_shorthand(name,options,keys){keys.forEach(function(key){if(options[key]){var defs={};defs[name]=options[name];options[key]=defaults(options[key],defs);}});}function init_cache(cache){if(!cache)return;if(!("props"in cache)){cache.props=new Dictionary();}else if(!(cache.props instanceof Dictionary)){cache.props=Dictionary.fromObject(cache.props);}}function to_json(cache){return {props:cache.props.toObject()};}function minify(files,options){try{options=defaults(options,{annotations:undefined,compress:{},enclose:false,expression:false,ie:false,ie8:false,keep_fargs:false,keep_fnames:false,mangle:{},module:undefined,nameCache:null,output:{},parse:{},rename:undefined,sourceMap:false,timings:false,toplevel:options&&!options["expression"]&&options["module"]?true:undefined,v8:false,validate:false,warnings:false,webkit:false,wrap:false},true);if(options.validate)AST_Node.enable_validation();var timings=options.timings&&{start:Date.now()};if(options.annotations!==undefined)set_shorthand("annotations",options,["compress","output"]);if(options.expression)set_shorthand("expression",options,["compress","parse"]);if(options.ie8)options.ie=options.ie||options.ie8;if(options.ie)set_shorthand("ie",options,["compress","mangle","output","rename"]);if(options.keep_fargs)set_shorthand("keep_fargs",options,["compress","mangle","rename"]);if(options.keep_fnames)set_shorthand("keep_fnames",options,["compress","mangle","rename"]);if(options.module===undefined&&!options.ie)options.module=true;if(options.module)set_shorthand("module",options,["compress","output","parse"]);if(options.toplevel!==undefined)set_shorthand("toplevel",options,["compress","mangle","rename"]);if(options.v8)set_shorthand("v8",options,["mangle","output","rename"]);if(options.webkit)set_shorthand("webkit",options,["compress","mangle","output","rename"]);var quoted_props;if(options.mangle){options.mangle=defaults(options.mangle,{cache:options.nameCache&&(options.nameCache.vars||{}),eval:false,ie:false,keep_fargs:false,keep_fnames:false,properties:false,reserved:[],toplevel:false,v8:false,webkit:false},true);if(options.mangle.properties){if(typeof options.mangle.properties!="object"){options.mangle.properties={};}if(options.mangle.properties.keep_quoted){quoted_props=options.mangle.properties.reserved;if(!Array.isArray(quoted_props))quoted_props=[];options.mangle.properties.reserved=quoted_props;}if(options.nameCache&&!("cache"in options.mangle.properties)){options.mangle.properties.cache=options.nameCache.props||{};}}init_cache(options.mangle.cache);init_cache(options.mangle.properties.cache);}if(options.rename===undefined)options.rename=options.compress&&options.mangle;if(options.sourceMap){options.sourceMap=defaults(options.sourceMap,{content:null,filename:null,includeSources:false,names:true,root:null,url:null},true);}var warnings=[];if(options.warnings)AST_Node.log_function(function(warning){warnings.push(warning);},options.warnings=="verbose");if(timings)timings.parse=Date.now();var toplevel;options.parse=options.parse||{};if(files instanceof AST_Node){toplevel=files;}else {if(typeof files=="string")files=[files];options.parse.toplevel=null;var source_map_content=options.sourceMap&&options.sourceMap.content;if(typeof source_map_content=="string"&&source_map_content!="inline"){source_map_content=parse_source_map(source_map_content);}if(source_map_content)options.sourceMap.orig=Object.create(null);for(var name in files)if(HOP(files,name)){options.parse.filename=name;options.parse.toplevel=toplevel=parse(files[name],options.parse);if(source_map_content=="inline"){var inlined_content=read_source_map(name,toplevel);if(inlined_content)options.sourceMap.orig[name]=parse_source_map(inlined_content);}else if(source_map_content){options.sourceMap.orig[name]=source_map_content;}}}if(options.parse.expression)toplevel=toplevel.wrap_expression();if(quoted_props)reserve_quoted_keys(toplevel,quoted_props);["enclose","wrap"].forEach(function(action){var option=options[action];if(!option)return;var orig=toplevel.print_to_string().slice(0,-1);toplevel=toplevel[action](option);files[toplevel.start.file]=toplevel.print_to_string().replace(orig,"");});if(options.validate)toplevel.validate_ast();if(timings)timings.rename=Date.now();if(options.rename){toplevel.figure_out_scope(options.rename);toplevel.expand_names(options.rename);}if(timings)timings.compress=Date.now();if(options.compress){toplevel=new Compressor(options.compress).compress(toplevel);if(options.validate)toplevel.validate_ast();}if(timings)timings.scope=Date.now();if(options.mangle)toplevel.figure_out_scope(options.mangle);if(timings)timings.mangle=Date.now();if(options.mangle){toplevel.compute_char_frequency(options.mangle);toplevel.mangle_names(options.mangle);}if(timings)timings.properties=Date.now();if(quoted_props)reserve_quoted_keys(toplevel,quoted_props);if(options.mangle&&options.mangle.properties)mangle_properties(toplevel,options.mangle.properties);if(options.parse.expression)toplevel=toplevel.unwrap_expression();if(timings)timings.output=Date.now();var result={};var output=defaults(options.output,{ast:false,code:true});if(output.ast)result.ast=toplevel;if(output.code){if(options.sourceMap){output.source_map=SourceMap(options.sourceMap);if(options.sourceMap.includeSources){if(files instanceof AST_Toplevel){throw new Error("original source content unavailable");}else for(var name in files)if(HOP(files,name)){output.source_map.setSourceContent(name,files[name]);}}}delete output.ast;delete output.code;var stream=OutputStream(output);toplevel.print(stream);result.code=stream.get();if(options.sourceMap){result.map=output.source_map.toString();var url=options.sourceMap.url;if(url){result.code=result.code.replace(/\n\/\/# sourceMappingURL=\S+\s*$/,"");if(url=="inline"){result.code+="\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,"+to_base64(result.map);}else {result.code+="\n//# sourceMappingURL="+url;}}}}if(options.nameCache&&options.mangle){if(options.mangle.cache)options.nameCache.vars=to_json(options.mangle.cache);if(options.mangle.properties&&options.mangle.properties.cache){options.nameCache.props=to_json(options.mangle.properties.cache);}}if(timings){timings.end=Date.now();result.timings={parse:1e-3*(timings.rename-timings.parse),rename:1e-3*(timings.compress-timings.rename),compress:1e-3*(timings.scope-timings.compress),scope:1e-3*(timings.mangle-timings.scope),mangle:1e-3*(timings.properties-timings.mangle),properties:1e-3*(timings.output-timings.properties),output:1e-3*(timings.end-timings.output),total:1e-3*(timings.end-timings.start)};}if(warnings.length){result.warnings=warnings;}return result;}catch(ex){return {error:ex};}finally{AST_Node.log_function();AST_Node.disable_validation();}}exports["Dictionary"]=Dictionary;exports["is_statement"]=is_statement;exports["List"]=List;exports["minify"]=minify;exports["parse"]=parse;exports["push_uniq"]=push_uniq;exports["TreeTransformer"]=TreeTransformer;exports["TreeWalker"]=TreeWalker;function to_comment(value){if(typeof value!="string")value=JSON.stringify(value,function(key,value){return typeof value=="function"?"<[ "+value+" ]>":value;},2);return "// "+value.replace(/\n/g,"\n// ");}if(+process.env["UGLIFY_BUG_REPORT"])exports.minify=function(files,options){if(typeof options=="undefined")options="<<undefined>>";var code=["// UGLIFY_BUG_REPORT",to_comment(options)];if(typeof files=="string"){code.push("");code.push("//-------------------------------------------------------------");code.push("// INPUT CODE",files);}else for(var name in files){code.push("");code.push("//-------------------------------------------------------------");code.push(to_comment(name),files[name]);}if(options.sourceMap&&options.sourceMap.url){code.push("");code.push("//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiJ9");}var result={code:code.join("\n")};if(options.sourceMap)result.map='{"version":3,"sources":[],"names":[],"mappings":""}';return result;};function describe_ast(){var out=OutputStream({beautify:true});doitem(AST_Node);return out.get()+"\n";function doitem(ctor){out.print("AST_"+ctor.TYPE);var props=ctor.SELF_PROPS.filter(function(prop){return !/^\$/.test(prop);});if(props.length>0){out.space();out.with_parens(function(){props.forEach(function(prop,i){if(i)out.space();out.print(prop);});});}if(ctor.documentation){out.space();out.print_string(ctor.documentation);}if(ctor.SUBCLASSES.length>0){out.space();out.with_block(function(){ctor.SUBCLASSES.sort(function(a,b){return a.TYPE<b.TYPE?-1:1;}).forEach(function(ctor,i){out.indent();doitem(ctor);out.newline();});});}}}function infer_options(options){var result=exports.minify("",options);return result.error&&result.error.defs;}exports.describe_ast=describe_ast;exports.default_options=function(component){if(component){var options={module:false};options[component]={0:0};return infer_options(options);}var defs=infer_options({0:0});Object.keys(defs).forEach(function(component){var options={module:false};options[component]={0:0};if(options=infer_options(options)){defs[component]=options;}});return defs;};})(node1);return node1;}

var hasRequiredHtmlminifier;
function requireHtmlminifier() {
  if (hasRequiredHtmlminifier) return htmlminifier;
  hasRequiredHtmlminifier = 1;
  var CleanCSS = requireCleanCss();
  var decode = requireHe().decode;
  var HTMLParser = requireHtmlparser().HTMLParser;
  var RelateUrl = requireLib$2();
  var TokenChain = requireTokenchain();
  var UglifyJS = requireNode1();
  var utils = requireUtils$3();
  function trimWhitespace(str) {
    return str && str.replace(/^[ \n\r\t\f]+/, '').replace(/[ \n\r\t\f]+$/, '');
  }
  function collapseWhitespaceAll(str) {
    // Non-breaking space is specifically handled inside the replacer function here:
    return str && str.replace(/[ \n\r\t\f\xA0]+/g, function (spaces) {
      return spaces === '\t' ? '\t' : spaces.replace(/(^|\xA0+)[^\xA0]+/g, '$1 ');
    });
  }
  function collapseWhitespace(str, options, trimLeft, trimRight, collapseAll) {
    var lineBreakBefore = '',
      lineBreakAfter = '';
    if (options.preserveLineBreaks) {
      str = str.replace(/^[ \n\r\t\f]*?[\n\r][ \n\r\t\f]*/, function () {
        lineBreakBefore = '\n';
        return '';
      }).replace(/[ \n\r\t\f]*?[\n\r][ \n\r\t\f]*$/, function () {
        lineBreakAfter = '\n';
        return '';
      });
    }
    if (trimLeft) {
      // Non-breaking space is specifically handled inside the replacer function here:
      str = str.replace(/^[ \n\r\t\f\xA0]+/, function (spaces) {
        var conservative = !lineBreakBefore && options.conservativeCollapse;
        if (conservative && spaces === '\t') {
          return '\t';
        }
        return spaces.replace(/^[^\xA0]+/, '').replace(/(\xA0+)[^\xA0]+/g, '$1 ') || (conservative ? ' ' : '');
      });
    }
    if (trimRight) {
      // Non-breaking space is specifically handled inside the replacer function here:
      str = str.replace(/[ \n\r\t\f\xA0]+$/, function (spaces) {
        var conservative = !lineBreakAfter && options.conservativeCollapse;
        if (conservative && spaces === '\t') {
          return '\t';
        }
        return spaces.replace(/[^\xA0]+(\xA0+)/g, ' $1').replace(/[^\xA0]+$/, '') || (conservative ? ' ' : '');
      });
    }
    if (collapseAll) {
      // strip non space whitespace then compress spaces to one
      str = collapseWhitespaceAll(str);
    }
    return lineBreakBefore + str + lineBreakAfter;
  }
  var createMapFromString = utils.createMapFromString;
  // non-empty tags that will maintain whitespace around them
  var inlineTags = createMapFromString('a,abbr,acronym,b,bdi,bdo,big,button,cite,code,del,dfn,em,font,i,ins,kbd,label,mark,math,nobr,object,q,rp,rt,rtc,ruby,s,samp,select,small,span,strike,strong,sub,sup,svg,textarea,time,tt,u,var');
  // non-empty tags that will maintain whitespace within them
  var inlineTextTags = createMapFromString('a,abbr,acronym,b,big,del,em,font,i,ins,kbd,mark,nobr,rp,s,samp,small,span,strike,strong,sub,sup,time,tt,u,var');
  // self-closing tags that will maintain whitespace around them
  var selfClosingInlineTags = createMapFromString('comment,img,input,wbr');
  function collapseWhitespaceSmart(str, prevTag, nextTag, options) {
    var trimLeft = prevTag && !selfClosingInlineTags(prevTag);
    if (trimLeft && !options.collapseInlineTagWhitespace) {
      trimLeft = prevTag.charAt(0) === '/' ? !inlineTags(prevTag.slice(1)) : !inlineTextTags(prevTag);
    }
    var trimRight = nextTag && !selfClosingInlineTags(nextTag);
    if (trimRight && !options.collapseInlineTagWhitespace) {
      trimRight = nextTag.charAt(0) === '/' ? !inlineTextTags(nextTag.slice(1)) : !inlineTags(nextTag);
    }
    return collapseWhitespace(str, options, trimLeft, trimRight, prevTag && nextTag);
  }
  function isConditionalComment(text) {
    return /^\[if\s[^\]]+]|\[endif]$/.test(text);
  }
  function isIgnoredComment(text, options) {
    for (var i = 0, len = options.ignoreCustomComments.length; i < len; i++) {
      if (options.ignoreCustomComments[i].test(text)) {
        return true;
      }
    }
    return false;
  }
  function isEventAttribute(attrName, options) {
    var patterns = options.customEventAttributes;
    if (patterns) {
      for (var i = patterns.length; i--;) {
        if (patterns[i].test(attrName)) {
          return true;
        }
      }
      return false;
    }
    return /^on[a-z]{3,}$/.test(attrName);
  }
  function canRemoveAttributeQuotes(value) {
    // https://mathiasbynens.be/notes/unquoted-attribute-values
    return /^[^ \t\n\f\r"'`=<>]+$/.test(value);
  }
  function attributesInclude(attributes, attribute) {
    for (var i = attributes.length; i--;) {
      if (attributes[i].name.toLowerCase() === attribute) {
        return true;
      }
    }
    return false;
  }
  function isAttributeRedundant(tag, attrName, attrValue, attrs) {
    attrValue = attrValue ? trimWhitespace(attrValue.toLowerCase()) : '';
    return tag === 'script' && attrName === 'language' && attrValue === 'javascript' || tag === 'form' && attrName === 'method' && attrValue === 'get' || tag === 'input' && attrName === 'type' && attrValue === 'text' || tag === 'script' && attrName === 'charset' && !attributesInclude(attrs, 'src') || tag === 'a' && attrName === 'name' && attributesInclude(attrs, 'id') || tag === 'area' && attrName === 'shape' && attrValue === 'rect';
  }

  // https://mathiasbynens.be/demo/javascript-mime-type
  // https://developer.mozilla.org/en/docs/Web/HTML/Element/script#attr-type
  var executableScriptsMimetypes = utils.createMap(['text/javascript', 'text/ecmascript', 'text/jscript', 'application/javascript', 'application/x-javascript', 'application/ecmascript']);
  function isScriptTypeAttribute(attrValue) {
    attrValue = trimWhitespace(attrValue.split(/;/, 2)[0]).toLowerCase();
    return attrValue === '' || executableScriptsMimetypes(attrValue);
  }
  function isExecutableScript(tag, attrs) {
    if (tag !== 'script') {
      return false;
    }
    for (var i = 0, len = attrs.length; i < len; i++) {
      var attrName = attrs[i].name.toLowerCase();
      if (attrName === 'type') {
        return isScriptTypeAttribute(attrs[i].value);
      }
    }
    return true;
  }
  function isStyleLinkTypeAttribute(attrValue) {
    attrValue = trimWhitespace(attrValue).toLowerCase();
    return attrValue === '' || attrValue === 'text/css';
  }
  function isStyleSheet(tag, attrs) {
    if (tag !== 'style') {
      return false;
    }
    for (var i = 0, len = attrs.length; i < len; i++) {
      var attrName = attrs[i].name.toLowerCase();
      if (attrName === 'type') {
        return isStyleLinkTypeAttribute(attrs[i].value);
      }
    }
    return true;
  }
  var isSimpleBoolean = createMapFromString('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible');
  var isBooleanValue = createMapFromString('true,false');
  function isBooleanAttribute(attrName, attrValue) {
    return isSimpleBoolean(attrName) || attrName === 'draggable' && !isBooleanValue(attrValue);
  }
  function isUriTypeAttribute(attrName, tag) {
    return /^(?:a|area|link|base)$/.test(tag) && attrName === 'href' || tag === 'img' && /^(?:src|longdesc|usemap)$/.test(attrName) || tag === 'object' && /^(?:classid|codebase|data|usemap)$/.test(attrName) || tag === 'q' && attrName === 'cite' || tag === 'blockquote' && attrName === 'cite' || (tag === 'ins' || tag === 'del') && attrName === 'cite' || tag === 'form' && attrName === 'action' || tag === 'input' && (attrName === 'src' || attrName === 'usemap') || tag === 'head' && attrName === 'profile' || tag === 'script' && (attrName === 'src' || attrName === 'for');
  }
  function isNumberTypeAttribute(attrName, tag) {
    return /^(?:a|area|object|button)$/.test(tag) && attrName === 'tabindex' || tag === 'input' && (attrName === 'maxlength' || attrName === 'tabindex') || tag === 'select' && (attrName === 'size' || attrName === 'tabindex') || tag === 'textarea' && /^(?:rows|cols|tabindex)$/.test(attrName) || tag === 'colgroup' && attrName === 'span' || tag === 'col' && attrName === 'span' || (tag === 'th' || tag === 'td') && (attrName === 'rowspan' || attrName === 'colspan');
  }
  function isLinkType(tag, attrs, value) {
    if (tag !== 'link') {
      return false;
    }
    for (var i = 0, len = attrs.length; i < len; i++) {
      if (attrs[i].name === 'rel' && attrs[i].value === value) {
        return true;
      }
    }
  }
  function isMediaQuery(tag, attrs, attrName) {
    return attrName === 'media' && (isLinkType(tag, attrs, 'stylesheet') || isStyleSheet(tag, attrs));
  }
  var srcsetTags = createMapFromString('img,source');
  function isSrcset(attrName, tag) {
    return attrName === 'srcset' && srcsetTags(tag);
  }
  function cleanAttributeValue(tag, attrName, attrValue, options, attrs) {
    if (isEventAttribute(attrName, options)) {
      attrValue = trimWhitespace(attrValue).replace(/^javascript:\s*/i, '');
      return options.minifyJS(attrValue, true);
    } else if (attrName === 'class') {
      attrValue = trimWhitespace(attrValue);
      if (options.sortClassName) {
        attrValue = options.sortClassName(attrValue);
      } else {
        attrValue = collapseWhitespaceAll(attrValue);
      }
      return attrValue;
    } else if (isUriTypeAttribute(attrName, tag)) {
      attrValue = trimWhitespace(attrValue);
      return isLinkType(tag, attrs, 'canonical') ? attrValue : options.minifyURLs(attrValue);
    } else if (isNumberTypeAttribute(attrName, tag)) {
      return trimWhitespace(attrValue);
    } else if (attrName === 'style') {
      attrValue = trimWhitespace(attrValue);
      if (attrValue) {
        if (/;$/.test(attrValue) && !/&#?[0-9a-zA-Z]+;$/.test(attrValue)) {
          attrValue = attrValue.replace(/\s*;$/, ';');
        }
        attrValue = options.minifyCSS(attrValue, 'inline');
      }
      return attrValue;
    } else if (isSrcset(attrName, tag)) {
      // https://html.spec.whatwg.org/multipage/embedded-content.html#attr-img-srcset
      attrValue = trimWhitespace(attrValue).split(/\s+,\s*|\s*,\s+/).map(function (candidate) {
        var url = candidate;
        var descriptor = '';
        var match = candidate.match(/\s+([1-9][0-9]*w|[0-9]+(?:\.[0-9]+)?x)$/);
        if (match) {
          url = url.slice(0, -match[0].length);
          var num = +match[1].slice(0, -1);
          var suffix = match[1].slice(-1);
          if (num !== 1 || suffix !== 'x') {
            descriptor = ' ' + num + suffix;
          }
        }
        return options.minifyURLs(url) + descriptor;
      }).join(', ');
    } else if (isMetaViewport(tag, attrs) && attrName === 'content') {
      attrValue = attrValue.replace(/\s+/g, '').replace(/[0-9]+\.[0-9]+/g, function (numString) {
        // "0.90000" -> "0.9"
        // "1.0" -> "1"
        // "1.0001" -> "1.0001" (unchanged)
        return (+numString).toString();
      });
    } else if (isContentSecurityPolicy(tag, attrs) && attrName.toLowerCase() === 'content') {
      return collapseWhitespaceAll(attrValue);
    } else if (options.customAttrCollapse && options.customAttrCollapse.test(attrName)) {
      attrValue = attrValue.replace(/\n+|\r+|\s{2,}/g, '');
    } else if (tag === 'script' && attrName === 'type') {
      attrValue = trimWhitespace(attrValue.replace(/\s*;\s*/g, ';'));
    } else if (isMediaQuery(tag, attrs, attrName)) {
      attrValue = trimWhitespace(attrValue);
      return options.minifyCSS(attrValue, 'media');
    }
    return attrValue;
  }
  function isMetaViewport(tag, attrs) {
    if (tag !== 'meta') {
      return false;
    }
    for (var i = 0, len = attrs.length; i < len; i++) {
      if (attrs[i].name === 'name' && attrs[i].value === 'viewport') {
        return true;
      }
    }
  }
  function isContentSecurityPolicy(tag, attrs) {
    if (tag !== 'meta') {
      return false;
    }
    for (var i = 0, len = attrs.length; i < len; i++) {
      if (attrs[i].name.toLowerCase() === 'http-equiv' && attrs[i].value.toLowerCase() === 'content-security-policy') {
        return true;
      }
    }
  }
  function ignoreCSS(id) {
    return '/* clean-css ignore:start */' + id + '/* clean-css ignore:end */';
  }

  // Wrap CSS declarations for CleanCSS > 3.x
  // See https://github.com/jakubpawlowicz/clean-css/issues/418
  function wrapCSS(text, type) {
    switch (type) {
      case 'inline':
        return '*{' + text + '}';
      case 'media':
        return '@media ' + text + '{a{top:0}}';
      default:
        return text;
    }
  }
  function unwrapCSS(text, type) {
    var matches;
    switch (type) {
      case 'inline':
        matches = text.match(/^\*\{([\s\S]*)\}$/);
        break;
      case 'media':
        matches = text.match(/^@media ([\s\S]*?)\s*{[\s\S]*}$/);
        break;
    }
    return matches ? matches[1] : text;
  }
  function cleanConditionalComment(comment, options) {
    return options.processConditionalComments ? comment.replace(/^(\[if\s[^\]]+]>)([\s\S]*?)(<!\[endif])$/, function (match, prefix, text, suffix) {
      return prefix + minify(text, options, true) + suffix;
    }) : comment;
  }
  function processScript(text, options, currentAttrs) {
    for (var i = 0, len = currentAttrs.length; i < len; i++) {
      if (currentAttrs[i].name.toLowerCase() === 'type' && options.processScripts.indexOf(currentAttrs[i].value) > -1) {
        return minify(text, options);
      }
    }
    return text;
  }

  // Tag omission rules from https://html.spec.whatwg.org/multipage/syntax.html#optional-tags
  // with the following deviations:
  // - retain <body> if followed by <noscript>
  // - </rb>, </rt>, </rtc>, </rp> & </tfoot> follow https://www.w3.org/TR/html5/syntax.html#optional-tags
  // - retain all tags which are adjacent to non-standard HTML tags
  var optionalStartTags = createMapFromString('html,head,body,colgroup,tbody');
  var optionalEndTags = createMapFromString('html,head,body,li,dt,dd,p,rb,rt,rtc,rp,optgroup,option,colgroup,caption,thead,tbody,tfoot,tr,td,th');
  var headerTags = createMapFromString('meta,link,script,style,template,noscript');
  var descriptionTags = createMapFromString('dt,dd');
  var pBlockTags = createMapFromString('address,article,aside,blockquote,details,div,dl,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,hgroup,hr,main,menu,nav,ol,p,pre,section,table,ul');
  var pInlineTags = createMapFromString('a,audio,del,ins,map,noscript,video');
  var rubyTags = createMapFromString('rb,rt,rtc,rp');
  var rtcTag = createMapFromString('rb,rtc,rp');
  var optionTag = createMapFromString('option,optgroup');
  var tableContentTags = createMapFromString('tbody,tfoot');
  var tableSectionTags = createMapFromString('thead,tbody,tfoot');
  var cellTags = createMapFromString('td,th');
  var topLevelTags = createMapFromString('html,head,body');
  var compactTags = createMapFromString('html,body');
  var looseTags = createMapFromString('head,colgroup,caption');
  var trailingTags = createMapFromString('dt,thead');
  var htmlTags = createMapFromString('a,abbr,acronym,address,applet,area,article,aside,audio,b,base,basefont,bdi,bdo,bgsound,big,blink,blockquote,body,br,button,canvas,caption,center,cite,code,col,colgroup,command,content,data,datalist,dd,del,details,dfn,dialog,dir,div,dl,dt,element,em,embed,fieldset,figcaption,figure,font,footer,form,frame,frameset,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,i,iframe,image,img,input,ins,isindex,kbd,keygen,label,legend,li,link,listing,main,map,mark,marquee,menu,menuitem,meta,meter,multicol,nav,nobr,noembed,noframes,noscript,object,ol,optgroup,option,output,p,param,picture,plaintext,pre,progress,q,rb,rp,rt,rtc,ruby,s,samp,script,section,select,shadow,small,source,spacer,span,strike,strong,style,sub,summary,sup,table,tbody,td,template,textarea,tfoot,th,thead,time,title,tr,track,tt,u,ul,var,video,wbr,xmp');
  function canRemoveParentTag(optionalStartTag, tag) {
    switch (optionalStartTag) {
      case 'html':
      case 'head':
        return true;
      case 'body':
        return !headerTags(tag);
      case 'colgroup':
        return tag === 'col';
      case 'tbody':
        return tag === 'tr';
    }
    return false;
  }
  function isStartTagMandatory(optionalEndTag, tag) {
    switch (tag) {
      case 'colgroup':
        return optionalEndTag === 'colgroup';
      case 'tbody':
        return tableSectionTags(optionalEndTag);
    }
    return false;
  }
  function canRemovePrecedingTag(optionalEndTag, tag) {
    switch (optionalEndTag) {
      case 'html':
      case 'head':
      case 'body':
      case 'colgroup':
      case 'caption':
        return true;
      case 'li':
      case 'optgroup':
      case 'tr':
        return tag === optionalEndTag;
      case 'dt':
      case 'dd':
        return descriptionTags(tag);
      case 'p':
        return pBlockTags(tag);
      case 'rb':
      case 'rt':
      case 'rp':
        return rubyTags(tag);
      case 'rtc':
        return rtcTag(tag);
      case 'option':
        return optionTag(tag);
      case 'thead':
      case 'tbody':
        return tableContentTags(tag);
      case 'tfoot':
        return tag === 'tbody';
      case 'td':
      case 'th':
        return cellTags(tag);
    }
    return false;
  }
  var reEmptyAttribute = new RegExp('^(?:class|id|style|title|lang|dir|on(?:focus|blur|change|click|dblclick|mouse(' + '?:down|up|over|move|out)|key(?:press|down|up)))$');
  function canDeleteEmptyAttribute(tag, attrName, attrValue, options) {
    var isValueEmpty = !attrValue || /^\s*$/.test(attrValue);
    if (!isValueEmpty) {
      return false;
    }
    if (typeof options.removeEmptyAttributes === 'function') {
      return options.removeEmptyAttributes(attrName, tag);
    }
    return tag === 'input' && attrName === 'value' || reEmptyAttribute.test(attrName);
  }
  function hasAttrName(name, attrs) {
    for (var i = attrs.length - 1; i >= 0; i--) {
      if (attrs[i].name === name) {
        return true;
      }
    }
    return false;
  }
  function canRemoveElement(tag, attrs) {
    switch (tag) {
      case 'textarea':
        return false;
      case 'audio':
      case 'script':
      case 'video':
        if (hasAttrName('src', attrs)) {
          return false;
        }
        break;
      case 'iframe':
        if (hasAttrName('src', attrs) || hasAttrName('srcdoc', attrs)) {
          return false;
        }
        break;
      case 'object':
        if (hasAttrName('data', attrs)) {
          return false;
        }
        break;
      case 'applet':
        if (hasAttrName('code', attrs)) {
          return false;
        }
        break;
    }
    return true;
  }
  function canCollapseWhitespace(tag) {
    return !/^(?:script|style|pre|textarea)$/.test(tag);
  }
  function canTrimWhitespace(tag) {
    return !/^(?:pre|textarea)$/.test(tag);
  }
  function normalizeAttr(attr, attrs, tag, options) {
    var attrName = options.name(attr.name),
      attrValue = attr.value;
    if (options.decodeEntities && attrValue) {
      attrValue = decode(attrValue, {
        isAttributeValue: true
      });
    }
    if (options.removeRedundantAttributes && isAttributeRedundant(tag, attrName, attrValue, attrs) || options.removeScriptTypeAttributes && tag === 'script' && attrName === 'type' && isScriptTypeAttribute(attrValue) || options.removeStyleLinkTypeAttributes && (tag === 'style' || tag === 'link') && attrName === 'type' && isStyleLinkTypeAttribute(attrValue)) {
      return;
    }
    if (attrValue) {
      attrValue = cleanAttributeValue(tag, attrName, attrValue, options, attrs);
    }
    if (options.removeEmptyAttributes && canDeleteEmptyAttribute(tag, attrName, attrValue, options)) {
      return;
    }
    if (options.decodeEntities && attrValue) {
      attrValue = attrValue.replace(/&(#?[0-9a-zA-Z]+;)/g, '&amp;$1');
    }
    return {
      attr: attr,
      name: attrName,
      value: attrValue
    };
  }
  function buildAttr(normalized, hasUnarySlash, options, isLast, uidAttr) {
    var attrName = normalized.name,
      attrValue = normalized.value,
      attr = normalized.attr,
      attrQuote = attr.quote,
      attrFragment,
      emittedAttrValue;
    if (typeof attrValue !== 'undefined' && (!options.removeAttributeQuotes || ~attrValue.indexOf(uidAttr) || !canRemoveAttributeQuotes(attrValue))) {
      if (!options.preventAttributesEscaping) {
        if (typeof options.quoteCharacter === 'undefined') {
          var apos = (attrValue.match(/'/g) || []).length;
          var quot = (attrValue.match(/"/g) || []).length;
          attrQuote = apos < quot ? '\'' : '"';
        } else {
          attrQuote = options.quoteCharacter === '\'' ? '\'' : '"';
        }
        if (attrQuote === '"') {
          attrValue = attrValue.replace(/"/g, '&#34;');
        } else {
          attrValue = attrValue.replace(/'/g, '&#39;');
        }
      }
      emittedAttrValue = attrQuote + attrValue + attrQuote;
      if (!isLast && !options.removeTagWhitespace) {
        emittedAttrValue += ' ';
      }
    }
    // make sure trailing slash is not interpreted as HTML self-closing tag
    else if (isLast && !hasUnarySlash && !/\/$/.test(attrValue)) {
      emittedAttrValue = attrValue;
    } else {
      emittedAttrValue = attrValue + ' ';
    }
    if (typeof attrValue === 'undefined' || options.collapseBooleanAttributes && isBooleanAttribute(attrName.toLowerCase(), attrValue.toLowerCase())) {
      attrFragment = attrName;
      if (!isLast) {
        attrFragment += ' ';
      }
    } else {
      attrFragment = attrName + attr.customAssign + emittedAttrValue;
    }
    return attr.customOpen + attrFragment + attr.customClose;
  }
  function identity(value) {
    return value;
  }
  function processOptions(values) {
    var options = {
      name: function (name) {
        return name.toLowerCase();
      },
      canCollapseWhitespace: canCollapseWhitespace,
      canTrimWhitespace: canTrimWhitespace,
      html5: true,
      ignoreCustomComments: [/^!/],
      ignoreCustomFragments: [/<%[\s\S]*?%>/, /<\?[\s\S]*?\?>/],
      includeAutoGeneratedTags: true,
      log: identity,
      minifyCSS: identity,
      minifyJS: identity,
      minifyURLs: identity
    };
    Object.keys(values).forEach(function (key) {
      var value = values[key];
      if (key === 'caseSensitive') {
        if (value) {
          options.name = identity;
        }
      } else if (key === 'log') {
        if (typeof value === 'function') {
          options.log = value;
        }
      } else if (key === 'minifyCSS' && typeof value !== 'function') {
        if (!value) {
          return;
        }
        if (typeof value !== 'object') {
          value = {};
        }
        options.minifyCSS = function (text, type) {
          text = text.replace(/(url\s*\(\s*)("|'|)(.*?)\2(\s*\))/ig, function (match, prefix, quote, url, suffix) {
            return prefix + quote + options.minifyURLs(url) + quote + suffix;
          });
          var cleanCssOutput = new CleanCSS(value).minify(wrapCSS(text, type));
          if (cleanCssOutput.errors.length > 0) {
            cleanCssOutput.errors.forEach(options.log);
            return text;
          }
          return unwrapCSS(cleanCssOutput.styles, type);
        };
      } else if (key === 'minifyJS' && typeof value !== 'function') {
        if (!value) {
          return;
        }
        if (typeof value !== 'object') {
          value = {};
        }
        (value.parse || (value.parse = {})).bare_returns = false;
        options.minifyJS = function (text, inline) {
          var start = text.match(/^\s*<!--.*/);
          var code = start ? text.slice(start[0].length).replace(/\n\s*-->\s*$/, '') : text;
          value.parse.bare_returns = inline;
          var result = UglifyJS.minify(code, value);
          if (result.error) {
            options.log(result.error);
            return text;
          }
          return result.code.replace(/;$/, '');
        };
      } else if (key === 'minifyURLs' && typeof value !== 'function') {
        if (!value) {
          return;
        }
        if (typeof value === 'string') {
          value = {
            site: value
          };
        } else if (typeof value !== 'object') {
          value = {};
        }
        options.minifyURLs = function (text) {
          try {
            return RelateUrl.relate(text, value);
          } catch (err) {
            options.log(err);
            return text;
          }
        };
      } else {
        options[key] = value;
      }
    });
    return options;
  }
  function uniqueId(value) {
    var id;
    do {
      id = Math.random().toString(36).replace(/^0\.[0-9]*/, '');
    } while (~value.indexOf(id));
    return id;
  }
  var specialContentTags = createMapFromString('script,style');
  function createSortFns(value, options, uidIgnore, uidAttr) {
    var attrChains = options.sortAttributes && Object.create(null);
    var classChain = options.sortClassName && new TokenChain();
    function attrNames(attrs) {
      return attrs.map(function (attr) {
        return options.name(attr.name);
      });
    }
    function shouldSkipUID(token, uid) {
      return !uid || token.indexOf(uid) === -1;
    }
    function shouldSkipUIDs(token) {
      return shouldSkipUID(token, uidIgnore) && shouldSkipUID(token, uidAttr);
    }
    function scan(input) {
      var currentTag, currentType;
      new HTMLParser(input, {
        start: function (tag, attrs) {
          if (attrChains) {
            if (!attrChains[tag]) {
              attrChains[tag] = new TokenChain();
            }
            attrChains[tag].add(attrNames(attrs).filter(shouldSkipUIDs));
          }
          for (var i = 0, len = attrs.length; i < len; i++) {
            var attr = attrs[i];
            if (classChain && attr.value && options.name(attr.name) === 'class') {
              classChain.add(trimWhitespace(attr.value).split(/[ \t\n\f\r]+/).filter(shouldSkipUIDs));
            } else if (options.processScripts && attr.name.toLowerCase() === 'type') {
              currentTag = tag;
              currentType = attr.value;
            }
          }
        },
        end: function () {
          currentTag = '';
        },
        chars: function (text) {
          if (options.processScripts && specialContentTags(currentTag) && options.processScripts.indexOf(currentType) > -1) {
            scan(text);
          }
        }
      });
    }
    var log = options.log;
    options.log = identity;
    options.sortAttributes = false;
    options.sortClassName = false;
    scan(minify(value, options));
    options.log = log;
    if (attrChains) {
      var attrSorters = Object.create(null);
      for (var tag in attrChains) {
        attrSorters[tag] = attrChains[tag].createSorter();
      }
      options.sortAttributes = function (tag, attrs) {
        var sorter = attrSorters[tag];
        if (sorter) {
          var attrMap = Object.create(null);
          var names = attrNames(attrs);
          names.forEach(function (name, index) {
            (attrMap[name] || (attrMap[name] = [])).push(attrs[index]);
          });
          sorter.sort(names).forEach(function (name, index) {
            attrs[index] = attrMap[name].shift();
          });
        }
      };
    }
    if (classChain) {
      var sorter = classChain.createSorter();
      options.sortClassName = function (value) {
        return sorter.sort(value.split(/[ \n\f\r]+/)).join(' ');
      };
    }
  }
  function minify(value, options, partialMarkup) {
    if (options.collapseWhitespace) {
      value = collapseWhitespace(value, options, true, true);
    }
    var buffer = [],
      charsPrevTag,
      currentChars = '',
      hasChars,
      currentTag = '',
      currentAttrs = [],
      stackNoTrimWhitespace = [],
      stackNoCollapseWhitespace = [],
      optionalStartTag = '',
      optionalEndTag = '',
      ignoredMarkupChunks = [],
      ignoredCustomMarkupChunks = [],
      uidIgnore,
      uidAttr,
      uidPattern;

    // temporarily replace ignored chunks with comments,
    // so that we don't have to worry what's there.
    // for all we care there might be
    // completely-horribly-broken-alien-non-html-emoj-cthulhu-filled content
    value = value.replace(/<!-- htmlmin:ignore -->([\s\S]*?)<!-- htmlmin:ignore -->/g, function (match, group1) {
      if (!uidIgnore) {
        uidIgnore = uniqueId(value);
        var pattern = new RegExp('^' + uidIgnore + '([0-9]+)$');
        if (options.ignoreCustomComments) {
          options.ignoreCustomComments = options.ignoreCustomComments.slice();
        } else {
          options.ignoreCustomComments = [];
        }
        options.ignoreCustomComments.push(pattern);
      }
      var token = '<!--' + uidIgnore + ignoredMarkupChunks.length + '-->';
      ignoredMarkupChunks.push(group1);
      return token;
    });
    var customFragments = options.ignoreCustomFragments.map(function (re) {
      return re.source;
    });
    if (customFragments.length) {
      var reCustomIgnore = new RegExp('\\s*(?:' + customFragments.join('|') + ')+\\s*', 'g');
      // temporarily replace custom ignored fragments with unique attributes
      value = value.replace(reCustomIgnore, function (match) {
        if (!uidAttr) {
          uidAttr = uniqueId(value);
          uidPattern = new RegExp('(\\s*)' + uidAttr + '([0-9]+)' + uidAttr + '(\\s*)', 'g');
          if (options.minifyCSS) {
            options.minifyCSS = function (fn) {
              return function (text, type) {
                text = text.replace(uidPattern, function (match, prefix, index) {
                  var chunks = ignoredCustomMarkupChunks[+index];
                  return chunks[1] + uidAttr + index + uidAttr + chunks[2];
                });
                var ids = [];
                new CleanCSS().minify(wrapCSS(text, type)).warnings.forEach(function (warning) {
                  var match = uidPattern.exec(warning);
                  if (match) {
                    var id = uidAttr + match[2] + uidAttr;
                    text = text.replace(id, ignoreCSS(id));
                    ids.push(id);
                  }
                });
                text = fn(text, type);
                ids.forEach(function (id) {
                  text = text.replace(ignoreCSS(id), id);
                });
                return text;
              };
            }(options.minifyCSS);
          }
          if (options.minifyJS) {
            options.minifyJS = function (fn) {
              return function (text, type) {
                return fn(text.replace(uidPattern, function (match, prefix, index) {
                  var chunks = ignoredCustomMarkupChunks[+index];
                  return chunks[1] + uidAttr + index + uidAttr + chunks[2];
                }), type);
              };
            }(options.minifyJS);
          }
        }
        var token = uidAttr + ignoredCustomMarkupChunks.length + uidAttr;
        ignoredCustomMarkupChunks.push(/^(\s*)[\s\S]*?(\s*)$/.exec(match));
        return '\t' + token + '\t';
      });
    }
    if (options.sortAttributes && typeof options.sortAttributes !== 'function' || options.sortClassName && typeof options.sortClassName !== 'function') {
      createSortFns(value, options, uidIgnore, uidAttr);
    }
    function _canCollapseWhitespace(tag, attrs) {
      return options.canCollapseWhitespace(tag, attrs, canCollapseWhitespace);
    }
    function _canTrimWhitespace(tag, attrs) {
      return options.canTrimWhitespace(tag, attrs, canTrimWhitespace);
    }
    function removeStartTag() {
      var index = buffer.length - 1;
      while (index > 0 && !/^<[^/!]/.test(buffer[index])) {
        index--;
      }
      buffer.length = Math.max(0, index);
    }
    function removeEndTag() {
      var index = buffer.length - 1;
      while (index > 0 && !/^<\//.test(buffer[index])) {
        index--;
      }
      buffer.length = Math.max(0, index);
    }

    // look for trailing whitespaces, bypass any inline tags
    function trimTrailingWhitespace(index, nextTag) {
      for (var endTag = null; index >= 0 && _canTrimWhitespace(endTag); index--) {
        var str = buffer[index];
        var match = str.match(/^<\/([\w:-]+)>$/);
        if (match) {
          endTag = match[1];
        } else if (/>$/.test(str) || (buffer[index] = collapseWhitespaceSmart(str, null, nextTag, options))) {
          break;
        }
      }
    }

    // look for trailing whitespaces from previously processed text
    // which may not be trimmed due to a following comment or an empty
    // element which has now been removed
    function squashTrailingWhitespace(nextTag) {
      var charsIndex = buffer.length - 1;
      if (buffer.length > 1) {
        var item = buffer[buffer.length - 1];
        if (/^(?:<!|$)/.test(item) && item.indexOf(uidIgnore) === -1) {
          charsIndex--;
        }
      }
      trimTrailingWhitespace(charsIndex, nextTag);
    }
    new HTMLParser(value, {
      partialMarkup: partialMarkup,
      continueOnParseError: options.continueOnParseError,
      customAttrAssign: options.customAttrAssign,
      customAttrSurround: options.customAttrSurround,
      html5: options.html5,
      start: function (tag, attrs, unary, unarySlash, autoGenerated) {
        if (tag.toLowerCase() === 'svg') {
          options = Object.create(options);
          options.caseSensitive = true;
          options.keepClosingSlash = true;
          options.name = identity;
        }
        tag = options.name(tag);
        currentTag = tag;
        charsPrevTag = tag;
        if (!inlineTextTags(tag)) {
          currentChars = '';
        }
        hasChars = false;
        currentAttrs = attrs;
        var optional = options.removeOptionalTags;
        if (optional) {
          var htmlTag = htmlTags(tag);
          // <html> may be omitted if first thing inside is not comment
          // <head> may be omitted if first thing inside is an element
          // <body> may be omitted if first thing inside is not space, comment, <meta>, <link>, <script>, <style> or <template>
          // <colgroup> may be omitted if first thing inside is <col>
          // <tbody> may be omitted if first thing inside is <tr>
          if (htmlTag && canRemoveParentTag(optionalStartTag, tag)) {
            removeStartTag();
          }
          optionalStartTag = '';
          // end-tag-followed-by-start-tag omission rules
          if (htmlTag && canRemovePrecedingTag(optionalEndTag, tag)) {
            removeEndTag();
            // <colgroup> cannot be omitted if preceding </colgroup> is omitted
            // <tbody> cannot be omitted if preceding </tbody>, </thead> or </tfoot> is omitted
            optional = !isStartTagMandatory(optionalEndTag, tag);
          }
          optionalEndTag = '';
        }

        // set whitespace flags for nested tags (eg. <code> within a <pre>)
        if (options.collapseWhitespace) {
          if (!stackNoTrimWhitespace.length) {
            squashTrailingWhitespace(tag);
          }
          if (!unary) {
            if (!_canTrimWhitespace(tag, attrs) || stackNoTrimWhitespace.length) {
              stackNoTrimWhitespace.push(tag);
            }
            if (!_canCollapseWhitespace(tag, attrs) || stackNoCollapseWhitespace.length) {
              stackNoCollapseWhitespace.push(tag);
            }
          }
        }
        var openTag = '<' + tag;
        var hasUnarySlash = unarySlash && options.keepClosingSlash;
        buffer.push(openTag);
        if (options.sortAttributes) {
          options.sortAttributes(tag, attrs);
        }
        var parts = [];
        for (var i = attrs.length, isLast = true; --i >= 0;) {
          var normalized = normalizeAttr(attrs[i], attrs, tag, options);
          if (normalized) {
            parts.unshift(buildAttr(normalized, hasUnarySlash, options, isLast, uidAttr));
            isLast = false;
          }
        }
        if (parts.length > 0) {
          buffer.push(' ');
          buffer.push.apply(buffer, parts);
        }
        // start tag must never be omitted if it has any attributes
        else if (optional && optionalStartTags(tag)) {
          optionalStartTag = tag;
        }
        buffer.push(buffer.pop() + (hasUnarySlash ? '/' : '') + '>');
        if (autoGenerated && !options.includeAutoGeneratedTags) {
          removeStartTag();
          optionalStartTag = '';
        }
      },
      end: function (tag, attrs, autoGenerated) {
        if (tag.toLowerCase() === 'svg') {
          options = Object.getPrototypeOf(options);
        }
        tag = options.name(tag);

        // check if current tag is in a whitespace stack
        if (options.collapseWhitespace) {
          if (stackNoTrimWhitespace.length) {
            if (tag === stackNoTrimWhitespace[stackNoTrimWhitespace.length - 1]) {
              stackNoTrimWhitespace.pop();
            }
          } else {
            squashTrailingWhitespace('/' + tag);
          }
          if (stackNoCollapseWhitespace.length && tag === stackNoCollapseWhitespace[stackNoCollapseWhitespace.length - 1]) {
            stackNoCollapseWhitespace.pop();
          }
        }
        var isElementEmpty = false;
        if (tag === currentTag) {
          currentTag = '';
          isElementEmpty = !hasChars;
        }
        if (options.removeOptionalTags) {
          // <html>, <head> or <body> may be omitted if the element is empty
          if (isElementEmpty && topLevelTags(optionalStartTag)) {
            removeStartTag();
          }
          optionalStartTag = '';
          // </html> or </body> may be omitted if not followed by comment
          // </head> may be omitted if not followed by space or comment
          // </p> may be omitted if no more content in non-</a> parent
          // except for </dt> or </thead>, end tags may be omitted if no more content in parent element
          if (htmlTags(tag) && optionalEndTag && !trailingTags(optionalEndTag) && (optionalEndTag !== 'p' || !pInlineTags(tag))) {
            removeEndTag();
          }
          optionalEndTag = optionalEndTags(tag) ? tag : '';
        }
        if (options.removeEmptyElements && isElementEmpty && canRemoveElement(tag, attrs)) {
          // remove last "element" from buffer
          removeStartTag();
          optionalStartTag = '';
          optionalEndTag = '';
        } else {
          if (autoGenerated && !options.includeAutoGeneratedTags) {
            optionalEndTag = '';
          } else {
            buffer.push('</' + tag + '>');
          }
          charsPrevTag = '/' + tag;
          if (!inlineTags(tag)) {
            currentChars = '';
          } else if (isElementEmpty) {
            currentChars += '|';
          }
        }
      },
      chars: function (text, prevTag, nextTag) {
        prevTag = prevTag === '' ? 'comment' : prevTag;
        nextTag = nextTag === '' ? 'comment' : nextTag;
        if (options.decodeEntities && text && !specialContentTags(currentTag)) {
          text = decode(text);
        }
        if (options.collapseWhitespace) {
          if (!stackNoTrimWhitespace.length) {
            if (prevTag === 'comment') {
              var prevComment = buffer[buffer.length - 1];
              if (prevComment.indexOf(uidIgnore) === -1) {
                if (!prevComment) {
                  prevTag = charsPrevTag;
                }
                if (buffer.length > 1 && (!prevComment || !options.conservativeCollapse && / $/.test(currentChars))) {
                  var charsIndex = buffer.length - 2;
                  buffer[charsIndex] = buffer[charsIndex].replace(/\s+$/, function (trailingSpaces) {
                    text = trailingSpaces + text;
                    return '';
                  });
                }
              }
            }
            if (prevTag) {
              if (prevTag === '/nobr' || prevTag === 'wbr') {
                if (/^\s/.test(text)) {
                  var tagIndex = buffer.length - 1;
                  while (tagIndex > 0 && buffer[tagIndex].lastIndexOf('<' + prevTag) !== 0) {
                    tagIndex--;
                  }
                  trimTrailingWhitespace(tagIndex - 1, 'br');
                }
              } else if (inlineTextTags(prevTag.charAt(0) === '/' ? prevTag.slice(1) : prevTag)) {
                text = collapseWhitespace(text, options, /(?:^|\s)$/.test(currentChars));
              }
            }
            if (prevTag || nextTag) {
              text = collapseWhitespaceSmart(text, prevTag, nextTag, options);
            } else {
              text = collapseWhitespace(text, options, true, true);
            }
            if (!text && /\s$/.test(currentChars) && prevTag && prevTag.charAt(0) === '/') {
              trimTrailingWhitespace(buffer.length - 1, nextTag);
            }
          }
          if (!stackNoCollapseWhitespace.length && nextTag !== 'html' && !(prevTag && nextTag)) {
            text = collapseWhitespace(text, options, false, false, true);
          }
        }
        if (options.processScripts && specialContentTags(currentTag)) {
          text = processScript(text, options, currentAttrs);
        }
        if (isExecutableScript(currentTag, currentAttrs)) {
          text = options.minifyJS(text);
        }
        if (isStyleSheet(currentTag, currentAttrs)) {
          text = options.minifyCSS(text);
        }
        if (options.removeOptionalTags && text) {
          // <html> may be omitted if first thing inside is not comment
          // <body> may be omitted if first thing inside is not space, comment, <meta>, <link>, <script>, <style> or <template>
          if (optionalStartTag === 'html' || optionalStartTag === 'body' && !/^\s/.test(text)) {
            removeStartTag();
          }
          optionalStartTag = '';
          // </html> or </body> may be omitted if not followed by comment
          // </head>, </colgroup> or </caption> may be omitted if not followed by space or comment
          if (compactTags(optionalEndTag) || looseTags(optionalEndTag) && !/^\s/.test(text)) {
            removeEndTag();
          }
          optionalEndTag = '';
        }
        charsPrevTag = /^\s*$/.test(text) ? prevTag : 'comment';
        if (options.decodeEntities && text && !specialContentTags(currentTag)) {
          // Escape any `&` symbols that start either:
          // 1) a legacy named character reference (i.e. one that doesn't end with `;`)
          // 2) or any other character reference (i.e. one that does end with `;`)
          // Note that `&` can be escaped as `&amp`, without the semi-colon.
          // https://mathiasbynens.be/notes/ambiguous-ampersands
          text = text.replace(/&((?:Iacute|aacute|uacute|plusmn|Otilde|otilde|agrave|Agrave|Yacute|yacute|Oslash|oslash|atilde|Atilde|brvbar|ccedil|Ccedil|Ograve|curren|divide|eacute|Eacute|ograve|Oacute|egrave|Egrave|Ugrave|frac12|frac14|frac34|ugrave|oacute|iacute|Ntilde|ntilde|Uacute|middot|igrave|Igrave|iquest|Aacute|cedil|laquo|micro|iexcl|Icirc|icirc|acirc|Ucirc|Ecirc|ocirc|Ocirc|ecirc|ucirc|Aring|aring|AElig|aelig|acute|pound|raquo|Acirc|times|THORN|szlig|thorn|COPY|auml|ordf|ordm|Uuml|macr|uuml|Auml|ouml|Ouml|para|nbsp|euml|quot|QUOT|Euml|yuml|cent|sect|copy|sup1|sup2|sup3|iuml|Iuml|ETH|shy|reg|not|yen|amp|AMP|REG|uml|eth|deg|gt|GT|LT|lt)(?!;)|(?:#?[0-9a-zA-Z]+;))/g, '&amp$1').replace(/</g, '&lt;');
        }
        if (uidPattern && options.collapseWhitespace && stackNoTrimWhitespace.length) {
          text = text.replace(uidPattern, function (match, prefix, index) {
            return ignoredCustomMarkupChunks[+index][0];
          });
        }
        currentChars += text;
        if (text) {
          hasChars = true;
        }
        buffer.push(text);
      },
      comment: function (text, nonStandard) {
        var prefix = nonStandard ? '<!' : '<!--';
        var suffix = nonStandard ? '>' : '-->';
        if (isConditionalComment(text)) {
          text = prefix + cleanConditionalComment(text, options) + suffix;
        } else if (options.removeComments) {
          if (isIgnoredComment(text, options)) {
            text = '<!--' + text + '-->';
          } else {
            text = '';
          }
        } else {
          text = prefix + text + suffix;
        }
        if (options.removeOptionalTags && text) {
          // preceding comments suppress tag omissions
          optionalStartTag = '';
          optionalEndTag = '';
        }
        buffer.push(text);
      },
      doctype: function (doctype) {
        buffer.push(options.useShortDoctype ? '<!doctype' + (options.removeTagWhitespace ? '' : ' ') + 'html>' : collapseWhitespaceAll(doctype));
      }
    });
    if (options.removeOptionalTags) {
      // <html> may be omitted if first thing inside is not comment
      // <head> or <body> may be omitted if empty
      if (topLevelTags(optionalStartTag)) {
        removeStartTag();
      }
      // except for </dt> or </thead>, end tags may be omitted if no more content in parent element
      if (optionalEndTag && !trailingTags(optionalEndTag)) {
        removeEndTag();
      }
    }
    if (options.collapseWhitespace) {
      squashTrailingWhitespace('br');
    }
    return joinResultSegments(buffer, options, uidPattern ? function (str) {
      return str.replace(uidPattern, function (match, prefix, index, suffix) {
        var chunk = ignoredCustomMarkupChunks[+index][0];
        if (options.collapseWhitespace) {
          if (prefix !== '\t') {
            chunk = prefix + chunk;
          }
          if (suffix !== '\t') {
            chunk += suffix;
          }
          return collapseWhitespace(chunk, {
            preserveLineBreaks: options.preserveLineBreaks,
            conservativeCollapse: !options.trimCustomFragments
          }, /^[ \n\r\t\f]/.test(chunk), /[ \n\r\t\f]$/.test(chunk));
        }
        return chunk;
      });
    } : identity, uidIgnore ? function (str) {
      return str.replace(new RegExp('<!--' + uidIgnore + '([0-9]+)-->', 'g'), function (match, index) {
        return ignoredMarkupChunks[+index];
      });
    } : identity);
  }
  function joinResultSegments(results, options, restoreCustom, restoreIgnore) {
    var str;
    var maxLineLength = options.maxLineLength;
    if (maxLineLength) {
      var line = '',
        lines = [];
      while (results.length) {
        var len = line.length;
        var end = results[0].indexOf('\n');
        if (end < 0) {
          line += restoreIgnore(restoreCustom(results.shift()));
        } else {
          line += restoreIgnore(restoreCustom(results[0].slice(0, end)));
          results[0] = results[0].slice(end + 1);
        }
        if (len > 0 && line.length > maxLineLength) {
          lines.push(line.slice(0, len));
          line = line.slice(len);
        } else if (end >= 0) {
          lines.push(line);
          line = '';
        }
      }
      if (line) {
        lines.push(line);
      }
      str = lines.join('\n');
    } else {
      str = restoreIgnore(restoreCustom(results.join('')));
    }
    return options.collapseWhitespace ? collapseWhitespace(str, options, true, true) : str;
  }
  htmlminifier.minify = function (value, options) {
    var start = Date.now();
    options = processOptions(options || {});
    var result = minify(value, options);
    options.log('minified in: ' + (Date.now() - start) + 'ms');
    return result;
  };
  return htmlminifier;
}

var cjs = {};

var hasRequiredCjs;
function requireCjs() {
  if (hasRequiredCjs) return cjs;
  hasRequiredCjs = 1;
  var os = require$$0$6;
  var RobotsLine = function () {
    function RobotsLine(line, index, key, value) {
      if (key === void 0) {
        key = '';
      }
      if (value === void 0) {
        value = '';
      }
      this._line = line;
      this._index = index;
      this._key = key;
      this._value = value;
      this._comment = '';
      this._before = '';
      this._after = '';
    }
    Object.defineProperty(RobotsLine.prototype, "key", {
      get: function () {
        return this._key;
      },
      set: function (val) {
        this._key = val;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(RobotsLine.prototype, "value", {
      get: function () {
        return this._value;
      },
      set: function (val) {
        if (!val) {
          val = '';
        }
        this._value = val;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(RobotsLine.prototype, "comment", {
      get: function () {
        return this._comment;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(RobotsLine.prototype, "line", {
      get: function () {
        return this._line;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(RobotsLine.prototype, "lineno", {
      get: function () {
        return this._index + 1;
      },
      enumerable: false,
      configurable: true
    });
    RobotsLine.prototype.hasComment = function () {
      return this.comment !== undefined;
    };
    RobotsLine.prototype.hasKeyPair = function () {
      return this.key !== undefined && this.value !== undefined;
    };
    RobotsLine.prototype.parse = function () {
      var line = this.line;
      var ind = line.indexOf(':');
      var isCommentLine = /^\s*#/.test(line);
      var before = /^(\s+).*/;
      var after = /(\s+)$/;
      if (isCommentLine) {
        this._comment = line.substring(line.indexOf('#'));
      } else if (~ind) {
        var key = line.substring(0, ind);
        var val = line.substring(ind + 1);
        var hash = val.indexOf('#');
        if (~hash) {
          this._comment = val.substring(hash);
          val = val.substring(0, hash);
        }
        this._before = val.replace(before, '$1');
        if (after.test(val)) {
          this._after = val.replace(after, '$1');
        }
        this.key = key;
        this.value = val.trim();
      }
      return this;
    };
    RobotsLine.prototype.serialize = function () {
      var content = '';
      if (this.hasKeyPair()) {
        content += "".concat(this.key, ":").concat(this._before).concat(this.value).concat(this._after);
        if (this.hasComment()) {
          content += this.comment;
        }
      } else {
        content += this.line;
      }
      content += os.EOL;
      return content;
    };
    return RobotsLine;
  }();
  var RobotsList = function () {
    function RobotsList() {
      var items = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        items[_i] = arguments[_i];
      }
      this.list = items;
    }
    RobotsList.prototype.append = function (key, value, line) {
      line = line || key + ': ' + value;
      var next = new RobotsLine(line, this.list.length, key, value);
      next['_before'] = ' ';
      this.list.push(next);
    };
    RobotsList.prototype.parse = function (content) {
      var _this = this;
      var lines = content.split('\n');
      if (!lines[lines.length - 1]) {
        lines.pop();
      }
      lines.forEach(function (line, index) {
        var item = new RobotsLine(line, index);
        _this.list.push(item.parse());
      });
      return this;
    };
    RobotsList.prototype.serialize = function () {
      var content = '';
      for (var _i = 0, _a = this.list; _i < _a.length; _i++) {
        var line = _a[_i];
        content += line.serialize();
      }
      return content;
    };
    return RobotsList;
  }();
  var RobotsParser = function () {
    function RobotsParser() {}
    RobotsParser.prototype.parse = function (content) {
      var list = new RobotsList();
      return list.parse(content);
    };
    RobotsParser.prototype.serialize = function (list) {
      return list.serialize();
    };
    return RobotsParser;
  }();
  var robots = new RobotsParser();
  cjs.RobotsLine = RobotsLine;
  cjs.RobotsList = RobotsList;
  cjs.RobotsParser = RobotsParser;
  cjs.robots = robots;
  return cjs;
}

var dist$1 = {};

var sitemapItemStream = {};

var errors = {};

var hasRequiredErrors;
function requireErrors() {
  if (hasRequiredErrors) return errors;
  hasRequiredErrors = 1;
  /* eslint-disable @typescript-eslint/explicit-module-boundary-types */
  /* eslint-disable @typescript-eslint/no-explicit-any */
  /*!
   * Sitemap
   * Copyright(c) 2011 Eugene Kalinin
   * MIT Licensed
   */
  Object.defineProperty(errors, "__esModule", {
    value: true
  });
  errors.EmptySitemap = errors.EmptyStream = errors.InvalidVideoPriceCurrency = errors.InvalidVideoResolution = errors.InvalidVideoPriceType = errors.InvalidVideoRestrictionRelationship = errors.InvalidVideoRestriction = errors.InvalidVideoFamilyFriendly = errors.InvalidVideoCategory = errors.InvalidVideoTagCount = errors.InvalidVideoViewCount = errors.InvalidVideoTitle = errors.XMLLintUnavailable = errors.InvalidNewsAccessValue = errors.InvalidNewsFormat = errors.InvalidAttr = errors.InvalidAttrValue = errors.InvalidVideoRating = errors.InvalidVideoDescription = errors.InvalidVideoDuration = errors.InvalidVideoFormat = errors.UndefinedTargetFolder = errors.PriorityInvalidError = errors.ChangeFreqInvalidError = errors.NoConfigError = errors.NoURLError = void 0;
  /**
   * URL in SitemapItem does not exist
   */
  class NoURLError extends Error {
    constructor(message) {
      super(message || 'URL is required');
      this.name = 'NoURLError';
      Error.captureStackTrace(this, NoURLError);
    }
  }
  errors.NoURLError = NoURLError;
  /**
   * Config was not passed to SitemapItem constructor
   */
  class NoConfigError extends Error {
    constructor(message) {
      super(message || 'SitemapItem requires a configuration');
      this.name = 'NoConfigError';
      Error.captureStackTrace(this, NoConfigError);
    }
  }
  errors.NoConfigError = NoConfigError;
  /**
   * changefreq property in sitemap is invalid
   */
  class ChangeFreqInvalidError extends Error {
    constructor(url, changefreq) {
      super(`${url}: changefreq "${changefreq}" is invalid`);
      this.name = 'ChangeFreqInvalidError';
      Error.captureStackTrace(this, ChangeFreqInvalidError);
    }
  }
  errors.ChangeFreqInvalidError = ChangeFreqInvalidError;
  /**
   * priority property in sitemap is invalid
   */
  class PriorityInvalidError extends Error {
    constructor(url, priority) {
      super(`${url}: priority "${priority}" must be a number between 0 and 1 inclusive`);
      this.name = 'PriorityInvalidError';
      Error.captureStackTrace(this, PriorityInvalidError);
    }
  }
  errors.PriorityInvalidError = PriorityInvalidError;
  /**
   * SitemapIndex target Folder does not exists
   */
  class UndefinedTargetFolder extends Error {
    constructor(message) {
      super(message || 'Target folder must exist');
      this.name = 'UndefinedTargetFolder';
      Error.captureStackTrace(this, UndefinedTargetFolder);
    }
  }
  errors.UndefinedTargetFolder = UndefinedTargetFolder;
  class InvalidVideoFormat extends Error {
    constructor(url) {
      super(`${url} video must include thumbnail_loc, title and description fields for videos`);
      this.name = 'InvalidVideoFormat';
      Error.captureStackTrace(this, InvalidVideoFormat);
    }
  }
  errors.InvalidVideoFormat = InvalidVideoFormat;
  class InvalidVideoDuration extends Error {
    constructor(url, duration) {
      super(`${url} duration "${duration}" must be an integer of seconds between 0 and 28800`);
      this.name = 'InvalidVideoDuration';
      Error.captureStackTrace(this, InvalidVideoDuration);
    }
  }
  errors.InvalidVideoDuration = InvalidVideoDuration;
  class InvalidVideoDescription extends Error {
    constructor(url, length) {
      const message = `${url}: video description is too long ${length} vs limit of 2048 characters.`;
      super(message);
      this.name = 'InvalidVideoDescription';
      Error.captureStackTrace(this, InvalidVideoDescription);
    }
  }
  errors.InvalidVideoDescription = InvalidVideoDescription;
  class InvalidVideoRating extends Error {
    constructor(url, title, rating) {
      super(`${url}: video "${title}" rating "${rating}" must be between 0 and 5 inclusive`);
      this.name = 'InvalidVideoRating';
      Error.captureStackTrace(this, InvalidVideoRating);
    }
  }
  errors.InvalidVideoRating = InvalidVideoRating;
  class InvalidAttrValue extends Error {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(key, val, validator) {
      super('"' + val + '" tested against: ' + validator + ' is not a valid value for attr: "' + key + '"');
      this.name = 'InvalidAttrValue';
      Error.captureStackTrace(this, InvalidAttrValue);
    }
  }
  errors.InvalidAttrValue = InvalidAttrValue;
  // InvalidAttr is only thrown when attrbuilder is called incorrectly internally
  /* istanbul ignore next */
  class InvalidAttr extends Error {
    constructor(key) {
      super('"' + key + '" is malformed');
      this.name = 'InvalidAttr';
      Error.captureStackTrace(this, InvalidAttr);
    }
  }
  errors.InvalidAttr = InvalidAttr;
  class InvalidNewsFormat extends Error {
    constructor(url) {
      super(`${url} News must include publication, publication name, publication language, title, and publication_date for news`);
      this.name = 'InvalidNewsFormat';
      Error.captureStackTrace(this, InvalidNewsFormat);
    }
  }
  errors.InvalidNewsFormat = InvalidNewsFormat;
  class InvalidNewsAccessValue extends Error {
    constructor(url, access) {
      super(`${url} News access "${access}" must be either Registration, Subscription or not be present`);
      this.name = 'InvalidNewsAccessValue';
      Error.captureStackTrace(this, InvalidNewsAccessValue);
    }
  }
  errors.InvalidNewsAccessValue = InvalidNewsAccessValue;
  class XMLLintUnavailable extends Error {
    constructor(message) {
      super(message || 'xmlLint is not installed. XMLLint is required to validate');
      this.name = 'XMLLintUnavailable';
      Error.captureStackTrace(this, XMLLintUnavailable);
    }
  }
  errors.XMLLintUnavailable = XMLLintUnavailable;
  class InvalidVideoTitle extends Error {
    constructor(url, length) {
      super(`${url}: video title is too long ${length} vs 100 character limit`);
      this.name = 'InvalidVideoTitle';
      Error.captureStackTrace(this, InvalidVideoTitle);
    }
  }
  errors.InvalidVideoTitle = InvalidVideoTitle;
  class InvalidVideoViewCount extends Error {
    constructor(url, count) {
      super(`${url}: video view count must be positive, view count was ${count}`);
      this.name = 'InvalidVideoViewCount';
      Error.captureStackTrace(this, InvalidVideoViewCount);
    }
  }
  errors.InvalidVideoViewCount = InvalidVideoViewCount;
  class InvalidVideoTagCount extends Error {
    constructor(url, count) {
      super(`${url}: video can have no more than 32 tags, this has ${count}`);
      this.name = 'InvalidVideoTagCount';
      Error.captureStackTrace(this, InvalidVideoTagCount);
    }
  }
  errors.InvalidVideoTagCount = InvalidVideoTagCount;
  class InvalidVideoCategory extends Error {
    constructor(url, count) {
      super(`${url}: video category can only be 256 characters but was passed ${count}`);
      this.name = 'InvalidVideoCategory';
      Error.captureStackTrace(this, InvalidVideoCategory);
    }
  }
  errors.InvalidVideoCategory = InvalidVideoCategory;
  class InvalidVideoFamilyFriendly extends Error {
    constructor(url, fam) {
      super(`${url}: video family friendly must be yes or no, was passed "${fam}"`);
      this.name = 'InvalidVideoFamilyFriendly';
      Error.captureStackTrace(this, InvalidVideoFamilyFriendly);
    }
  }
  errors.InvalidVideoFamilyFriendly = InvalidVideoFamilyFriendly;
  class InvalidVideoRestriction extends Error {
    constructor(url, code) {
      super(`${url}: video restriction must be one or more two letter country codes. Was passed "${code}"`);
      this.name = 'InvalidVideoRestriction';
      Error.captureStackTrace(this, InvalidVideoRestriction);
    }
  }
  errors.InvalidVideoRestriction = InvalidVideoRestriction;
  class InvalidVideoRestrictionRelationship extends Error {
    constructor(url, val) {
      super(`${url}: video restriction relationship must be either allow or deny. Was passed "${val}"`);
      this.name = 'InvalidVideoRestrictionRelationship';
      Error.captureStackTrace(this, InvalidVideoRestrictionRelationship);
    }
  }
  errors.InvalidVideoRestrictionRelationship = InvalidVideoRestrictionRelationship;
  class InvalidVideoPriceType extends Error {
    constructor(url, priceType, price) {
      super(priceType === undefined && price === '' ? `${url}: video priceType is required when price is not provided` : `${url}: video price type "${priceType}" is not "rent" or "purchase"`);
      this.name = 'InvalidVideoPriceType';
      Error.captureStackTrace(this, InvalidVideoPriceType);
    }
  }
  errors.InvalidVideoPriceType = InvalidVideoPriceType;
  class InvalidVideoResolution extends Error {
    constructor(url, resolution) {
      super(`${url}: video price resolution "${resolution}" is not hd or sd`);
      this.name = 'InvalidVideoResolution';
      Error.captureStackTrace(this, InvalidVideoResolution);
    }
  }
  errors.InvalidVideoResolution = InvalidVideoResolution;
  class InvalidVideoPriceCurrency extends Error {
    constructor(url, currency) {
      super(`${url}: video price currency "${currency}" must be a three capital letter abbrieviation for the country currency`);
      this.name = 'InvalidVideoPriceCurrency';
      Error.captureStackTrace(this, InvalidVideoPriceCurrency);
    }
  }
  errors.InvalidVideoPriceCurrency = InvalidVideoPriceCurrency;
  class EmptyStream extends Error {
    constructor() {
      super('You have ended the stream before anything was written. streamToPromise MUST be called before ending the stream.');
      this.name = 'EmptyStream';
      Error.captureStackTrace(this, EmptyStream);
    }
  }
  errors.EmptyStream = EmptyStream;
  class EmptySitemap extends Error {
    constructor() {
      super('You ended the stream without writing anything.');
      this.name = 'EmptySitemap';
      Error.captureStackTrace(this, EmptyStream);
    }
  }
  errors.EmptySitemap = EmptySitemap;
  return errors;
}

var types$2 = {};

var hasRequiredTypes$2;
function requireTypes$2() {
  if (hasRequiredTypes$2) return types$2;
  hasRequiredTypes$2 = 1;
  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.IndexTagNames = exports.TagNames = exports.ErrorLevel = exports.isAllowDeny = exports.EnumAllowDeny = exports.isValidYesNo = exports.EnumYesNo = exports.isValidChangeFreq = exports.CHANGEFREQ = exports.isResolution = exports.isPriceType = exports.validators = exports.EnumChangefreq = void 0;
    /**
     * How frequently the page is likely to change. This value provides general
     * information to search engines and may not correlate exactly to how often they crawl the page. Please note that the
     * value of this tag is considered a hint and not a command. See
     * <https://www.sitemaps.org/protocol.html#xmlTagDefinitions> for the acceptable
     * values
     */
    var EnumChangefreq;
    (function (EnumChangefreq) {
      EnumChangefreq["DAILY"] = "daily";
      EnumChangefreq["MONTHLY"] = "monthly";
      EnumChangefreq["ALWAYS"] = "always";
      EnumChangefreq["HOURLY"] = "hourly";
      EnumChangefreq["WEEKLY"] = "weekly";
      EnumChangefreq["YEARLY"] = "yearly";
      EnumChangefreq["NEVER"] = "never";
    })(EnumChangefreq = exports.EnumChangefreq || (exports.EnumChangefreq = {}));
    const allowDeny = /^(?:allow|deny)$/;
    exports.validators = {
      'price:currency': /^[A-Z]{3}$/,
      'price:type': /^(?:rent|purchase|RENT|PURCHASE)$/,
      'price:resolution': /^(?:HD|hd|sd|SD)$/,
      'platform:relationship': allowDeny,
      'restriction:relationship': allowDeny,
      restriction: /^([A-Z]{2}( +[A-Z]{2})*)?$/,
      platform: /^((web|mobile|tv)( (web|mobile|tv))*)?$/,
      language: /^zh-cn|zh-tw|([a-z]{2,3})$/,
      genres: /^(PressRelease|Satire|Blog|OpEd|Opinion|UserGenerated)(, *(PressRelease|Satire|Blog|OpEd|Opinion|UserGenerated))*$/,
      stock_tickers: /^(\w+:\w+(, *\w+:\w+){0,4})?$/
    };
    function isPriceType(pt) {
      return exports.validators['price:type'].test(pt);
    }
    exports.isPriceType = isPriceType;
    function isResolution(res) {
      return exports.validators['price:resolution'].test(res);
    }
    exports.isResolution = isResolution;
    exports.CHANGEFREQ = Object.values(EnumChangefreq);
    function isValidChangeFreq(freq) {
      return exports.CHANGEFREQ.includes(freq);
    }
    exports.isValidChangeFreq = isValidChangeFreq;
    (function (EnumYesNo) {
      EnumYesNo["YES"] = "YES";
      EnumYesNo["NO"] = "NO";
      EnumYesNo["Yes"] = "Yes";
      EnumYesNo["No"] = "No";
      EnumYesNo["yes"] = "yes";
      EnumYesNo["no"] = "no";
    })(exports.EnumYesNo || (exports.EnumYesNo = {}));
    function isValidYesNo(yn) {
      return /^YES|NO|[Yy]es|[Nn]o$/.test(yn);
    }
    exports.isValidYesNo = isValidYesNo;
    (function (EnumAllowDeny) {
      EnumAllowDeny["ALLOW"] = "allow";
      EnumAllowDeny["DENY"] = "deny";
    })(exports.EnumAllowDeny || (exports.EnumAllowDeny = {}));
    function isAllowDeny(ad) {
      return allowDeny.test(ad);
    }
    exports.isAllowDeny = isAllowDeny;
    (function (ErrorLevel) {
      /**
       * Validation will be skipped and nothing logged or thrown.
       */
      ErrorLevel["SILENT"] = "silent";
      /**
       * If an invalid value is encountered, a console.warn will be called with details
       */
      ErrorLevel["WARN"] = "warn";
      /**
       * An Error will be thrown on encountering invalid data.
       */
      ErrorLevel["THROW"] = "throw";
    })(exports.ErrorLevel || (exports.ErrorLevel = {}));
    (function (TagNames) {
      TagNames["url"] = "url";
      TagNames["loc"] = "loc";
      TagNames["urlset"] = "urlset";
      TagNames["lastmod"] = "lastmod";
      TagNames["changefreq"] = "changefreq";
      TagNames["priority"] = "priority";
      TagNames["video:thumbnail_loc"] = "video:thumbnail_loc";
      TagNames["video:video"] = "video:video";
      TagNames["video:title"] = "video:title";
      TagNames["video:description"] = "video:description";
      TagNames["video:tag"] = "video:tag";
      TagNames["video:duration"] = "video:duration";
      TagNames["video:player_loc"] = "video:player_loc";
      TagNames["video:content_loc"] = "video:content_loc";
      TagNames["image:image"] = "image:image";
      TagNames["image:loc"] = "image:loc";
      TagNames["image:geo_location"] = "image:geo_location";
      TagNames["image:license"] = "image:license";
      TagNames["image:title"] = "image:title";
      TagNames["image:caption"] = "image:caption";
      TagNames["video:requires_subscription"] = "video:requires_subscription";
      TagNames["video:publication_date"] = "video:publication_date";
      TagNames["video:id"] = "video:id";
      TagNames["video:restriction"] = "video:restriction";
      TagNames["video:family_friendly"] = "video:family_friendly";
      TagNames["video:view_count"] = "video:view_count";
      TagNames["video:uploader"] = "video:uploader";
      TagNames["video:expiration_date"] = "video:expiration_date";
      TagNames["video:platform"] = "video:platform";
      TagNames["video:price"] = "video:price";
      TagNames["video:rating"] = "video:rating";
      TagNames["video:category"] = "video:category";
      TagNames["video:live"] = "video:live";
      TagNames["video:gallery_loc"] = "video:gallery_loc";
      TagNames["news:news"] = "news:news";
      TagNames["news:publication"] = "news:publication";
      TagNames["news:name"] = "news:name";
      TagNames["news:access"] = "news:access";
      TagNames["news:genres"] = "news:genres";
      TagNames["news:publication_date"] = "news:publication_date";
      TagNames["news:title"] = "news:title";
      TagNames["news:keywords"] = "news:keywords";
      TagNames["news:stock_tickers"] = "news:stock_tickers";
      TagNames["news:language"] = "news:language";
      TagNames["mobile:mobile"] = "mobile:mobile";
      TagNames["xhtml:link"] = "xhtml:link";
      TagNames["expires"] = "expires";
    })(exports.TagNames || (exports.TagNames = {}));
    (function (IndexTagNames) {
      IndexTagNames["sitemap"] = "sitemap";
      IndexTagNames["sitemapindex"] = "sitemapindex";
      IndexTagNames["loc"] = "loc";
      IndexTagNames["lastmod"] = "lastmod";
    })(exports.IndexTagNames || (exports.IndexTagNames = {}));
  })(types$2);
  return types$2;
}

var sitemapXml = {};

var hasRequiredSitemapXml;
function requireSitemapXml() {
  if (hasRequiredSitemapXml) return sitemapXml;
  hasRequiredSitemapXml = 1;
  Object.defineProperty(sitemapXml, "__esModule", {
    value: true
  });
  sitemapXml.element = sitemapXml.ctag = sitemapXml.otag = sitemapXml.text = void 0;
  const invalidXMLUnicodeRegex =
  // eslint-disable-next-line no-control-regex
  /[\u0000-\u0008\u000B\u000C\u000E-\u001F\u007F-\u0084\u0086-\u009F\uD800-\uDFFF\uFDD0-\uFDDF\u{1FFFE}-\u{1FFFF}\u{2FFFE}-\u{2FFFF}\u{3FFFE}-\u{3FFFF}\u{4FFFE}-\u{4FFFF}\u{5FFFE}-\u{5FFFF}\u{6FFFE}-\u{6FFFF}\u{7FFFE}-\u{7FFFF}\u{8FFFE}-\u{8FFFF}\u{9FFFE}-\u{9FFFF}\u{AFFFE}-\u{AFFFF}\u{BFFFE}-\u{BFFFF}\u{CFFFE}-\u{CFFFF}\u{DFFFE}-\u{DFFFF}\u{EFFFE}-\u{EFFFF}\u{FFFFE}-\u{FFFFF}\u{10FFFE}-\u{10FFFF}]/gu;
  const amp = /&/g;
  const lt = /</g;
  const apos = /'/g;
  const quot = /"/g;
  function text(txt) {
    return txt.replace(amp, '&amp;').replace(lt, '&lt;').replace(invalidXMLUnicodeRegex, '');
  }
  sitemapXml.text = text;
  function otag(nodeName, attrs, selfClose = false) {
    let attrstr = '';
    for (const k in attrs) {
      const val = attrs[k].replace(amp, '&amp;').replace(lt, '&lt;').replace(apos, '&apos;').replace(quot, '&quot;').replace(invalidXMLUnicodeRegex, '');
      attrstr += ` ${k}="${val}"`;
    }
    return `<${nodeName}${attrstr}${selfClose ? '/' : ''}>`;
  }
  sitemapXml.otag = otag;
  function ctag(nodeName) {
    return `</${nodeName}>`;
  }
  sitemapXml.ctag = ctag;
  function element(nodeName, attrs, innerText) {
    if (typeof attrs === 'string') {
      return otag(nodeName) + text(attrs) + ctag(nodeName);
    } else if (innerText) {
      return otag(nodeName, attrs) + text(innerText) + ctag(nodeName);
    } else {
      return otag(nodeName, attrs, true);
    }
  }
  sitemapXml.element = element;
  return sitemapXml;
}

var hasRequiredSitemapItemStream;
function requireSitemapItemStream() {
  if (hasRequiredSitemapItemStream) return sitemapItemStream;
  hasRequiredSitemapItemStream = 1;
  Object.defineProperty(sitemapItemStream, "__esModule", {
    value: true
  });
  sitemapItemStream.SitemapItemStream = void 0;
  const stream_1 = require$$0$4;
  const errors_1 = requireErrors();
  const types_1 = requireTypes$2();
  const sitemap_xml_1 = requireSitemapXml();
  function attrBuilder(conf, keys) {
    if (typeof keys === 'string') {
      keys = [keys];
    }
    const iv = {};
    return keys.reduce((attrs, key) => {
      // eslint-disable-next-line
      if (conf[key] !== undefined) {
        const keyAr = key.split(':');
        if (keyAr.length !== 2) {
          throw new errors_1.InvalidAttr(key);
        }
        attrs[keyAr[1]] = conf[key];
      }
      return attrs;
    }, iv);
  }
  /**
   * Takes a stream of SitemapItemOptions and spits out xml for each
   * @example
   * // writes <url><loc>https://example.com</loc><url><url><loc>https://example.com/2</loc><url>
   * const smis = new SitemapItemStream({level: 'warn'})
   * smis.pipe(writestream)
   * smis.write({url: 'https://example.com', img: [], video: [], links: []})
   * smis.write({url: 'https://example.com/2', img: [], video: [], links: []})
   * smis.end()
   * @param level - Error level
   */
  class SitemapItemStream extends stream_1.Transform {
    constructor(opts = {
      level: types_1.ErrorLevel.WARN
    }) {
      opts.objectMode = true;
      super(opts);
      this.level = opts.level || types_1.ErrorLevel.WARN;
    }
    _transform(item, encoding, callback) {
      this.push((0, sitemap_xml_1.otag)(types_1.TagNames.url));
      this.push((0, sitemap_xml_1.element)(types_1.TagNames.loc, item.url));
      if (item.lastmod) {
        this.push((0, sitemap_xml_1.element)(types_1.TagNames.lastmod, item.lastmod));
      }
      if (item.changefreq) {
        this.push((0, sitemap_xml_1.element)(types_1.TagNames.changefreq, item.changefreq));
      }
      if (item.priority !== undefined && item.priority !== null) {
        if (item.fullPrecisionPriority) {
          this.push((0, sitemap_xml_1.element)(types_1.TagNames.priority, item.priority.toString()));
        } else {
          this.push((0, sitemap_xml_1.element)(types_1.TagNames.priority, item.priority.toFixed(1)));
        }
      }
      item.video.forEach(video => {
        this.push((0, sitemap_xml_1.otag)(types_1.TagNames['video:video']));
        this.push((0, sitemap_xml_1.element)(types_1.TagNames['video:thumbnail_loc'], video.thumbnail_loc));
        this.push((0, sitemap_xml_1.element)(types_1.TagNames['video:title'], video.title));
        this.push((0, sitemap_xml_1.element)(types_1.TagNames['video:description'], video.description));
        if (video.content_loc) {
          this.push((0, sitemap_xml_1.element)(types_1.TagNames['video:content_loc'], video.content_loc));
        }
        if (video.player_loc) {
          this.push((0, sitemap_xml_1.element)(types_1.TagNames['video:player_loc'], attrBuilder(video, ['player_loc:autoplay', 'player_loc:allow_embed']), video.player_loc));
        }
        if (video.duration) {
          this.push((0, sitemap_xml_1.element)(types_1.TagNames['video:duration'], video.duration.toString()));
        }
        if (video.expiration_date) {
          this.push((0, sitemap_xml_1.element)(types_1.TagNames['video:expiration_date'], video.expiration_date));
        }
        if (video.rating !== undefined) {
          this.push((0, sitemap_xml_1.element)(types_1.TagNames['video:rating'], video.rating.toString()));
        }
        if (video.view_count !== undefined) {
          this.push((0, sitemap_xml_1.element)(types_1.TagNames['video:view_count'], video.view_count.toString()));
        }
        if (video.publication_date) {
          this.push((0, sitemap_xml_1.element)(types_1.TagNames['video:publication_date'], video.publication_date));
        }
        for (const tag of video.tag) {
          this.push((0, sitemap_xml_1.element)(types_1.TagNames['video:tag'], tag));
        }
        if (video.category) {
          this.push((0, sitemap_xml_1.element)(types_1.TagNames['video:category'], video.category));
        }
        if (video.family_friendly) {
          this.push((0, sitemap_xml_1.element)(types_1.TagNames['video:family_friendly'], video.family_friendly));
        }
        if (video.restriction) {
          this.push((0, sitemap_xml_1.element)(types_1.TagNames['video:restriction'], attrBuilder(video, 'restriction:relationship'), video.restriction));
        }
        if (video.gallery_loc) {
          this.push((0, sitemap_xml_1.element)(types_1.TagNames['video:gallery_loc'], {
            title: video['gallery_loc:title']
          }, video.gallery_loc));
        }
        if (video.price) {
          this.push((0, sitemap_xml_1.element)(types_1.TagNames['video:price'], attrBuilder(video, ['price:resolution', 'price:currency', 'price:type']), video.price));
        }
        if (video.requires_subscription) {
          this.push((0, sitemap_xml_1.element)(types_1.TagNames['video:requires_subscription'], video.requires_subscription));
        }
        if (video.uploader) {
          this.push((0, sitemap_xml_1.element)(types_1.TagNames['video:uploader'], attrBuilder(video, 'uploader:info'), video.uploader));
        }
        if (video.platform) {
          this.push((0, sitemap_xml_1.element)(types_1.TagNames['video:platform'], attrBuilder(video, 'platform:relationship'), video.platform));
        }
        if (video.live) {
          this.push((0, sitemap_xml_1.element)(types_1.TagNames['video:live'], video.live));
        }
        if (video.id) {
          this.push((0, sitemap_xml_1.element)(types_1.TagNames['video:id'], {
            type: 'url'
          }, video.id));
        }
        this.push((0, sitemap_xml_1.ctag)(types_1.TagNames['video:video']));
      });
      item.links.forEach(link => {
        this.push((0, sitemap_xml_1.element)(types_1.TagNames['xhtml:link'], {
          rel: 'alternate',
          hreflang: link.lang || link.hreflang,
          href: link.url
        }));
      });
      if (item.expires) {
        this.push((0, sitemap_xml_1.element)(types_1.TagNames.expires, new Date(item.expires).toISOString()));
      }
      if (item.androidLink) {
        this.push((0, sitemap_xml_1.element)(types_1.TagNames['xhtml:link'], {
          rel: 'alternate',
          href: item.androidLink
        }));
      }
      if (item.ampLink) {
        this.push((0, sitemap_xml_1.element)(types_1.TagNames['xhtml:link'], {
          rel: 'amphtml',
          href: item.ampLink
        }));
      }
      if (item.news) {
        this.push((0, sitemap_xml_1.otag)(types_1.TagNames['news:news']));
        this.push((0, sitemap_xml_1.otag)(types_1.TagNames['news:publication']));
        this.push((0, sitemap_xml_1.element)(types_1.TagNames['news:name'], item.news.publication.name));
        this.push((0, sitemap_xml_1.element)(types_1.TagNames['news:language'], item.news.publication.language));
        this.push((0, sitemap_xml_1.ctag)(types_1.TagNames['news:publication']));
        if (item.news.access) {
          this.push((0, sitemap_xml_1.element)(types_1.TagNames['news:access'], item.news.access));
        }
        if (item.news.genres) {
          this.push((0, sitemap_xml_1.element)(types_1.TagNames['news:genres'], item.news.genres));
        }
        this.push((0, sitemap_xml_1.element)(types_1.TagNames['news:publication_date'], item.news.publication_date));
        this.push((0, sitemap_xml_1.element)(types_1.TagNames['news:title'], item.news.title));
        if (item.news.keywords) {
          this.push((0, sitemap_xml_1.element)(types_1.TagNames['news:keywords'], item.news.keywords));
        }
        if (item.news.stock_tickers) {
          this.push((0, sitemap_xml_1.element)(types_1.TagNames['news:stock_tickers'], item.news.stock_tickers));
        }
        this.push((0, sitemap_xml_1.ctag)(types_1.TagNames['news:news']));
      }
      // Image handling
      item.img.forEach(image => {
        this.push((0, sitemap_xml_1.otag)(types_1.TagNames['image:image']));
        this.push((0, sitemap_xml_1.element)(types_1.TagNames['image:loc'], image.url));
        if (image.caption) {
          this.push((0, sitemap_xml_1.element)(types_1.TagNames['image:caption'], image.caption));
        }
        if (image.geoLocation) {
          this.push((0, sitemap_xml_1.element)(types_1.TagNames['image:geo_location'], image.geoLocation));
        }
        if (image.title) {
          this.push((0, sitemap_xml_1.element)(types_1.TagNames['image:title'], image.title));
        }
        if (image.license) {
          this.push((0, sitemap_xml_1.element)(types_1.TagNames['image:license'], image.license));
        }
        this.push((0, sitemap_xml_1.ctag)(types_1.TagNames['image:image']));
      });
      this.push((0, sitemap_xml_1.ctag)(types_1.TagNames.url));
      callback();
    }
  }
  sitemapItemStream.SitemapItemStream = SitemapItemStream;
  return sitemapItemStream;
}

var sitemapIndexStream = {};

var sitemapStream = {};

var utils$2 = {};

var hasRequiredUtils$2;
function requireUtils$2() {
  if (hasRequiredUtils$2) return utils$2;
  hasRequiredUtils$2 = 1;
  Object.defineProperty(utils$2, "__esModule", {
    value: true
  });
  utils$2.normalizeURL = utils$2.chunk = utils$2.lineSeparatedURLsToSitemapOptions = utils$2.ReadlineStream = utils$2.mergeStreams = utils$2.validateSMIOptions = void 0;
  /*!
   * Sitemap
   * Copyright(c) 2011 Eugene Kalinin
   * MIT Licensed
   */
  const fs_1 = require$$0$5;
  const stream_1 = require$$0$4;
  const readline_1 = require$$2$2;
  const url_1 = require$$1$2;
  const types_1 = requireTypes$2();
  const errors_1 = requireErrors();
  const types_2 = requireTypes$2();
  function validate(subject, name, url, level) {
    Object.keys(subject).forEach(key => {
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      const val = subject[key];
      if (types_2.validators[key] && !types_2.validators[key].test(val)) {
        if (level === types_1.ErrorLevel.THROW) {
          throw new errors_1.InvalidAttrValue(key, val, types_2.validators[key]);
        } else {
          console.warn(`${url}: ${name} key ${key} has invalid value: ${val}`);
        }
      }
    });
  }
  function handleError(error, level) {
    if (level === types_1.ErrorLevel.THROW) {
      throw error;
    } else if (level === types_1.ErrorLevel.WARN) {
      console.warn(error.name, error.message);
    }
  }
  /**
   * Verifies all data passed in will comply with sitemap spec.
   * @param conf Options to validate
   * @param level logging level
   * @param errorHandler error handling func
   */
  function validateSMIOptions(conf, level = types_1.ErrorLevel.WARN, errorHandler = handleError) {
    if (!conf) {
      throw new errors_1.NoConfigError();
    }
    if (level === types_1.ErrorLevel.SILENT) {
      return conf;
    }
    const {
      url,
      changefreq,
      priority,
      news,
      video
    } = conf;
    if (!url) {
      errorHandler(new errors_1.NoURLError(), level);
    }
    if (changefreq) {
      if (!(0, types_1.isValidChangeFreq)(changefreq)) {
        errorHandler(new errors_1.ChangeFreqInvalidError(url, changefreq), level);
      }
    }
    if (priority) {
      if (!(priority >= 0.0 && priority <= 1.0)) {
        errorHandler(new errors_1.PriorityInvalidError(url, priority), level);
      }
    }
    if (news) {
      if (news.access && news.access !== 'Registration' && news.access !== 'Subscription') {
        errorHandler(new errors_1.InvalidNewsAccessValue(url, news.access), level);
      }
      if (!news.publication || !news.publication.name || !news.publication.language || !news.publication_date || !news.title) {
        errorHandler(new errors_1.InvalidNewsFormat(url), level);
      }
      validate(news, 'news', url, level);
      validate(news.publication, 'publication', url, level);
    }
    if (video) {
      video.forEach(vid => {
        var _a;
        if (vid.duration !== undefined) {
          if (vid.duration < 0 || vid.duration > 28800) {
            errorHandler(new errors_1.InvalidVideoDuration(url, vid.duration), level);
          }
        }
        if (vid.rating !== undefined && (vid.rating < 0 || vid.rating > 5)) {
          errorHandler(new errors_1.InvalidVideoRating(url, vid.title, vid.rating), level);
        }
        if (typeof vid !== 'object' || !vid.thumbnail_loc || !vid.title || !vid.description) {
          // has to be an object and include required categories https://support.google.com/webmasters/answer/80471?hl=en&ref_topic=4581190
          errorHandler(new errors_1.InvalidVideoFormat(url), level);
        }
        if (vid.title.length > 100) {
          errorHandler(new errors_1.InvalidVideoTitle(url, vid.title.length), level);
        }
        if (vid.description.length > 2048) {
          errorHandler(new errors_1.InvalidVideoDescription(url, vid.description.length), level);
        }
        if (vid.view_count !== undefined && vid.view_count < 0) {
          errorHandler(new errors_1.InvalidVideoViewCount(url, vid.view_count), level);
        }
        if (vid.tag.length > 32) {
          errorHandler(new errors_1.InvalidVideoTagCount(url, vid.tag.length), level);
        }
        if (vid.category !== undefined && ((_a = vid.category) === null || _a === void 0 ? void 0 : _a.length) > 256) {
          errorHandler(new errors_1.InvalidVideoCategory(url, vid.category.length), level);
        }
        if (vid.family_friendly !== undefined && !(0, types_1.isValidYesNo)(vid.family_friendly)) {
          errorHandler(new errors_1.InvalidVideoFamilyFriendly(url, vid.family_friendly), level);
        }
        if (vid.restriction) {
          if (!types_2.validators.restriction.test(vid.restriction)) {
            errorHandler(new errors_1.InvalidVideoRestriction(url, vid.restriction), level);
          }
          if (!vid['restriction:relationship'] || !(0, types_1.isAllowDeny)(vid['restriction:relationship'])) {
            errorHandler(new errors_1.InvalidVideoRestrictionRelationship(url, vid['restriction:relationship']), level);
          }
        }
        // TODO price element should be unbounded
        if (vid.price === '' && vid['price:type'] === undefined || vid['price:type'] !== undefined && !(0, types_1.isPriceType)(vid['price:type'])) {
          errorHandler(new errors_1.InvalidVideoPriceType(url, vid['price:type'], vid.price), level);
        }
        if (vid['price:resolution'] !== undefined && !(0, types_1.isResolution)(vid['price:resolution'])) {
          errorHandler(new errors_1.InvalidVideoResolution(url, vid['price:resolution']), level);
        }
        if (vid['price:currency'] !== undefined && !types_2.validators['price:currency'].test(vid['price:currency'])) {
          errorHandler(new errors_1.InvalidVideoPriceCurrency(url, vid['price:currency']), level);
        }
        validate(vid, 'video', url, level);
      });
    }
    return conf;
  }
  utils$2.validateSMIOptions = validateSMIOptions;
  /**
   * Combines multiple streams into one
   * @param streams the streams to combine
   */
  function mergeStreams(streams, options) {
    let pass = new stream_1.PassThrough(options);
    let waiting = streams.length;
    for (const stream of streams) {
      pass = stream.pipe(pass, {
        end: false
      });
      stream.once('end', () => --waiting === 0 && pass.emit('end'));
    }
    return pass;
  }
  utils$2.mergeStreams = mergeStreams;
  /**
   * Wraps node's ReadLine in a stream
   */
  class ReadlineStream extends stream_1.Readable {
    constructor(options) {
      if (options.autoDestroy === undefined) {
        options.autoDestroy = true;
      }
      options.objectMode = true;
      super(options);
      this._source = (0, readline_1.createInterface)({
        input: options.input,
        terminal: false,
        crlfDelay: Infinity
      });
      // Every time there's data, push it into the internal buffer.
      this._source.on('line', chunk => {
        // If push() returns false, then stop reading from source.
        if (!this.push(chunk)) this._source.pause();
      });
      // When the source ends, push the EOF-signaling `null` chunk.
      this._source.on('close', () => {
        this.push(null);
      });
    }
    // _read() will be called when the stream wants to pull more data in.
    // The advisory size argument is ignored in this case.
    _read(size) {
      this._source.resume();
    }
  }
  utils$2.ReadlineStream = ReadlineStream;
  /**
   * Takes a stream likely from fs.createReadStream('./path') and returns a stream
   * of sitemap items
   * @param stream a stream of line separated urls.
   * @param opts.isJSON is the stream line separated JSON. leave undefined to guess
   */
  function lineSeparatedURLsToSitemapOptions(stream, {
    isJSON
  } = {}) {
    return new ReadlineStream({
      input: stream
    }).pipe(new stream_1.Transform({
      objectMode: true,
      // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
      transform: (line, encoding, cb) => {
        if (isJSON || isJSON === undefined && line[0] === '{') {
          cb(null, JSON.parse(line));
        } else {
          cb(null, line);
        }
      }
    }));
  }
  utils$2.lineSeparatedURLsToSitemapOptions = lineSeparatedURLsToSitemapOptions;
  /**
   * Based on lodash's implementation of chunk.
   *
   * Copyright JS Foundation and other contributors <https://js.foundation/>
   *
   * Based on Underscore.js, copyright Jeremy Ashkenas,
   * DocumentCloud and Investigative Reporters & Editors <http://underscorejs.org/>
   *
   * This software consists of voluntary contributions made by many
   * individuals. For exact contribution history, see the revision history
   * available at https://github.com/lodash/lodash
   */
  /* eslint-disable @typescript-eslint/no-explicit-any */
  function chunk(array, size = 1) {
    size = Math.max(Math.trunc(size), 0);
    const length = array ? array.length : 0;
    if (!length || size < 1) {
      return [];
    }
    const result = Array(Math.ceil(length / size));
    let index = 0,
      resIndex = 0;
    while (index < length) {
      result[resIndex++] = array.slice(index, index += size);
    }
    return result;
  }
  utils$2.chunk = chunk;
  function boolToYESNO(bool) {
    if (bool === undefined) {
      return bool;
    }
    if (typeof bool === 'boolean') {
      return bool ? types_1.EnumYesNo.yes : types_1.EnumYesNo.no;
    }
    return bool;
  }
  /**
   * Converts the passed in sitemap entry into one capable of being consumed by SitemapItem
   * @param {string | SitemapItemLoose} elem the string or object to be converted
   * @param {string} hostname
   * @returns SitemapItemOptions a strict sitemap item option
   */
  function normalizeURL(elem, hostname, lastmodDateOnly = false) {
    // SitemapItem
    // create object with url property
    let smi = {
      img: [],
      video: [],
      links: [],
      url: ''
    };
    let smiLoose;
    if (typeof elem === 'string') {
      smi.url = elem;
      smiLoose = {
        url: elem
      };
    } else {
      smiLoose = elem;
    }
    smi.url = new url_1.URL(smiLoose.url, hostname).toString();
    let img = [];
    if (smiLoose.img) {
      if (typeof smiLoose.img === 'string') {
        // string -> array of objects
        smiLoose.img = [{
          url: smiLoose.img
        }];
      } else if (!Array.isArray(smiLoose.img)) {
        // object -> array of objects
        smiLoose.img = [smiLoose.img];
      }
      img = smiLoose.img.map(el => typeof el === 'string' ? {
        url: el
      } : el);
    }
    // prepend hostname to all image urls
    smi.img = img.map(el => ({
      ...el,
      url: new url_1.URL(el.url, hostname).toString()
    }));
    let links = [];
    if (smiLoose.links) {
      links = smiLoose.links;
    }
    smi.links = links.map(link => {
      return {
        ...link,
        url: new url_1.URL(link.url, hostname).toString()
      };
    });
    if (smiLoose.video) {
      if (!Array.isArray(smiLoose.video)) {
        // make it an array
        smiLoose.video = [smiLoose.video];
      }
      smi.video = smiLoose.video.map(video => {
        const nv = {
          ...video,
          family_friendly: boolToYESNO(video.family_friendly),
          live: boolToYESNO(video.live),
          requires_subscription: boolToYESNO(video.requires_subscription),
          tag: [],
          rating: undefined
        };
        if (video.tag !== undefined) {
          nv.tag = !Array.isArray(video.tag) ? [video.tag] : video.tag;
        }
        if (video.rating !== undefined) {
          if (typeof video.rating === 'string') {
            nv.rating = parseFloat(video.rating);
          } else {
            nv.rating = video.rating;
          }
        }
        if (typeof video.view_count === 'string') {
          nv.view_count = parseInt(video.view_count, 10);
        } else if (typeof video.view_count === 'number') {
          nv.view_count = video.view_count;
        }
        return nv;
      });
    }
    // If given a file to use for last modified date
    if (smiLoose.lastmodfile) {
      const {
        mtime
      } = (0, fs_1.statSync)(smiLoose.lastmodfile);
      smi.lastmod = new Date(mtime).toISOString();
      // The date of last modification (YYYY-MM-DD)
    } else if (smiLoose.lastmodISO) {
      smi.lastmod = new Date(smiLoose.lastmodISO).toISOString();
    } else if (smiLoose.lastmod) {
      smi.lastmod = new Date(smiLoose.lastmod).toISOString();
    }
    if (lastmodDateOnly && smi.lastmod) {
      smi.lastmod = smi.lastmod.slice(0, 10);
    }
    delete smiLoose.lastmodfile;
    delete smiLoose.lastmodISO;
    smi = {
      ...smiLoose,
      ...smi
    };
    return smi;
  }
  utils$2.normalizeURL = normalizeURL;
  return utils$2;
}

var hasRequiredSitemapStream;
function requireSitemapStream() {
  if (hasRequiredSitemapStream) return sitemapStream;
  hasRequiredSitemapStream = 1;
  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.streamToPromise = exports.SitemapStream = exports.closetag = exports.stylesheetInclude = void 0;
    const stream_1 = require$$0$4;
    const types_1 = requireTypes$2();
    const utils_1 = requireUtils$2();
    const sitemap_item_stream_1 = requireSitemapItemStream();
    const errors_1 = requireErrors();
    const xmlDec = '<?xml version="1.0" encoding="UTF-8"?>';
    const stylesheetInclude = url => {
      return `<?xml-stylesheet type="text/xsl" href="${url}"?>`;
    };
    exports.stylesheetInclude = stylesheetInclude;
    const urlsetTagStart = '<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9"';
    const getURLSetNs = ({
      news,
      video,
      image,
      xhtml,
      custom
    }, xslURL) => {
      let ns = xmlDec;
      if (xslURL) {
        ns += (0, exports.stylesheetInclude)(xslURL);
      }
      ns += urlsetTagStart;
      if (news) {
        ns += ' xmlns:news="http://www.google.com/schemas/sitemap-news/0.9"';
      }
      if (xhtml) {
        ns += ' xmlns:xhtml="http://www.w3.org/1999/xhtml"';
      }
      if (image) {
        ns += ' xmlns:image="http://www.google.com/schemas/sitemap-image/1.1"';
      }
      if (video) {
        ns += ' xmlns:video="http://www.google.com/schemas/sitemap-video/1.1"';
      }
      if (custom) {
        ns += ' ' + custom.join(' ');
      }
      return ns + '>';
    };
    exports.closetag = '</urlset>';
    const defaultXMLNS = {
      news: true,
      xhtml: true,
      image: true,
      video: true
    };
    const defaultStreamOpts = {
      xmlns: defaultXMLNS
    };
    /**
     * A [Transform](https://nodejs.org/api/stream.html#stream_implementing_a_transform_stream)
     * for turning a
     * [Readable stream](https://nodejs.org/api/stream.html#stream_readable_streams)
     * of either [SitemapItemOptions](#sitemap-item-options) or url strings into a
     * Sitemap. The readable stream it transforms **must** be in object mode.
     */
    class SitemapStream extends stream_1.Transform {
      constructor(opts = defaultStreamOpts) {
        opts.objectMode = true;
        super(opts);
        this.hasHeadOutput = false;
        this.hostname = opts.hostname;
        this.level = opts.level || types_1.ErrorLevel.WARN;
        this.errorHandler = opts.errorHandler;
        this.smiStream = new sitemap_item_stream_1.SitemapItemStream({
          level: opts.level
        });
        this.smiStream.on('data', data => this.push(data));
        this.lastmodDateOnly = opts.lastmodDateOnly || false;
        this.xmlNS = opts.xmlns || defaultXMLNS;
        this.xslUrl = opts.xslUrl;
      }
      _transform(item, encoding, callback) {
        if (!this.hasHeadOutput) {
          this.hasHeadOutput = true;
          this.push(getURLSetNs(this.xmlNS, this.xslUrl));
        }
        if (!this.smiStream.write((0, utils_1.validateSMIOptions)((0, utils_1.normalizeURL)(item, this.hostname, this.lastmodDateOnly), this.level, this.errorHandler))) {
          this.smiStream.once('drain', callback);
        } else {
          process.nextTick(callback);
        }
      }
      _flush(cb) {
        if (!this.hasHeadOutput) {
          cb(new errors_1.EmptySitemap());
        } else {
          this.push(exports.closetag);
          cb();
        }
      }
    }
    exports.SitemapStream = SitemapStream;
    /**
     * Converts a readable stream into a promise that resolves with the concatenated data from the stream.
     *
     * The function listens for 'data' events from the stream, and when the stream ends, it resolves the promise with the concatenated data. If an error occurs while reading from the stream, the promise is rejected with the error.
     *
     *  CAUTION: This function should not generally be used in production / when writing to files as it holds a copy of the entire file contents in memory until finished.
     *
     * @param {Readable} stream - The readable stream to convert to a promise.
     * @returns {Promise<Buffer>} A promise that resolves with the concatenated data from the stream as a Buffer, or rejects with an error if one occurred while reading from the stream. If the stream is empty, the promise is rejected with an EmptyStream error.
     * @throws {EmptyStream} If the stream is empty.
     */
    function streamToPromise(stream) {
      return new Promise((resolve, reject) => {
        const drain = [];
        stream
        // Error propagation is not automatic
        // Bubble up errors on the read stream
        .on('error', reject).pipe(new stream_1.Writable({
          write(chunk, enc, next) {
            drain.push(chunk);
            next();
          }
        }))
        // This bubbles up errors when writing to the internal buffer
        // This is unlikely to happen, but we have this for completeness
        .on('error', reject).on('finish', () => {
          if (!drain.length) {
            reject(new errors_1.EmptyStream());
          } else {
            resolve(Buffer.concat(drain));
          }
        });
      });
    }
    exports.streamToPromise = streamToPromise;
  })(sitemapStream);
  return sitemapStream;
}

var hasRequiredSitemapIndexStream;
function requireSitemapIndexStream() {
  if (hasRequiredSitemapIndexStream) return sitemapIndexStream;
  hasRequiredSitemapIndexStream = 1;
  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SitemapAndIndexStream = exports.SitemapIndexStream = exports.IndexTagNames = void 0;
    const stream_1 = require$$0$4;
    const types_1 = requireTypes$2();
    const sitemap_stream_1 = requireSitemapStream();
    const sitemap_xml_1 = requireSitemapXml();
    var IndexTagNames;
    (function (IndexTagNames) {
      IndexTagNames["sitemap"] = "sitemap";
      IndexTagNames["loc"] = "loc";
      IndexTagNames["lastmod"] = "lastmod";
    })(IndexTagNames = exports.IndexTagNames || (exports.IndexTagNames = {}));
    const xmlDec = '<?xml version="1.0" encoding="UTF-8"?>';
    const sitemapIndexTagStart = '<sitemapindex xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">';
    const closetag = '</sitemapindex>';
    const defaultStreamOpts = {};
    /**
     * `SitemapIndexStream` is a Transform stream that takes `IndexItem`s or sitemap URL strings and outputs a stream of sitemap index XML.
     *
     * It automatically handles the XML declaration and the opening and closing tags for the sitemap index.
     *
     *  CAUTION: This object is `readable` and must be read (e.g. piped to a file or to /dev/null)
     * before `finish` will be emitted. Failure to read the stream will result in hangs.
     *
     * @extends {Transform}
     */
    class SitemapIndexStream extends stream_1.Transform {
      /**
       * `SitemapIndexStream` is a Transform stream that takes `IndexItem`s or sitemap URL strings and outputs a stream of sitemap index XML.
       *
       * It automatically handles the XML declaration and the opening and closing tags for the sitemap index.
       *
       *  CAUTION: This object is `readable` and must be read (e.g. piped to a file or to /dev/null)
       * before `finish` will be emitted. Failure to read the stream will result in hangs.
       *
       * @param {SitemapIndexStreamOptions} [opts=defaultStreamOpts] - Stream options.
       */
      constructor(opts = defaultStreamOpts) {
        var _a;
        opts.objectMode = true;
        super(opts);
        this.hasHeadOutput = false;
        this.lastmodDateOnly = opts.lastmodDateOnly || false;
        this.level = (_a = opts.level) !== null && _a !== void 0 ? _a : types_1.ErrorLevel.WARN;
        this.xslUrl = opts.xslUrl;
      }
      writeHeadOutput() {
        this.hasHeadOutput = true;
        let stylesheet = '';
        if (this.xslUrl) {
          stylesheet = (0, sitemap_stream_1.stylesheetInclude)(this.xslUrl);
        }
        this.push(xmlDec + stylesheet + sitemapIndexTagStart);
      }
      _transform(item, encoding, callback) {
        if (!this.hasHeadOutput) {
          this.writeHeadOutput();
        }
        this.push((0, sitemap_xml_1.otag)(IndexTagNames.sitemap));
        if (typeof item === 'string') {
          this.push((0, sitemap_xml_1.element)(IndexTagNames.loc, item));
        } else {
          this.push((0, sitemap_xml_1.element)(IndexTagNames.loc, item.url));
          if (item.lastmod) {
            const lastmod = new Date(item.lastmod).toISOString();
            this.push((0, sitemap_xml_1.element)(IndexTagNames.lastmod, this.lastmodDateOnly ? lastmod.slice(0, 10) : lastmod));
          }
        }
        this.push((0, sitemap_xml_1.ctag)(IndexTagNames.sitemap));
        callback();
      }
      _flush(cb) {
        if (!this.hasHeadOutput) {
          this.writeHeadOutput();
        }
        this.push(closetag);
        cb();
      }
    }
    exports.SitemapIndexStream = SitemapIndexStream;
    /**
     * `SitemapAndIndexStream` is a Transform stream that takes in sitemap items,
     * writes them to sitemap files, adds the sitemap files to a sitemap index,
     * and creates new sitemap files when the count limit is reached.
     *
     * It waits for the target stream of the current sitemap file to finish before
     * moving on to the next if the target stream is returned by the `getSitemapStream`
     * callback in the 3rd position of the tuple.
     *
     *  CAUTION: This object is `readable` and must be read (e.g. piped to a file or to /dev/null)
     * before `finish` will be emitted. Failure to read the stream will result in hangs.
     *
     * @extends {SitemapIndexStream}
     */
    class SitemapAndIndexStream extends SitemapIndexStream {
      /**
       * `SitemapAndIndexStream` is a Transform stream that takes in sitemap items,
       * writes them to sitemap files, adds the sitemap files to a sitemap index,
       * and creates new sitemap files when the count limit is reached.
       *
       * It waits for the target stream of the current sitemap file to finish before
       * moving on to the next if the target stream is returned by the `getSitemapStream`
       * callback in the 3rd position of the tuple.
       *
       *  CAUTION: This object is `readable` and must be read (e.g. piped to a file or to /dev/null)
       * before `finish` will be emitted. Failure to read the stream will result in hangs.
       *
       * @param {SitemapAndIndexStreamOptions} opts - Stream options.
       */
      constructor(opts) {
        var _a;
        opts.objectMode = true;
        super(opts);
        this.itemsWritten = 0;
        this.getSitemapStream = opts.getSitemapStream;
        this.limit = (_a = opts.limit) !== null && _a !== void 0 ? _a : 45000;
      }
      _transform(item, encoding, callback) {
        if (this.itemsWritten % this.limit === 0) {
          if (this.currentSitemap) {
            const onFinish = new Promise((resolve, reject) => {
              var _a, _b, _c;
              (_a = this.currentSitemap) === null || _a === void 0 ? void 0 : _a.on('finish', resolve);
              (_b = this.currentSitemap) === null || _b === void 0 ? void 0 : _b.on('error', reject);
              (_c = this.currentSitemap) === null || _c === void 0 ? void 0 : _c.end();
            });
            const onPipelineFinish = this.currentSitemapPipeline ? new Promise((resolve, reject) => {
              var _a, _b;
              (_a = this.currentSitemapPipeline) === null || _a === void 0 ? void 0 : _a.on('finish', resolve);
              (_b = this.currentSitemapPipeline) === null || _b === void 0 ? void 0 : _b.on('error', reject);
            }) : Promise.resolve();
            Promise.all([onFinish, onPipelineFinish]).then(() => {
              this.createSitemap(encoding);
              this.writeItem(item, callback);
            }).catch(callback);
            return;
          } else {
            this.createSitemap(encoding);
          }
        }
        this.writeItem(item, callback);
      }
      writeItem(item, callback) {
        if (!this.currentSitemap) {
          callback(new Error('No sitemap stream available'));
          return;
        }
        if (!this.currentSitemap.write(item)) {
          this.currentSitemap.once('drain', callback);
        } else {
          process.nextTick(callback);
        }
        // Increment the count of items written
        this.itemsWritten++;
      }
      /**
       * Called when the stream is finished.
       * If there is a current sitemap, we wait for it to finish before calling the callback.
       *
       * @param cb
       */
      _flush(cb) {
        const onFinish = new Promise((resolve, reject) => {
          if (this.currentSitemap) {
            this.currentSitemap.on('finish', resolve);
            this.currentSitemap.on('error', reject);
            this.currentSitemap.end();
          } else {
            resolve();
          }
        });
        const onPipelineFinish = new Promise((resolve, reject) => {
          if (this.currentSitemapPipeline) {
            this.currentSitemapPipeline.on('finish', resolve);
            this.currentSitemapPipeline.on('error', reject);
            // The pipeline (pipe target) will get it's end() call
            // from the sitemap stream ending.
          } else {
            resolve();
          }
        });
        Promise.all([onFinish, onPipelineFinish]).then(() => {
          super._flush(cb);
        }).catch(err => {
          cb(err);
        });
      }
      createSitemap(encoding) {
        const [idxItem, currentSitemap, currentSitemapPipeline] = this.getSitemapStream(this.itemsWritten / this.limit);
        currentSitemap.on('error', err => this.emit('error', err));
        this.currentSitemap = currentSitemap;
        this.currentSitemapPipeline = currentSitemapPipeline;
        super._transform(idxItem, encoding, () => {
          // We are not too fussed about waiting for the index item to be written
          // we we'll wait for the file to finish at the end
          // and index file write volume tends to be small in comprarison to sitemap
          // writes.
          // noop
        });
      }
    }
    exports.SitemapAndIndexStream = SitemapAndIndexStream;
  })(sitemapIndexStream);
  return sitemapIndexStream;
}

var xmllint = {};

var hasRequiredXmllint;
function requireXmllint() {
  if (hasRequiredXmllint) return xmllint;
  hasRequiredXmllint = 1;
  Object.defineProperty(xmllint, "__esModule", {
    value: true
  });
  xmllint.xmlLint = void 0;
  const path_1 = require$$1$1;
  const child_process_1 = require$$1$4;
  const errors_1 = requireErrors();
  /**
   * Verify the passed in xml is valid. Requires xmllib be installed
   * @param xml what you want validated
   * @return {Promise<void>} resolves on valid rejects [error stderr]
   */
  function xmlLint(xml) {
    const args = ['--schema', (0, path_1.resolve)(__dirname, '..', '..', 'schema', 'all.xsd'), '--noout', '-'];
    if (typeof xml === 'string') {
      args[args.length - 1] = xml;
    }
    return new Promise((resolve, reject) => {
      (0, child_process_1.execFile)('which', ['xmllint'], (error, stdout, stderr) => {
        if (error) {
          reject([new errors_1.XMLLintUnavailable()]);
          return;
        }
        const xmllint = (0, child_process_1.execFile)('xmllint', args, (error, stdout, stderr) => {
          if (error) {
            reject([error, stderr]);
          }
          resolve();
        });
        if (xmllint.stdout) {
          xmllint.stdout.unpipe();
          if (typeof xml !== 'string' && xml && xmllint.stdin) {
            xml.pipe(xmllint.stdin);
          }
        }
      });
    });
  }
  xmllint.xmlLint = xmlLint;
  return xmllint;
}

var sitemapParser = {};

var sax = {};

var hasRequiredSax;
function requireSax() {
  if (hasRequiredSax) return sax;
  hasRequiredSax = 1;
  (function (exports) {
    (function (sax) {
      // wrapper for non-node envs
      sax.parser = function (strict, opt) {
        return new SAXParser(strict, opt);
      };
      sax.SAXParser = SAXParser;
      sax.SAXStream = SAXStream;
      sax.createStream = createStream;

      // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
      // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
      // since that's the earliest that a buffer overrun could occur.  This way, checks are
      // as rare as required, but as often as necessary to ensure never crossing this bound.
      // Furthermore, buffers are only tested at most once per write(), so passing a very
      // large string into write() might have undesirable effects, but this is manageable by
      // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
      // edge case, result in creating at most one complete copy of the string passed in.
      // Set to Infinity to have unlimited buffers.
      sax.MAX_BUFFER_LENGTH = 64 * 1024;
      var buffers = ['comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype', 'procInstName', 'procInstBody', 'entity', 'attribName', 'attribValue', 'cdata', 'script'];
      sax.EVENTS = ['text', 'processinginstruction', 'sgmldeclaration', 'doctype', 'comment', 'opentagstart', 'attribute', 'opentag', 'closetag', 'opencdata', 'cdata', 'closecdata', 'error', 'end', 'ready', 'script', 'opennamespace', 'closenamespace'];
      function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) {
          return new SAXParser(strict, opt);
        }
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = '';
        parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
        parser.opt = opt || {};
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase';
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
        parser.attribList = [];

        // namespaces form a prototype chain.
        // it always points at the current tag,
        // which protos to its parent tag.
        if (parser.opt.xmlns) {
          parser.ns = Object.create(rootNS);
        }

        // disallow unquoted attribute values if not otherwise configured
        // and strict mode is true
        if (parser.opt.unquotedAttributeValues === undefined) {
          parser.opt.unquotedAttributeValues = !strict;
        }

        // mostly just for error reporting
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) {
          parser.position = parser.line = parser.column = 0;
        }
        emit(parser, 'onready');
      }
      if (!Object.create) {
        Object.create = function (o) {
          function F() {}
          F.prototype = o;
          var newf = new F();
          return newf;
        };
      }
      if (!Object.keys) {
        Object.keys = function (o) {
          var a = [];
          for (var i in o) if (o.hasOwnProperty(i)) a.push(i);
          return a;
        };
      }
      function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for (var i = 0, l = buffers.length; i < l; i++) {
          var len = parser[buffers[i]].length;
          if (len > maxAllowed) {
            // Text/cdata nodes can get big, and since they're buffered,
            // we can get here under normal conditions.
            // Avoid issues by emitting the text node now,
            // so at least it won't get any bigger.
            switch (buffers[i]) {
              case 'textNode':
                closeText(parser);
                break;
              case 'cdata':
                emitNode(parser, 'oncdata', parser.cdata);
                parser.cdata = '';
                break;
              case 'script':
                emitNode(parser, 'onscript', parser.script);
                parser.script = '';
                break;
              default:
                error(parser, 'Max buffer length exceeded: ' + buffers[i]);
            }
          }
          maxActual = Math.max(maxActual, len);
        }
        // schedule the next check for the earliest possible buffer overrun.
        var m = sax.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m + parser.position;
      }
      function clearBuffers(parser) {
        for (var i = 0, l = buffers.length; i < l; i++) {
          parser[buffers[i]] = '';
        }
      }
      function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== '') {
          emitNode(parser, 'oncdata', parser.cdata);
          parser.cdata = '';
        }
        if (parser.script !== '') {
          emitNode(parser, 'onscript', parser.script);
          parser.script = '';
        }
      }
      SAXParser.prototype = {
        end: function () {
          end(this);
        },
        write: write,
        resume: function () {
          this.error = null;
          return this;
        },
        close: function () {
          return this.write(null);
        },
        flush: function () {
          flushBuffers(this);
        }
      };
      var Stream;
      try {
        Stream = require('stream').Stream;
      } catch (ex) {
        Stream = function () {};
      }
      if (!Stream) Stream = function () {};
      var streamWraps = sax.EVENTS.filter(function (ev) {
        return ev !== 'error' && ev !== 'end';
      });
      function createStream(strict, opt) {
        return new SAXStream(strict, opt);
      }
      function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream)) {
          return new SAXStream(strict, opt);
        }
        Stream.apply(this);
        this._parser = new SAXParser(strict, opt);
        this.writable = true;
        this.readable = true;
        var me = this;
        this._parser.onend = function () {
          me.emit('end');
        };
        this._parser.onerror = function (er) {
          me.emit('error', er);

          // if didn't throw, then means error was handled.
          // go ahead and clear error, so we can write again.
          me._parser.error = null;
        };
        this._decoder = null;
        streamWraps.forEach(function (ev) {
          Object.defineProperty(me, 'on' + ev, {
            get: function () {
              return me._parser['on' + ev];
            },
            set: function (h) {
              if (!h) {
                me.removeAllListeners(ev);
                me._parser['on' + ev] = h;
                return h;
              }
              me.on(ev, h);
            },
            enumerable: true,
            configurable: false
          });
        });
      }
      SAXStream.prototype = Object.create(Stream.prototype, {
        constructor: {
          value: SAXStream
        }
      });
      SAXStream.prototype.write = function (data) {
        if (typeof Buffer === 'function' && typeof Buffer.isBuffer === 'function' && Buffer.isBuffer(data)) {
          if (!this._decoder) {
            var SD = require$$1$5.StringDecoder;
            this._decoder = new SD('utf8');
          }
          data = this._decoder.write(data);
        }
        this._parser.write(data.toString());
        this.emit('data', data);
        return true;
      };
      SAXStream.prototype.end = function (chunk) {
        if (chunk && chunk.length) {
          this.write(chunk);
        }
        this._parser.end();
        return true;
      };
      SAXStream.prototype.on = function (ev, handler) {
        var me = this;
        if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {
          me._parser['on' + ev] = function () {
            var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
            args.splice(0, 0, ev);
            me.emit.apply(me, args);
          };
        }
        return Stream.prototype.on.call(me, ev, handler);
      };

      // this really needs to be replaced with character classes.
      // XML allows all manner of ridiculous numbers and digits.
      var CDATA = '[CDATA[';
      var DOCTYPE = 'DOCTYPE';
      var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';
      var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/';
      var rootNS = {
        xml: XML_NAMESPACE,
        xmlns: XMLNS_NAMESPACE
      };

      // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
      // This implementation works on strings, a single character at a time
      // as such, it cannot ever support astral-plane characters (10000-EFFFF)
      // without a significant breaking change to either this  parser, or the
      // JavaScript language.  Implementation of an emoji-capable xml parser
      // is left as an exercise for the reader.
      var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function isWhitespace(c) {
        return c === ' ' || c === '\n' || c === '\r' || c === '\t';
      }
      function isQuote(c) {
        return c === '"' || c === '\'';
      }
      function isAttribEnd(c) {
        return c === '>' || isWhitespace(c);
      }
      function isMatch(regex, c) {
        return regex.test(c);
      }
      function notMatch(regex, c) {
        return !isMatch(regex, c);
      }
      var S = 0;
      sax.STATE = {
        BEGIN: S++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: S++,
        // leading whitespace
        TEXT: S++,
        // general stuff
        TEXT_ENTITY: S++,
        // &amp and such.
        OPEN_WAKA: S++,
        // <
        SGML_DECL: S++,
        // <!BLARG
        SGML_DECL_QUOTED: S++,
        // <!BLARG foo "bar
        DOCTYPE: S++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: S++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: S++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: S++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: S++,
        // <!-
        COMMENT: S++,
        // <!--
        COMMENT_ENDING: S++,
        // <!-- blah -
        COMMENT_ENDED: S++,
        // <!-- blah --
        CDATA: S++,
        // <![CDATA[ something
        CDATA_ENDING: S++,
        // ]
        CDATA_ENDING_2: S++,
        // ]]
        PROC_INST: S++,
        // <?hi
        PROC_INST_BODY: S++,
        // <?hi there
        PROC_INST_ENDING: S++,
        // <?hi "there" ?
        OPEN_TAG: S++,
        // <strong
        OPEN_TAG_SLASH: S++,
        // <strong /
        ATTRIB: S++,
        // <a
        ATTRIB_NAME: S++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: S++,
        // <a foo _
        ATTRIB_VALUE: S++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: S++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: S++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: S++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: S++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: S++,
        // <foo bar=&quot
        CLOSE_TAG: S++,
        // </a
        CLOSE_TAG_SAW_WHITE: S++,
        // </a   >
        SCRIPT: S++,
        // <script> ...
        SCRIPT_ENDING: S++ // <script> ... <
      };
      sax.XML_ENTITIES = {
        'amp': '&',
        'gt': '>',
        'lt': '<',
        'quot': '"',
        'apos': "'"
      };
      sax.ENTITIES = {
        'amp': '&',
        'gt': '>',
        'lt': '<',
        'quot': '"',
        'apos': "'",
        'AElig': 198,
        'Aacute': 193,
        'Acirc': 194,
        'Agrave': 192,
        'Aring': 197,
        'Atilde': 195,
        'Auml': 196,
        'Ccedil': 199,
        'ETH': 208,
        'Eacute': 201,
        'Ecirc': 202,
        'Egrave': 200,
        'Euml': 203,
        'Iacute': 205,
        'Icirc': 206,
        'Igrave': 204,
        'Iuml': 207,
        'Ntilde': 209,
        'Oacute': 211,
        'Ocirc': 212,
        'Ograve': 210,
        'Oslash': 216,
        'Otilde': 213,
        'Ouml': 214,
        'THORN': 222,
        'Uacute': 218,
        'Ucirc': 219,
        'Ugrave': 217,
        'Uuml': 220,
        'Yacute': 221,
        'aacute': 225,
        'acirc': 226,
        'aelig': 230,
        'agrave': 224,
        'aring': 229,
        'atilde': 227,
        'auml': 228,
        'ccedil': 231,
        'eacute': 233,
        'ecirc': 234,
        'egrave': 232,
        'eth': 240,
        'euml': 235,
        'iacute': 237,
        'icirc': 238,
        'igrave': 236,
        'iuml': 239,
        'ntilde': 241,
        'oacute': 243,
        'ocirc': 244,
        'ograve': 242,
        'oslash': 248,
        'otilde': 245,
        'ouml': 246,
        'szlig': 223,
        'thorn': 254,
        'uacute': 250,
        'ucirc': 251,
        'ugrave': 249,
        'uuml': 252,
        'yacute': 253,
        'yuml': 255,
        'copy': 169,
        'reg': 174,
        'nbsp': 160,
        'iexcl': 161,
        'cent': 162,
        'pound': 163,
        'curren': 164,
        'yen': 165,
        'brvbar': 166,
        'sect': 167,
        'uml': 168,
        'ordf': 170,
        'laquo': 171,
        'not': 172,
        'shy': 173,
        'macr': 175,
        'deg': 176,
        'plusmn': 177,
        'sup1': 185,
        'sup2': 178,
        'sup3': 179,
        'acute': 180,
        'micro': 181,
        'para': 182,
        'middot': 183,
        'cedil': 184,
        'ordm': 186,
        'raquo': 187,
        'frac14': 188,
        'frac12': 189,
        'frac34': 190,
        'iquest': 191,
        'times': 215,
        'divide': 247,
        'OElig': 338,
        'oelig': 339,
        'Scaron': 352,
        'scaron': 353,
        'Yuml': 376,
        'fnof': 402,
        'circ': 710,
        'tilde': 732,
        'Alpha': 913,
        'Beta': 914,
        'Gamma': 915,
        'Delta': 916,
        'Epsilon': 917,
        'Zeta': 918,
        'Eta': 919,
        'Theta': 920,
        'Iota': 921,
        'Kappa': 922,
        'Lambda': 923,
        'Mu': 924,
        'Nu': 925,
        'Xi': 926,
        'Omicron': 927,
        'Pi': 928,
        'Rho': 929,
        'Sigma': 931,
        'Tau': 932,
        'Upsilon': 933,
        'Phi': 934,
        'Chi': 935,
        'Psi': 936,
        'Omega': 937,
        'alpha': 945,
        'beta': 946,
        'gamma': 947,
        'delta': 948,
        'epsilon': 949,
        'zeta': 950,
        'eta': 951,
        'theta': 952,
        'iota': 953,
        'kappa': 954,
        'lambda': 955,
        'mu': 956,
        'nu': 957,
        'xi': 958,
        'omicron': 959,
        'pi': 960,
        'rho': 961,
        'sigmaf': 962,
        'sigma': 963,
        'tau': 964,
        'upsilon': 965,
        'phi': 966,
        'chi': 967,
        'psi': 968,
        'omega': 969,
        'thetasym': 977,
        'upsih': 978,
        'piv': 982,
        'ensp': 8194,
        'emsp': 8195,
        'thinsp': 8201,
        'zwnj': 8204,
        'zwj': 8205,
        'lrm': 8206,
        'rlm': 8207,
        'ndash': 8211,
        'mdash': 8212,
        'lsquo': 8216,
        'rsquo': 8217,
        'sbquo': 8218,
        'ldquo': 8220,
        'rdquo': 8221,
        'bdquo': 8222,
        'dagger': 8224,
        'Dagger': 8225,
        'bull': 8226,
        'hellip': 8230,
        'permil': 8240,
        'prime': 8242,
        'Prime': 8243,
        'lsaquo': 8249,
        'rsaquo': 8250,
        'oline': 8254,
        'frasl': 8260,
        'euro': 8364,
        'image': 8465,
        'weierp': 8472,
        'real': 8476,
        'trade': 8482,
        'alefsym': 8501,
        'larr': 8592,
        'uarr': 8593,
        'rarr': 8594,
        'darr': 8595,
        'harr': 8596,
        'crarr': 8629,
        'lArr': 8656,
        'uArr': 8657,
        'rArr': 8658,
        'dArr': 8659,
        'hArr': 8660,
        'forall': 8704,
        'part': 8706,
        'exist': 8707,
        'empty': 8709,
        'nabla': 8711,
        'isin': 8712,
        'notin': 8713,
        'ni': 8715,
        'prod': 8719,
        'sum': 8721,
        'minus': 8722,
        'lowast': 8727,
        'radic': 8730,
        'prop': 8733,
        'infin': 8734,
        'ang': 8736,
        'and': 8743,
        'or': 8744,
        'cap': 8745,
        'cup': 8746,
        'int': 8747,
        'there4': 8756,
        'sim': 8764,
        'cong': 8773,
        'asymp': 8776,
        'ne': 8800,
        'equiv': 8801,
        'le': 8804,
        'ge': 8805,
        'sub': 8834,
        'sup': 8835,
        'nsub': 8836,
        'sube': 8838,
        'supe': 8839,
        'oplus': 8853,
        'otimes': 8855,
        'perp': 8869,
        'sdot': 8901,
        'lceil': 8968,
        'rceil': 8969,
        'lfloor': 8970,
        'rfloor': 8971,
        'lang': 9001,
        'rang': 9002,
        'loz': 9674,
        'spades': 9824,
        'clubs': 9827,
        'hearts': 9829,
        'diams': 9830
      };
      Object.keys(sax.ENTITIES).forEach(function (key) {
        var e = sax.ENTITIES[key];
        var s = typeof e === 'number' ? String.fromCharCode(e) : e;
        sax.ENTITIES[key] = s;
      });
      for (var s in sax.STATE) {
        sax.STATE[sax.STATE[s]] = s;
      }

      // shorthand
      S = sax.STATE;
      function emit(parser, event, data) {
        parser[event] && parser[event](data);
      }
      function emitNode(parser, nodeType, data) {
        if (parser.textNode) closeText(parser);
        emit(parser, nodeType, data);
      }
      function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode);
        if (parser.textNode) emit(parser, 'ontext', parser.textNode);
        parser.textNode = '';
      }
      function textopts(opt, text) {
        if (opt.trim) text = text.trim();
        if (opt.normalize) text = text.replace(/\s+/g, ' ');
        return text;
      }
      function error(parser, er) {
        closeText(parser);
        if (parser.trackPosition) {
          er += '\nLine: ' + parser.line + '\nColumn: ' + parser.column + '\nChar: ' + parser.c;
        }
        er = new Error(er);
        parser.error = er;
        emit(parser, 'onerror', er);
        return parser;
      }
      function end(parser) {
        if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag');
        if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
          error(parser, 'Unexpected end');
        }
        closeText(parser);
        parser.c = '';
        parser.closed = true;
        emit(parser, 'onend');
        SAXParser.call(parser, parser.strict, parser.opt);
        return parser;
      }
      function strictFail(parser, message) {
        if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {
          throw new Error('bad call to strictFail');
        }
        if (parser.strict) {
          error(parser, message);
        }
      }
      function newTag(parser) {
        if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
        var parent = parser.tags[parser.tags.length - 1] || parser;
        var tag = parser.tag = {
          name: parser.tagName,
          attributes: {}
        };

        // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
        if (parser.opt.xmlns) {
          tag.ns = parent.ns;
        }
        parser.attribList.length = 0;
        emitNode(parser, 'onopentagstart', tag);
      }
      function qname(name, attribute) {
        var i = name.indexOf(':');
        var qualName = i < 0 ? ['', name] : name.split(':');
        var prefix = qualName[0];
        var local = qualName[1];

        // <x "xmlns"="http://foo">
        if (attribute && name === 'xmlns') {
          prefix = 'xmlns';
          local = '';
        }
        return {
          prefix: prefix,
          local: local
        };
      }
      function attrib(parser) {
        if (!parser.strict) {
          parser.attribName = parser.attribName[parser.looseCase]();
        }
        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
          parser.attribName = parser.attribValue = '';
          return;
        }
        if (parser.opt.xmlns) {
          var qn = qname(parser.attribName, true);
          var prefix = qn.prefix;
          var local = qn.local;
          if (prefix === 'xmlns') {
            // namespace binding attribute. push the binding into scope
            if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {
              strictFail(parser, 'xml: prefix must be bound to ' + XML_NAMESPACE + '\n' + 'Actual: ' + parser.attribValue);
            } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {
              strictFail(parser, 'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\n' + 'Actual: ' + parser.attribValue);
            } else {
              var tag = parser.tag;
              var parent = parser.tags[parser.tags.length - 1] || parser;
              if (tag.ns === parent.ns) {
                tag.ns = Object.create(parent.ns);
              }
              tag.ns[local] = parser.attribValue;
            }
          }

          // defer onattribute events until all attributes have been seen
          // so any new bindings can take effect. preserve attribute order
          // so deferred events can be emitted in document order
          parser.attribList.push([parser.attribName, parser.attribValue]);
        } else {
          // in non-xmlns mode, we can emit the event right away
          parser.tag.attributes[parser.attribName] = parser.attribValue;
          emitNode(parser, 'onattribute', {
            name: parser.attribName,
            value: parser.attribValue
          });
        }
        parser.attribName = parser.attribValue = '';
      }
      function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
          // emit namespace binding events
          var tag = parser.tag;

          // add namespace info to tag
          var qn = qname(parser.tagName);
          tag.prefix = qn.prefix;
          tag.local = qn.local;
          tag.uri = tag.ns[qn.prefix] || '';
          if (tag.prefix && !tag.uri) {
            strictFail(parser, 'Unbound namespace prefix: ' + JSON.stringify(parser.tagName));
            tag.uri = qn.prefix;
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (tag.ns && parent.ns !== tag.ns) {
            Object.keys(tag.ns).forEach(function (p) {
              emitNode(parser, 'onopennamespace', {
                prefix: p,
                uri: tag.ns[p]
              });
            });
          }

          // handle deferred onattribute events
          // Note: do not apply default ns to attributes:
          //   http://www.w3.org/TR/REC-xml-names/#defaulting
          for (var i = 0, l = parser.attribList.length; i < l; i++) {
            var nv = parser.attribList[i];
            var name = nv[0];
            var value = nv[1];
            var qualName = qname(name, true);
            var prefix = qualName.prefix;
            var local = qualName.local;
            var uri = prefix === '' ? '' : tag.ns[prefix] || '';
            var a = {
              name: name,
              value: value,
              prefix: prefix,
              local: local,
              uri: uri
            };

            // if there's any attributes with an undefined namespace,
            // then fail on them now.
            if (prefix && prefix !== 'xmlns' && !uri) {
              strictFail(parser, 'Unbound namespace prefix: ' + JSON.stringify(prefix));
              a.uri = prefix;
            }
            parser.tag.attributes[name] = a;
            emitNode(parser, 'onattribute', a);
          }
          parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing;

        // process the tag
        parser.sawRoot = true;
        parser.tags.push(parser.tag);
        emitNode(parser, 'onopentag', parser.tag);
        if (!selfClosing) {
          // special case for <script> in non-strict mode.
          if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {
            parser.state = S.SCRIPT;
          } else {
            parser.state = S.TEXT;
          }
          parser.tag = null;
          parser.tagName = '';
        }
        parser.attribName = parser.attribValue = '';
        parser.attribList.length = 0;
      }
      function closeTag(parser) {
        if (!parser.tagName) {
          strictFail(parser, 'Weird empty close tag.');
          parser.textNode += '</>';
          parser.state = S.TEXT;
          return;
        }
        if (parser.script) {
          if (parser.tagName !== 'script') {
            parser.script += '</' + parser.tagName + '>';
            parser.tagName = '';
            parser.state = S.SCRIPT;
            return;
          }
          emitNode(parser, 'onscript', parser.script);
          parser.script = '';
        }

        // first make sure that the closing tag actually exists.
        // <a><b></c></b></a> will close everything, otherwise.
        var t = parser.tags.length;
        var tagName = parser.tagName;
        if (!parser.strict) {
          tagName = tagName[parser.looseCase]();
        }
        var closeTo = tagName;
        while (t--) {
          var close = parser.tags[t];
          if (close.name !== closeTo) {
            // fail the first time in strict mode
            strictFail(parser, 'Unexpected close tag');
          } else {
            break;
          }
        }

        // didn't find it.  we already failed for strict, so just abort.
        if (t < 0) {
          strictFail(parser, 'Unmatched closing tag: ' + parser.tagName);
          parser.textNode += '</' + parser.tagName + '>';
          parser.state = S.TEXT;
          return;
        }
        parser.tagName = tagName;
        var s = parser.tags.length;
        while (s-- > t) {
          var tag = parser.tag = parser.tags.pop();
          parser.tagName = parser.tag.name;
          emitNode(parser, 'onclosetag', parser.tagName);
          var x = {};
          for (var i in tag.ns) {
            x[i] = tag.ns[i];
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (parser.opt.xmlns && tag.ns !== parent.ns) {
            // remove namespace bindings introduced by tag
            Object.keys(tag.ns).forEach(function (p) {
              var n = tag.ns[p];
              emitNode(parser, 'onclosenamespace', {
                prefix: p,
                uri: n
              });
            });
          }
        }
        if (t === 0) parser.closedRoot = true;
        parser.tagName = parser.attribValue = parser.attribName = '';
        parser.attribList.length = 0;
        parser.state = S.TEXT;
      }
      function parseEntity(parser) {
        var entity = parser.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = '';
        if (parser.ENTITIES[entity]) {
          return parser.ENTITIES[entity];
        }
        if (parser.ENTITIES[entityLC]) {
          return parser.ENTITIES[entityLC];
        }
        entity = entityLC;
        if (entity.charAt(0) === '#') {
          if (entity.charAt(1) === 'x') {
            entity = entity.slice(2);
            num = parseInt(entity, 16);
            numStr = num.toString(16);
          } else {
            entity = entity.slice(1);
            num = parseInt(entity, 10);
            numStr = num.toString(10);
          }
        }
        entity = entity.replace(/^0+/, '');
        if (isNaN(num) || numStr.toLowerCase() !== entity) {
          strictFail(parser, 'Invalid character entity');
          return '&' + parser.entity + ';';
        }
        return String.fromCodePoint(num);
      }
      function beginWhiteSpace(parser, c) {
        if (c === '<') {
          parser.state = S.OPEN_WAKA;
          parser.startTagPosition = parser.position;
        } else if (!isWhitespace(c)) {
          // have to process this as a text node.
          // weird, but happens.
          strictFail(parser, 'Non-whitespace before first tag.');
          parser.textNode = c;
          parser.state = S.TEXT;
        }
      }
      function charAt(chunk, i) {
        var result = '';
        if (i < chunk.length) {
          result = chunk.charAt(i);
        }
        return result;
      }
      function write(chunk) {
        var parser = this;
        if (this.error) {
          throw this.error;
        }
        if (parser.closed) {
          return error(parser, 'Cannot write after close. Assign an onready handler.');
        }
        if (chunk === null) {
          return end(parser);
        }
        if (typeof chunk === 'object') {
          chunk = chunk.toString();
        }
        var i = 0;
        var c = '';
        while (true) {
          c = charAt(chunk, i++);
          parser.c = c;
          if (!c) {
            break;
          }
          if (parser.trackPosition) {
            parser.position++;
            if (c === '\n') {
              parser.line++;
              parser.column = 0;
            } else {
              parser.column++;
            }
          }
          switch (parser.state) {
            case S.BEGIN:
              parser.state = S.BEGIN_WHITESPACE;
              if (c === '\uFEFF') {
                continue;
              }
              beginWhiteSpace(parser, c);
              continue;
            case S.BEGIN_WHITESPACE:
              beginWhiteSpace(parser, c);
              continue;
            case S.TEXT:
              if (parser.sawRoot && !parser.closedRoot) {
                var starti = i - 1;
                while (c && c !== '<' && c !== '&') {
                  c = charAt(chunk, i++);
                  if (c && parser.trackPosition) {
                    parser.position++;
                    if (c === '\n') {
                      parser.line++;
                      parser.column = 0;
                    } else {
                      parser.column++;
                    }
                  }
                }
                parser.textNode += chunk.substring(starti, i - 1);
              }
              if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                parser.state = S.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else {
                if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                  strictFail(parser, 'Text data outside of root node.');
                }
                if (c === '&') {
                  parser.state = S.TEXT_ENTITY;
                } else {
                  parser.textNode += c;
                }
              }
              continue;
            case S.SCRIPT:
              // only non-strict
              if (c === '<') {
                parser.state = S.SCRIPT_ENDING;
              } else {
                parser.script += c;
              }
              continue;
            case S.SCRIPT_ENDING:
              if (c === '/') {
                parser.state = S.CLOSE_TAG;
              } else {
                parser.script += '<' + c;
                parser.state = S.SCRIPT;
              }
              continue;
            case S.OPEN_WAKA:
              // either a /, ?, !, or text is coming next.
              if (c === '!') {
                parser.state = S.SGML_DECL;
                parser.sgmlDecl = '';
              } else if (isWhitespace(c)) ; else if (isMatch(nameStart, c)) {
                parser.state = S.OPEN_TAG;
                parser.tagName = c;
              } else if (c === '/') {
                parser.state = S.CLOSE_TAG;
                parser.tagName = '';
              } else if (c === '?') {
                parser.state = S.PROC_INST;
                parser.procInstName = parser.procInstBody = '';
              } else {
                strictFail(parser, 'Unencoded <');
                // if there was some whitespace, then add that in.
                if (parser.startTagPosition + 1 < parser.position) {
                  var pad = parser.position - parser.startTagPosition;
                  c = new Array(pad).join(' ') + c;
                }
                parser.textNode += '<' + c;
                parser.state = S.TEXT;
              }
              continue;
            case S.SGML_DECL:
              if (parser.sgmlDecl + c === '--') {
                parser.state = S.COMMENT;
                parser.comment = '';
                parser.sgmlDecl = '';
                continue;
              }
              if (parser.doctype && parser.doctype !== true && parser.sgmlDecl) {
                parser.state = S.DOCTYPE_DTD;
                parser.doctype += '<!' + parser.sgmlDecl + c;
                parser.sgmlDecl = '';
              } else if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                emitNode(parser, 'onopencdata');
                parser.state = S.CDATA;
                parser.sgmlDecl = '';
                parser.cdata = '';
              } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                parser.state = S.DOCTYPE;
                if (parser.doctype || parser.sawRoot) {
                  strictFail(parser, 'Inappropriately located doctype declaration');
                }
                parser.doctype = '';
                parser.sgmlDecl = '';
              } else if (c === '>') {
                emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl);
                parser.sgmlDecl = '';
                parser.state = S.TEXT;
              } else if (isQuote(c)) {
                parser.state = S.SGML_DECL_QUOTED;
                parser.sgmlDecl += c;
              } else {
                parser.sgmlDecl += c;
              }
              continue;
            case S.SGML_DECL_QUOTED:
              if (c === parser.q) {
                parser.state = S.SGML_DECL;
                parser.q = '';
              }
              parser.sgmlDecl += c;
              continue;
            case S.DOCTYPE:
              if (c === '>') {
                parser.state = S.TEXT;
                emitNode(parser, 'ondoctype', parser.doctype);
                parser.doctype = true; // just remember that we saw it.
              } else {
                parser.doctype += c;
                if (c === '[') {
                  parser.state = S.DOCTYPE_DTD;
                } else if (isQuote(c)) {
                  parser.state = S.DOCTYPE_QUOTED;
                  parser.q = c;
                }
              }
              continue;
            case S.DOCTYPE_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.q = '';
                parser.state = S.DOCTYPE;
              }
              continue;
            case S.DOCTYPE_DTD:
              if (c === ']') {
                parser.doctype += c;
                parser.state = S.DOCTYPE;
              } else if (c === '<') {
                parser.state = S.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else if (isQuote(c)) {
                parser.doctype += c;
                parser.state = S.DOCTYPE_DTD_QUOTED;
                parser.q = c;
              } else {
                parser.doctype += c;
              }
              continue;
            case S.DOCTYPE_DTD_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.state = S.DOCTYPE_DTD;
                parser.q = '';
              }
              continue;
            case S.COMMENT:
              if (c === '-') {
                parser.state = S.COMMENT_ENDING;
              } else {
                parser.comment += c;
              }
              continue;
            case S.COMMENT_ENDING:
              if (c === '-') {
                parser.state = S.COMMENT_ENDED;
                parser.comment = textopts(parser.opt, parser.comment);
                if (parser.comment) {
                  emitNode(parser, 'oncomment', parser.comment);
                }
                parser.comment = '';
              } else {
                parser.comment += '-' + c;
                parser.state = S.COMMENT;
              }
              continue;
            case S.COMMENT_ENDED:
              if (c !== '>') {
                strictFail(parser, 'Malformed comment');
                // allow <!-- blah -- bloo --> in non-strict mode,
                // which is a comment of " blah -- bloo "
                parser.comment += '--' + c;
                parser.state = S.COMMENT;
              } else if (parser.doctype && parser.doctype !== true) {
                parser.state = S.DOCTYPE_DTD;
              } else {
                parser.state = S.TEXT;
              }
              continue;
            case S.CDATA:
              if (c === ']') {
                parser.state = S.CDATA_ENDING;
              } else {
                parser.cdata += c;
              }
              continue;
            case S.CDATA_ENDING:
              if (c === ']') {
                parser.state = S.CDATA_ENDING_2;
              } else {
                parser.cdata += ']' + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.CDATA_ENDING_2:
              if (c === '>') {
                if (parser.cdata) {
                  emitNode(parser, 'oncdata', parser.cdata);
                }
                emitNode(parser, 'onclosecdata');
                parser.cdata = '';
                parser.state = S.TEXT;
              } else if (c === ']') {
                parser.cdata += ']';
              } else {
                parser.cdata += ']]' + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.PROC_INST:
              if (c === '?') {
                parser.state = S.PROC_INST_ENDING;
              } else if (isWhitespace(c)) {
                parser.state = S.PROC_INST_BODY;
              } else {
                parser.procInstName += c;
              }
              continue;
            case S.PROC_INST_BODY:
              if (!parser.procInstBody && isWhitespace(c)) {
                continue;
              } else if (c === '?') {
                parser.state = S.PROC_INST_ENDING;
              } else {
                parser.procInstBody += c;
              }
              continue;
            case S.PROC_INST_ENDING:
              if (c === '>') {
                emitNode(parser, 'onprocessinginstruction', {
                  name: parser.procInstName,
                  body: parser.procInstBody
                });
                parser.procInstName = parser.procInstBody = '';
                parser.state = S.TEXT;
              } else {
                parser.procInstBody += '?' + c;
                parser.state = S.PROC_INST_BODY;
              }
              continue;
            case S.OPEN_TAG:
              if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else {
                newTag(parser);
                if (c === '>') {
                  openTag(parser);
                } else if (c === '/') {
                  parser.state = S.OPEN_TAG_SLASH;
                } else {
                  if (!isWhitespace(c)) {
                    strictFail(parser, 'Invalid character in tag name');
                  }
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.OPEN_TAG_SLASH:
              if (c === '>') {
                openTag(parser, true);
                closeTag(parser);
              } else {
                strictFail(parser, 'Forward-slash in opening tag not followed by >');
                parser.state = S.ATTRIB;
              }
              continue;
            case S.ATTRIB:
              // haven't read the attribute name yet.
              if (isWhitespace(c)) {
                continue;
              } else if (c === '>') {
                openTag(parser);
              } else if (c === '/') {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                parser.attribName = c;
                parser.attribValue = '';
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, 'Invalid attribute name');
              }
              continue;
            case S.ATTRIB_NAME:
              if (c === '=') {
                parser.state = S.ATTRIB_VALUE;
              } else if (c === '>') {
                strictFail(parser, 'Attribute without value');
                parser.attribValue = parser.attribName;
                attrib(parser);
                openTag(parser);
              } else if (isWhitespace(c)) {
                parser.state = S.ATTRIB_NAME_SAW_WHITE;
              } else if (isMatch(nameBody, c)) {
                parser.attribName += c;
              } else {
                strictFail(parser, 'Invalid attribute name');
              }
              continue;
            case S.ATTRIB_NAME_SAW_WHITE:
              if (c === '=') {
                parser.state = S.ATTRIB_VALUE;
              } else if (isWhitespace(c)) {
                continue;
              } else {
                strictFail(parser, 'Attribute without value');
                parser.tag.attributes[parser.attribName] = '';
                parser.attribValue = '';
                emitNode(parser, 'onattribute', {
                  name: parser.attribName,
                  value: ''
                });
                parser.attribName = '';
                if (c === '>') {
                  openTag(parser);
                } else if (isMatch(nameStart, c)) {
                  parser.attribName = c;
                  parser.state = S.ATTRIB_NAME;
                } else {
                  strictFail(parser, 'Invalid attribute name');
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.ATTRIB_VALUE:
              if (isWhitespace(c)) {
                continue;
              } else if (isQuote(c)) {
                parser.q = c;
                parser.state = S.ATTRIB_VALUE_QUOTED;
              } else {
                if (!parser.opt.unquotedAttributeValues) {
                  error(parser, 'Unquoted attribute value');
                }
                parser.state = S.ATTRIB_VALUE_UNQUOTED;
                parser.attribValue = c;
              }
              continue;
            case S.ATTRIB_VALUE_QUOTED:
              if (c !== parser.q) {
                if (c === '&') {
                  parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              parser.q = '';
              parser.state = S.ATTRIB_VALUE_CLOSED;
              continue;
            case S.ATTRIB_VALUE_CLOSED:
              if (isWhitespace(c)) {
                parser.state = S.ATTRIB;
              } else if (c === '>') {
                openTag(parser);
              } else if (c === '/') {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                strictFail(parser, 'No whitespace between attributes');
                parser.attribName = c;
                parser.attribValue = '';
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, 'Invalid attribute name');
              }
              continue;
            case S.ATTRIB_VALUE_UNQUOTED:
              if (!isAttribEnd(c)) {
                if (c === '&') {
                  parser.state = S.ATTRIB_VALUE_ENTITY_U;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              if (c === '>') {
                openTag(parser);
              } else {
                parser.state = S.ATTRIB;
              }
              continue;
            case S.CLOSE_TAG:
              if (!parser.tagName) {
                if (isWhitespace(c)) {
                  continue;
                } else if (notMatch(nameStart, c)) {
                  if (parser.script) {
                    parser.script += '</' + c;
                    parser.state = S.SCRIPT;
                  } else {
                    strictFail(parser, 'Invalid tagname in closing tag.');
                  }
                } else {
                  parser.tagName = c;
                }
              } else if (c === '>') {
                closeTag(parser);
              } else if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else if (parser.script) {
                parser.script += '</' + parser.tagName;
                parser.tagName = '';
                parser.state = S.SCRIPT;
              } else {
                if (!isWhitespace(c)) {
                  strictFail(parser, 'Invalid tagname in closing tag');
                }
                parser.state = S.CLOSE_TAG_SAW_WHITE;
              }
              continue;
            case S.CLOSE_TAG_SAW_WHITE:
              if (isWhitespace(c)) {
                continue;
              }
              if (c === '>') {
                closeTag(parser);
              } else {
                strictFail(parser, 'Invalid characters in closing tag');
              }
              continue;
            case S.TEXT_ENTITY:
            case S.ATTRIB_VALUE_ENTITY_Q:
            case S.ATTRIB_VALUE_ENTITY_U:
              var returnState;
              var buffer;
              switch (parser.state) {
                case S.TEXT_ENTITY:
                  returnState = S.TEXT;
                  buffer = 'textNode';
                  break;
                case S.ATTRIB_VALUE_ENTITY_Q:
                  returnState = S.ATTRIB_VALUE_QUOTED;
                  buffer = 'attribValue';
                  break;
                case S.ATTRIB_VALUE_ENTITY_U:
                  returnState = S.ATTRIB_VALUE_UNQUOTED;
                  buffer = 'attribValue';
                  break;
              }
              if (c === ';') {
                var parsedEntity = parseEntity(parser);
                if (parser.opt.unparsedEntities && !Object.values(sax.XML_ENTITIES).includes(parsedEntity)) {
                  parser.entity = '';
                  parser.state = returnState;
                  parser.write(parsedEntity);
                } else {
                  parser[buffer] += parsedEntity;
                  parser.entity = '';
                  parser.state = returnState;
                }
              } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
                parser.entity += c;
              } else {
                strictFail(parser, 'Invalid character in entity name');
                parser[buffer] += '&' + parser.entity + c;
                parser.entity = '';
                parser.state = returnState;
              }
              continue;
            default:
              /* istanbul ignore next */{
                throw new Error(parser, 'Unknown state: ' + parser.state);
              }
          }
        } // while

        if (parser.position >= parser.bufferCheckPosition) {
          checkBufferLength(parser);
        }
        return parser;
      }

      /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
      /* istanbul ignore next */
      if (!String.fromCodePoint) {
        (function () {
          var stringFromCharCode = String.fromCharCode;
          var floor = Math.floor;
          var fromCodePoint = function () {
            var MAX_SIZE = 0x4000;
            var codeUnits = [];
            var highSurrogate;
            var lowSurrogate;
            var index = -1;
            var length = arguments.length;
            if (!length) {
              return '';
            }
            var result = '';
            while (++index < length) {
              var codePoint = Number(arguments[index]);
              if (!isFinite(codePoint) ||
              // `NaN`, `+Infinity`, or `-Infinity`
              codePoint < 0 ||
              // not a valid Unicode code point
              codePoint > 0x10FFFF ||
              // not a valid Unicode code point
              floor(codePoint) !== codePoint // not an integer
              ) {
                throw RangeError('Invalid code point: ' + codePoint);
              }
              if (codePoint <= 0xFFFF) {
                // BMP code point
                codeUnits.push(codePoint);
              } else {
                // Astral code point; split in surrogate halves
                // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                codePoint -= 0x10000;
                highSurrogate = (codePoint >> 10) + 0xD800;
                lowSurrogate = codePoint % 0x400 + 0xDC00;
                codeUnits.push(highSurrogate, lowSurrogate);
              }
              if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                result += stringFromCharCode.apply(null, codeUnits);
                codeUnits.length = 0;
              }
            }
            return result;
          };
          /* istanbul ignore next */
          if (Object.defineProperty) {
            Object.defineProperty(String, 'fromCodePoint', {
              value: fromCodePoint,
              configurable: true,
              writable: true
            });
          } else {
            String.fromCodePoint = fromCodePoint;
          }
        })();
      }
    })(exports);
  })(sax);
  return sax;
}

var hasRequiredSitemapParser;
function requireSitemapParser() {
  if (hasRequiredSitemapParser) return sitemapParser;
  hasRequiredSitemapParser = 1;
  var __importDefault = sitemapParser && sitemapParser.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(sitemapParser, "__esModule", {
    value: true
  });
  sitemapParser.ObjectStreamToJSON = sitemapParser.parseSitemap = sitemapParser.XMLToSitemapItemStream = void 0;
  const sax_1 = __importDefault(requireSax());
  const stream_1 = require$$0$4;
  const types_1 = requireTypes$2();
  function isValidTagName(tagName) {
    // This only works because the enum name and value are the same
    return tagName in types_1.TagNames;
  }
  function tagTemplate() {
    return {
      img: [],
      video: [],
      links: [],
      url: ''
    };
  }
  function videoTemplate() {
    return {
      tag: [],
      thumbnail_loc: '',
      title: '',
      description: ''
    };
  }
  const imageTemplate = {
    url: ''
  };
  const linkTemplate = {
    lang: '',
    url: ''
  };
  function newsTemplate() {
    return {
      publication: {
        name: '',
        language: ''
      },
      publication_date: '',
      title: ''
    };
  }
  const defaultLogger = (level, ...message) => console[level](...message);
  const defaultStreamOpts = {
    logger: defaultLogger
  };
  // TODO does this need to end with `options`
  /**
   * Takes a stream of xml and transforms it into a stream of SitemapItems
   * Use this to parse existing sitemaps into config options compatible with this library
   */
  class XMLToSitemapItemStream extends stream_1.Transform {
    constructor(opts = defaultStreamOpts) {
      var _a;
      opts.objectMode = true;
      super(opts);
      this.error = null;
      this.saxStream = sax_1.default.createStream(true, {
        xmlns: true,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        strictEntities: true,
        trim: true
      });
      this.level = opts.level || types_1.ErrorLevel.WARN;
      if (this.level !== types_1.ErrorLevel.SILENT && opts.logger !== false) {
        this.logger = (_a = opts.logger) !== null && _a !== void 0 ? _a : defaultLogger;
      } else {
        this.logger = () => undefined;
      }
      let currentItem = tagTemplate();
      let currentTag;
      let currentVideo = videoTemplate();
      let currentImage = {
        ...imageTemplate
      };
      let currentLink = {
        ...linkTemplate
      };
      let dontpushCurrentLink = false;
      this.saxStream.on('opentagstart', tag => {
        currentTag = tag.name;
        if (currentTag.startsWith('news:') && !currentItem.news) {
          currentItem.news = newsTemplate();
        }
      });
      this.saxStream.on('opentag', tag => {
        if (isValidTagName(tag.name)) {
          if (tag.name === 'xhtml:link') {
            if (typeof tag.attributes.rel === 'string' || typeof tag.attributes.href === 'string') {
              return;
            }
            if (tag.attributes.rel.value === 'alternate' && tag.attributes.hreflang) {
              currentLink.url = tag.attributes.href.value;
              if (typeof tag.attributes.hreflang === 'string') return;
              currentLink.lang = tag.attributes.hreflang.value;
            } else if (tag.attributes.rel.value === 'alternate') {
              dontpushCurrentLink = true;
              currentItem.androidLink = tag.attributes.href.value;
            } else if (tag.attributes.rel.value === 'amphtml') {
              dontpushCurrentLink = true;
              currentItem.ampLink = tag.attributes.href.value;
            } else {
              this.logger('log', 'unhandled attr for xhtml:link', tag.attributes);
              this.err(`unhandled attr for xhtml:link ${tag.attributes}`);
            }
          }
        } else {
          this.logger('warn', 'unhandled tag', tag.name);
          this.err(`unhandled tag: ${tag.name}`);
        }
      });
      this.saxStream.on('text', text => {
        switch (currentTag) {
          case 'mobile:mobile':
            break;
          case types_1.TagNames.loc:
            currentItem.url = text;
            break;
          case types_1.TagNames.changefreq:
            if ((0, types_1.isValidChangeFreq)(text)) {
              currentItem.changefreq = text;
            }
            break;
          case types_1.TagNames.priority:
            currentItem.priority = parseFloat(text);
            break;
          case types_1.TagNames.lastmod:
            currentItem.lastmod = text;
            break;
          case types_1.TagNames['video:thumbnail_loc']:
            currentVideo.thumbnail_loc = text;
            break;
          case types_1.TagNames['video:tag']:
            currentVideo.tag.push(text);
            break;
          case types_1.TagNames['video:duration']:
            currentVideo.duration = parseInt(text, 10);
            break;
          case types_1.TagNames['video:player_loc']:
            currentVideo.player_loc = text;
            break;
          case types_1.TagNames['video:content_loc']:
            currentVideo.content_loc = text;
            break;
          case types_1.TagNames['video:requires_subscription']:
            if ((0, types_1.isValidYesNo)(text)) {
              currentVideo.requires_subscription = text;
            }
            break;
          case types_1.TagNames['video:publication_date']:
            currentVideo.publication_date = text;
            break;
          case types_1.TagNames['video:id']:
            currentVideo.id = text;
            break;
          case types_1.TagNames['video:restriction']:
            currentVideo.restriction = text;
            break;
          case types_1.TagNames['video:view_count']:
            currentVideo.view_count = parseInt(text, 10);
            break;
          case types_1.TagNames['video:uploader']:
            currentVideo.uploader = text;
            break;
          case types_1.TagNames['video:family_friendly']:
            if ((0, types_1.isValidYesNo)(text)) {
              currentVideo.family_friendly = text;
            }
            break;
          case types_1.TagNames['video:expiration_date']:
            currentVideo.expiration_date = text;
            break;
          case types_1.TagNames['video:platform']:
            currentVideo.platform = text;
            break;
          case types_1.TagNames['video:price']:
            currentVideo.price = text;
            break;
          case types_1.TagNames['video:rating']:
            currentVideo.rating = parseFloat(text);
            break;
          case types_1.TagNames['video:category']:
            currentVideo.category = text;
            break;
          case types_1.TagNames['video:live']:
            if ((0, types_1.isValidYesNo)(text)) {
              currentVideo.live = text;
            }
            break;
          case types_1.TagNames['video:gallery_loc']:
            currentVideo.gallery_loc = text;
            break;
          case types_1.TagNames['image:loc']:
            currentImage.url = text;
            break;
          case types_1.TagNames['image:geo_location']:
            currentImage.geoLocation = text;
            break;
          case types_1.TagNames['image:license']:
            currentImage.license = text;
            break;
          case types_1.TagNames['news:access']:
            if (!currentItem.news) {
              currentItem.news = newsTemplate();
            }
            currentItem.news.access = text;
            break;
          case types_1.TagNames['news:genres']:
            if (!currentItem.news) {
              currentItem.news = newsTemplate();
            }
            currentItem.news.genres = text;
            break;
          case types_1.TagNames['news:publication_date']:
            if (!currentItem.news) {
              currentItem.news = newsTemplate();
            }
            currentItem.news.publication_date = text;
            break;
          case types_1.TagNames['news:keywords']:
            if (!currentItem.news) {
              currentItem.news = newsTemplate();
            }
            currentItem.news.keywords = text;
            break;
          case types_1.TagNames['news:stock_tickers']:
            if (!currentItem.news) {
              currentItem.news = newsTemplate();
            }
            currentItem.news.stock_tickers = text;
            break;
          case types_1.TagNames['news:language']:
            if (!currentItem.news) {
              currentItem.news = newsTemplate();
            }
            currentItem.news.publication.language = text;
            break;
          case types_1.TagNames['video:title']:
            currentVideo.title += text;
            break;
          case types_1.TagNames['video:description']:
            currentVideo.description += text;
            break;
          case types_1.TagNames['news:name']:
            if (!currentItem.news) {
              currentItem.news = newsTemplate();
            }
            currentItem.news.publication.name += text;
            break;
          case types_1.TagNames['news:title']:
            if (!currentItem.news) {
              currentItem.news = newsTemplate();
            }
            currentItem.news.title += text;
            break;
          case types_1.TagNames['image:caption']:
            if (!currentImage.caption) {
              currentImage.caption = text;
            } else {
              currentImage.caption += text;
            }
            break;
          case types_1.TagNames['image:title']:
            if (!currentImage.title) {
              currentImage.title = text;
            } else {
              currentImage.title += text;
            }
            break;
          default:
            this.logger('log', 'unhandled text for tag:', currentTag, `'${text}'`);
            this.err(`unhandled text for tag: ${currentTag} '${text}'`);
            break;
        }
      });
      this.saxStream.on('cdata', text => {
        switch (currentTag) {
          case types_1.TagNames['video:title']:
            currentVideo.title += text;
            break;
          case types_1.TagNames['video:description']:
            currentVideo.description += text;
            break;
          case types_1.TagNames['news:name']:
            if (!currentItem.news) {
              currentItem.news = newsTemplate();
            }
            currentItem.news.publication.name += text;
            break;
          case types_1.TagNames['news:title']:
            if (!currentItem.news) {
              currentItem.news = newsTemplate();
            }
            currentItem.news.title += text;
            break;
          case types_1.TagNames['image:caption']:
            if (!currentImage.caption) {
              currentImage.caption = text;
            } else {
              currentImage.caption += text;
            }
            break;
          case types_1.TagNames['image:title']:
            if (!currentImage.title) {
              currentImage.title = text;
            } else {
              currentImage.title += text;
            }
            break;
          default:
            this.logger('log', 'unhandled cdata for tag:', currentTag);
            this.err(`unhandled cdata for tag: ${currentTag}`);
            break;
        }
      });
      this.saxStream.on('attribute', attr => {
        switch (currentTag) {
          case types_1.TagNames['urlset']:
          case types_1.TagNames['xhtml:link']:
          case types_1.TagNames['video:id']:
            break;
          case types_1.TagNames['video:restriction']:
            if (attr.name === 'relationship' && (0, types_1.isAllowDeny)(attr.value)) {
              currentVideo['restriction:relationship'] = attr.value;
            } else {
              this.logger('log', 'unhandled attr', currentTag, attr.name);
              this.err(`unhandled attr: ${currentTag} ${attr.name}`);
            }
            break;
          case types_1.TagNames['video:price']:
            if (attr.name === 'type' && (0, types_1.isPriceType)(attr.value)) {
              currentVideo['price:type'] = attr.value;
            } else if (attr.name === 'currency') {
              currentVideo['price:currency'] = attr.value;
            } else if (attr.name === 'resolution' && (0, types_1.isResolution)(attr.value)) {
              currentVideo['price:resolution'] = attr.value;
            } else {
              this.logger('log', 'unhandled attr for video:price', attr.name);
              this.err(`unhandled attr: ${currentTag} ${attr.name}`);
            }
            break;
          case types_1.TagNames['video:player_loc']:
            if (attr.name === 'autoplay') {
              currentVideo['player_loc:autoplay'] = attr.value;
            } else if (attr.name === 'allow_embed' && (0, types_1.isValidYesNo)(attr.value)) {
              currentVideo['player_loc:allow_embed'] = attr.value;
            } else {
              this.logger('log', 'unhandled attr for video:player_loc', attr.name);
              this.err(`unhandled attr: ${currentTag} ${attr.name}`);
            }
            break;
          case types_1.TagNames['video:platform']:
            if (attr.name === 'relationship' && (0, types_1.isAllowDeny)(attr.value)) {
              currentVideo['platform:relationship'] = attr.value;
            } else {
              this.logger('log', 'unhandled attr for video:platform', attr.name, attr.value);
              this.err(`unhandled attr: ${currentTag} ${attr.name} ${attr.value}`);
            }
            break;
          case types_1.TagNames['video:gallery_loc']:
            if (attr.name === 'title') {
              currentVideo['gallery_loc:title'] = attr.value;
            } else {
              this.logger('log', 'unhandled attr for video:galler_loc', attr.name);
              this.err(`unhandled attr: ${currentTag} ${attr.name}`);
            }
            break;
          case types_1.TagNames['video:uploader']:
            if (attr.name === 'info') {
              currentVideo['uploader:info'] = attr.value;
            } else {
              this.logger('log', 'unhandled attr for video:uploader', attr.name);
              this.err(`unhandled attr: ${currentTag} ${attr.name}`);
            }
            break;
          default:
            this.logger('log', 'unhandled attr', currentTag, attr.name);
            this.err(`unhandled attr: ${currentTag} ${attr.name}`);
        }
      });
      this.saxStream.on('closetag', tag => {
        switch (tag) {
          case types_1.TagNames.url:
            this.push(currentItem);
            currentItem = tagTemplate();
            break;
          case types_1.TagNames['video:video']:
            currentItem.video.push(currentVideo);
            currentVideo = videoTemplate();
            break;
          case types_1.TagNames['image:image']:
            currentItem.img.push(currentImage);
            currentImage = {
              ...imageTemplate
            };
            break;
          case types_1.TagNames['xhtml:link']:
            if (!dontpushCurrentLink) {
              currentItem.links.push(currentLink);
            }
            currentLink = {
              ...linkTemplate
            };
            break;
        }
      });
    }
    _transform(data, encoding, callback) {
      try {
        const cb = () => callback(this.level === types_1.ErrorLevel.THROW ? this.error : null);
        // correcting the type here can be done without making it a breaking change
        // TODO fix this
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        if (!this.saxStream.write(data, encoding)) {
          this.saxStream.once('drain', cb);
        } else {
          process.nextTick(cb);
        }
      } catch (error) {
        callback(error);
      }
    }
    err(msg) {
      if (!this.error) this.error = new Error(msg);
    }
  }
  sitemapParser.XMLToSitemapItemStream = XMLToSitemapItemStream;
  /**
    Read xml and resolve with the configuration that would produce it or reject with
    an error
    ```
    const { createReadStream } = require('fs')
    const { parseSitemap, createSitemap } = require('sitemap')
    parseSitemap(createReadStream('./example.xml')).then(
      // produces the same xml
      // you can, of course, more practically modify it or store it
      (xmlConfig) => console.log(createSitemap(xmlConfig).toString()),
      (err) => console.log(err)
    )
    ```
    @param {Readable} xml what to parse
    @return {Promise<SitemapItem[]>} resolves with list of sitemap items that can be fed into a SitemapStream. Rejects with an Error object.
   */
  async function parseSitemap(xml) {
    const urls = [];
    return new Promise((resolve, reject) => {
      xml.pipe(new XMLToSitemapItemStream()).on('data', smi => urls.push(smi)).on('end', () => {
        resolve(urls);
      }).on('error', error => {
        reject(error);
      });
    });
  }
  sitemapParser.parseSitemap = parseSitemap;
  const defaultObjectStreamOpts = {
    lineSeparated: false
  };
  /**
   * A Transform that converts a stream of objects into a JSON Array or a line
   * separated stringified JSON
   * @param [lineSeparated=false] whether to separate entries by a new line or comma
   */
  class ObjectStreamToJSON extends stream_1.Transform {
    constructor(opts = defaultObjectStreamOpts) {
      opts.writableObjectMode = true;
      super(opts);
      this.lineSeparated = opts.lineSeparated;
      this.firstWritten = false;
    }
    _transform(chunk, encoding, cb) {
      if (!this.firstWritten) {
        this.firstWritten = true;
        if (!this.lineSeparated) {
          this.push('[');
        }
      } else if (this.lineSeparated) {
        this.push('\n');
      } else {
        this.push(',');
      }
      if (chunk) {
        this.push(JSON.stringify(chunk));
      }
      cb();
    }
    _flush(cb) {
      if (!this.lineSeparated) {
        this.push(']');
      }
      cb();
    }
  }
  sitemapParser.ObjectStreamToJSON = ObjectStreamToJSON;
  return sitemapParser;
}

var sitemapIndexParser = {};

var hasRequiredSitemapIndexParser;
function requireSitemapIndexParser() {
  if (hasRequiredSitemapIndexParser) return sitemapIndexParser;
  hasRequiredSitemapIndexParser = 1;
  var __importDefault = sitemapIndexParser && sitemapIndexParser.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(sitemapIndexParser, "__esModule", {
    value: true
  });
  sitemapIndexParser.IndexObjectStreamToJSON = sitemapIndexParser.parseSitemapIndex = sitemapIndexParser.XMLToSitemapIndexStream = void 0;
  const sax_1 = __importDefault(requireSax());
  const stream_1 = require$$0$4;
  const types_1 = requireTypes$2();
  function isValidTagName(tagName) {
    // This only works because the enum name and value are the same
    return tagName in types_1.IndexTagNames;
  }
  function tagTemplate() {
    return {
      url: ''
    };
  }
  const defaultLogger = (level, ...message) => console[level](...message);
  const defaultStreamOpts = {
    logger: defaultLogger
  };
  // TODO does this need to end with `options`
  /**
   * Takes a stream of xml and transforms it into a stream of IndexItems
   * Use this to parse existing sitemap indices into config options compatible with this library
   */
  class XMLToSitemapIndexStream extends stream_1.Transform {
    constructor(opts = defaultStreamOpts) {
      var _a;
      opts.objectMode = true;
      super(opts);
      this.saxStream = sax_1.default.createStream(true, {
        xmlns: true,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        strictEntities: true,
        trim: true
      });
      this.level = opts.level || types_1.ErrorLevel.WARN;
      if (this.level !== types_1.ErrorLevel.SILENT && opts.logger !== false) {
        this.logger = (_a = opts.logger) !== null && _a !== void 0 ? _a : defaultLogger;
      } else {
        this.logger = () => undefined;
      }
      let currentItem = tagTemplate();
      let currentTag;
      this.saxStream.on('opentagstart', tag => {
        currentTag = tag.name;
      });
      this.saxStream.on('opentag', tag => {
        if (!isValidTagName(tag.name)) {
          this.logger('warn', 'unhandled tag', tag.name);
        }
      });
      this.saxStream.on('text', text => {
        switch (currentTag) {
          case types_1.IndexTagNames.loc:
            currentItem.url = text;
            break;
          case types_1.IndexTagNames.lastmod:
            currentItem.lastmod = text;
            break;
          default:
            this.logger('log', 'unhandled text for tag:', currentTag, `'${text}'`);
            break;
        }
      });
      this.saxStream.on('cdata', _text => {
        switch (currentTag) {
          default:
            this.logger('log', 'unhandled cdata for tag:', currentTag);
            break;
        }
      });
      this.saxStream.on('attribute', attr => {
        switch (currentTag) {
          case types_1.IndexTagNames.sitemapindex:
            break;
          default:
            this.logger('log', 'unhandled attr', currentTag, attr.name);
        }
      });
      this.saxStream.on('closetag', tag => {
        switch (tag) {
          case types_1.IndexTagNames.sitemap:
            this.push(currentItem);
            currentItem = tagTemplate();
            break;
        }
      });
    }
    _transform(data, encoding, callback) {
      try {
        // correcting the type here can be done without making it a breaking change
        // TODO fix this
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        this.saxStream.write(data, encoding);
        callback();
      } catch (error) {
        callback(error);
      }
    }
  }
  sitemapIndexParser.XMLToSitemapIndexStream = XMLToSitemapIndexStream;
  /**
    Read xml and resolve with the configuration that would produce it or reject with
    an error
    ```
    const { createReadStream } = require('fs')
    const { parseSitemapIndex, createSitemap } = require('sitemap')
    parseSitemapIndex(createReadStream('./example-index.xml')).then(
      // produces the same xml
      // you can, of course, more practically modify it or store it
      (xmlConfig) => console.log(createSitemap(xmlConfig).toString()),
      (err) => console.log(err)
    )
    ```
    @param {Readable} xml what to parse
    @return {Promise<IndexItem[]>} resolves with list of index items that can be fed into a SitemapIndexStream. Rejects with an Error object.
   */
  async function parseSitemapIndex(xml) {
    const urls = [];
    return new Promise((resolve, reject) => {
      xml.pipe(new XMLToSitemapIndexStream()).on('data', smi => urls.push(smi)).on('end', () => {
        resolve(urls);
      }).on('error', error => {
        reject(error);
      });
    });
  }
  sitemapIndexParser.parseSitemapIndex = parseSitemapIndex;
  const defaultObjectStreamOpts = {
    lineSeparated: false
  };
  /**
   * A Transform that converts a stream of objects into a JSON Array or a line
   * separated stringified JSON
   * @param [lineSeparated=false] whether to separate entries by a new line or comma
   */
  class IndexObjectStreamToJSON extends stream_1.Transform {
    constructor(opts = defaultObjectStreamOpts) {
      opts.writableObjectMode = true;
      super(opts);
      this.lineSeparated = opts.lineSeparated;
      this.firstWritten = false;
    }
    _transform(chunk, encoding, cb) {
      if (!this.firstWritten) {
        this.firstWritten = true;
        if (!this.lineSeparated) {
          this.push('[');
        }
      } else if (this.lineSeparated) {
        this.push('\n');
      } else {
        this.push(',');
      }
      if (chunk) {
        this.push(JSON.stringify(chunk));
      }
      cb();
    }
    _flush(cb) {
      if (!this.lineSeparated) {
        this.push(']');
      }
      cb();
    }
  }
  sitemapIndexParser.IndexObjectStreamToJSON = IndexObjectStreamToJSON;
  return sitemapIndexParser;
}

var sitemapSimple = {};

var hasRequiredSitemapSimple;
function requireSitemapSimple() {
  if (hasRequiredSitemapSimple) return sitemapSimple;
  hasRequiredSitemapSimple = 1;
  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.simpleSitemapAndIndex = void 0;
    const sitemap_index_stream_1 = requireSitemapIndexStream();
    const sitemap_stream_1 = requireSitemapStream();
    const utils_1 = requireUtils$2();
    const zlib_1 = require$$3$2;
    const fs_1 = require$$0$5;
    const path_1 = require$$1$1;
    const stream_1 = require$$0$4;
    const util_1 = require$$5$1;
    const url_1 = require$$1$2;
    const pipeline = (0, util_1.promisify)(stream_1.pipeline);
    /**
     *
     * @param {object} options -
     * @param {string} options.hostname - The hostname for all URLs
     * @param {string} [options.sitemapHostname] - The hostname for the sitemaps if different than hostname
     * @param {SitemapItemLoose[] | string | Readable | string[]} options.sourceData - The urls you want to make a sitemap out of.
     * @param {string} options.destinationDir - where to write the sitemaps and index
     * @param {string} [options.publicBasePath] - where the sitemaps are relative to the hostname. Defaults to root.
     * @param {number} [options.limit] - how many URLs to write before switching to a new file. Defaults to 50k
     * @param {boolean} [options.gzip] - whether to compress the written files. Defaults to true
     * @returns {Promise<void>} an empty promise that resolves when everything is done
     */
    const simpleSitemapAndIndex = async ({
      hostname,
      sitemapHostname = hostname,
      // if different
      /**
       * Pass a line separated list of sitemap items or a stream or an array
       */
      sourceData,
      destinationDir,
      limit = 50000,
      gzip = true,
      publicBasePath = './'
    }) => {
      await fs_1.promises.mkdir(destinationDir, {
        recursive: true
      });
      const sitemapAndIndexStream = new sitemap_index_stream_1.SitemapAndIndexStream({
        limit,
        getSitemapStream: i => {
          const sitemapStream = new sitemap_stream_1.SitemapStream({
            hostname
          });
          const path = `./sitemap-${i}.xml`;
          const writePath = (0, path_1.resolve)(destinationDir, path + (gzip ? '.gz' : ''));
          if (!publicBasePath.endsWith('/')) {
            publicBasePath += '/';
          }
          const publicPath = (0, path_1.normalize)(publicBasePath + path);
          let pipeline;
          if (gzip) {
            pipeline = sitemapStream.pipe((0, zlib_1.createGzip)()) // compress the output of the sitemap
            .pipe((0, fs_1.createWriteStream)(writePath)); // write it to sitemap-NUMBER.xml
          } else {
            pipeline = sitemapStream.pipe((0, fs_1.createWriteStream)(writePath)); // write it to sitemap-NUMBER.xml
          }
          return [new url_1.URL(`${publicPath}${gzip ? '.gz' : ''}`, sitemapHostname).toString(), sitemapStream, pipeline];
        }
      });
      let src;
      if (typeof sourceData === 'string') {
        src = (0, utils_1.lineSeparatedURLsToSitemapOptions)((0, fs_1.createReadStream)(sourceData));
      } else if (sourceData instanceof stream_1.Readable) {
        src = sourceData;
      } else if (Array.isArray(sourceData)) {
        src = stream_1.Readable.from(sourceData);
      } else {
        throw new Error("unhandled source type. You've passed in data that is not supported");
      }
      const writePath = (0, path_1.resolve)(destinationDir, `./sitemap-index.xml${gzip ? '.gz' : ''}`);
      if (gzip) {
        return pipeline(src, sitemapAndIndexStream, (0, zlib_1.createGzip)(), (0, fs_1.createWriteStream)(writePath));
      } else {
        return pipeline(src, sitemapAndIndexStream, (0, fs_1.createWriteStream)(writePath));
      }
    };
    exports.simpleSitemapAndIndex = simpleSitemapAndIndex;
    exports.default = exports.simpleSitemapAndIndex;
  })(sitemapSimple);
  return sitemapSimple;
}

var hasRequiredDist$1;
function requireDist$1() {
  if (hasRequiredDist$1) return dist$1;
  hasRequiredDist$1 = 1;
  (function (exports) {

    var __createBinding = dist$1 && dist$1.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, {
        enumerable: true,
        get: function () {
          return m[k];
        }
      });
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = dist$1 && dist$1.__exportStar || function (m, exports) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.simpleSitemapAndIndex = exports.IndexObjectStreamToJSON = exports.XMLToSitemapIndexStream = exports.parseSitemapIndex = exports.ObjectStreamToJSON = exports.XMLToSitemapItemStream = exports.parseSitemap = exports.xmlLint = exports.ReadlineStream = exports.normalizeURL = exports.validateSMIOptions = exports.mergeStreams = exports.lineSeparatedURLsToSitemapOptions = exports.SitemapStream = exports.streamToPromise = exports.SitemapAndIndexStream = exports.SitemapIndexStream = exports.IndexTagNames = exports.SitemapItemStream = void 0;
    /*!
     * Sitemap
     * Copyright(c) 2011 Eugene Kalinin
     * MIT Licensed
     */
    var sitemap_item_stream_1 = requireSitemapItemStream();
    Object.defineProperty(exports, "SitemapItemStream", {
      enumerable: true,
      get: function () {
        return sitemap_item_stream_1.SitemapItemStream;
      }
    });
    var sitemap_index_stream_1 = requireSitemapIndexStream();
    Object.defineProperty(exports, "IndexTagNames", {
      enumerable: true,
      get: function () {
        return sitemap_index_stream_1.IndexTagNames;
      }
    });
    Object.defineProperty(exports, "SitemapIndexStream", {
      enumerable: true,
      get: function () {
        return sitemap_index_stream_1.SitemapIndexStream;
      }
    });
    Object.defineProperty(exports, "SitemapAndIndexStream", {
      enumerable: true,
      get: function () {
        return sitemap_index_stream_1.SitemapAndIndexStream;
      }
    });
    var sitemap_stream_1 = requireSitemapStream();
    Object.defineProperty(exports, "streamToPromise", {
      enumerable: true,
      get: function () {
        return sitemap_stream_1.streamToPromise;
      }
    });
    Object.defineProperty(exports, "SitemapStream", {
      enumerable: true,
      get: function () {
        return sitemap_stream_1.SitemapStream;
      }
    });
    __exportStar(requireErrors(), exports);
    __exportStar(requireTypes$2(), exports);
    var utils_1 = requireUtils$2();
    Object.defineProperty(exports, "lineSeparatedURLsToSitemapOptions", {
      enumerable: true,
      get: function () {
        return utils_1.lineSeparatedURLsToSitemapOptions;
      }
    });
    Object.defineProperty(exports, "mergeStreams", {
      enumerable: true,
      get: function () {
        return utils_1.mergeStreams;
      }
    });
    Object.defineProperty(exports, "validateSMIOptions", {
      enumerable: true,
      get: function () {
        return utils_1.validateSMIOptions;
      }
    });
    Object.defineProperty(exports, "normalizeURL", {
      enumerable: true,
      get: function () {
        return utils_1.normalizeURL;
      }
    });
    Object.defineProperty(exports, "ReadlineStream", {
      enumerable: true,
      get: function () {
        return utils_1.ReadlineStream;
      }
    });
    var xmllint_1 = requireXmllint();
    Object.defineProperty(exports, "xmlLint", {
      enumerable: true,
      get: function () {
        return xmllint_1.xmlLint;
      }
    });
    var sitemap_parser_1 = requireSitemapParser();
    Object.defineProperty(exports, "parseSitemap", {
      enumerable: true,
      get: function () {
        return sitemap_parser_1.parseSitemap;
      }
    });
    Object.defineProperty(exports, "XMLToSitemapItemStream", {
      enumerable: true,
      get: function () {
        return sitemap_parser_1.XMLToSitemapItemStream;
      }
    });
    Object.defineProperty(exports, "ObjectStreamToJSON", {
      enumerable: true,
      get: function () {
        return sitemap_parser_1.ObjectStreamToJSON;
      }
    });
    var sitemap_index_parser_1 = requireSitemapIndexParser();
    Object.defineProperty(exports, "parseSitemapIndex", {
      enumerable: true,
      get: function () {
        return sitemap_index_parser_1.parseSitemapIndex;
      }
    });
    Object.defineProperty(exports, "XMLToSitemapIndexStream", {
      enumerable: true,
      get: function () {
        return sitemap_index_parser_1.XMLToSitemapIndexStream;
      }
    });
    Object.defineProperty(exports, "IndexObjectStreamToJSON", {
      enumerable: true,
      get: function () {
        return sitemap_index_parser_1.IndexObjectStreamToJSON;
      }
    });
    var sitemap_simple_1 = requireSitemapSimple();
    Object.defineProperty(exports, "simpleSitemapAndIndex", {
      enumerable: true,
      get: function () {
        return sitemap_simple_1.simpleSitemapAndIndex;
      }
    });
  })(dist$1);
  return dist$1;
}

var moment$2 = {exports: {}};

var moment$1 = moment$2.exports;
var hasRequiredMoment;
function requireMoment() {
  if (hasRequiredMoment) return moment$2.exports;
  hasRequiredMoment = 1;
  (function (module, exports) {
    (function (global, factory) {
      module.exports = factory() ;
    })(moment$1, function () {

      var hookCallback;
      function hooks() {
        return hookCallback.apply(null, arguments);
      }

      // This is done to register the method called with moment()
      // without creating circular dependencies.
      function setHookCallback(callback) {
        hookCallback = callback;
      }
      function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
      }
      function isObject(input) {
        // IE8 will treat undefined and null as object if it wasn't for
        // input != null
        return input != null && Object.prototype.toString.call(input) === '[object Object]';
      }
      function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
      }
      function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
          return Object.getOwnPropertyNames(obj).length === 0;
        } else {
          var k;
          for (k in obj) {
            if (hasOwnProp(obj, k)) {
              return false;
            }
          }
          return true;
        }
      }
      function isUndefined(input) {
        return input === void 0;
      }
      function isNumber(input) {
        return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
      }
      function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
      }
      function map(arr, fn) {
        var res = [],
          i,
          arrLen = arr.length;
        for (i = 0; i < arrLen; ++i) {
          res.push(fn(arr[i], i));
        }
        return res;
      }
      function extend(a, b) {
        for (var i in b) {
          if (hasOwnProp(b, i)) {
            a[i] = b[i];
          }
        }
        if (hasOwnProp(b, 'toString')) {
          a.toString = b.toString;
        }
        if (hasOwnProp(b, 'valueOf')) {
          a.valueOf = b.valueOf;
        }
        return a;
      }
      function createUTC(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
      }
      function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
          empty: false,
          unusedTokens: [],
          unusedInput: [],
          overflow: -2,
          charsLeftOver: 0,
          nullInput: false,
          invalidEra: null,
          invalidMonth: null,
          invalidFormat: false,
          userInvalidated: false,
          iso: false,
          parsedDateParts: [],
          era: null,
          meridiem: null,
          rfc2822: false,
          weekdayMismatch: false
        };
      }
      function getParsingFlags(m) {
        if (m._pf == null) {
          m._pf = defaultParsingFlags();
        }
        return m._pf;
      }
      var some;
      if (Array.prototype.some) {
        some = Array.prototype.some;
      } else {
        some = function (fun) {
          var t = Object(this),
            len = t.length >>> 0,
            i;
          for (i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
              return true;
            }
          }
          return false;
        };
      }
      function isValid(m) {
        var flags = null,
          parsedParts = false,
          isNowValid = m._d && !isNaN(m._d.getTime());
        if (isNowValid) {
          flags = getParsingFlags(m);
          parsedParts = some.call(flags.parsedDateParts, function (i) {
            return i != null;
          });
          isNowValid = flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
          if (m._strict) {
            isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
          }
        }
        if (Object.isFrozen == null || !Object.isFrozen(m)) {
          m._isValid = isNowValid;
        } else {
          return isNowValid;
        }
        return m._isValid;
      }
      function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
          extend(getParsingFlags(m), flags);
        } else {
          getParsingFlags(m).userInvalidated = true;
        }
        return m;
      }

      // Plugins that add properties should also add the key here (null value),
      // so we can properly clone ourselves.
      var momentProperties = hooks.momentProperties = [],
        updateInProgress = false;
      function copyConfig(to, from) {
        var i,
          prop,
          val,
          momentPropertiesLen = momentProperties.length;
        if (!isUndefined(from._isAMomentObject)) {
          to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
          to._i = from._i;
        }
        if (!isUndefined(from._f)) {
          to._f = from._f;
        }
        if (!isUndefined(from._l)) {
          to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
          to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
          to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
          to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
          to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
          to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
          to._locale = from._locale;
        }
        if (momentPropertiesLen > 0) {
          for (i = 0; i < momentPropertiesLen; i++) {
            prop = momentProperties[i];
            val = from[prop];
            if (!isUndefined(val)) {
              to[prop] = val;
            }
          }
        }
        return to;
      }

      // Moment prototype object
      function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
          this._d = new Date(NaN);
        }
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
          updateInProgress = true;
          hooks.updateOffset(this);
          updateInProgress = false;
        }
      }
      function isMoment(obj) {
        return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
      }
      function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
          console.warn('Deprecation warning: ' + msg);
        }
      }
      function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function () {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
          }
          if (firstTime) {
            var args = [],
              arg,
              i,
              key,
              argLen = arguments.length;
            for (i = 0; i < argLen; i++) {
              arg = '';
              if (typeof arguments[i] === 'object') {
                arg += '\n[' + i + '] ';
                for (key in arguments[0]) {
                  if (hasOwnProp(arguments[0], key)) {
                    arg += key + ': ' + arguments[0][key] + ', ';
                  }
                }
                arg = arg.slice(0, -2); // Remove trailing comma and space
              } else {
                arg = arguments[i];
              }
              args.push(arg);
            }
            warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + new Error().stack);
            firstTime = false;
          }
          return fn.apply(this, arguments);
        }, fn);
      }
      var deprecations = {};
      function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
          warn(msg);
          deprecations[name] = true;
        }
      }
      hooks.suppressDeprecationWarnings = false;
      hooks.deprecationHandler = null;
      function isFunction(input) {
        return typeof Function !== 'undefined' && input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
      }
      function set(config) {
        var prop, i;
        for (i in config) {
          if (hasOwnProp(config, i)) {
            prop = config[i];
            if (isFunction(prop)) {
              this[i] = prop;
            } else {
              this['_' + i] = prop;
            }
          }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
        // TODO: Remove "ordinalParse" fallback in next major release.
        this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + '|' + /\d{1,2}/.source);
      }
      function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig),
          prop;
        for (prop in childConfig) {
          if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
              res[prop] = {};
              extend(res[prop], parentConfig[prop]);
              extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
              res[prop] = childConfig[prop];
            } else {
              delete res[prop];
            }
          }
        }
        for (prop in parentConfig) {
          if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
            // make sure changes to properties don't modify parent config
            res[prop] = extend({}, res[prop]);
          }
        }
        return res;
      }
      function Locale(config) {
        if (config != null) {
          this.set(config);
        }
      }
      var keys;
      if (Object.keys) {
        keys = Object.keys;
      } else {
        keys = function (obj) {
          var i,
            res = [];
          for (i in obj) {
            if (hasOwnProp(obj, i)) {
              res.push(i);
            }
          }
          return res;
        };
      }
      var defaultCalendar = {
        sameDay: '[Today at] LT',
        nextDay: '[Tomorrow at] LT',
        nextWeek: 'dddd [at] LT',
        lastDay: '[Yesterday at] LT',
        lastWeek: '[Last] dddd [at] LT',
        sameElse: 'L'
      };
      function calendar(key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
      }
      function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
          zerosToFill = targetLength - absNumber.length,
          sign = number >= 0;
        return (sign ? forceSign ? '+' : '' : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
      }
      var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
        formatFunctions = {},
        formatTokenFunctions = {};

      // token:    'M'
      // padded:   ['MM', 2]
      // ordinal:  'Mo'
      // callback: function () { this.month() + 1 }
      function addFormatToken(token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
          func = function () {
            return this[callback]();
          };
        }
        if (token) {
          formatTokenFunctions[token] = func;
        }
        if (padded) {
          formatTokenFunctions[padded[0]] = function () {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
          };
        }
        if (ordinal) {
          formatTokenFunctions[ordinal] = function () {
            return this.localeData().ordinal(func.apply(this, arguments), token);
          };
        }
      }
      function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
          return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
      }
      function makeFormatFunction(format) {
        var array = format.match(formattingTokens),
          i,
          length;
        for (i = 0, length = array.length; i < length; i++) {
          if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
          } else {
            array[i] = removeFormattingTokens(array[i]);
          }
        }
        return function (mom) {
          var output = '',
            i;
          for (i = 0; i < length; i++) {
            output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
          }
          return output;
        };
      }

      // format date using native date object
      function formatMoment(m, format) {
        if (!m.isValid()) {
          return m.localeData().invalidDate();
        }
        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
        return formatFunctions[format](m);
      }
      function expandFormat(format, locale) {
        var i = 5;
        function replaceLongDateFormatTokens(input) {
          return locale.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
          format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
          localFormattingTokens.lastIndex = 0;
          i -= 1;
        }
        return format;
      }
      var defaultLongDateFormat = {
        LTS: 'h:mm:ss A',
        LT: 'h:mm A',
        L: 'MM/DD/YYYY',
        LL: 'MMMM D, YYYY',
        LLL: 'MMMM D, YYYY h:mm A',
        LLLL: 'dddd, MMMM D, YYYY h:mm A'
      };
      function longDateFormat(key) {
        var format = this._longDateFormat[key],
          formatUpper = this._longDateFormat[key.toUpperCase()];
        if (format || !formatUpper) {
          return format;
        }
        this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function (tok) {
          if (tok === 'MMMM' || tok === 'MM' || tok === 'DD' || tok === 'dddd') {
            return tok.slice(1);
          }
          return tok;
        }).join('');
        return this._longDateFormat[key];
      }
      var defaultInvalidDate = 'Invalid date';
      function invalidDate() {
        return this._invalidDate;
      }
      var defaultOrdinal = '%d',
        defaultDayOfMonthOrdinalParse = /\d{1,2}/;
      function ordinal(number) {
        return this._ordinal.replace('%d', number);
      }
      var defaultRelativeTime = {
        future: 'in %s',
        past: '%s ago',
        s: 'a few seconds',
        ss: '%d seconds',
        m: 'a minute',
        mm: '%d minutes',
        h: 'an hour',
        hh: '%d hours',
        d: 'a day',
        dd: '%d days',
        w: 'a week',
        ww: '%d weeks',
        M: 'a month',
        MM: '%d months',
        y: 'a year',
        yy: '%d years'
      };
      function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
      }
      function pastFuture(diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
      }
      var aliases = {
        D: 'date',
        dates: 'date',
        date: 'date',
        d: 'day',
        days: 'day',
        day: 'day',
        e: 'weekday',
        weekdays: 'weekday',
        weekday: 'weekday',
        E: 'isoWeekday',
        isoweekdays: 'isoWeekday',
        isoweekday: 'isoWeekday',
        DDD: 'dayOfYear',
        dayofyears: 'dayOfYear',
        dayofyear: 'dayOfYear',
        h: 'hour',
        hours: 'hour',
        hour: 'hour',
        ms: 'millisecond',
        milliseconds: 'millisecond',
        millisecond: 'millisecond',
        m: 'minute',
        minutes: 'minute',
        minute: 'minute',
        M: 'month',
        months: 'month',
        month: 'month',
        Q: 'quarter',
        quarters: 'quarter',
        quarter: 'quarter',
        s: 'second',
        seconds: 'second',
        second: 'second',
        gg: 'weekYear',
        weekyears: 'weekYear',
        weekyear: 'weekYear',
        GG: 'isoWeekYear',
        isoweekyears: 'isoWeekYear',
        isoweekyear: 'isoWeekYear',
        w: 'week',
        weeks: 'week',
        week: 'week',
        W: 'isoWeek',
        isoweeks: 'isoWeek',
        isoweek: 'isoWeek',
        y: 'year',
        years: 'year',
        year: 'year'
      };
      function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
      }
      function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
          normalizedProp,
          prop;
        for (prop in inputObject) {
          if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
              normalizedInput[normalizedProp] = inputObject[prop];
            }
          }
        }
        return normalizedInput;
      }
      var priorities = {
        date: 9,
        day: 11,
        weekday: 11,
        isoWeekday: 11,
        dayOfYear: 4,
        hour: 13,
        millisecond: 16,
        minute: 14,
        month: 8,
        quarter: 7,
        second: 15,
        weekYear: 1,
        isoWeekYear: 1,
        week: 5,
        isoWeek: 5,
        year: 1
      };
      function getPrioritizedUnits(unitsObj) {
        var units = [],
          u;
        for (u in unitsObj) {
          if (hasOwnProp(unitsObj, u)) {
            units.push({
              unit: u,
              priority: priorities[u]
            });
          }
        }
        units.sort(function (a, b) {
          return a.priority - b.priority;
        });
        return units;
      }
      var match1 = /\d/,
        //       0 - 9
        match2 = /\d\d/,
        //      00 - 99
        match3 = /\d{3}/,
        //     000 - 999
        match4 = /\d{4}/,
        //    0000 - 9999
        match6 = /[+-]?\d{6}/,
        // -999999 - 999999
        match1to2 = /\d\d?/,
        //       0 - 99
        match3to4 = /\d\d\d\d?/,
        //     999 - 9999
        match5to6 = /\d\d\d\d\d\d?/,
        //   99999 - 999999
        match1to3 = /\d{1,3}/,
        //       0 - 999
        match1to4 = /\d{1,4}/,
        //       0 - 9999
        match1to6 = /[+-]?\d{1,6}/,
        // -999999 - 999999
        matchUnsigned = /\d+/,
        //       0 - inf
        matchSigned = /[+-]?\d+/,
        //    -inf - inf
        matchOffset = /Z|[+-]\d\d:?\d\d/gi,
        // +00:00 -00:00 +0000 -0000 or Z
        matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi,
        // +00 -00 +00:00 -00:00 +0000 -0000 or Z
        matchTimestamp = /[+-]?\d+(\.\d{1,3})?/,
        // 123456789 123456789.123
        // any word (or two) characters or numbers including two/three word month in arabic.
        // includes scottish gaelic two word and hyphenated months
        matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
        match1to2NoLeadingZero = /^[1-9]\d?/,
        //         1-99
        match1to2HasZero = /^([1-9]\d|\d)/,
        //           0-99
        regexes;
      regexes = {};
      function addRegexToken(token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
          return isStrict && strictRegex ? strictRegex : regex;
        };
      }
      function getParseRegexForToken(token, config) {
        if (!hasOwnProp(regexes, token)) {
          return new RegExp(unescapeFormat(token));
        }
        return regexes[token](config._strict, config._locale);
      }

      // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
      function unescapeFormat(s) {
        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
          return p1 || p2 || p3 || p4;
        }));
      }
      function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
      }
      function absFloor(number) {
        if (number < 0) {
          // -0 -> 0
          return Math.ceil(number) || 0;
        } else {
          return Math.floor(number);
        }
      }
      function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
          value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
          value = absFloor(coercedNumber);
        }
        return value;
      }
      var tokens = {};
      function addParseToken(token, callback) {
        var i,
          func = callback,
          tokenLen;
        if (typeof token === 'string') {
          token = [token];
        }
        if (isNumber(callback)) {
          func = function (input, array) {
            array[callback] = toInt(input);
          };
        }
        tokenLen = token.length;
        for (i = 0; i < tokenLen; i++) {
          tokens[token[i]] = func;
        }
      }
      function addWeekParseToken(token, callback) {
        addParseToken(token, function (input, array, config, token) {
          config._w = config._w || {};
          callback(input, config._w, config, token);
        });
      }
      function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
          tokens[token](input, config._a, config, token);
        }
      }
      function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
      }
      var YEAR = 0,
        MONTH = 1,
        DATE = 2,
        HOUR = 3,
        MINUTE = 4,
        SECOND = 5,
        MILLISECOND = 6,
        WEEK = 7,
        WEEKDAY = 8;

      // FORMATTING

      addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? zeroFill(y, 4) : '+' + y;
      });
      addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
      });
      addFormatToken(0, ['YYYY', 4], 0, 'year');
      addFormatToken(0, ['YYYYY', 5], 0, 'year');
      addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

      // PARSING

      addRegexToken('Y', matchSigned);
      addRegexToken('YY', match1to2, match2);
      addRegexToken('YYYY', match1to4, match4);
      addRegexToken('YYYYY', match1to6, match6);
      addRegexToken('YYYYYY', match1to6, match6);
      addParseToken(['YYYYY', 'YYYYYY'], YEAR);
      addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
      });
      addParseToken('YY', function (input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
      });
      addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
      });

      // HELPERS

      function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
      }

      // HOOKS

      hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
      };

      // MOMENTS

      var getSetYear = makeGetSet('FullYear', true);
      function getIsLeapYear() {
        return isLeapYear(this.year());
      }
      function makeGetSet(unit, keepTime) {
        return function (value) {
          if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
          } else {
            return get(this, unit);
          }
        };
      }
      function get(mom, unit) {
        if (!mom.isValid()) {
          return NaN;
        }
        var d = mom._d,
          isUTC = mom._isUTC;
        switch (unit) {
          case 'Milliseconds':
            return isUTC ? d.getUTCMilliseconds() : d.getMilliseconds();
          case 'Seconds':
            return isUTC ? d.getUTCSeconds() : d.getSeconds();
          case 'Minutes':
            return isUTC ? d.getUTCMinutes() : d.getMinutes();
          case 'Hours':
            return isUTC ? d.getUTCHours() : d.getHours();
          case 'Date':
            return isUTC ? d.getUTCDate() : d.getDate();
          case 'Day':
            return isUTC ? d.getUTCDay() : d.getDay();
          case 'Month':
            return isUTC ? d.getUTCMonth() : d.getMonth();
          case 'FullYear':
            return isUTC ? d.getUTCFullYear() : d.getFullYear();
          default:
            return NaN;
          // Just in case
        }
      }
      function set$1(mom, unit, value) {
        var d, isUTC, year, month, date;
        if (!mom.isValid() || isNaN(value)) {
          return;
        }
        d = mom._d;
        isUTC = mom._isUTC;
        switch (unit) {
          case 'Milliseconds':
            return void (isUTC ? d.setUTCMilliseconds(value) : d.setMilliseconds(value));
          case 'Seconds':
            return void (isUTC ? d.setUTCSeconds(value) : d.setSeconds(value));
          case 'Minutes':
            return void (isUTC ? d.setUTCMinutes(value) : d.setMinutes(value));
          case 'Hours':
            return void (isUTC ? d.setUTCHours(value) : d.setHours(value));
          case 'Date':
            return void (isUTC ? d.setUTCDate(value) : d.setDate(value));
          // case 'Day': // Not real
          //    return void (isUTC ? d.setUTCDay(value) : d.setDay(value));
          // case 'Month': // Not used because we need to pass two variables
          //     return void (isUTC ? d.setUTCMonth(value) : d.setMonth(value));
          case 'FullYear':
            break;
          // See below ...
          default:
            return;
          // Just in case
        }
        year = value;
        month = mom.month();
        date = mom.date();
        date = date === 29 && month === 1 && !isLeapYear(year) ? 28 : date;
        void (isUTC ? d.setUTCFullYear(year, month, date) : d.setFullYear(year, month, date));
      }

      // MOMENTS

      function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
          return this[units]();
        }
        return this;
      }
      function stringSet(units, value) {
        if (typeof units === 'object') {
          units = normalizeObjectUnits(units);
          var prioritized = getPrioritizedUnits(units),
            i,
            prioritizedLen = prioritized.length;
          for (i = 0; i < prioritizedLen; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
          }
        } else {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
            return this[units](value);
          }
        }
        return this;
      }
      function mod(n, x) {
        return (n % x + x) % x;
      }
      var indexOf;
      if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
      } else {
        indexOf = function (o) {
          // I know
          var i;
          for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
              return i;
            }
          }
          return -1;
        };
      }
      function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
          return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
      }

      // FORMATTING

      addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
      });
      addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
      });
      addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
      });

      // PARSING

      addRegexToken('M', match1to2, match1to2NoLeadingZero);
      addRegexToken('MM', match1to2, match2);
      addRegexToken('MMM', function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
      });
      addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
      });
      addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
      });
      addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
          array[MONTH] = month;
        } else {
          getParsingFlags(config).invalidMonth = input;
        }
      });

      // LOCALES

      var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
        defaultMonthsShortRegex = matchWord,
        defaultMonthsRegex = matchWord;
      function localeMonths(m, format) {
        if (!m) {
          return isArray(this._months) ? this._months : this._months['standalone'];
        }
        return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
      }
      function localeMonthsShort(m, format) {
        if (!m) {
          return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort['standalone'];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
      }
      function handleStrictParse(monthName, format, strict) {
        var i,
          ii,
          mom,
          llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
          // this is not used
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
          for (i = 0; i < 12; ++i) {
            mom = createUTC([2000, i]);
            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format === 'MMM') {
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format === 'MMM') {
            ii = indexOf.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeMonthsParse(monthName, format, strict) {
        var i, mom, regex;
        if (this._monthsParseExact) {
          return handleStrictParse.call(this, monthName, format, strict);
        }
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
          // make the regex if we don't have it already
          mom = createUTC([2000, i]);
          if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
          }
          if (!strict && !this._monthsParse[i]) {
            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
          }
          // test the regex
          if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
            return i;
          } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
            return i;
          } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
          }
        }
      }

      // MOMENTS

      function setMonth(mom, value) {
        if (!mom.isValid()) {
          // No op
          return mom;
        }
        if (typeof value === 'string') {
          if (/^\d+$/.test(value)) {
            value = toInt(value);
          } else {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (!isNumber(value)) {
              return mom;
            }
          }
        }
        var month = value,
          date = mom.date();
        date = date < 29 ? date : Math.min(date, daysInMonth(mom.year(), month));
        void (mom._isUTC ? mom._d.setUTCMonth(month, date) : mom._d.setMonth(month, date));
        return mom;
      }
      function getSetMonth(value) {
        if (value != null) {
          setMonth(this, value);
          hooks.updateOffset(this, true);
          return this;
        } else {
          return get(this, 'Month');
        }
      }
      function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
      }
      function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsShortStrictRegex;
          } else {
            return this._monthsShortRegex;
          }
        } else {
          if (!hasOwnProp(this, '_monthsShortRegex')) {
            this._monthsShortRegex = defaultMonthsShortRegex;
          }
          return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
        }
      }
      function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsStrictRegex;
          } else {
            return this._monthsRegex;
          }
        } else {
          if (!hasOwnProp(this, '_monthsRegex')) {
            this._monthsRegex = defaultMonthsRegex;
          }
          return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
        }
      }
      function computeMonthsParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var shortPieces = [],
          longPieces = [],
          mixedPieces = [],
          i,
          mom,
          shortP,
          longP;
        for (i = 0; i < 12; i++) {
          // make the regex if we don't have it already
          mom = createUTC([2000, i]);
          shortP = regexEscape(this.monthsShort(mom, ''));
          longP = regexEscape(this.months(mom, ''));
          shortPieces.push(shortP);
          longPieces.push(longP);
          mixedPieces.push(longP);
          mixedPieces.push(shortP);
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
      }
      function createDate(y, m, d, h, M, s, ms) {
        // can't just apply() to create a date:
        // https://stackoverflow.com/q/181348
        var date;
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
          // preserve leap years using a full 400 year cycle, then reset
          date = new Date(y + 400, m, d, h, M, s, ms);
          if (isFinite(date.getFullYear())) {
            date.setFullYear(y);
          }
        } else {
          date = new Date(y, m, d, h, M, s, ms);
        }
        return date;
      }
      function createUTCDate(y) {
        var date, args;
        // the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
          args = Array.prototype.slice.call(arguments);
          // preserve leap years using a full 400 year cycle, then reset
          args[0] = y + 400;
          date = new Date(Date.UTC.apply(null, args));
          if (isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
          }
        } else {
          date = new Date(Date.UTC.apply(null, arguments));
        }
        return date;
      }

      // start-of-first-week - start-of-year
      function firstWeekOffset(year, dow, doy) {
        var
          // first-week day -- which january is always in the first week (4 for iso, 1 for other)
          fwd = 7 + dow - doy,
          // first-week day local weekday -- which local weekday is fwd
          fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
        return -fwdlw + fwd - 1;
      }

      // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
      function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
          weekOffset = firstWeekOffset(year, dow, doy),
          dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
          resYear,
          resDayOfYear;
        if (dayOfYear <= 0) {
          resYear = year - 1;
          resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
          resYear = year + 1;
          resDayOfYear = dayOfYear - daysInYear(year);
        } else {
          resYear = year;
          resDayOfYear = dayOfYear;
        }
        return {
          year: resYear,
          dayOfYear: resDayOfYear
        };
      }
      function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
          week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
          resWeek,
          resYear;
        if (week < 1) {
          resYear = mom.year() - 1;
          resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
          resWeek = week - weeksInYear(mom.year(), dow, doy);
          resYear = mom.year() + 1;
        } else {
          resYear = mom.year();
          resWeek = week;
        }
        return {
          week: resWeek,
          year: resYear
        };
      }
      function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
          weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
      }

      // FORMATTING

      addFormatToken('w', ['ww', 2], 'wo', 'week');
      addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

      // PARSING

      addRegexToken('w', match1to2, match1to2NoLeadingZero);
      addRegexToken('ww', match1to2, match2);
      addRegexToken('W', match1to2, match1to2NoLeadingZero);
      addRegexToken('WW', match1to2, match2);
      addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
      });

      // HELPERS

      // LOCALES

      function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
      }
      var defaultLocaleWeek = {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 6 // The week that contains Jan 6th is the first week of the year.
      };
      function localeFirstDayOfWeek() {
        return this._week.dow;
      }
      function localeFirstDayOfYear() {
        return this._week.doy;
      }

      // MOMENTS

      function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
      }
      function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
      }

      // FORMATTING

      addFormatToken('d', 0, 'do', 'day');
      addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
      });
      addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
      });
      addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
      });
      addFormatToken('e', 0, 0, 'weekday');
      addFormatToken('E', 0, 0, 'isoWeekday');

      // PARSING

      addRegexToken('d', match1to2);
      addRegexToken('e', match1to2);
      addRegexToken('E', match1to2);
      addRegexToken('dd', function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
      });
      addRegexToken('ddd', function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
      });
      addRegexToken('dddd', function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
      });
      addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
          week.d = weekday;
        } else {
          getParsingFlags(config).invalidWeekday = input;
        }
      });
      addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
      });

      // HELPERS

      function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
          return input;
        }
        if (!isNaN(input)) {
          return parseInt(input, 10);
        }
        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
          return input;
        }
        return null;
      }
      function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
          return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
      }

      // LOCALES
      function shiftWeekdays(ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
      }
      var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        defaultWeekdaysRegex = matchWord,
        defaultWeekdaysShortRegex = matchWord,
        defaultWeekdaysMinRegex = matchWord;
      function localeWeekdays(m, format) {
        var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format) ? 'format' : 'standalone'];
        return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
      }
      function localeWeekdaysShort(m) {
        return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
      }
      function localeWeekdaysMin(m) {
        return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
      }
      function handleStrictParse$1(weekdayName, format, strict) {
        var i,
          ii,
          mom,
          llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._minWeekdaysParse = [];
          for (i = 0; i < 7; ++i) {
            mom = createUTC([2000, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format === 'dddd') {
            ii = indexOf.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format === 'ddd') {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format === 'dddd') {
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format === 'ddd') {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeWeekdaysParse(weekdayName, format, strict) {
        var i, mom, regex;
        if (this._weekdaysParseExact) {
          return handleStrictParse$1.call(this, weekdayName, format, strict);
        }
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._minWeekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._fullWeekdaysParse = [];
        }
        for (i = 0; i < 7; i++) {
          // make the regex if we don't have it already

          mom = createUTC([2000, 1]).day(i);
          if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
          }
          if (!this._weekdaysParse[i]) {
            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
          }
          // test the regex
          if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
          }
        }
      }

      // MOMENTS

      function getSetDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var day = get(this, 'Day');
        if (input != null) {
          input = parseWeekday(input, this.localeData());
          return this.add(input - day, 'd');
        } else {
          return day;
        }
      }
      function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
      }
      function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }

        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.

        if (input != null) {
          var weekday = parseIsoWeekday(input, this.localeData());
          return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
          return this.day() || 7;
        }
      }
      function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysStrictRegex;
          } else {
            return this._weekdaysRegex;
          }
        } else {
          if (!hasOwnProp(this, '_weekdaysRegex')) {
            this._weekdaysRegex = defaultWeekdaysRegex;
          }
          return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
        }
      }
      function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysShortStrictRegex;
          } else {
            return this._weekdaysShortRegex;
          }
        } else {
          if (!hasOwnProp(this, '_weekdaysShortRegex')) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
          }
          return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
      }
      function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysMinStrictRegex;
          } else {
            return this._weekdaysMinRegex;
          }
        } else {
          if (!hasOwnProp(this, '_weekdaysMinRegex')) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
          }
          return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
      }
      function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var minPieces = [],
          shortPieces = [],
          longPieces = [],
          mixedPieces = [],
          i,
          mom,
          minp,
          shortp,
          longp;
        for (i = 0; i < 7; i++) {
          // make the regex if we don't have it already
          mom = createUTC([2000, 1]).day(i);
          minp = regexEscape(this.weekdaysMin(mom, ''));
          shortp = regexEscape(this.weekdaysShort(mom, ''));
          longp = regexEscape(this.weekdays(mom, ''));
          minPieces.push(minp);
          shortPieces.push(shortp);
          longPieces.push(longp);
          mixedPieces.push(minp);
          mixedPieces.push(shortp);
          mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;
        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
      }

      // FORMATTING

      function hFormat() {
        return this.hours() % 12 || 12;
      }
      function kFormat() {
        return this.hours() || 24;
      }
      addFormatToken('H', ['HH', 2], 0, 'hour');
      addFormatToken('h', ['hh', 2], 0, hFormat);
      addFormatToken('k', ['kk', 2], 0, kFormat);
      addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
      });
      addFormatToken('hmmss', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
      });
      addFormatToken('Hmmss', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      function meridiem(token, lowercase) {
        addFormatToken(token, 0, 0, function () {
          return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
      }
      meridiem('a', true);
      meridiem('A', false);

      // PARSING

      function matchMeridiem(isStrict, locale) {
        return locale._meridiemParse;
      }
      addRegexToken('a', matchMeridiem);
      addRegexToken('A', matchMeridiem);
      addRegexToken('H', match1to2, match1to2HasZero);
      addRegexToken('h', match1to2, match1to2NoLeadingZero);
      addRegexToken('k', match1to2, match1to2NoLeadingZero);
      addRegexToken('HH', match1to2, match2);
      addRegexToken('hh', match1to2, match2);
      addRegexToken('kk', match1to2, match2);
      addRegexToken('hmm', match3to4);
      addRegexToken('hmmss', match5to6);
      addRegexToken('Hmm', match3to4);
      addRegexToken('Hmmss', match5to6);
      addParseToken(['H', 'HH'], HOUR);
      addParseToken(['k', 'kk'], function (input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
      });
      addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
      });
      addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
      });
      addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4,
          pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
      });
      addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4,
          pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
      });

      // LOCALES

      function localeIsPM(input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return (input + '').toLowerCase().charAt(0) === 'p';
      }
      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
        // Setting the hour should keep the time, because the user explicitly
        // specified which hour they want. So trying to maintain the same hour (in
        // a new timezone) makes sense. Adding/subtracting hours does not follow
        // this rule.
        getSetHour = makeGetSet('Hours', true);
      function localeMeridiem(hours, minutes, isLower) {
        if (hours > 11) {
          return isLower ? 'pm' : 'PM';
        } else {
          return isLower ? 'am' : 'AM';
        }
      }
      var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,
        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,
        week: defaultLocaleWeek,
        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,
        meridiemParse: defaultLocaleMeridiemParse
      };

      // internal storage for locale config files
      var locales = {},
        localeFamilies = {},
        globalLocale;
      function commonPrefix(arr1, arr2) {
        var i,
          minl = Math.min(arr1.length, arr2.length);
        for (i = 0; i < minl; i += 1) {
          if (arr1[i] !== arr2[i]) {
            return i;
          }
        }
        return minl;
      }
      function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
      }

      // pick the locale from the array
      // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
      // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
      function chooseLocale(names) {
        var i = 0,
          j,
          next,
          locale,
          split;
        while (i < names.length) {
          split = normalizeLocale(names[i]).split('-');
          j = split.length;
          next = normalizeLocale(names[i + 1]);
          next = next ? next.split('-') : null;
          while (j > 0) {
            locale = loadLocale(split.slice(0, j).join('-'));
            if (locale) {
              return locale;
            }
            if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
              //the next array item is better than a shallower substring of this one
              break;
            }
            j--;
          }
          i++;
        }
        return globalLocale;
      }
      function isLocaleNameSane(name) {
        // Prevent names that look like filesystem paths, i.e contain '/' or '\'
        // Ensure name is available and function returns boolean
        return !!(name && name.match('^[^/\\\\]*$'));
      }
      function loadLocale(name) {
        var oldLocale = null,
          aliasedRequire;
        // TODO: Find a better way to register and load all the locales in Node
        if (locales[name] === undefined && 'object' !== 'undefined' && module && module.exports && isLocaleNameSane(name)) {
          try {
            oldLocale = globalLocale._abbr;
            aliasedRequire = commonjsRequire;
            aliasedRequire('./locale/' + name);
            getSetGlobalLocale(oldLocale);
          } catch (e) {
            // mark as not found to avoid repeating expensive file require call causing high CPU
            // when trying to find en-US, en_US, en-us for every format call
            locales[name] = null; // null means not found
          }
        }
        return locales[name];
      }

      // This function will load locale and then set the global locale.  If
      // no arguments are passed in, it will simply return the current global
      // locale key.
      function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
          if (isUndefined(values)) {
            data = getLocale(key);
          } else {
            data = defineLocale(key, values);
          }
          if (data) {
            // moment.duration._locale = moment._locale = data;
            globalLocale = data;
          } else {
            if (typeof console !== 'undefined' && console.warn) {
              //warn user if arguments are passed but the locale could not be set
              console.warn('Locale ' + key + ' not found. Did you forget to load it?');
            }
          }
        }
        return globalLocale._abbr;
      }
      function defineLocale(name, config) {
        if (config !== null) {
          var locale,
            parentConfig = baseConfig;
          config.abbr = name;
          if (locales[name] != null) {
            deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' + 'an existing locale. moment.defineLocale(localeName, ' + 'config) should only be used for creating a new locale ' + 'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
            parentConfig = locales[name]._config;
          } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
              parentConfig = locales[config.parentLocale]._config;
            } else {
              locale = loadLocale(config.parentLocale);
              if (locale != null) {
                parentConfig = locale._config;
              } else {
                if (!localeFamilies[config.parentLocale]) {
                  localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                  name: name,
                  config: config
                });
                return null;
              }
            }
          }
          locales[name] = new Locale(mergeConfigs(parentConfig, config));
          if (localeFamilies[name]) {
            localeFamilies[name].forEach(function (x) {
              defineLocale(x.name, x.config);
            });
          }

          // backwards compat for now: also set the locale
          // make sure we set the locale AFTER all child locales have been
          // created, so we won't end up with the child locale set.
          getSetGlobalLocale(name);
          return locales[name];
        } else {
          // useful for testing
          delete locales[name];
          return null;
        }
      }
      function updateLocale(name, config) {
        if (config != null) {
          var locale,
            tmpLocale,
            parentConfig = baseConfig;
          if (locales[name] != null && locales[name].parentLocale != null) {
            // Update existing child locale in-place to avoid memory-leaks
            locales[name].set(mergeConfigs(locales[name]._config, config));
          } else {
            // MERGE
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
              parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            if (tmpLocale == null) {
              // updateLocale is called for creating a new locale
              // Set abbr so it will have a name (getters return
              // undefined otherwise).
              config.abbr = name;
            }
            locale = new Locale(config);
            locale.parentLocale = locales[name];
            locales[name] = locale;
          }

          // backwards compat for now: also set the locale
          getSetGlobalLocale(name);
        } else {
          // pass null for config to unupdate, useful for tests
          if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
              locales[name] = locales[name].parentLocale;
              if (name === getSetGlobalLocale()) {
                getSetGlobalLocale(name);
              }
            } else if (locales[name] != null) {
              delete locales[name];
            }
          }
        }
        return locales[name];
      }

      // returns locale data
      function getLocale(key) {
        var locale;
        if (key && key._locale && key._locale._abbr) {
          key = key._locale._abbr;
        }
        if (!key) {
          return globalLocale;
        }
        if (!isArray(key)) {
          //short-circuit everything else
          locale = loadLocale(key);
          if (locale) {
            return locale;
          }
          key = [key];
        }
        return chooseLocale(key);
      }
      function listLocales() {
        return keys(locales);
      }
      function checkOverflow(m) {
        var overflow,
          a = m._a;
        if (a && getParsingFlags(m).overflow === -2) {
          overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
          if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
          }
          if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
          }
          if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
          }
          getParsingFlags(m).overflow = overflow;
        }
        return m;
      }

      // iso 8601 regex
      // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
      var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
        basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
        tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
        isoDates = [['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/], ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/], ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/], ['GGGG-[W]WW', /\d{4}-W\d\d/, false], ['YYYY-DDD', /\d{4}-\d{3}/], ['YYYY-MM', /\d{4}-\d\d/, false], ['YYYYYYMMDD', /[+-]\d{10}/], ['YYYYMMDD', /\d{8}/], ['GGGG[W]WWE', /\d{4}W\d{3}/], ['GGGG[W]WW', /\d{4}W\d{2}/, false], ['YYYYDDD', /\d{7}/], ['YYYYMM', /\d{6}/, false], ['YYYY', /\d{4}/, false]],
        // iso time formats and regexes
        isoTimes = [['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/], ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/], ['HH:mm:ss', /\d\d:\d\d:\d\d/], ['HH:mm', /\d\d:\d\d/], ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/], ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/], ['HHmmss', /\d\d\d\d\d\d/], ['HHmm', /\d\d\d\d/], ['HH', /\d\d/]],
        aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
        // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
        rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
        obsOffsets = {
          UT: 0,
          GMT: 0,
          EDT: -4 * 60,
          EST: -5 * 60,
          CDT: -5 * 60,
          CST: -6 * 60,
          MDT: -6 * 60,
          MST: -7 * 60,
          PDT: -7 * 60,
          PST: -8 * 60
        };

      // date from iso format
      function configFromISO(config) {
        var i,
          l,
          string = config._i,
          match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
          allowTime,
          dateFormat,
          timeFormat,
          tzFormat,
          isoDatesLen = isoDates.length,
          isoTimesLen = isoTimes.length;
        if (match) {
          getParsingFlags(config).iso = true;
          for (i = 0, l = isoDatesLen; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
              dateFormat = isoDates[i][0];
              allowTime = isoDates[i][2] !== false;
              break;
            }
          }
          if (dateFormat == null) {
            config._isValid = false;
            return;
          }
          if (match[3]) {
            for (i = 0, l = isoTimesLen; i < l; i++) {
              if (isoTimes[i][1].exec(match[3])) {
                // match[2] should be 'T' or space
                timeFormat = (match[2] || ' ') + isoTimes[i][0];
                break;
              }
            }
            if (timeFormat == null) {
              config._isValid = false;
              return;
            }
          }
          if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
          }
          if (match[4]) {
            if (tzRegex.exec(match[4])) {
              tzFormat = 'Z';
            } else {
              config._isValid = false;
              return;
            }
          }
          config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
          configFromStringAndFormat(config);
        } else {
          config._isValid = false;
        }
      }
      function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [untruncateYear(yearStr), defaultLocaleMonthsShort.indexOf(monthStr), parseInt(dayStr, 10), parseInt(hourStr, 10), parseInt(minuteStr, 10)];
        if (secondStr) {
          result.push(parseInt(secondStr, 10));
        }
        return result;
      }
      function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
          return 2000 + year;
        } else if (year <= 999) {
          return 1900 + year;
        }
        return year;
      }
      function preprocessRFC2822(s) {
        // Remove comments and folding whitespace and replace multiple-spaces with a single space
        return s.replace(/\([^()]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
      }
      function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
          // TODO: Replace the vanilla JS Date object with an independent day-of-week check.
          var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
            weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
          if (weekdayProvided !== weekdayActual) {
            getParsingFlags(config).weekdayMismatch = true;
            config._isValid = false;
            return false;
          }
        }
        return true;
      }
      function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
          return obsOffsets[obsOffset];
        } else if (militaryOffset) {
          // the only allowed military tz is Z
          return 0;
        } else {
          var hm = parseInt(numOffset, 10),
            m = hm % 100,
            h = (hm - m) / 100;
          return h * 60 + m;
        }
      }

      // date and time from ref 2822 format
      function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i)),
          parsedArray;
        if (match) {
          parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
          if (!checkWeekday(match[1], parsedArray, config)) {
            return;
          }
          config._a = parsedArray;
          config._tzm = calculateOffset(match[8], match[9], match[10]);
          config._d = createUTCDate.apply(null, config._a);
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          getParsingFlags(config).rfc2822 = true;
        } else {
          config._isValid = false;
        }
      }

      // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict
      function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
          config._d = new Date(+matched[1]);
          return;
        }
        configFromISO(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        configFromRFC2822(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        if (config._strict) {
          config._isValid = false;
        } else {
          // Final attempt, use Input Fallback
          hooks.createFromInputFallback(config);
        }
      }
      hooks.createFromInputFallback = deprecate('value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' + 'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' + 'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.', function (config) {
        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
      });

      // Pick the first defined of two or three arguments.
      function defaults(a, b, c) {
        if (a != null) {
          return a;
        }
        if (b != null) {
          return b;
        }
        return c;
      }
      function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
          return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
      }

      // convert an array to a date.
      // the array should mirror the parameters below
      // note: all values past the year are optional and will default to the lowest possible value.
      // [year, month, day , hour, minute, second, millisecond]
      function configFromArray(config) {
        var i,
          date,
          input = [],
          currentDate,
          expectedWeekday,
          yearToUse;
        if (config._d) {
          return;
        }
        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
          dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear != null) {
          yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
          if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
          }
          date = createUTCDate(yearToUse, 0, config._dayOfYear);
          config._a[MONTH] = date.getUTCMonth();
          config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
          config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
          config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
          config._nextDay = true;
          config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }
        if (config._nextDay) {
          config._a[HOUR] = 24;
        }

        // check for mismatching day of week
        if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
          getParsingFlags(config).weekdayMismatch = true;
        }
      }
      function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
          dow = 1;
          doy = 4;

          // TODO: We need to take the current isoWeekYear, but that depends on
          // how we interpret now (local, utc, fixed offset). So create
          // a now version of current config (take local/utc/offset flags, and
          // create now).
          weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
          week = defaults(w.W, 1);
          weekday = defaults(w.E, 1);
          if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
          }
        } else {
          dow = config._locale._week.dow;
          doy = config._locale._week.doy;
          curWeek = weekOfYear(createLocal(), dow, doy);
          weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

          // Default to current week.
          week = defaults(w.w, curWeek.week);
          if (w.d != null) {
            // weekday -- low day numbers are considered next week
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
              weekdayOverflow = true;
            }
          } else if (w.e != null) {
            // local weekday -- counting starts from beginning of week
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
              weekdayOverflow = true;
            }
          } else {
            // default to beginning of week
            weekday = dow;
          }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
          getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
          getParsingFlags(config)._overflowWeekday = true;
        } else {
          temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
          config._a[YEAR] = temp.year;
          config._dayOfYear = temp.dayOfYear;
        }
      }

      // constant that refers to the ISO standard
      hooks.ISO_8601 = function () {};

      // constant that refers to the RFC 2822 form
      hooks.RFC_2822 = function () {};

      // date from string and format string
      function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === hooks.ISO_8601) {
          configFromISO(config);
          return;
        }
        if (config._f === hooks.RFC_2822) {
          configFromRFC2822(config);
          return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
          i,
          parsedInput,
          tokens,
          token,
          skipped,
          stringLength = string.length,
          totalParsedInputLength = 0,
          era,
          tokenLen;
        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        tokenLen = tokens.length;
        for (i = 0; i < tokenLen; i++) {
          token = tokens[i];
          parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
          if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
              getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength += parsedInput.length;
          }
          // don't parse if it's not a known token
          if (formatTokenFunctions[token]) {
            if (parsedInput) {
              getParsingFlags(config).empty = false;
            } else {
              getParsingFlags(config).unusedTokens.push(token);
            }
            addTimeToArrayFromToken(token, parsedInput, config);
          } else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token);
          }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
          getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
          getParsingFlags(config).bigHour = undefined;
        }
        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        // handle era
        era = getParsingFlags(config).era;
        if (era !== null) {
          config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }
        configFromArray(config);
        checkOverflow(config);
      }
      function meridiemFixWrap(locale, hour, meridiem) {
        var isPm;
        if (meridiem == null) {
          // nothing to do
          return hour;
        }
        if (locale.meridiemHour != null) {
          return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
          // Fallback
          isPm = locale.isPM(meridiem);
          if (isPm && hour < 12) {
            hour += 12;
          }
          if (!isPm && hour === 12) {
            hour = 0;
          }
          return hour;
        } else {
          // this is not supposed to happen
          return hour;
        }
      }

      // date from string and array of format strings
      function configFromStringAndArray(config) {
        var tempConfig,
          bestMoment,
          scoreToBeat,
          i,
          currentScore,
          validFormatFound,
          bestFormatIsValid = false,
          configfLen = config._f.length;
        if (configfLen === 0) {
          getParsingFlags(config).invalidFormat = true;
          config._d = new Date(NaN);
          return;
        }
        for (i = 0; i < configfLen; i++) {
          currentScore = 0;
          validFormatFound = false;
          tempConfig = copyConfig({}, config);
          if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
          }
          tempConfig._f = config._f[i];
          configFromStringAndFormat(tempConfig);
          if (isValid(tempConfig)) {
            validFormatFound = true;
          }

          // if there is any input that was not parsed add a penalty for that format
          currentScore += getParsingFlags(tempConfig).charsLeftOver;

          //or tokens
          currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
          getParsingFlags(tempConfig).score = currentScore;
          if (!bestFormatIsValid) {
            if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
              if (validFormatFound) {
                bestFormatIsValid = true;
              }
            }
          } else {
            if (currentScore < scoreToBeat) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
            }
          }
        }
        extend(config, bestMoment || tempConfig);
      }
      function configFromObject(config) {
        if (config._d) {
          return;
        }
        var i = normalizeObjectUnits(config._i),
          dayOrDate = i.day === undefined ? i.date : i.day;
        config._a = map([i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond], function (obj) {
          return obj && parseInt(obj, 10);
        });
        configFromArray(config);
      }
      function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
          // Adding is smart enough around DST
          res.add(1, 'd');
          res._nextDay = undefined;
        }
        return res;
      }
      function prepareConfig(config) {
        var input = config._i,
          format = config._f;
        config._locale = config._locale || getLocale(config._l);
        if (input === null || format === undefined && input === '') {
          return createInvalid({
            nullInput: true
          });
        }
        if (typeof input === 'string') {
          config._i = input = config._locale.preparse(input);
        }
        if (isMoment(input)) {
          return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
          config._d = input;
        } else if (isArray(format)) {
          configFromStringAndArray(config);
        } else if (format) {
          configFromStringAndFormat(config);
        } else {
          configFromInput(config);
        }
        if (!isValid(config)) {
          config._d = null;
        }
        return config;
      }
      function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
          config._d = new Date(hooks.now());
        } else if (isDate(input)) {
          config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
          configFromString(config);
        } else if (isArray(input)) {
          config._a = map(input.slice(0), function (obj) {
            return parseInt(obj, 10);
          });
          configFromArray(config);
        } else if (isObject(input)) {
          configFromObject(config);
        } else if (isNumber(input)) {
          // from milliseconds
          config._d = new Date(input);
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      function createLocalOrUTC(input, format, locale, strict, isUTC) {
        var c = {};
        if (format === true || format === false) {
          strict = format;
          format = undefined;
        }
        if (locale === true || locale === false) {
          strict = locale;
          locale = undefined;
        }
        if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
          input = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;
        return createFromConfig(c);
      }
      function createLocal(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
      }
      var prototypeMin = deprecate('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
          } else {
            return createInvalid();
          }
        }),
        prototypeMax = deprecate('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
          } else {
            return createInvalid();
          }
        });

      // Pick a moment m from moments so that m[fn](other) is true for all
      // other. This relies on the function fn to be transitive.
      //
      // moments should either be an array of moment objects or an array, whose
      // first element is an array of moment objects.
      function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
          moments = moments[0];
        }
        if (!moments.length) {
          return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
          if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
          }
        }
        return res;
      }

      // TODO: Use [].sort instead?
      function min() {
        var args = [].slice.call(arguments, 0);
        return pickBy('isBefore', args);
      }
      function max() {
        var args = [].slice.call(arguments, 0);
        return pickBy('isAfter', args);
      }
      var now = function () {
        return Date.now ? Date.now() : +new Date();
      };
      var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];
      function isDurationValid(m) {
        var key,
          unitHasDecimal = false,
          i,
          orderLen = ordering.length;
        for (key in m) {
          if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
          }
        }
        for (i = 0; i < orderLen; ++i) {
          if (m[ordering[i]]) {
            if (unitHasDecimal) {
              return false; // only allow non-integers for smallest unit
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
              unitHasDecimal = true;
            }
          }
        }
        return true;
      }
      function isValid$1() {
        return this._isValid;
      }
      function createInvalid$1() {
        return createDuration(NaN);
      }
      function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
          years = normalizedInput.year || 0,
          quarters = normalizedInput.quarter || 0,
          months = normalizedInput.month || 0,
          weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
          days = normalizedInput.day || 0,
          hours = normalizedInput.hour || 0,
          minutes = normalizedInput.minute || 0,
          seconds = normalizedInput.second || 0,
          milliseconds = normalizedInput.millisecond || 0;
        this._isValid = isDurationValid(normalizedInput);

        // representation for dateAddRemove
        this._milliseconds = +milliseconds + seconds * 1e3 +
        // 1000
        minutes * 6e4 +
        // 1000 * 60
        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days + weeks * 7;
        // It is impossible to translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months + quarters * 3 + years * 12;
        this._data = {};
        this._locale = getLocale();
        this._bubble();
      }
      function isDuration(obj) {
        return obj instanceof Duration;
      }
      function absRound(number) {
        if (number < 0) {
          return Math.round(-1 * number) * -1;
        } else {
          return Math.round(number);
        }
      }

      // compare two arrays, return the number of differences
      function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
          lengthDiff = Math.abs(array1.length - array2.length),
          diffs = 0,
          i;
        for (i = 0; i < len; i++) {
          if (toInt(array1[i]) !== toInt(array2[i])) {
            diffs++;
          }
        }
        return diffs + lengthDiff;
      }

      // FORMATTING

      function offset(token, separator) {
        addFormatToken(token, 0, 0, function () {
          var offset = this.utcOffset(),
            sign = '+';
          if (offset < 0) {
            offset = -offset;
            sign = '-';
          }
          return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
        });
      }
      offset('Z', ':');
      offset('ZZ', '');

      // PARSING

      addRegexToken('Z', matchShortOffset);
      addRegexToken('ZZ', matchShortOffset);
      addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
      });

      // HELPERS

      // timezone chunker
      // '+10:00' > ['10',  '00']
      // '-1530'  > ['-15', '30']
      var chunkOffset = /([\+\-]|\d\d)/gi;
      function offsetFromString(matcher, string) {
        var matches = (string || '').match(matcher),
          chunk,
          parts,
          minutes;
        if (matches === null) {
          return null;
        }
        chunk = matches[matches.length - 1] || [];
        parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        minutes = +(parts[1] * 60) + toInt(parts[2]);
        return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
      }

      // Return a moment from input, that is local/utc/zone equivalent to model.
      function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
          res = model.clone();
          diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
          // Use low-level api, because this fn is low-level api.
          res._d.setTime(res._d.valueOf() + diff);
          hooks.updateOffset(res, false);
          return res;
        } else {
          return createLocal(input).local();
        }
      }
      function getDateOffset(m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset());
      }

      // HOOKS

      // This function will be called whenever a moment is mutated.
      // It is intended to keep the offset in sync with the timezone.
      hooks.updateOffset = function () {};

      // MOMENTS

      // keepLocalTime = true means only change the timezone, without
      // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
      // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
      // +0200, so we adjust the time as needed, to be valid.
      //
      // Keeping the time actually adds/subtracts (one hour)
      // from the actual represented time. That is why we call updateOffset
      // a second time. In case it wants us to change the offset again
      // _changeInProgress == true case, then we have to adjust, because
      // there is no such time in the given timezone.
      function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset = this._offset || 0,
          localAdjust;
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          if (typeof input === 'string') {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
              return this;
            }
          } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
          }
          if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
          }
          this._offset = input;
          this._isUTC = true;
          if (localAdjust != null) {
            this.add(localAdjust, 'm');
          }
          if (offset !== input) {
            if (!keepLocalTime || this._changeInProgress) {
              addSubtract(this, createDuration(input - offset, 'm'), 1, false);
            } else if (!this._changeInProgress) {
              this._changeInProgress = true;
              hooks.updateOffset(this, true);
              this._changeInProgress = null;
            }
          }
          return this;
        } else {
          return this._isUTC ? offset : getDateOffset(this);
        }
      }
      function getSetZone(input, keepLocalTime) {
        if (input != null) {
          if (typeof input !== 'string') {
            input = -input;
          }
          this.utcOffset(input, keepLocalTime);
          return this;
        } else {
          return -this.utcOffset();
        }
      }
      function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
      }
      function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
          this.utcOffset(0, keepLocalTime);
          this._isUTC = false;
          if (keepLocalTime) {
            this.subtract(getDateOffset(this), 'm');
          }
        }
        return this;
      }
      function setOffsetToParsedOffset() {
        if (this._tzm != null) {
          this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === 'string') {
          var tZone = offsetFromString(matchOffset, this._i);
          if (tZone != null) {
            this.utcOffset(tZone);
          } else {
            this.utcOffset(0, true);
          }
        }
        return this;
      }
      function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
          return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;
        return (this.utcOffset() - input) % 60 === 0;
      }
      function isDaylightSavingTime() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
      }
      function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
          return this._isDSTShifted;
        }
        var c = {},
          other;
        copyConfig(c, this);
        c = prepareConfig(c);
        if (c._a) {
          other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
          this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
          this._isDSTShifted = false;
        }
        return this._isDSTShifted;
      }
      function isLocal() {
        return this.isValid() ? !this._isUTC : false;
      }
      function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
      }
      function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
      }

      // ASP.NET json date format regex
      var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
        // and further modified to allow for strings containing both week and day
        isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
      function createDuration(input, key) {
        var duration = input,
          // matching against regexp is expensive, do it on demand
          match = null,
          sign,
          ret,
          diffRes;
        if (isDuration(input)) {
          duration = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months
          };
        } else if (isNumber(input) || !isNaN(+input)) {
          duration = {};
          if (key) {
            duration[key] = +input;
          } else {
            duration.milliseconds = +input;
          }
        } else if (match = aspNetRegex.exec(input)) {
          sign = match[1] === '-' ? -1 : 1;
          duration = {
            y: 0,
            d: toInt(match[DATE]) * sign,
            h: toInt(match[HOUR]) * sign,
            m: toInt(match[MINUTE]) * sign,
            s: toInt(match[SECOND]) * sign,
            ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
          };
        } else if (match = isoRegex.exec(input)) {
          sign = match[1] === '-' ? -1 : 1;
          duration = {
            y: parseIso(match[2], sign),
            M: parseIso(match[3], sign),
            w: parseIso(match[4], sign),
            d: parseIso(match[5], sign),
            h: parseIso(match[6], sign),
            m: parseIso(match[7], sign),
            s: parseIso(match[8], sign)
          };
        } else if (duration == null) {
          // checks for null or undefined
          duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
          diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
          duration = {};
          duration.ms = diffRes.milliseconds;
          duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (isDuration(input) && hasOwnProp(input, '_locale')) {
          ret._locale = input._locale;
        }
        if (isDuration(input) && hasOwnProp(input, '_isValid')) {
          ret._isValid = input._isValid;
        }
        return ret;
      }
      createDuration.fn = Duration.prototype;
      createDuration.invalid = createInvalid$1;
      function parseIso(inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
      }
      function positiveMomentsDifference(base, other) {
        var res = {};
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
          --res.months;
        }
        res.milliseconds = +other - +base.clone().add(res.months, 'M');
        return res;
      }
      function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
          return {
            milliseconds: 0,
            months: 0
          };
        }
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
          res = positiveMomentsDifference(base, other);
        } else {
          res = positiveMomentsDifference(other, base);
          res.milliseconds = -res.milliseconds;
          res.months = -res.months;
        }
        return res;
      }

      // TODO: remove 'name' arg after deprecation is removed
      function createAdder(direction, name) {
        return function (val, period) {
          var dur, tmp;
          //invert the arguments, but complain about it
          if (period !== null && !isNaN(+period)) {
            deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' + 'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
            tmp = val;
            val = period;
            period = tmp;
          }
          dur = createDuration(val, period);
          addSubtract(this, dur, direction);
          return this;
        };
      }
      function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
          days = absRound(duration._days),
          months = absRound(duration._months);
        if (!mom.isValid()) {
          // No op
          return;
        }
        updateOffset = updateOffset == null ? true : updateOffset;
        if (months) {
          setMonth(mom, get(mom, 'Month') + months * isAdding);
        }
        if (days) {
          set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
        }
        if (milliseconds) {
          mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (updateOffset) {
          hooks.updateOffset(mom, days || months);
        }
      }
      var add = createAdder(1, 'add'),
        subtract = createAdder(-1, 'subtract');
      function isString(input) {
        return typeof input === 'string' || input instanceof String;
      }

      // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined
      function isMomentInput(input) {
        return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === undefined;
      }
      function isMomentInputObject(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input),
          propertyTest = false,
          properties = ['years', 'year', 'y', 'months', 'month', 'M', 'days', 'day', 'd', 'dates', 'date', 'D', 'hours', 'hour', 'h', 'minutes', 'minute', 'm', 'seconds', 'second', 's', 'milliseconds', 'millisecond', 'ms'],
          i,
          property,
          propertyLen = properties.length;
        for (i = 0; i < propertyLen; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function isNumberOrStringArray(input) {
        var arrayTest = isArray(input),
          dataTypeTest = false;
        if (arrayTest) {
          dataTypeTest = input.filter(function (item) {
            return !isNumber(item) && isString(input);
          }).length === 0;
        }
        return arrayTest && dataTypeTest;
      }
      function isCalendarSpec(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input),
          propertyTest = false,
          properties = ['sameDay', 'nextDay', 'lastDay', 'nextWeek', 'lastWeek', 'sameElse'],
          i,
          property;
        for (i = 0; i < properties.length; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';
      }
      function calendar$1(time, formats) {
        // Support for single parameter, formats only overload to the calendar function
        if (arguments.length === 1) {
          if (!arguments[0]) {
            time = undefined;
            formats = undefined;
          } else if (isMomentInput(arguments[0])) {
            time = arguments[0];
            formats = undefined;
          } else if (isCalendarSpec(arguments[0])) {
            formats = arguments[0];
            time = undefined;
          }
        }
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || createLocal(),
          sod = cloneWithOffset(now, this).startOf('day'),
          format = hooks.calendarFormat(this, sod) || 'sameElse',
          output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
      }
      function clone() {
        return new Moment(this);
      }
      function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
          return this.valueOf() > localInput.valueOf();
        } else {
          return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
      }
      function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
          return this.valueOf() < localInput.valueOf();
        } else {
          return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
      }
      function isBetween(from, to, units, inclusivity) {
        var localFrom = isMoment(from) ? from : createLocal(from),
          localTo = isMoment(to) ? to : createLocal(to);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
          return false;
        }
        inclusivity = inclusivity || '()';
        return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
      }
      function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input),
          inputMs;
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
          return this.valueOf() === localInput.valueOf();
        } else {
          inputMs = localInput.valueOf();
          return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
      }
      function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
      }
      function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
      }
      function diff(input, units, asFloat) {
        var that, zoneDelta, output;
        if (!this.isValid()) {
          return NaN;
        }
        that = cloneWithOffset(input, this);
        if (!that.isValid()) {
          return NaN;
        }
        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
        units = normalizeUnits(units);
        switch (units) {
          case 'year':
            output = monthDiff(this, that) / 12;
            break;
          case 'month':
            output = monthDiff(this, that);
            break;
          case 'quarter':
            output = monthDiff(this, that) / 3;
            break;
          case 'second':
            output = (this - that) / 1e3;
            break;
          // 1000
          case 'minute':
            output = (this - that) / 6e4;
            break;
          // 1000 * 60
          case 'hour':
            output = (this - that) / 36e5;
            break;
          // 1000 * 60 * 60
          case 'day':
            output = (this - that - zoneDelta) / 864e5;
            break;
          // 1000 * 60 * 60 * 24, negate dst
          case 'week':
            output = (this - that - zoneDelta) / 6048e5;
            break;
          // 1000 * 60 * 60 * 24 * 7, negate dst
          default:
            output = this - that;
        }
        return asFloat ? output : absFloor(output);
      }
      function monthDiff(a, b) {
        if (a.date() < b.date()) {
          // end-of-month calculations work correct when the start month has more
          // days than the end month.
          return -monthDiff(b, a);
        }
        // difference in months
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
          // b is in (anchor - 1 month, anchor + 1 month)
          anchor = a.clone().add(wholeMonthDiff, 'months'),
          anchor2,
          adjust;
        if (b - anchor < 0) {
          anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
          // linear across the month
          adjust = (b - anchor) / (anchor - anchor2);
        } else {
          anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
          // linear across the month
          adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
      }
      hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
      hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';
      function toString() {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
      }
      function toISOString(keepOffset) {
        if (!this.isValid()) {
          return null;
        }
        var utc = keepOffset !== true,
          m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
          return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
        }
        if (isFunction(Date.prototype.toISOString)) {
          // native implementation is ~50x faster, use it when we can
          if (utc) {
            return this.toDate().toISOString();
          } else {
            return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
          }
        }
        return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
      }

      /**
       * Return a human readable representation of a moment that can
       * also be evaluated to get a new moment which is the same
       *
       * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
       */
      function inspect() {
        if (!this.isValid()) {
          return 'moment.invalid(/* ' + this._i + ' */)';
        }
        var func = 'moment',
          zone = '',
          prefix,
          year,
          datetime,
          suffix;
        if (!this.isLocal()) {
          func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
          zone = 'Z';
        }
        prefix = '[' + func + '("]';
        year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
        datetime = '-MM-DD[T]HH:mm:ss.SSS';
        suffix = zone + '[")]';
        return this.format(prefix + year + datetime + suffix);
      }
      function format(inputString) {
        if (!inputString) {
          inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
      }
      function from(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({
            to: this,
            from: time
          }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
      }
      function to(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({
            from: this,
            to: time
          }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
      }

      // If passed a locale key, it will set the locale for this
      // instance.  Otherwise, it will return the locale configuration
      // variables for this instance.
      function locale(key) {
        var newLocaleData;
        if (key === undefined) {
          return this._locale._abbr;
        } else {
          newLocaleData = getLocale(key);
          if (newLocaleData != null) {
            this._locale = newLocaleData;
          }
          return this;
        }
      }
      var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function (key) {
        if (key === undefined) {
          return this.localeData();
        } else {
          return this.locale(key);
        }
      });
      function localeData() {
        return this._locale;
      }
      var MS_PER_SECOND = 1000,
        MS_PER_MINUTE = 60 * MS_PER_SECOND,
        MS_PER_HOUR = 60 * MS_PER_MINUTE,
        MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

      // actual modulo - handles negative numbers (for dates before 1970):
      function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
      }
      function localStartOfDate(y, m, d) {
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
          // preserve leap years using a full 400 year cycle, then reset
          return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return new Date(y, m, d).valueOf();
        }
      }
      function utcStartOfDate(y, m, d) {
        // Date.UTC remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
          // preserve leap years using a full 400 year cycle, then reset
          return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return Date.UTC(y, m, d);
        }
      }
      function startOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case 'year':
            time = startOfDate(this.year(), 0, 1);
            break;
          case 'quarter':
            time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
            break;
          case 'month':
            time = startOfDate(this.year(), this.month(), 1);
            break;
          case 'week':
            time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
            break;
          case 'isoWeek':
            time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
            break;
          case 'day':
          case 'date':
            time = startOfDate(this.year(), this.month(), this.date());
            break;
          case 'hour':
            time = this._d.valueOf();
            time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
            break;
          case 'minute':
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_MINUTE);
            break;
          case 'second':
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_SECOND);
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function endOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case 'year':
            time = startOfDate(this.year() + 1, 0, 1) - 1;
            break;
          case 'quarter':
            time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
            break;
          case 'month':
            time = startOfDate(this.year(), this.month() + 1, 1) - 1;
            break;
          case 'week':
            time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
            break;
          case 'isoWeek':
            time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
            break;
          case 'day':
          case 'date':
            time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
            break;
          case 'hour':
            time = this._d.valueOf();
            time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
            break;
          case 'minute':
            time = this._d.valueOf();
            time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
            break;
          case 'second':
            time = this._d.valueOf();
            time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 60000;
      }
      function unix() {
        return Math.floor(this.valueOf() / 1000);
      }
      function toDate() {
        return new Date(this.valueOf());
      }
      function toArray() {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
      }
      function toObject() {
        var m = this;
        return {
          years: m.year(),
          months: m.month(),
          date: m.date(),
          hours: m.hours(),
          minutes: m.minutes(),
          seconds: m.seconds(),
          milliseconds: m.milliseconds()
        };
      }
      function toJSON() {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
      }
      function isValid$2() {
        return isValid(this);
      }
      function parsingFlags() {
        return extend({}, getParsingFlags(this));
      }
      function invalidAt() {
        return getParsingFlags(this).overflow;
      }
      function creationData() {
        return {
          input: this._i,
          format: this._f,
          locale: this._locale,
          isUTC: this._isUTC,
          strict: this._strict
        };
      }
      addFormatToken('N', 0, 0, 'eraAbbr');
      addFormatToken('NN', 0, 0, 'eraAbbr');
      addFormatToken('NNN', 0, 0, 'eraAbbr');
      addFormatToken('NNNN', 0, 0, 'eraName');
      addFormatToken('NNNNN', 0, 0, 'eraNarrow');
      addFormatToken('y', ['y', 1], 'yo', 'eraYear');
      addFormatToken('y', ['yy', 2], 0, 'eraYear');
      addFormatToken('y', ['yyy', 3], 0, 'eraYear');
      addFormatToken('y', ['yyyy', 4], 0, 'eraYear');
      addRegexToken('N', matchEraAbbr);
      addRegexToken('NN', matchEraAbbr);
      addRegexToken('NNN', matchEraAbbr);
      addRegexToken('NNNN', matchEraName);
      addRegexToken('NNNNN', matchEraNarrow);
      addParseToken(['N', 'NN', 'NNN', 'NNNN', 'NNNNN'], function (input, array, config, token) {
        var era = config._locale.erasParse(input, token, config._strict);
        if (era) {
          getParsingFlags(config).era = era;
        } else {
          getParsingFlags(config).invalidEra = input;
        }
      });
      addRegexToken('y', matchUnsigned);
      addRegexToken('yy', matchUnsigned);
      addRegexToken('yyy', matchUnsigned);
      addRegexToken('yyyy', matchUnsigned);
      addRegexToken('yo', matchEraYearOrdinal);
      addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);
      addParseToken(['yo'], function (input, array, config, token) {
        var match;
        if (config._locale._eraYearOrdinalRegex) {
          match = input.match(config._locale._eraYearOrdinalRegex);
        }
        if (config._locale.eraYearOrdinalParse) {
          array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
        } else {
          array[YEAR] = parseInt(input, 10);
        }
      });
      function localeEras(m, format) {
        var i,
          l,
          date,
          eras = this._eras || getLocale('en')._eras;
        for (i = 0, l = eras.length; i < l; ++i) {
          switch (typeof eras[i].since) {
            case 'string':
              // truncate time
              date = hooks(eras[i].since).startOf('day');
              eras[i].since = date.valueOf();
              break;
          }
          switch (typeof eras[i].until) {
            case 'undefined':
              eras[i].until = +Infinity;
              break;
            case 'string':
              // truncate time
              date = hooks(eras[i].until).startOf('day').valueOf();
              eras[i].until = date.valueOf();
              break;
          }
        }
        return eras;
      }
      function localeErasParse(eraName, format, strict) {
        var i,
          l,
          eras = this.eras(),
          name,
          abbr,
          narrow;
        eraName = eraName.toUpperCase();
        for (i = 0, l = eras.length; i < l; ++i) {
          name = eras[i].name.toUpperCase();
          abbr = eras[i].abbr.toUpperCase();
          narrow = eras[i].narrow.toUpperCase();
          if (strict) {
            switch (format) {
              case 'N':
              case 'NN':
              case 'NNN':
                if (abbr === eraName) {
                  return eras[i];
                }
                break;
              case 'NNNN':
                if (name === eraName) {
                  return eras[i];
                }
                break;
              case 'NNNNN':
                if (narrow === eraName) {
                  return eras[i];
                }
                break;
            }
          } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
            return eras[i];
          }
        }
      }
      function localeErasConvertYear(era, year) {
        var dir = era.since <= era.until ? +1 : -1;
        if (year === undefined) {
          return hooks(era.since).year();
        } else {
          return hooks(era.since).year() + (year - era.offset) * dir;
        }
      }
      function getEraName() {
        var i,
          l,
          val,
          eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          // truncate time
          val = this.clone().startOf('day').valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].name;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].name;
          }
        }
        return '';
      }
      function getEraNarrow() {
        var i,
          l,
          val,
          eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          // truncate time
          val = this.clone().startOf('day').valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].narrow;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].narrow;
          }
        }
        return '';
      }
      function getEraAbbr() {
        var i,
          l,
          val,
          eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          // truncate time
          val = this.clone().startOf('day').valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].abbr;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].abbr;
          }
        }
        return '';
      }
      function getEraYear() {
        var i,
          l,
          dir,
          val,
          eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          dir = eras[i].since <= eras[i].until ? +1 : -1;

          // truncate time
          val = this.clone().startOf('day').valueOf();
          if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
            return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
          }
        }
        return this.year();
      }
      function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, '_erasNameRegex')) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
      }
      function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, '_erasAbbrRegex')) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
      }
      function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, '_erasNarrowRegex')) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
      }
      function matchEraAbbr(isStrict, locale) {
        return locale.erasAbbrRegex(isStrict);
      }
      function matchEraName(isStrict, locale) {
        return locale.erasNameRegex(isStrict);
      }
      function matchEraNarrow(isStrict, locale) {
        return locale.erasNarrowRegex(isStrict);
      }
      function matchEraYearOrdinal(isStrict, locale) {
        return locale._eraYearOrdinalRegex || matchUnsigned;
      }
      function computeErasParse() {
        var abbrPieces = [],
          namePieces = [],
          narrowPieces = [],
          mixedPieces = [],
          i,
          l,
          erasName,
          erasAbbr,
          erasNarrow,
          eras = this.eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          erasName = regexEscape(eras[i].name);
          erasAbbr = regexEscape(eras[i].abbr);
          erasNarrow = regexEscape(eras[i].narrow);
          namePieces.push(erasName);
          abbrPieces.push(erasAbbr);
          narrowPieces.push(erasNarrow);
          mixedPieces.push(erasName);
          mixedPieces.push(erasAbbr);
          mixedPieces.push(erasNarrow);
        }
        this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');
        this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');
        this._erasNarrowRegex = new RegExp('^(' + narrowPieces.join('|') + ')', 'i');
      }

      // FORMATTING

      addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
      });
      addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
      });
      function addWeekYearFormatToken(token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
      }
      addWeekYearFormatToken('gggg', 'weekYear');
      addWeekYearFormatToken('ggggg', 'weekYear');
      addWeekYearFormatToken('GGGG', 'isoWeekYear');
      addWeekYearFormatToken('GGGGG', 'isoWeekYear');

      // ALIASES

      // PARSING

      addRegexToken('G', matchSigned);
      addRegexToken('g', matchSigned);
      addRegexToken('GG', match1to2, match2);
      addRegexToken('gg', match1to2, match2);
      addRegexToken('GGGG', match1to4, match4);
      addRegexToken('gggg', match1to4, match4);
      addRegexToken('GGGGG', match1to6, match6);
      addRegexToken('ggggg', match1to6, match6);
      addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
      });
      addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
      });

      // MOMENTS

      function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.week(), this.weekday() + this.localeData()._week.dow, this.localeData()._week.dow, this.localeData()._week.doy);
      }
      function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
      }
      function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
      }
      function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
      }
      function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
      }
      function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
      }
      function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
          return weekOfYear(this, dow, doy).year;
        } else {
          weeksTarget = weeksInYear(input, dow, doy);
          if (week > weeksTarget) {
            week = weeksTarget;
          }
          return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
      }
      function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
          date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
      }

      // FORMATTING

      addFormatToken('Q', 0, 'Qo', 'quarter');

      // PARSING

      addRegexToken('Q', match1);
      addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
      });

      // MOMENTS

      function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
      }

      // FORMATTING

      addFormatToken('D', ['DD', 2], 'Do', 'date');

      // PARSING

      addRegexToken('D', match1to2, match1to2NoLeadingZero);
      addRegexToken('DD', match1to2, match2);
      addRegexToken('Do', function (isStrict, locale) {
        // TODO: Remove "ordinalParse" fallback in next major release.
        return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;
      });
      addParseToken(['D', 'DD'], DATE);
      addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
      });

      // MOMENTS

      var getSetDayOfMonth = makeGetSet('Date', true);

      // FORMATTING

      addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

      // PARSING

      addRegexToken('DDD', match1to3);
      addRegexToken('DDDD', match3);
      addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
      });

      // HELPERS

      // MOMENTS

      function getSetDayOfYear(input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
      }

      // FORMATTING

      addFormatToken('m', ['mm', 2], 0, 'minute');

      // PARSING

      addRegexToken('m', match1to2, match1to2HasZero);
      addRegexToken('mm', match1to2, match2);
      addParseToken(['m', 'mm'], MINUTE);

      // MOMENTS

      var getSetMinute = makeGetSet('Minutes', false);

      // FORMATTING

      addFormatToken('s', ['ss', 2], 0, 'second');

      // PARSING

      addRegexToken('s', match1to2, match1to2HasZero);
      addRegexToken('ss', match1to2, match2);
      addParseToken(['s', 'ss'], SECOND);

      // MOMENTS

      var getSetSecond = makeGetSet('Seconds', false);

      // FORMATTING

      addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
      });
      addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
      });
      addFormatToken(0, ['SSS', 3], 0, 'millisecond');
      addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
      });
      addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
      });
      addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
      });
      addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
      });
      addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
      });
      addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
      });

      // PARSING

      addRegexToken('S', match1to3, match1);
      addRegexToken('SS', match1to3, match2);
      addRegexToken('SSS', match1to3, match3);
      var token, getSetMillisecond;
      for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
      }
      function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
      }
      for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
      }
      getSetMillisecond = makeGetSet('Milliseconds', false);

      // FORMATTING

      addFormatToken('z', 0, 0, 'zoneAbbr');
      addFormatToken('zz', 0, 0, 'zoneName');

      // MOMENTS

      function getZoneAbbr() {
        return this._isUTC ? 'UTC' : '';
      }
      function getZoneName() {
        return this._isUTC ? 'Coordinated Universal Time' : '';
      }
      var proto = Moment.prototype;
      proto.add = add;
      proto.calendar = calendar$1;
      proto.clone = clone;
      proto.diff = diff;
      proto.endOf = endOf;
      proto.format = format;
      proto.from = from;
      proto.fromNow = fromNow;
      proto.to = to;
      proto.toNow = toNow;
      proto.get = stringGet;
      proto.invalidAt = invalidAt;
      proto.isAfter = isAfter;
      proto.isBefore = isBefore;
      proto.isBetween = isBetween;
      proto.isSame = isSame;
      proto.isSameOrAfter = isSameOrAfter;
      proto.isSameOrBefore = isSameOrBefore;
      proto.isValid = isValid$2;
      proto.lang = lang;
      proto.locale = locale;
      proto.localeData = localeData;
      proto.max = prototypeMax;
      proto.min = prototypeMin;
      proto.parsingFlags = parsingFlags;
      proto.set = stringSet;
      proto.startOf = startOf;
      proto.subtract = subtract;
      proto.toArray = toArray;
      proto.toObject = toObject;
      proto.toDate = toDate;
      proto.toISOString = toISOString;
      proto.inspect = inspect;
      if (typeof Symbol !== 'undefined' && Symbol.for != null) {
        proto[Symbol.for('nodejs.util.inspect.custom')] = function () {
          return 'Moment<' + this.format() + '>';
        };
      }
      proto.toJSON = toJSON;
      proto.toString = toString;
      proto.unix = unix;
      proto.valueOf = valueOf;
      proto.creationData = creationData;
      proto.eraName = getEraName;
      proto.eraNarrow = getEraNarrow;
      proto.eraAbbr = getEraAbbr;
      proto.eraYear = getEraYear;
      proto.year = getSetYear;
      proto.isLeapYear = getIsLeapYear;
      proto.weekYear = getSetWeekYear;
      proto.isoWeekYear = getSetISOWeekYear;
      proto.quarter = proto.quarters = getSetQuarter;
      proto.month = getSetMonth;
      proto.daysInMonth = getDaysInMonth;
      proto.week = proto.weeks = getSetWeek;
      proto.isoWeek = proto.isoWeeks = getSetISOWeek;
      proto.weeksInYear = getWeeksInYear;
      proto.weeksInWeekYear = getWeeksInWeekYear;
      proto.isoWeeksInYear = getISOWeeksInYear;
      proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
      proto.date = getSetDayOfMonth;
      proto.day = proto.days = getSetDayOfWeek;
      proto.weekday = getSetLocaleDayOfWeek;
      proto.isoWeekday = getSetISODayOfWeek;
      proto.dayOfYear = getSetDayOfYear;
      proto.hour = proto.hours = getSetHour;
      proto.minute = proto.minutes = getSetMinute;
      proto.second = proto.seconds = getSetSecond;
      proto.millisecond = proto.milliseconds = getSetMillisecond;
      proto.utcOffset = getSetOffset;
      proto.utc = setOffsetToUTC;
      proto.local = setOffsetToLocal;
      proto.parseZone = setOffsetToParsedOffset;
      proto.hasAlignedHourOffset = hasAlignedHourOffset;
      proto.isDST = isDaylightSavingTime;
      proto.isLocal = isLocal;
      proto.isUtcOffset = isUtcOffset;
      proto.isUtc = isUtc;
      proto.isUTC = isUtc;
      proto.zoneAbbr = getZoneAbbr;
      proto.zoneName = getZoneName;
      proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
      proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
      proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
      proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
      proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);
      function createUnix(input) {
        return createLocal(input * 1000);
      }
      function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
      }
      function preParsePostFormat(string) {
        return string;
      }
      var proto$1 = Locale.prototype;
      proto$1.calendar = calendar;
      proto$1.longDateFormat = longDateFormat;
      proto$1.invalidDate = invalidDate;
      proto$1.ordinal = ordinal;
      proto$1.preparse = preParsePostFormat;
      proto$1.postformat = preParsePostFormat;
      proto$1.relativeTime = relativeTime;
      proto$1.pastFuture = pastFuture;
      proto$1.set = set;
      proto$1.eras = localeEras;
      proto$1.erasParse = localeErasParse;
      proto$1.erasConvertYear = localeErasConvertYear;
      proto$1.erasAbbrRegex = erasAbbrRegex;
      proto$1.erasNameRegex = erasNameRegex;
      proto$1.erasNarrowRegex = erasNarrowRegex;
      proto$1.months = localeMonths;
      proto$1.monthsShort = localeMonthsShort;
      proto$1.monthsParse = localeMonthsParse;
      proto$1.monthsRegex = monthsRegex;
      proto$1.monthsShortRegex = monthsShortRegex;
      proto$1.week = localeWeek;
      proto$1.firstDayOfYear = localeFirstDayOfYear;
      proto$1.firstDayOfWeek = localeFirstDayOfWeek;
      proto$1.weekdays = localeWeekdays;
      proto$1.weekdaysMin = localeWeekdaysMin;
      proto$1.weekdaysShort = localeWeekdaysShort;
      proto$1.weekdaysParse = localeWeekdaysParse;
      proto$1.weekdaysRegex = weekdaysRegex;
      proto$1.weekdaysShortRegex = weekdaysShortRegex;
      proto$1.weekdaysMinRegex = weekdaysMinRegex;
      proto$1.isPM = localeIsPM;
      proto$1.meridiem = localeMeridiem;
      function get$1(format, index, field, setter) {
        var locale = getLocale(),
          utc = createUTC().set(setter, index);
        return locale[field](utc, format);
      }
      function listMonthsImpl(format, index, field) {
        if (isNumber(format)) {
          index = format;
          format = undefined;
        }
        format = format || '';
        if (index != null) {
          return get$1(format, index, field, 'month');
        }
        var i,
          out = [];
        for (i = 0; i < 12; i++) {
          out[i] = get$1(format, i, field, 'month');
        }
        return out;
      }

      // ()
      // (5)
      // (fmt, 5)
      // (fmt)
      // (true)
      // (true, 5)
      // (true, fmt, 5)
      // (true, fmt)
      function listWeekdaysImpl(localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
          if (isNumber(format)) {
            index = format;
            format = undefined;
          }
          format = format || '';
        } else {
          format = localeSorted;
          index = format;
          localeSorted = false;
          if (isNumber(format)) {
            index = format;
            format = undefined;
          }
          format = format || '';
        }
        var locale = getLocale(),
          shift = localeSorted ? locale._week.dow : 0,
          i,
          out = [];
        if (index != null) {
          return get$1(format, (index + shift) % 7, field, 'day');
        }
        for (i = 0; i < 7; i++) {
          out[i] = get$1(format, (i + shift) % 7, field, 'day');
        }
        return out;
      }
      function listMonths(format, index) {
        return listMonthsImpl(format, index, 'months');
      }
      function listMonthsShort(format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
      }
      function listWeekdays(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
      }
      function listWeekdaysShort(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
      }
      function listWeekdaysMin(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
      }
      getSetGlobalLocale('en', {
        eras: [{
          since: '0001-01-01',
          until: +Infinity,
          offset: 1,
          name: 'Anno Domini',
          narrow: 'AD',
          abbr: 'AD'
        }, {
          since: '0000-12-31',
          until: -Infinity,
          offset: 1,
          name: 'Before Christ',
          narrow: 'BC',
          abbr: 'BC'
        }],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function (number) {
          var b = number % 10,
            output = toInt(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
          return number + output;
        }
      });

      // Side effect imports

      hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
      hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);
      var mathAbs = Math.abs;
      function abs() {
        var data = this._data;
        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);
        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);
        return this;
      }
      function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);
        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;
        return duration._bubble();
      }

      // supports only 2.0-style add(1, 's') or add(duration)
      function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
      }

      // supports only 2.0-style subtract(1, 's') or subtract(duration)
      function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
      }
      function absCeil(number) {
        if (number < 0) {
          return Math.floor(number);
        } else {
          return Math.ceil(number);
        }
      }
      function bubble() {
        var milliseconds = this._milliseconds,
          days = this._days,
          months = this._months,
          data = this._data,
          seconds,
          minutes,
          hours,
          years,
          monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {
          milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
          days = 0;
          months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;
        seconds = absFloor(milliseconds / 1000);
        data.seconds = seconds % 60;
        minutes = absFloor(seconds / 60);
        data.minutes = minutes % 60;
        hours = absFloor(minutes / 60);
        data.hours = hours % 24;
        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;
        data.days = days;
        data.months = months;
        data.years = years;
        return this;
      }
      function daysToMonths(days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
      }
      function monthsToDays(months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
      }
      function as(units) {
        if (!this.isValid()) {
          return NaN;
        }
        var days,
          months,
          milliseconds = this._milliseconds;
        units = normalizeUnits(units);
        if (units === 'month' || units === 'quarter' || units === 'year') {
          days = this._days + milliseconds / 864e5;
          months = this._months + daysToMonths(days);
          switch (units) {
            case 'month':
              return months;
            case 'quarter':
              return months / 3;
            case 'year':
              return months / 12;
          }
        } else {
          // handle milliseconds separately because of floating point math errors (issue #1867)
          days = this._days + Math.round(monthsToDays(this._months));
          switch (units) {
            case 'week':
              return days / 7 + milliseconds / 6048e5;
            case 'day':
              return days + milliseconds / 864e5;
            case 'hour':
              return days * 24 + milliseconds / 36e5;
            case 'minute':
              return days * 1440 + milliseconds / 6e4;
            case 'second':
              return days * 86400 + milliseconds / 1000;
            // Math.floor prevents floating point math errors here
            case 'millisecond':
              return Math.floor(days * 864e5) + milliseconds;
            default:
              throw new Error('Unknown unit ' + units);
          }
        }
      }
      function makeAs(alias) {
        return function () {
          return this.as(alias);
        };
      }
      var asMilliseconds = makeAs('ms'),
        asSeconds = makeAs('s'),
        asMinutes = makeAs('m'),
        asHours = makeAs('h'),
        asDays = makeAs('d'),
        asWeeks = makeAs('w'),
        asMonths = makeAs('M'),
        asQuarters = makeAs('Q'),
        asYears = makeAs('y'),
        valueOf$1 = asMilliseconds;
      function clone$1() {
        return createDuration(this);
      }
      function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + 's']() : NaN;
      }
      function makeGetter(name) {
        return function () {
          return this.isValid() ? this._data[name] : NaN;
        };
      }
      var milliseconds = makeGetter('milliseconds'),
        seconds = makeGetter('seconds'),
        minutes = makeGetter('minutes'),
        hours = makeGetter('hours'),
        days = makeGetter('days'),
        months = makeGetter('months'),
        years = makeGetter('years');
      function weeks() {
        return absFloor(this.days() / 7);
      }
      var round = Math.round,
        thresholds = {
          ss: 44,
          // a few seconds to seconds
          s: 45,
          // seconds to minute
          m: 45,
          // minutes to hour
          h: 22,
          // hours to day
          d: 26,
          // days to month/week
          w: null,
          // weeks to month
          M: 11 // months to year
        };

      // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
      function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
      }
      function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
        var duration = createDuration(posNegDuration).abs(),
          seconds = round(duration.as('s')),
          minutes = round(duration.as('m')),
          hours = round(duration.as('h')),
          days = round(duration.as('d')),
          months = round(duration.as('M')),
          weeks = round(duration.as('w')),
          years = round(duration.as('y')),
          a = seconds <= thresholds.ss && ['s', seconds] || seconds < thresholds.s && ['ss', seconds] || minutes <= 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours <= 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days <= 1 && ['d'] || days < thresholds.d && ['dd', days];
        if (thresholds.w != null) {
          a = a || weeks <= 1 && ['w'] || weeks < thresholds.w && ['ww', weeks];
        }
        a = a || months <= 1 && ['M'] || months < thresholds.M && ['MM', months] || years <= 1 && ['y'] || ['yy', years];
        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
      }

      // This function allows you to set the rounding function for relative time strings
      function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === undefined) {
          return round;
        }
        if (typeof roundingFunction === 'function') {
          round = roundingFunction;
          return true;
        }
        return false;
      }

      // This function allows you to set a threshold for relative time strings
      function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === undefined) {
          return false;
        }
        if (limit === undefined) {
          return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === 's') {
          thresholds.ss = limit - 1;
        }
        return true;
      }
      function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var withSuffix = false,
          th = thresholds,
          locale,
          output;
        if (typeof argWithSuffix === 'object') {
          argThresholds = argWithSuffix;
          argWithSuffix = false;
        }
        if (typeof argWithSuffix === 'boolean') {
          withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === 'object') {
          th = Object.assign({}, thresholds, argThresholds);
          if (argThresholds.s != null && argThresholds.ss == null) {
            th.ss = argThresholds.s - 1;
          }
        }
        locale = this.localeData();
        output = relativeTime$1(this, !withSuffix, th, locale);
        if (withSuffix) {
          output = locale.pastFuture(+this, output);
        }
        return locale.postformat(output);
      }
      var abs$1 = Math.abs;
      function sign(x) {
        return (x > 0) - (x < 0) || +x;
      }
      function toISOString$1() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var seconds = abs$1(this._milliseconds) / 1000,
          days = abs$1(this._days),
          months = abs$1(this._months),
          minutes,
          hours,
          years,
          s,
          total = this.asSeconds(),
          totalSign,
          ymSign,
          daysSign,
          hmsSign;
        if (!total) {
          // this is the same as C#'s (Noda) and python (isodate)...
          // but not other JS (goog.date)
          return 'P0D';
        }

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes = absFloor(seconds / 60);
        hours = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
        totalSign = total < 0 ? '-' : '';
        ymSign = sign(this._months) !== sign(total) ? '-' : '';
        daysSign = sign(this._days) !== sign(total) ? '-' : '';
        hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';
        return totalSign + 'P' + (years ? ymSign + years + 'Y' : '') + (months ? ymSign + months + 'M' : '') + (days ? daysSign + days + 'D' : '') + (hours || minutes || seconds ? 'T' : '') + (hours ? hmsSign + hours + 'H' : '') + (minutes ? hmsSign + minutes + 'M' : '') + (seconds ? hmsSign + s + 'S' : '');
      }
      var proto$2 = Duration.prototype;
      proto$2.isValid = isValid$1;
      proto$2.abs = abs;
      proto$2.add = add$1;
      proto$2.subtract = subtract$1;
      proto$2.as = as;
      proto$2.asMilliseconds = asMilliseconds;
      proto$2.asSeconds = asSeconds;
      proto$2.asMinutes = asMinutes;
      proto$2.asHours = asHours;
      proto$2.asDays = asDays;
      proto$2.asWeeks = asWeeks;
      proto$2.asMonths = asMonths;
      proto$2.asQuarters = asQuarters;
      proto$2.asYears = asYears;
      proto$2.valueOf = valueOf$1;
      proto$2._bubble = bubble;
      proto$2.clone = clone$1;
      proto$2.get = get$2;
      proto$2.milliseconds = milliseconds;
      proto$2.seconds = seconds;
      proto$2.minutes = minutes;
      proto$2.hours = hours;
      proto$2.days = days;
      proto$2.weeks = weeks;
      proto$2.months = months;
      proto$2.years = years;
      proto$2.humanize = humanize;
      proto$2.toISOString = toISOString$1;
      proto$2.toString = toISOString$1;
      proto$2.toJSON = toISOString$1;
      proto$2.locale = locale;
      proto$2.localeData = localeData;
      proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
      proto$2.lang = lang;

      // FORMATTING

      addFormatToken('X', 0, 0, 'unix');
      addFormatToken('x', 0, 0, 'valueOf');

      // PARSING

      addRegexToken('x', matchSigned);
      addRegexToken('X', matchTimestamp);
      addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input) * 1000);
      });
      addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
      });

      //! moment.js

      hooks.version = '2.30.1';
      setHookCallback(createLocal);
      hooks.fn = proto;
      hooks.min = min;
      hooks.max = max;
      hooks.now = now;
      hooks.utc = createUTC;
      hooks.unix = createUnix;
      hooks.months = listMonths;
      hooks.isDate = isDate;
      hooks.locale = getSetGlobalLocale;
      hooks.invalid = createInvalid;
      hooks.duration = createDuration;
      hooks.isMoment = isMoment;
      hooks.weekdays = listWeekdays;
      hooks.parseZone = createInZone;
      hooks.localeData = getLocale;
      hooks.isDuration = isDuration;
      hooks.monthsShort = listMonthsShort;
      hooks.weekdaysMin = listWeekdaysMin;
      hooks.defineLocale = defineLocale;
      hooks.updateLocale = updateLocale;
      hooks.locales = listLocales;
      hooks.weekdaysShort = listWeekdaysShort;
      hooks.normalizeUnits = normalizeUnits;
      hooks.relativeTimeRounding = getSetRelativeTimeRounding;
      hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
      hooks.calendarFormat = getCalendarFormat;
      hooks.prototype = proto;

      // currently HTML5 input type only supports 24-hour formats
      hooks.HTML5_FMT = {
        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',
        // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',
        // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',
        // <input type="datetime-local" step="0.001" />
        DATE: 'YYYY-MM-DD',
        // <input type="date" />
        TIME: 'HH:mm',
        // <input type="time" />
        TIME_SECONDS: 'HH:mm:ss',
        // <input type="time" step="1" />
        TIME_MS: 'HH:mm:ss.SSS',
        // <input type="time" step="0.001" />
        WEEK: 'GGGG-[W]WW',
        // <input type="week" />
        MONTH: 'YYYY-MM' // <input type="month" />
      };
      return hooks;
    });
  })(moment$2);
  return moment$2.exports;
}

var lessNode = {};

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */

var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind,
    key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _,
    done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function (f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? {
      get: descriptor.get,
      set: descriptor.set
    } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", {
    configurable: true,
    value: prefix ? "".concat(prefix, " ", name) : name
  });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = {
      label: 0,
      sent: function () {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
    f,
    y,
    t,
    g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;
  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}
var __createBinding = Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function () {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
};
function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
    m = s && o[s],
    i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function () {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
    r,
    ar = [],
    e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}

/** @deprecated */
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
  return ar;
}

/** @deprecated */
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];
  return r;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []),
    i,
    q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function () {
    return this;
  }, i;
  function awaitReturn(f) {
    return function (v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  function verb(n, f) {
    if (g[n]) {
      i[n] = function (v) {
        return new Promise(function (a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
      if (f) i[n] = f(i[n]);
    }
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function () {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function (v) {
      return (p = !p) ? {
        value: __await(o[n](v)),
        done: false
      } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator],
    i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function (v) {
      return new Promise(function (resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function (v) {
      resolve({
        value: v,
        done: d
      });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", {
      value: raw
    });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
var __setModuleDefault = Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
};
var ownKeys = function (o) {
  ownKeys = Object.getOwnPropertyNames || function (o) {
    var ar = [];
    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
    return ar;
  };
  return ownKeys(o);
};
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
  __setModuleDefault(result, mod);
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : {
    default: mod
  };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function () {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    env.stack.push({
      value: value,
      dispose: dispose,
      async: async
    });
  } else if (async) {
    env.stack.push({
      async: true
    });
  }
  return value;
}
var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  var r,
    s = 0;
  function next() {
    while (r = env.stack.pop()) {
      try {
        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
        if (r.dispose) {
          var result = r.dispose.call(r.value);
          if (r.async) return s |= 2, Promise.resolve(result).then(next, function (e) {
            fail(e);
            return next();
          });
        } else s |= 1;
      } catch (e) {
        fail(e);
      }
    }
    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
    if (env.hasError) throw env.error;
  }
  return next();
}
function __rewriteRelativeImportExtension(path, preserveJsx) {
  if (typeof path === "string" && /^\.\.?\//.test(path)) {
    return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {
      return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
    });
  }
  return path;
}
var tslib_es6 = {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __esDecorate,
  __runInitializers,
  __propKey,
  __setFunctionName,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
  __rewriteRelativeImportExtension
};

var tslib_es6$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	__addDisposableResource: __addDisposableResource,
	get __assign () { return __assign; },
	__asyncDelegator: __asyncDelegator,
	__asyncGenerator: __asyncGenerator,
	__asyncValues: __asyncValues,
	__await: __await,
	__awaiter: __awaiter,
	__classPrivateFieldGet: __classPrivateFieldGet,
	__classPrivateFieldIn: __classPrivateFieldIn,
	__classPrivateFieldSet: __classPrivateFieldSet,
	__createBinding: __createBinding,
	__decorate: __decorate,
	__disposeResources: __disposeResources,
	__esDecorate: __esDecorate,
	__exportStar: __exportStar,
	__extends: __extends,
	__generator: __generator,
	__importDefault: __importDefault,
	__importStar: __importStar,
	__makeTemplateObject: __makeTemplateObject,
	__metadata: __metadata,
	__param: __param,
	__propKey: __propKey,
	__read: __read,
	__rest: __rest,
	__rewriteRelativeImportExtension: __rewriteRelativeImportExtension,
	__runInitializers: __runInitializers,
	__setFunctionName: __setFunctionName,
	__spread: __spread,
	__spreadArray: __spreadArray,
	__spreadArrays: __spreadArrays,
	__values: __values,
	default: tslib_es6
});

var require$$0$2 = /*@__PURE__*/getAugmentedNamespace(tslib_es6$1);

var environment$1 = {};

var require$$2$1 = {
	"application/andrew-inset": [
	"ez"
],
	"application/applixware": [
	"aw"
],
	"application/atom+xml": [
	"atom"
],
	"application/atomcat+xml": [
	"atomcat"
],
	"application/atomsvc+xml": [
	"atomsvc"
],
	"application/bdoc": [
	"bdoc"
],
	"application/ccxml+xml": [
	"ccxml"
],
	"application/cdmi-capability": [
	"cdmia"
],
	"application/cdmi-container": [
	"cdmic"
],
	"application/cdmi-domain": [
	"cdmid"
],
	"application/cdmi-object": [
	"cdmio"
],
	"application/cdmi-queue": [
	"cdmiq"
],
	"application/cu-seeme": [
	"cu"
],
	"application/dash+xml": [
	"mpd"
],
	"application/davmount+xml": [
	"davmount"
],
	"application/docbook+xml": [
	"dbk"
],
	"application/dssc+der": [
	"dssc"
],
	"application/dssc+xml": [
	"xdssc"
],
	"application/ecmascript": [
	"ecma"
],
	"application/emma+xml": [
	"emma"
],
	"application/epub+zip": [
	"epub"
],
	"application/exi": [
	"exi"
],
	"application/font-tdpfr": [
	"pfr"
],
	"application/font-woff": [
],
	"application/font-woff2": [
],
	"application/geo+json": [
	"geojson"
],
	"application/gml+xml": [
	"gml"
],
	"application/gpx+xml": [
	"gpx"
],
	"application/gxf": [
	"gxf"
],
	"application/gzip": [
	"gz"
],
	"application/hyperstudio": [
	"stk"
],
	"application/inkml+xml": [
	"ink",
	"inkml"
],
	"application/ipfix": [
	"ipfix"
],
	"application/java-archive": [
	"jar",
	"war",
	"ear"
],
	"application/java-serialized-object": [
	"ser"
],
	"application/java-vm": [
	"class"
],
	"application/javascript": [
	"js",
	"mjs"
],
	"application/json": [
	"json",
	"map"
],
	"application/json5": [
	"json5"
],
	"application/jsonml+json": [
	"jsonml"
],
	"application/ld+json": [
	"jsonld"
],
	"application/lost+xml": [
	"lostxml"
],
	"application/mac-binhex40": [
	"hqx"
],
	"application/mac-compactpro": [
	"cpt"
],
	"application/mads+xml": [
	"mads"
],
	"application/manifest+json": [
	"webmanifest"
],
	"application/marc": [
	"mrc"
],
	"application/marcxml+xml": [
	"mrcx"
],
	"application/mathematica": [
	"ma",
	"nb",
	"mb"
],
	"application/mathml+xml": [
	"mathml"
],
	"application/mbox": [
	"mbox"
],
	"application/mediaservercontrol+xml": [
	"mscml"
],
	"application/metalink+xml": [
	"metalink"
],
	"application/metalink4+xml": [
	"meta4"
],
	"application/mets+xml": [
	"mets"
],
	"application/mods+xml": [
	"mods"
],
	"application/mp21": [
	"m21",
	"mp21"
],
	"application/mp4": [
	"mp4s",
	"m4p"
],
	"application/msword": [
	"doc",
	"dot"
],
	"application/mxf": [
	"mxf"
],
	"application/octet-stream": [
	"bin",
	"dms",
	"lrf",
	"mar",
	"so",
	"dist",
	"distz",
	"pkg",
	"bpk",
	"dump",
	"elc",
	"deploy",
	"exe",
	"dll",
	"deb",
	"dmg",
	"iso",
	"img",
	"msi",
	"msp",
	"msm",
	"buffer"
],
	"application/oda": [
	"oda"
],
	"application/oebps-package+xml": [
	"opf"
],
	"application/ogg": [
	"ogx"
],
	"application/omdoc+xml": [
	"omdoc"
],
	"application/onenote": [
	"onetoc",
	"onetoc2",
	"onetmp",
	"onepkg"
],
	"application/oxps": [
	"oxps"
],
	"application/patch-ops-error+xml": [
	"xer"
],
	"application/pdf": [
	"pdf"
],
	"application/pgp-encrypted": [
	"pgp"
],
	"application/pgp-signature": [
	"asc",
	"sig"
],
	"application/pics-rules": [
	"prf"
],
	"application/pkcs10": [
	"p10"
],
	"application/pkcs7-mime": [
	"p7m",
	"p7c"
],
	"application/pkcs7-signature": [
	"p7s"
],
	"application/pkcs8": [
	"p8"
],
	"application/pkix-attr-cert": [
	"ac"
],
	"application/pkix-cert": [
	"cer"
],
	"application/pkix-crl": [
	"crl"
],
	"application/pkix-pkipath": [
	"pkipath"
],
	"application/pkixcmp": [
	"pki"
],
	"application/pls+xml": [
	"pls"
],
	"application/postscript": [
	"ai",
	"eps",
	"ps"
],
	"application/prs.cww": [
	"cww"
],
	"application/pskc+xml": [
	"pskcxml"
],
	"application/raml+yaml": [
	"raml"
],
	"application/rdf+xml": [
	"rdf"
],
	"application/reginfo+xml": [
	"rif"
],
	"application/relax-ng-compact-syntax": [
	"rnc"
],
	"application/resource-lists+xml": [
	"rl"
],
	"application/resource-lists-diff+xml": [
	"rld"
],
	"application/rls-services+xml": [
	"rs"
],
	"application/rpki-ghostbusters": [
	"gbr"
],
	"application/rpki-manifest": [
	"mft"
],
	"application/rpki-roa": [
	"roa"
],
	"application/rsd+xml": [
	"rsd"
],
	"application/rss+xml": [
	"rss"
],
	"application/rtf": [
	"rtf"
],
	"application/sbml+xml": [
	"sbml"
],
	"application/scvp-cv-request": [
	"scq"
],
	"application/scvp-cv-response": [
	"scs"
],
	"application/scvp-vp-request": [
	"spq"
],
	"application/scvp-vp-response": [
	"spp"
],
	"application/sdp": [
	"sdp"
],
	"application/set-payment-initiation": [
	"setpay"
],
	"application/set-registration-initiation": [
	"setreg"
],
	"application/shf+xml": [
	"shf"
],
	"application/smil+xml": [
	"smi",
	"smil"
],
	"application/sparql-query": [
	"rq"
],
	"application/sparql-results+xml": [
	"srx"
],
	"application/srgs": [
	"gram"
],
	"application/srgs+xml": [
	"grxml"
],
	"application/sru+xml": [
	"sru"
],
	"application/ssdl+xml": [
	"ssdl"
],
	"application/ssml+xml": [
	"ssml"
],
	"application/tei+xml": [
	"tei",
	"teicorpus"
],
	"application/thraud+xml": [
	"tfi"
],
	"application/timestamped-data": [
	"tsd"
],
	"application/vnd.3gpp.pic-bw-large": [
	"plb"
],
	"application/vnd.3gpp.pic-bw-small": [
	"psb"
],
	"application/vnd.3gpp.pic-bw-var": [
	"pvb"
],
	"application/vnd.3gpp2.tcap": [
	"tcap"
],
	"application/vnd.3m.post-it-notes": [
	"pwn"
],
	"application/vnd.accpac.simply.aso": [
	"aso"
],
	"application/vnd.accpac.simply.imp": [
	"imp"
],
	"application/vnd.acucobol": [
	"acu"
],
	"application/vnd.acucorp": [
	"atc",
	"acutc"
],
	"application/vnd.adobe.air-application-installer-package+zip": [
	"air"
],
	"application/vnd.adobe.formscentral.fcdt": [
	"fcdt"
],
	"application/vnd.adobe.fxp": [
	"fxp",
	"fxpl"
],
	"application/vnd.adobe.xdp+xml": [
	"xdp"
],
	"application/vnd.adobe.xfdf": [
	"xfdf"
],
	"application/vnd.ahead.space": [
	"ahead"
],
	"application/vnd.airzip.filesecure.azf": [
	"azf"
],
	"application/vnd.airzip.filesecure.azs": [
	"azs"
],
	"application/vnd.amazon.ebook": [
	"azw"
],
	"application/vnd.americandynamics.acc": [
	"acc"
],
	"application/vnd.amiga.ami": [
	"ami"
],
	"application/vnd.android.package-archive": [
	"apk"
],
	"application/vnd.anser-web-certificate-issue-initiation": [
	"cii"
],
	"application/vnd.anser-web-funds-transfer-initiation": [
	"fti"
],
	"application/vnd.antix.game-component": [
	"atx"
],
	"application/vnd.apple.installer+xml": [
	"mpkg"
],
	"application/vnd.apple.mpegurl": [
	"m3u8"
],
	"application/vnd.apple.pkpass": [
	"pkpass"
],
	"application/vnd.aristanetworks.swi": [
	"swi"
],
	"application/vnd.astraea-software.iota": [
	"iota"
],
	"application/vnd.audiograph": [
	"aep"
],
	"application/vnd.blueice.multipass": [
	"mpm"
],
	"application/vnd.bmi": [
	"bmi"
],
	"application/vnd.businessobjects": [
	"rep"
],
	"application/vnd.chemdraw+xml": [
	"cdxml"
],
	"application/vnd.chipnuts.karaoke-mmd": [
	"mmd"
],
	"application/vnd.cinderella": [
	"cdy"
],
	"application/vnd.claymore": [
	"cla"
],
	"application/vnd.cloanto.rp9": [
	"rp9"
],
	"application/vnd.clonk.c4group": [
	"c4g",
	"c4d",
	"c4f",
	"c4p",
	"c4u"
],
	"application/vnd.cluetrust.cartomobile-config": [
	"c11amc"
],
	"application/vnd.cluetrust.cartomobile-config-pkg": [
	"c11amz"
],
	"application/vnd.commonspace": [
	"csp"
],
	"application/vnd.contact.cmsg": [
	"cdbcmsg"
],
	"application/vnd.cosmocaller": [
	"cmc"
],
	"application/vnd.crick.clicker": [
	"clkx"
],
	"application/vnd.crick.clicker.keyboard": [
	"clkk"
],
	"application/vnd.crick.clicker.palette": [
	"clkp"
],
	"application/vnd.crick.clicker.template": [
	"clkt"
],
	"application/vnd.crick.clicker.wordbank": [
	"clkw"
],
	"application/vnd.criticaltools.wbs+xml": [
	"wbs"
],
	"application/vnd.ctc-posml": [
	"pml"
],
	"application/vnd.cups-ppd": [
	"ppd"
],
	"application/vnd.curl.car": [
	"car"
],
	"application/vnd.curl.pcurl": [
	"pcurl"
],
	"application/vnd.dart": [
	"dart"
],
	"application/vnd.data-vision.rdz": [
	"rdz"
],
	"application/vnd.dece.data": [
	"uvf",
	"uvvf",
	"uvd",
	"uvvd"
],
	"application/vnd.dece.ttml+xml": [
	"uvt",
	"uvvt"
],
	"application/vnd.dece.unspecified": [
	"uvx",
	"uvvx"
],
	"application/vnd.dece.zip": [
	"uvz",
	"uvvz"
],
	"application/vnd.denovo.fcselayout-link": [
	"fe_launch"
],
	"application/vnd.dna": [
	"dna"
],
	"application/vnd.dolby.mlp": [
	"mlp"
],
	"application/vnd.dpgraph": [
	"dpg"
],
	"application/vnd.dreamfactory": [
	"dfac"
],
	"application/vnd.ds-keypoint": [
	"kpxx"
],
	"application/vnd.dvb.ait": [
	"ait"
],
	"application/vnd.dvb.service": [
	"svc"
],
	"application/vnd.dynageo": [
	"geo"
],
	"application/vnd.ecowin.chart": [
	"mag"
],
	"application/vnd.enliven": [
	"nml"
],
	"application/vnd.epson.esf": [
	"esf"
],
	"application/vnd.epson.msf": [
	"msf"
],
	"application/vnd.epson.quickanime": [
	"qam"
],
	"application/vnd.epson.salt": [
	"slt"
],
	"application/vnd.epson.ssf": [
	"ssf"
],
	"application/vnd.eszigno3+xml": [
	"es3",
	"et3"
],
	"application/vnd.ezpix-album": [
	"ez2"
],
	"application/vnd.ezpix-package": [
	"ez3"
],
	"application/vnd.fdf": [
	"fdf"
],
	"application/vnd.fdsn.mseed": [
	"mseed"
],
	"application/vnd.fdsn.seed": [
	"seed",
	"dataless"
],
	"application/vnd.flographit": [
	"gph"
],
	"application/vnd.fluxtime.clip": [
	"ftc"
],
	"application/vnd.framemaker": [
	"fm",
	"frame",
	"maker",
	"book"
],
	"application/vnd.frogans.fnc": [
	"fnc"
],
	"application/vnd.frogans.ltf": [
	"ltf"
],
	"application/vnd.fsc.weblaunch": [
	"fsc"
],
	"application/vnd.fujitsu.oasys": [
	"oas"
],
	"application/vnd.fujitsu.oasys2": [
	"oa2"
],
	"application/vnd.fujitsu.oasys3": [
	"oa3"
],
	"application/vnd.fujitsu.oasysgp": [
	"fg5"
],
	"application/vnd.fujitsu.oasysprs": [
	"bh2"
],
	"application/vnd.fujixerox.ddd": [
	"ddd"
],
	"application/vnd.fujixerox.docuworks": [
	"xdw"
],
	"application/vnd.fujixerox.docuworks.binder": [
	"xbd"
],
	"application/vnd.fuzzysheet": [
	"fzs"
],
	"application/vnd.genomatix.tuxedo": [
	"txd"
],
	"application/vnd.geogebra.file": [
	"ggb"
],
	"application/vnd.geogebra.tool": [
	"ggt"
],
	"application/vnd.geometry-explorer": [
	"gex",
	"gre"
],
	"application/vnd.geonext": [
	"gxt"
],
	"application/vnd.geoplan": [
	"g2w"
],
	"application/vnd.geospace": [
	"g3w"
],
	"application/vnd.gmx": [
	"gmx"
],
	"application/vnd.google-apps.document": [
	"gdoc"
],
	"application/vnd.google-apps.presentation": [
	"gslides"
],
	"application/vnd.google-apps.spreadsheet": [
	"gsheet"
],
	"application/vnd.google-earth.kml+xml": [
	"kml"
],
	"application/vnd.google-earth.kmz": [
	"kmz"
],
	"application/vnd.grafeq": [
	"gqf",
	"gqs"
],
	"application/vnd.groove-account": [
	"gac"
],
	"application/vnd.groove-help": [
	"ghf"
],
	"application/vnd.groove-identity-message": [
	"gim"
],
	"application/vnd.groove-injector": [
	"grv"
],
	"application/vnd.groove-tool-message": [
	"gtm"
],
	"application/vnd.groove-tool-template": [
	"tpl"
],
	"application/vnd.groove-vcard": [
	"vcg"
],
	"application/vnd.hal+xml": [
	"hal"
],
	"application/vnd.handheld-entertainment+xml": [
	"zmm"
],
	"application/vnd.hbci": [
	"hbci"
],
	"application/vnd.hhe.lesson-player": [
	"les"
],
	"application/vnd.hp-hpgl": [
	"hpgl"
],
	"application/vnd.hp-hpid": [
	"hpid"
],
	"application/vnd.hp-hps": [
	"hps"
],
	"application/vnd.hp-jlyt": [
	"jlt"
],
	"application/vnd.hp-pcl": [
	"pcl"
],
	"application/vnd.hp-pclxl": [
	"pclxl"
],
	"application/vnd.hydrostatix.sof-data": [
	"sfd-hdstx"
],
	"application/vnd.ibm.minipay": [
	"mpy"
],
	"application/vnd.ibm.modcap": [
	"afp",
	"listafp",
	"list3820"
],
	"application/vnd.ibm.rights-management": [
	"irm"
],
	"application/vnd.ibm.secure-container": [
	"sc"
],
	"application/vnd.iccprofile": [
	"icc",
	"icm"
],
	"application/vnd.igloader": [
	"igl"
],
	"application/vnd.immervision-ivp": [
	"ivp"
],
	"application/vnd.immervision-ivu": [
	"ivu"
],
	"application/vnd.insors.igm": [
	"igm"
],
	"application/vnd.intercon.formnet": [
	"xpw",
	"xpx"
],
	"application/vnd.intergeo": [
	"i2g"
],
	"application/vnd.intu.qbo": [
	"qbo"
],
	"application/vnd.intu.qfx": [
	"qfx"
],
	"application/vnd.ipunplugged.rcprofile": [
	"rcprofile"
],
	"application/vnd.irepository.package+xml": [
	"irp"
],
	"application/vnd.is-xpr": [
	"xpr"
],
	"application/vnd.isac.fcs": [
	"fcs"
],
	"application/vnd.jam": [
	"jam"
],
	"application/vnd.jcp.javame.midlet-rms": [
	"rms"
],
	"application/vnd.jisp": [
	"jisp"
],
	"application/vnd.joost.joda-archive": [
	"joda"
],
	"application/vnd.kahootz": [
	"ktz",
	"ktr"
],
	"application/vnd.kde.karbon": [
	"karbon"
],
	"application/vnd.kde.kchart": [
	"chrt"
],
	"application/vnd.kde.kformula": [
	"kfo"
],
	"application/vnd.kde.kivio": [
	"flw"
],
	"application/vnd.kde.kontour": [
	"kon"
],
	"application/vnd.kde.kpresenter": [
	"kpr",
	"kpt"
],
	"application/vnd.kde.kspread": [
	"ksp"
],
	"application/vnd.kde.kword": [
	"kwd",
	"kwt"
],
	"application/vnd.kenameaapp": [
	"htke"
],
	"application/vnd.kidspiration": [
	"kia"
],
	"application/vnd.kinar": [
	"kne",
	"knp"
],
	"application/vnd.koan": [
	"skp",
	"skd",
	"skt",
	"skm"
],
	"application/vnd.kodak-descriptor": [
	"sse"
],
	"application/vnd.las.las+xml": [
	"lasxml"
],
	"application/vnd.llamagraphics.life-balance.desktop": [
	"lbd"
],
	"application/vnd.llamagraphics.life-balance.exchange+xml": [
	"lbe"
],
	"application/vnd.lotus-1-2-3": [
	"123"
],
	"application/vnd.lotus-approach": [
	"apr"
],
	"application/vnd.lotus-freelance": [
	"pre"
],
	"application/vnd.lotus-notes": [
	"nsf"
],
	"application/vnd.lotus-organizer": [
	"org"
],
	"application/vnd.lotus-screencam": [
	"scm"
],
	"application/vnd.lotus-wordpro": [
	"lwp"
],
	"application/vnd.macports.portpkg": [
	"portpkg"
],
	"application/vnd.mcd": [
	"mcd"
],
	"application/vnd.medcalcdata": [
	"mc1"
],
	"application/vnd.mediastation.cdkey": [
	"cdkey"
],
	"application/vnd.mfer": [
	"mwf"
],
	"application/vnd.mfmp": [
	"mfm"
],
	"application/vnd.micrografx.flo": [
	"flo"
],
	"application/vnd.micrografx.igx": [
	"igx"
],
	"application/vnd.mif": [
	"mif"
],
	"application/vnd.mobius.daf": [
	"daf"
],
	"application/vnd.mobius.dis": [
	"dis"
],
	"application/vnd.mobius.mbk": [
	"mbk"
],
	"application/vnd.mobius.mqy": [
	"mqy"
],
	"application/vnd.mobius.msl": [
	"msl"
],
	"application/vnd.mobius.plc": [
	"plc"
],
	"application/vnd.mobius.txf": [
	"txf"
],
	"application/vnd.mophun.application": [
	"mpn"
],
	"application/vnd.mophun.certificate": [
	"mpc"
],
	"application/vnd.mozilla.xul+xml": [
	"xul"
],
	"application/vnd.ms-artgalry": [
	"cil"
],
	"application/vnd.ms-cab-compressed": [
	"cab"
],
	"application/vnd.ms-excel": [
	"xls",
	"xlm",
	"xla",
	"xlc",
	"xlt",
	"xlw"
],
	"application/vnd.ms-excel.addin.macroenabled.12": [
	"xlam"
],
	"application/vnd.ms-excel.sheet.binary.macroenabled.12": [
	"xlsb"
],
	"application/vnd.ms-excel.sheet.macroenabled.12": [
	"xlsm"
],
	"application/vnd.ms-excel.template.macroenabled.12": [
	"xltm"
],
	"application/vnd.ms-fontobject": [
	"eot"
],
	"application/vnd.ms-htmlhelp": [
	"chm"
],
	"application/vnd.ms-ims": [
	"ims"
],
	"application/vnd.ms-lrm": [
	"lrm"
],
	"application/vnd.ms-officetheme": [
	"thmx"
],
	"application/vnd.ms-outlook": [
	"msg"
],
	"application/vnd.ms-pki.seccat": [
	"cat"
],
	"application/vnd.ms-pki.stl": [
	"stl"
],
	"application/vnd.ms-powerpoint": [
	"ppt",
	"pps",
	"pot"
],
	"application/vnd.ms-powerpoint.addin.macroenabled.12": [
	"ppam"
],
	"application/vnd.ms-powerpoint.presentation.macroenabled.12": [
	"pptm"
],
	"application/vnd.ms-powerpoint.slide.macroenabled.12": [
	"sldm"
],
	"application/vnd.ms-powerpoint.slideshow.macroenabled.12": [
	"ppsm"
],
	"application/vnd.ms-powerpoint.template.macroenabled.12": [
	"potm"
],
	"application/vnd.ms-project": [
	"mpp",
	"mpt"
],
	"application/vnd.ms-word.document.macroenabled.12": [
	"docm"
],
	"application/vnd.ms-word.template.macroenabled.12": [
	"dotm"
],
	"application/vnd.ms-works": [
	"wps",
	"wks",
	"wcm",
	"wdb"
],
	"application/vnd.ms-wpl": [
	"wpl"
],
	"application/vnd.ms-xpsdocument": [
	"xps"
],
	"application/vnd.mseq": [
	"mseq"
],
	"application/vnd.musician": [
	"mus"
],
	"application/vnd.muvee.style": [
	"msty"
],
	"application/vnd.mynfc": [
	"taglet"
],
	"application/vnd.neurolanguage.nlu": [
	"nlu"
],
	"application/vnd.nitf": [
	"ntf",
	"nitf"
],
	"application/vnd.noblenet-directory": [
	"nnd"
],
	"application/vnd.noblenet-sealer": [
	"nns"
],
	"application/vnd.noblenet-web": [
	"nnw"
],
	"application/vnd.nokia.n-gage.data": [
	"ngdat"
],
	"application/vnd.nokia.n-gage.symbian.install": [
	"n-gage"
],
	"application/vnd.nokia.radio-preset": [
	"rpst"
],
	"application/vnd.nokia.radio-presets": [
	"rpss"
],
	"application/vnd.novadigm.edm": [
	"edm"
],
	"application/vnd.novadigm.edx": [
	"edx"
],
	"application/vnd.novadigm.ext": [
	"ext"
],
	"application/vnd.oasis.opendocument.chart": [
	"odc"
],
	"application/vnd.oasis.opendocument.chart-template": [
	"otc"
],
	"application/vnd.oasis.opendocument.database": [
	"odb"
],
	"application/vnd.oasis.opendocument.formula": [
	"odf"
],
	"application/vnd.oasis.opendocument.formula-template": [
	"odft"
],
	"application/vnd.oasis.opendocument.graphics": [
	"odg"
],
	"application/vnd.oasis.opendocument.graphics-template": [
	"otg"
],
	"application/vnd.oasis.opendocument.image": [
	"odi"
],
	"application/vnd.oasis.opendocument.image-template": [
	"oti"
],
	"application/vnd.oasis.opendocument.presentation": [
	"odp"
],
	"application/vnd.oasis.opendocument.presentation-template": [
	"otp"
],
	"application/vnd.oasis.opendocument.spreadsheet": [
	"ods"
],
	"application/vnd.oasis.opendocument.spreadsheet-template": [
	"ots"
],
	"application/vnd.oasis.opendocument.text": [
	"odt"
],
	"application/vnd.oasis.opendocument.text-master": [
	"odm"
],
	"application/vnd.oasis.opendocument.text-template": [
	"ott"
],
	"application/vnd.oasis.opendocument.text-web": [
	"oth"
],
	"application/vnd.olpc-sugar": [
	"xo"
],
	"application/vnd.oma.dd2+xml": [
	"dd2"
],
	"application/vnd.openofficeorg.extension": [
	"oxt"
],
	"application/vnd.openxmlformats-officedocument.presentationml.presentation": [
	"pptx"
],
	"application/vnd.openxmlformats-officedocument.presentationml.slide": [
	"sldx"
],
	"application/vnd.openxmlformats-officedocument.presentationml.slideshow": [
	"ppsx"
],
	"application/vnd.openxmlformats-officedocument.presentationml.template": [
	"potx"
],
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": [
	"xlsx"
],
	"application/vnd.openxmlformats-officedocument.spreadsheetml.template": [
	"xltx"
],
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document": [
	"docx"
],
	"application/vnd.openxmlformats-officedocument.wordprocessingml.template": [
	"dotx"
],
	"application/vnd.osgeo.mapguide.package": [
	"mgp"
],
	"application/vnd.osgi.dp": [
	"dp"
],
	"application/vnd.osgi.subsystem": [
	"esa"
],
	"application/vnd.palm": [
	"pdb",
	"pqa",
	"oprc"
],
	"application/vnd.pawaafile": [
	"paw"
],
	"application/vnd.pg.format": [
	"str"
],
	"application/vnd.pg.osasli": [
	"ei6"
],
	"application/vnd.picsel": [
	"efif"
],
	"application/vnd.pmi.widget": [
	"wg"
],
	"application/vnd.pocketlearn": [
	"plf"
],
	"application/vnd.powerbuilder6": [
	"pbd"
],
	"application/vnd.previewsystems.box": [
	"box"
],
	"application/vnd.proteus.magazine": [
	"mgz"
],
	"application/vnd.publishare-delta-tree": [
	"qps"
],
	"application/vnd.pvi.ptid1": [
	"ptid"
],
	"application/vnd.quark.quarkxpress": [
	"qxd",
	"qxt",
	"qwd",
	"qwt",
	"qxl",
	"qxb"
],
	"application/vnd.realvnc.bed": [
	"bed"
],
	"application/vnd.recordare.musicxml": [
	"mxl"
],
	"application/vnd.recordare.musicxml+xml": [
	"musicxml"
],
	"application/vnd.rig.cryptonote": [
	"cryptonote"
],
	"application/vnd.rim.cod": [
	"cod"
],
	"application/vnd.rn-realmedia": [
	"rm"
],
	"application/vnd.rn-realmedia-vbr": [
	"rmvb"
],
	"application/vnd.route66.link66+xml": [
	"link66"
],
	"application/vnd.sailingtracker.track": [
	"st"
],
	"application/vnd.seemail": [
	"see"
],
	"application/vnd.sema": [
	"sema"
],
	"application/vnd.semd": [
	"semd"
],
	"application/vnd.semf": [
	"semf"
],
	"application/vnd.shana.informed.formdata": [
	"ifm"
],
	"application/vnd.shana.informed.formtemplate": [
	"itp"
],
	"application/vnd.shana.informed.interchange": [
	"iif"
],
	"application/vnd.shana.informed.package": [
	"ipk"
],
	"application/vnd.simtech-mindmapper": [
	"twd",
	"twds"
],
	"application/vnd.smaf": [
	"mmf"
],
	"application/vnd.smart.teacher": [
	"teacher"
],
	"application/vnd.solent.sdkm+xml": [
	"sdkm",
	"sdkd"
],
	"application/vnd.spotfire.dxp": [
	"dxp"
],
	"application/vnd.spotfire.sfs": [
	"sfs"
],
	"application/vnd.stardivision.calc": [
	"sdc"
],
	"application/vnd.stardivision.draw": [
	"sda"
],
	"application/vnd.stardivision.impress": [
	"sdd"
],
	"application/vnd.stardivision.math": [
	"smf"
],
	"application/vnd.stardivision.writer": [
	"sdw",
	"vor"
],
	"application/vnd.stardivision.writer-global": [
	"sgl"
],
	"application/vnd.stepmania.package": [
	"smzip"
],
	"application/vnd.stepmania.stepchart": [
	"sm"
],
	"application/vnd.sun.wadl+xml": [
	"wadl"
],
	"application/vnd.sun.xml.calc": [
	"sxc"
],
	"application/vnd.sun.xml.calc.template": [
	"stc"
],
	"application/vnd.sun.xml.draw": [
	"sxd"
],
	"application/vnd.sun.xml.draw.template": [
	"std"
],
	"application/vnd.sun.xml.impress": [
	"sxi"
],
	"application/vnd.sun.xml.impress.template": [
	"sti"
],
	"application/vnd.sun.xml.math": [
	"sxm"
],
	"application/vnd.sun.xml.writer": [
	"sxw"
],
	"application/vnd.sun.xml.writer.global": [
	"sxg"
],
	"application/vnd.sun.xml.writer.template": [
	"stw"
],
	"application/vnd.sus-calendar": [
	"sus",
	"susp"
],
	"application/vnd.svd": [
	"svd"
],
	"application/vnd.symbian.install": [
	"sis",
	"sisx"
],
	"application/vnd.syncml+xml": [
	"xsm"
],
	"application/vnd.syncml.dm+wbxml": [
	"bdm"
],
	"application/vnd.syncml.dm+xml": [
	"xdm"
],
	"application/vnd.tao.intent-module-archive": [
	"tao"
],
	"application/vnd.tcpdump.pcap": [
	"pcap",
	"cap",
	"dmp"
],
	"application/vnd.tmobile-livetv": [
	"tmo"
],
	"application/vnd.trid.tpt": [
	"tpt"
],
	"application/vnd.triscape.mxs": [
	"mxs"
],
	"application/vnd.trueapp": [
	"tra"
],
	"application/vnd.ufdl": [
	"ufd",
	"ufdl"
],
	"application/vnd.uiq.theme": [
	"utz"
],
	"application/vnd.umajin": [
	"umj"
],
	"application/vnd.unity": [
	"unityweb"
],
	"application/vnd.uoml+xml": [
	"uoml"
],
	"application/vnd.vcx": [
	"vcx"
],
	"application/vnd.visio": [
	"vsd",
	"vst",
	"vss",
	"vsw"
],
	"application/vnd.visionary": [
	"vis"
],
	"application/vnd.vsf": [
	"vsf"
],
	"application/vnd.wap.wbxml": [
	"wbxml"
],
	"application/vnd.wap.wmlc": [
	"wmlc"
],
	"application/vnd.wap.wmlscriptc": [
	"wmlsc"
],
	"application/vnd.webturbo": [
	"wtb"
],
	"application/vnd.wolfram.player": [
	"nbp"
],
	"application/vnd.wordperfect": [
	"wpd"
],
	"application/vnd.wqd": [
	"wqd"
],
	"application/vnd.wt.stf": [
	"stf"
],
	"application/vnd.xara": [
	"xar"
],
	"application/vnd.xfdl": [
	"xfdl"
],
	"application/vnd.yamaha.hv-dic": [
	"hvd"
],
	"application/vnd.yamaha.hv-script": [
	"hvs"
],
	"application/vnd.yamaha.hv-voice": [
	"hvp"
],
	"application/vnd.yamaha.openscoreformat": [
	"osf"
],
	"application/vnd.yamaha.openscoreformat.osfpvg+xml": [
	"osfpvg"
],
	"application/vnd.yamaha.smaf-audio": [
	"saf"
],
	"application/vnd.yamaha.smaf-phrase": [
	"spf"
],
	"application/vnd.yellowriver-custom-menu": [
	"cmp"
],
	"application/vnd.zul": [
	"zir",
	"zirz"
],
	"application/vnd.zzazz.deck+xml": [
	"zaz"
],
	"application/voicexml+xml": [
	"vxml"
],
	"application/wasm": [
	"wasm"
],
	"application/widget": [
	"wgt"
],
	"application/winhlp": [
	"hlp"
],
	"application/wsdl+xml": [
	"wsdl"
],
	"application/wspolicy+xml": [
	"wspolicy"
],
	"application/x-7z-compressed": [
	"7z"
],
	"application/x-abiword": [
	"abw"
],
	"application/x-ace-compressed": [
	"ace"
],
	"application/x-apple-diskimage": [
],
	"application/x-arj": [
	"arj"
],
	"application/x-authorware-bin": [
	"aab",
	"x32",
	"u32",
	"vox"
],
	"application/x-authorware-map": [
	"aam"
],
	"application/x-authorware-seg": [
	"aas"
],
	"application/x-bcpio": [
	"bcpio"
],
	"application/x-bdoc": [
],
	"application/x-bittorrent": [
	"torrent"
],
	"application/x-blorb": [
	"blb",
	"blorb"
],
	"application/x-bzip": [
	"bz"
],
	"application/x-bzip2": [
	"bz2",
	"boz"
],
	"application/x-cbr": [
	"cbr",
	"cba",
	"cbt",
	"cbz",
	"cb7"
],
	"application/x-cdlink": [
	"vcd"
],
	"application/x-cfs-compressed": [
	"cfs"
],
	"application/x-chat": [
	"chat"
],
	"application/x-chess-pgn": [
	"pgn"
],
	"application/x-chrome-extension": [
	"crx"
],
	"application/x-cocoa": [
	"cco"
],
	"application/x-conference": [
	"nsc"
],
	"application/x-cpio": [
	"cpio"
],
	"application/x-csh": [
	"csh"
],
	"application/x-debian-package": [
	"udeb"
],
	"application/x-dgc-compressed": [
	"dgc"
],
	"application/x-director": [
	"dir",
	"dcr",
	"dxr",
	"cst",
	"cct",
	"cxt",
	"w3d",
	"fgd",
	"swa"
],
	"application/x-doom": [
	"wad"
],
	"application/x-dtbncx+xml": [
	"ncx"
],
	"application/x-dtbook+xml": [
	"dtb"
],
	"application/x-dtbresource+xml": [
	"res"
],
	"application/x-dvi": [
	"dvi"
],
	"application/x-envoy": [
	"evy"
],
	"application/x-eva": [
	"eva"
],
	"application/x-font-bdf": [
	"bdf"
],
	"application/x-font-ghostscript": [
	"gsf"
],
	"application/x-font-linux-psf": [
	"psf"
],
	"application/x-font-pcf": [
	"pcf"
],
	"application/x-font-snf": [
	"snf"
],
	"application/x-font-type1": [
	"pfa",
	"pfb",
	"pfm",
	"afm"
],
	"application/x-freearc": [
	"arc"
],
	"application/x-futuresplash": [
	"spl"
],
	"application/x-gca-compressed": [
	"gca"
],
	"application/x-glulx": [
	"ulx"
],
	"application/x-gnumeric": [
	"gnumeric"
],
	"application/x-gramps-xml": [
	"gramps"
],
	"application/x-gtar": [
	"gtar"
],
	"application/x-hdf": [
	"hdf"
],
	"application/x-httpd-php": [
	"php"
],
	"application/x-install-instructions": [
	"install"
],
	"application/x-iso9660-image": [
],
	"application/x-java-archive-diff": [
	"jardiff"
],
	"application/x-java-jnlp-file": [
	"jnlp"
],
	"application/x-latex": [
	"latex"
],
	"application/x-lua-bytecode": [
	"luac"
],
	"application/x-lzh-compressed": [
	"lzh",
	"lha"
],
	"application/x-makeself": [
	"run"
],
	"application/x-mie": [
	"mie"
],
	"application/x-mobipocket-ebook": [
	"prc",
	"mobi"
],
	"application/x-ms-application": [
	"application"
],
	"application/x-ms-shortcut": [
	"lnk"
],
	"application/x-ms-wmd": [
	"wmd"
],
	"application/x-ms-wmz": [
	"wmz"
],
	"application/x-ms-xbap": [
	"xbap"
],
	"application/x-msaccess": [
	"mdb"
],
	"application/x-msbinder": [
	"obd"
],
	"application/x-mscardfile": [
	"crd"
],
	"application/x-msclip": [
	"clp"
],
	"application/x-msdos-program": [
],
	"application/x-msdownload": [
	"com",
	"bat"
],
	"application/x-msmediaview": [
	"mvb",
	"m13",
	"m14"
],
	"application/x-msmetafile": [
	"wmf",
	"emf",
	"emz"
],
	"application/x-msmoney": [
	"mny"
],
	"application/x-mspublisher": [
	"pub"
],
	"application/x-msschedule": [
	"scd"
],
	"application/x-msterminal": [
	"trm"
],
	"application/x-mswrite": [
	"wri"
],
	"application/x-netcdf": [
	"nc",
	"cdf"
],
	"application/x-ns-proxy-autoconfig": [
	"pac"
],
	"application/x-nzb": [
	"nzb"
],
	"application/x-perl": [
	"pl",
	"pm"
],
	"application/x-pilot": [
],
	"application/x-pkcs12": [
	"p12",
	"pfx"
],
	"application/x-pkcs7-certificates": [
	"p7b",
	"spc"
],
	"application/x-pkcs7-certreqresp": [
	"p7r"
],
	"application/x-rar-compressed": [
	"rar"
],
	"application/x-redhat-package-manager": [
	"rpm"
],
	"application/x-research-info-systems": [
	"ris"
],
	"application/x-sea": [
	"sea"
],
	"application/x-sh": [
	"sh"
],
	"application/x-shar": [
	"shar"
],
	"application/x-shockwave-flash": [
	"swf"
],
	"application/x-silverlight-app": [
	"xap"
],
	"application/x-sql": [
	"sql"
],
	"application/x-stuffit": [
	"sit"
],
	"application/x-stuffitx": [
	"sitx"
],
	"application/x-subrip": [
	"srt"
],
	"application/x-sv4cpio": [
	"sv4cpio"
],
	"application/x-sv4crc": [
	"sv4crc"
],
	"application/x-t3vm-image": [
	"t3"
],
	"application/x-tads": [
	"gam"
],
	"application/x-tar": [
	"tar"
],
	"application/x-tcl": [
	"tcl",
	"tk"
],
	"application/x-tex": [
	"tex"
],
	"application/x-tex-tfm": [
	"tfm"
],
	"application/x-texinfo": [
	"texinfo",
	"texi"
],
	"application/x-tgif": [
	"obj"
],
	"application/x-ustar": [
	"ustar"
],
	"application/x-virtualbox-hdd": [
	"hdd"
],
	"application/x-virtualbox-ova": [
	"ova"
],
	"application/x-virtualbox-ovf": [
	"ovf"
],
	"application/x-virtualbox-vbox": [
	"vbox"
],
	"application/x-virtualbox-vbox-extpack": [
	"vbox-extpack"
],
	"application/x-virtualbox-vdi": [
	"vdi"
],
	"application/x-virtualbox-vhd": [
	"vhd"
],
	"application/x-virtualbox-vmdk": [
	"vmdk"
],
	"application/x-wais-source": [
	"src"
],
	"application/x-web-app-manifest+json": [
	"webapp"
],
	"application/x-x509-ca-cert": [
	"der",
	"crt",
	"pem"
],
	"application/x-xfig": [
	"fig"
],
	"application/x-xliff+xml": [
	"xlf"
],
	"application/x-xpinstall": [
	"xpi"
],
	"application/x-xz": [
	"xz"
],
	"application/x-zmachine": [
	"z1",
	"z2",
	"z3",
	"z4",
	"z5",
	"z6",
	"z7",
	"z8"
],
	"application/xaml+xml": [
	"xaml"
],
	"application/xcap-diff+xml": [
	"xdf"
],
	"application/xenc+xml": [
	"xenc"
],
	"application/xhtml+xml": [
	"xhtml",
	"xht"
],
	"application/xml": [
	"xml",
	"xsl",
	"xsd",
	"rng"
],
	"application/xml-dtd": [
	"dtd"
],
	"application/xop+xml": [
	"xop"
],
	"application/xproc+xml": [
	"xpl"
],
	"application/xslt+xml": [
	"xslt"
],
	"application/xspf+xml": [
	"xspf"
],
	"application/xv+xml": [
	"mxml",
	"xhvml",
	"xvml",
	"xvm"
],
	"application/yang": [
	"yang"
],
	"application/yin+xml": [
	"yin"
],
	"application/zip": [
	"zip"
],
	"audio/3gpp": [
],
	"audio/adpcm": [
	"adp"
],
	"audio/basic": [
	"au",
	"snd"
],
	"audio/midi": [
	"mid",
	"midi",
	"kar",
	"rmi"
],
	"audio/mp3": [
],
	"audio/mp4": [
	"m4a",
	"mp4a"
],
	"audio/mpeg": [
	"mpga",
	"mp2",
	"mp2a",
	"mp3",
	"m2a",
	"m3a"
],
	"audio/ogg": [
	"oga",
	"ogg",
	"spx"
],
	"audio/s3m": [
	"s3m"
],
	"audio/silk": [
	"sil"
],
	"audio/vnd.dece.audio": [
	"uva",
	"uvva"
],
	"audio/vnd.digital-winds": [
	"eol"
],
	"audio/vnd.dra": [
	"dra"
],
	"audio/vnd.dts": [
	"dts"
],
	"audio/vnd.dts.hd": [
	"dtshd"
],
	"audio/vnd.lucent.voice": [
	"lvp"
],
	"audio/vnd.ms-playready.media.pya": [
	"pya"
],
	"audio/vnd.nuera.ecelp4800": [
	"ecelp4800"
],
	"audio/vnd.nuera.ecelp7470": [
	"ecelp7470"
],
	"audio/vnd.nuera.ecelp9600": [
	"ecelp9600"
],
	"audio/vnd.rip": [
	"rip"
],
	"audio/wav": [
	"wav"
],
	"audio/wave": [
],
	"audio/webm": [
	"weba"
],
	"audio/x-aac": [
	"aac"
],
	"audio/x-aiff": [
	"aif",
	"aiff",
	"aifc"
],
	"audio/x-caf": [
	"caf"
],
	"audio/x-flac": [
	"flac"
],
	"audio/x-m4a": [
],
	"audio/x-matroska": [
	"mka"
],
	"audio/x-mpegurl": [
	"m3u"
],
	"audio/x-ms-wax": [
	"wax"
],
	"audio/x-ms-wma": [
	"wma"
],
	"audio/x-pn-realaudio": [
	"ram",
	"ra"
],
	"audio/x-pn-realaudio-plugin": [
	"rmp"
],
	"audio/x-realaudio": [
],
	"audio/x-wav": [
],
	"audio/xm": [
	"xm"
],
	"chemical/x-cdx": [
	"cdx"
],
	"chemical/x-cif": [
	"cif"
],
	"chemical/x-cmdf": [
	"cmdf"
],
	"chemical/x-cml": [
	"cml"
],
	"chemical/x-csml": [
	"csml"
],
	"chemical/x-xyz": [
	"xyz"
],
	"font/collection": [
	"ttc"
],
	"font/otf": [
	"otf"
],
	"font/ttf": [
	"ttf"
],
	"font/woff": [
	"woff"
],
	"font/woff2": [
	"woff2"
],
	"image/apng": [
	"apng"
],
	"image/bmp": [
	"bmp"
],
	"image/cgm": [
	"cgm"
],
	"image/g3fax": [
	"g3"
],
	"image/gif": [
	"gif"
],
	"image/ief": [
	"ief"
],
	"image/jp2": [
	"jp2",
	"jpg2"
],
	"image/jpeg": [
	"jpeg",
	"jpg",
	"jpe"
],
	"image/jpm": [
	"jpm"
],
	"image/jpx": [
	"jpx",
	"jpf"
],
	"image/ktx": [
	"ktx"
],
	"image/png": [
	"png"
],
	"image/prs.btif": [
	"btif"
],
	"image/sgi": [
	"sgi"
],
	"image/svg+xml": [
	"svg",
	"svgz"
],
	"image/tiff": [
	"tiff",
	"tif"
],
	"image/vnd.adobe.photoshop": [
	"psd"
],
	"image/vnd.dece.graphic": [
	"uvi",
	"uvvi",
	"uvg",
	"uvvg"
],
	"image/vnd.djvu": [
	"djvu",
	"djv"
],
	"image/vnd.dvb.subtitle": [
],
	"image/vnd.dwg": [
	"dwg"
],
	"image/vnd.dxf": [
	"dxf"
],
	"image/vnd.fastbidsheet": [
	"fbs"
],
	"image/vnd.fpx": [
	"fpx"
],
	"image/vnd.fst": [
	"fst"
],
	"image/vnd.fujixerox.edmics-mmr": [
	"mmr"
],
	"image/vnd.fujixerox.edmics-rlc": [
	"rlc"
],
	"image/vnd.ms-modi": [
	"mdi"
],
	"image/vnd.ms-photo": [
	"wdp"
],
	"image/vnd.net-fpx": [
	"npx"
],
	"image/vnd.wap.wbmp": [
	"wbmp"
],
	"image/vnd.xiff": [
	"xif"
],
	"image/webp": [
	"webp"
],
	"image/x-3ds": [
	"3ds"
],
	"image/x-cmu-raster": [
	"ras"
],
	"image/x-cmx": [
	"cmx"
],
	"image/x-freehand": [
	"fh",
	"fhc",
	"fh4",
	"fh5",
	"fh7"
],
	"image/x-icon": [
	"ico"
],
	"image/x-jng": [
	"jng"
],
	"image/x-mrsid-image": [
	"sid"
],
	"image/x-ms-bmp": [
],
	"image/x-pcx": [
	"pcx"
],
	"image/x-pict": [
	"pic",
	"pct"
],
	"image/x-portable-anymap": [
	"pnm"
],
	"image/x-portable-bitmap": [
	"pbm"
],
	"image/x-portable-graymap": [
	"pgm"
],
	"image/x-portable-pixmap": [
	"ppm"
],
	"image/x-rgb": [
	"rgb"
],
	"image/x-tga": [
	"tga"
],
	"image/x-xbitmap": [
	"xbm"
],
	"image/x-xpixmap": [
	"xpm"
],
	"image/x-xwindowdump": [
	"xwd"
],
	"message/rfc822": [
	"eml",
	"mime"
],
	"model/gltf+json": [
	"gltf"
],
	"model/gltf-binary": [
	"glb"
],
	"model/iges": [
	"igs",
	"iges"
],
	"model/mesh": [
	"msh",
	"mesh",
	"silo"
],
	"model/vnd.collada+xml": [
	"dae"
],
	"model/vnd.dwf": [
	"dwf"
],
	"model/vnd.gdl": [
	"gdl"
],
	"model/vnd.gtw": [
	"gtw"
],
	"model/vnd.mts": [
	"mts"
],
	"model/vnd.vtu": [
	"vtu"
],
	"model/vrml": [
	"wrl",
	"vrml"
],
	"model/x3d+binary": [
	"x3db",
	"x3dbz"
],
	"model/x3d+vrml": [
	"x3dv",
	"x3dvz"
],
	"model/x3d+xml": [
	"x3d",
	"x3dz"
],
	"text/cache-manifest": [
	"appcache",
	"manifest"
],
	"text/calendar": [
	"ics",
	"ifb"
],
	"text/coffeescript": [
	"coffee",
	"litcoffee"
],
	"text/css": [
	"css"
],
	"text/csv": [
	"csv"
],
	"text/hjson": [
	"hjson"
],
	"text/html": [
	"html",
	"htm",
	"shtml"
],
	"text/jade": [
	"jade"
],
	"text/jsx": [
	"jsx"
],
	"text/less": [
	"less"
],
	"text/markdown": [
	"markdown",
	"md"
],
	"text/mathml": [
	"mml"
],
	"text/n3": [
	"n3"
],
	"text/plain": [
	"txt",
	"text",
	"conf",
	"def",
	"list",
	"log",
	"in",
	"ini"
],
	"text/prs.lines.tag": [
	"dsc"
],
	"text/richtext": [
	"rtx"
],
	"text/rtf": [
],
	"text/sgml": [
	"sgml",
	"sgm"
],
	"text/slim": [
	"slim",
	"slm"
],
	"text/stylus": [
	"stylus",
	"styl"
],
	"text/tab-separated-values": [
	"tsv"
],
	"text/troff": [
	"t",
	"tr",
	"roff",
	"man",
	"me",
	"ms"
],
	"text/turtle": [
	"ttl"
],
	"text/uri-list": [
	"uri",
	"uris",
	"urls"
],
	"text/vcard": [
	"vcard"
],
	"text/vnd.curl": [
	"curl"
],
	"text/vnd.curl.dcurl": [
	"dcurl"
],
	"text/vnd.curl.mcurl": [
	"mcurl"
],
	"text/vnd.curl.scurl": [
	"scurl"
],
	"text/vnd.dvb.subtitle": [
	"sub"
],
	"text/vnd.fly": [
	"fly"
],
	"text/vnd.fmi.flexstor": [
	"flx"
],
	"text/vnd.graphviz": [
	"gv"
],
	"text/vnd.in3d.3dml": [
	"3dml"
],
	"text/vnd.in3d.spot": [
	"spot"
],
	"text/vnd.sun.j2me.app-descriptor": [
	"jad"
],
	"text/vnd.wap.wml": [
	"wml"
],
	"text/vnd.wap.wmlscript": [
	"wmls"
],
	"text/vtt": [
	"vtt"
],
	"text/x-asm": [
	"s",
	"asm"
],
	"text/x-c": [
	"c",
	"cc",
	"cxx",
	"cpp",
	"h",
	"hh",
	"dic"
],
	"text/x-component": [
	"htc"
],
	"text/x-fortran": [
	"f",
	"for",
	"f77",
	"f90"
],
	"text/x-handlebars-template": [
	"hbs"
],
	"text/x-java-source": [
	"java"
],
	"text/x-lua": [
	"lua"
],
	"text/x-markdown": [
	"mkd"
],
	"text/x-nfo": [
	"nfo"
],
	"text/x-opml": [
	"opml"
],
	"text/x-org": [
],
	"text/x-pascal": [
	"p",
	"pas"
],
	"text/x-processing": [
	"pde"
],
	"text/x-sass": [
	"sass"
],
	"text/x-scss": [
	"scss"
],
	"text/x-setext": [
	"etx"
],
	"text/x-sfv": [
	"sfv"
],
	"text/x-suse-ymp": [
	"ymp"
],
	"text/x-uuencode": [
	"uu"
],
	"text/x-vcalendar": [
	"vcs"
],
	"text/x-vcard": [
	"vcf"
],
	"text/xml": [
],
	"text/yaml": [
	"yaml",
	"yml"
],
	"video/3gpp": [
	"3gp",
	"3gpp"
],
	"video/3gpp2": [
	"3g2"
],
	"video/h261": [
	"h261"
],
	"video/h263": [
	"h263"
],
	"video/h264": [
	"h264"
],
	"video/jpeg": [
	"jpgv"
],
	"video/jpm": [
	"jpgm"
],
	"video/mj2": [
	"mj2",
	"mjp2"
],
	"video/mp2t": [
	"ts"
],
	"video/mp4": [
	"mp4",
	"mp4v",
	"mpg4"
],
	"video/mpeg": [
	"mpeg",
	"mpg",
	"mpe",
	"m1v",
	"m2v"
],
	"video/ogg": [
	"ogv"
],
	"video/quicktime": [
	"qt",
	"mov"
],
	"video/vnd.dece.hd": [
	"uvh",
	"uvvh"
],
	"video/vnd.dece.mobile": [
	"uvm",
	"uvvm"
],
	"video/vnd.dece.pd": [
	"uvp",
	"uvvp"
],
	"video/vnd.dece.sd": [
	"uvs",
	"uvvs"
],
	"video/vnd.dece.video": [
	"uvv",
	"uvvv"
],
	"video/vnd.dvb.file": [
	"dvb"
],
	"video/vnd.fvt": [
	"fvt"
],
	"video/vnd.mpegurl": [
	"mxu",
	"m4u"
],
	"video/vnd.ms-playready.media.pyv": [
	"pyv"
],
	"video/vnd.uvvu.mp4": [
	"uvu",
	"uvvu"
],
	"video/vnd.vivo": [
	"viv"
],
	"video/webm": [
	"webm"
],
	"video/x-f4v": [
	"f4v"
],
	"video/x-fli": [
	"fli"
],
	"video/x-flv": [
	"flv"
],
	"video/x-m4v": [
	"m4v"
],
	"video/x-matroska": [
	"mkv",
	"mk3d",
	"mks"
],
	"video/x-mng": [
	"mng"
],
	"video/x-ms-asf": [
	"asf",
	"asx"
],
	"video/x-ms-vob": [
	"vob"
],
	"video/x-ms-wm": [
	"wm"
],
	"video/x-ms-wmv": [
	"wmv"
],
	"video/x-ms-wmx": [
	"wmx"
],
	"video/x-ms-wvx": [
	"wvx"
],
	"video/x-msvideo": [
	"avi"
],
	"video/x-sgi-movie": [
	"movie"
],
	"video/x-smv": [
	"smv"
],
	"x-conference/x-cooltalk": [
	"ice"
]
};

var mime_1;
var hasRequiredMime;
function requireMime() {
  if (hasRequiredMime) return mime_1;
  hasRequiredMime = 1;
  var fs = require$$0$5;
  function Mime() {
    // Map of extension -> mime type
    this.types = Object.create(null);

    // Map of mime type -> extension
    this.extensions = Object.create(null);
  }

  /**
   * Define mimetype -> extension mappings.  Each key is a mime-type that maps
   * to an array of extensions associated with the type.  The first extension is
   * used as the default extension for the type.
   *
   * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
   *
   * @param map (Object) type definitions
   */
  Mime.prototype.define = function (map) {
    for (var type in map) {
      var exts = map[type];
      for (var i = 0; i < exts.length; i++) {
        if (process.env.DEBUG_MIME && this.types[exts[i]]) {
          console.warn((this._loading || "define()").replace(/.*\//, ''), 'changes "' + exts[i] + '" extension type from ' + this.types[exts[i]] + ' to ' + type);
        }
        this.types[exts[i]] = type;
      }

      // Default extension is the first one we encounter
      if (!this.extensions[type]) {
        this.extensions[type] = exts[0];
      }
    }
  };

  /**
   * Load an Apache2-style ".types" file
   *
   * This may be called multiple times (it's expected).  Where files declare
   * overlapping types/extensions, the last file wins.
   *
   * @param file (String) path of file to load.
   */
  Mime.prototype.load = function (file) {
    this._loading = file;
    // Read file and split into lines
    var map = {},
      content = fs.readFileSync(file, 'ascii'),
      lines = content.split(/[\r\n]+/);
    lines.forEach(function (line) {
      // Clean up whitespace/comments, and split into fields
      var fields = line.replace(/\s*#.*|^\s*|\s*$/g, '').split(/\s+/);
      map[fields.shift()] = fields;
    });
    this.define(map);
    this._loading = null;
  };

  /**
   * Lookup a mime type based on extension
   */
  Mime.prototype.lookup = function (path, fallback) {
    var ext = path.replace(/^.*[\.\/\\]/, '').toLowerCase();
    return this.types[ext] || fallback || this.default_type;
  };

  /**
   * Return file extension associated with a mime type
   */
  Mime.prototype.extension = function (mimeType) {
    var type = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
    return this.extensions[type];
  };

  // Default instance
  var mime = new Mime();

  // Define built-in types
  mime.define(require$$2$1);

  // Default type
  mime.default_type = mime.lookup('bin');

  //
  // Additional API specific to the default instance
  //

  mime.Mime = Mime;

  /**
   * Lookup a charset based on mime type.
   */
  mime.charsets = {
    lookup: function (mimeType, fallback) {
      // Assume text types are utf8
      return /^text\/|^application\/(javascript|json)/.test(mimeType) ? 'UTF-8' : fallback;
    }
  };
  mime_1 = mime;
  return mime_1;
}

var hasRequiredEnvironment$1;
function requireEnvironment$1() {
  if (hasRequiredEnvironment$1) return environment$1;
  hasRequiredEnvironment$1 = 1;
  Object.defineProperty(environment$1, "__esModule", {
    value: true
  });
  environment$1.default = {
    encodeBase64: function encodeBase64(str) {
      // Avoid Buffer constructor on newer versions of Node.js.
      var buffer = Buffer.from ? Buffer.from(str) : new Buffer(str);
      return buffer.toString('base64');
    },
    mimeLookup: function (filename) {
      return requireMime().lookup(filename);
    },
    charsetLookup: function (mime) {
      return requireMime().charsets.lookup(mime);
    },
    getSourceMapGenerator: function getSourceMapGenerator() {
      return requireSourceMap().SourceMapGenerator;
    }
  };
  return environment$1;
}

var fileManager = {};

var fs = {};

var hasRequiredFs;
function requireFs() {
  if (hasRequiredFs) return fs;
  hasRequiredFs = 1;
  Object.defineProperty(fs, "__esModule", {
    value: true
  });
  var fs$1;
  try {
    fs$1 = requireGracefulFs();
  } catch (e) {
    fs$1 = require$$0$5;
  }
  fs.default = fs$1;
  return fs;
}

var abstractFileManager = {};

var hasRequiredAbstractFileManager;
function requireAbstractFileManager() {
  if (hasRequiredAbstractFileManager) return abstractFileManager;
  hasRequiredAbstractFileManager = 1;
  Object.defineProperty(abstractFileManager, "__esModule", {
    value: true
  });
  var AbstractFileManager = /** @class */function () {
    function AbstractFileManager() {}
    AbstractFileManager.prototype.getPath = function (filename) {
      var j = filename.lastIndexOf('?');
      if (j > 0) {
        filename = filename.slice(0, j);
      }
      j = filename.lastIndexOf('/');
      if (j < 0) {
        j = filename.lastIndexOf('\\');
      }
      if (j < 0) {
        return '';
      }
      return filename.slice(0, j + 1);
    };
    AbstractFileManager.prototype.tryAppendExtension = function (path, ext) {
      return /(\.[a-z]*$)|([?;].*)$/.test(path) ? path : path + ext;
    };
    AbstractFileManager.prototype.tryAppendLessExtension = function (path) {
      return this.tryAppendExtension(path, '.less');
    };
    AbstractFileManager.prototype.supportsSync = function () {
      return false;
    };
    AbstractFileManager.prototype.alwaysMakePathsAbsolute = function () {
      return false;
    };
    AbstractFileManager.prototype.isPathAbsolute = function (filename) {
      return /^(?:[a-z-]+:|\/|\\|#)/i.test(filename);
    };
    // TODO: pull out / replace?
    AbstractFileManager.prototype.join = function (basePath, laterPath) {
      if (!basePath) {
        return laterPath;
      }
      return basePath + laterPath;
    };
    AbstractFileManager.prototype.pathDiff = function (url, baseUrl) {
      // diff between two paths to create a relative path
      var urlParts = this.extractUrlParts(url);
      var baseUrlParts = this.extractUrlParts(baseUrl);
      var i;
      var max;
      var urlDirectories;
      var baseUrlDirectories;
      var diff = '';
      if (urlParts.hostPart !== baseUrlParts.hostPart) {
        return '';
      }
      max = Math.max(baseUrlParts.directories.length, urlParts.directories.length);
      for (i = 0; i < max; i++) {
        if (baseUrlParts.directories[i] !== urlParts.directories[i]) {
          break;
        }
      }
      baseUrlDirectories = baseUrlParts.directories.slice(i);
      urlDirectories = urlParts.directories.slice(i);
      for (i = 0; i < baseUrlDirectories.length - 1; i++) {
        diff += '../';
      }
      for (i = 0; i < urlDirectories.length - 1; i++) {
        diff += "".concat(urlDirectories[i], "/");
      }
      return diff;
    };
    /**
     * Helper function, not part of API.
     * This should be replaceable by newer Node / Browser APIs
     *
     * @param {string} url
     * @param {string} baseUrl
     */
    AbstractFileManager.prototype.extractUrlParts = function (url, baseUrl) {
      // urlParts[1] = protocol://hostname/ OR /
      // urlParts[2] = / if path relative to host base
      // urlParts[3] = directories
      // urlParts[4] = filename
      // urlParts[5] = parameters
      var urlPartsRegex = /^((?:[a-z-]+:)?\/{2}(?:[^/?#]*\/)|([/\\]))?((?:[^/\\?#]*[/\\])*)([^/\\?#]*)([#?].*)?$/i;
      var urlParts = url.match(urlPartsRegex);
      var returner = {};
      var rawDirectories = [];
      var directories = [];
      var i;
      var baseUrlParts;
      if (!urlParts) {
        throw new Error("Could not parse sheet href - '".concat(url, "'"));
      }
      // Stylesheets in IE don't always return the full path
      if (baseUrl && (!urlParts[1] || urlParts[2])) {
        baseUrlParts = baseUrl.match(urlPartsRegex);
        if (!baseUrlParts) {
          throw new Error("Could not parse page url - '".concat(baseUrl, "'"));
        }
        urlParts[1] = urlParts[1] || baseUrlParts[1] || '';
        if (!urlParts[2]) {
          urlParts[3] = baseUrlParts[3] + urlParts[3];
        }
      }
      if (urlParts[3]) {
        rawDirectories = urlParts[3].replace(/\\/g, '/').split('/');
        // collapse '..' and skip '.'
        for (i = 0; i < rawDirectories.length; i++) {
          if (rawDirectories[i] === '..') {
            directories.pop();
          } else if (rawDirectories[i] !== '.') {
            directories.push(rawDirectories[i]);
          }
        }
      }
      returner.hostPart = urlParts[1];
      returner.directories = directories;
      returner.rawPath = (urlParts[1] || '') + rawDirectories.join('/');
      returner.path = (urlParts[1] || '') + directories.join('/');
      returner.filename = urlParts[4];
      returner.fileUrl = returner.path + (urlParts[4] || '');
      returner.url = returner.fileUrl + (urlParts[5] || '');
      return returner;
    };
    return AbstractFileManager;
  }();
  abstractFileManager.default = AbstractFileManager;
  return abstractFileManager;
}

var hasRequiredFileManager;
function requireFileManager() {
  if (hasRequiredFileManager) return fileManager;
  hasRequiredFileManager = 1;
  Object.defineProperty(fileManager, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var path_1 = tslib_1.__importDefault(require$$1$1);
  var fs_1 = tslib_1.__importDefault(requireFs());
  var abstract_file_manager_js_1 = tslib_1.__importDefault(requireAbstractFileManager());
  var FileManager = function () {};
  FileManager.prototype = Object.assign(new abstract_file_manager_js_1.default(), {
    supports: function () {
      return true;
    },
    supportsSync: function () {
      return true;
    },
    loadFile: function (filename, currentDirectory, options, environment, callback) {
      var fullFilename;
      var isAbsoluteFilename = this.isPathAbsolute(filename);
      var filenamesTried = [];
      var self = this;
      var prefix = filename.slice(0, 1);
      var explicit = prefix === '.' || prefix === '/';
      var result = null;
      var isNodeModule = false;
      var npmPrefix = 'npm://';
      options = options || {};
      var paths = isAbsoluteFilename ? [''] : [currentDirectory];
      if (options.paths) {
        paths.push.apply(paths, options.paths);
      }
      if (!isAbsoluteFilename && paths.indexOf('.') === -1) {
        paths.push('.');
      }
      var prefixes = options.prefixes || [''];
      var fileParts = this.extractUrlParts(filename);
      if (options.syncImport) {
        getFileData(returnData, returnData);
        if (callback) {
          callback(result.error, result);
        } else {
          return result;
        }
      } else {
        // promise is guaranteed to be asyncronous
        // which helps as it allows the file handle
        // to be closed before it continues with the next file
        return new Promise(getFileData);
      }
      function returnData(data) {
        if (!data.filename) {
          result = {
            error: data
          };
        } else {
          result = data;
        }
      }
      function getFileData(fulfill, reject) {
        (function tryPathIndex(i) {
          function tryWithExtension() {
            var extFilename = options.ext ? self.tryAppendExtension(fullFilename, options.ext) : fullFilename;
            if (extFilename !== fullFilename && !explicit && paths[i] === '.') {
              try {
                fullFilename = require.resolve(extFilename);
                isNodeModule = true;
              } catch (e) {
                filenamesTried.push(npmPrefix + extFilename);
                fullFilename = extFilename;
              }
            } else {
              fullFilename = extFilename;
            }
          }
          if (i < paths.length) {
            (function tryPrefix(j) {
              if (j < prefixes.length) {
                isNodeModule = false;
                fullFilename = fileParts.rawPath + prefixes[j] + fileParts.filename;
                if (paths[i]) {
                  fullFilename = path_1.default.join(paths[i], fullFilename);
                }
                if (!explicit && paths[i] === '.') {
                  try {
                    fullFilename = require.resolve(fullFilename);
                    isNodeModule = true;
                  } catch (e) {
                    filenamesTried.push(npmPrefix + fullFilename);
                    tryWithExtension();
                  }
                } else {
                  tryWithExtension();
                }
                var readFileArgs = [fullFilename];
                if (!options.rawBuffer) {
                  readFileArgs.push('utf-8');
                }
                if (options.syncImport) {
                  try {
                    var data = fs_1.default.readFileSync.apply(this, readFileArgs);
                    fulfill({
                      contents: data,
                      filename: fullFilename
                    });
                  } catch (e) {
                    filenamesTried.push(isNodeModule ? npmPrefix + fullFilename : fullFilename);
                    return tryPrefix(j + 1);
                  }
                } else {
                  readFileArgs.push(function (e, data) {
                    if (e) {
                      filenamesTried.push(isNodeModule ? npmPrefix + fullFilename : fullFilename);
                      return tryPrefix(j + 1);
                    }
                    fulfill({
                      contents: data,
                      filename: fullFilename
                    });
                  });
                  fs_1.default.readFile.apply(this, readFileArgs);
                }
              } else {
                tryPathIndex(i + 1);
              }
            })(0);
          } else {
            reject({
              type: 'File',
              message: "'".concat(filename, "' wasn't found. Tried - ").concat(filenamesTried.join(','))
            });
          }
        })(0);
      }
    },
    loadFileSync: function (filename, currentDirectory, options, environment) {
      options.syncImport = true;
      return this.loadFile(filename, currentDirectory, options, environment);
    }
  });
  fileManager.default = FileManager;
  return fileManager;
}

var urlFileManager = {};

var logger = {};

var hasRequiredLogger;
function requireLogger() {
  if (hasRequiredLogger) return logger;
  hasRequiredLogger = 1;
  Object.defineProperty(logger, "__esModule", {
    value: true
  });
  logger.default = {
    error: function (msg) {
      this._fireEvent('error', msg);
    },
    warn: function (msg) {
      this._fireEvent('warn', msg);
    },
    info: function (msg) {
      this._fireEvent('info', msg);
    },
    debug: function (msg) {
      this._fireEvent('debug', msg);
    },
    addListener: function (listener) {
      this._listeners.push(listener);
    },
    removeListener: function (listener) {
      for (var i = 0; i < this._listeners.length; i++) {
        if (this._listeners[i] === listener) {
          this._listeners.splice(i, 1);
          return;
        }
      }
    },
    _fireEvent: function (type, msg) {
      for (var i = 0; i < this._listeners.length; i++) {
        var logFunction = this._listeners[i][type];
        if (logFunction) {
          logFunction(msg);
        }
      }
    },
    _listeners: []
  };
  return logger;
}

var needle = {exports: {}};

var querystring = {};

var hasRequiredQuerystring;
function requireQuerystring() {
  if (hasRequiredQuerystring) return querystring;
  hasRequiredQuerystring = 1;
  // based on the qs module, but handles null objects as expected
  // fixes by Tomas Pollak.

  var toString = Object.prototype.toString;
  function stringify(obj, prefix) {
    if (prefix && (obj === null || typeof obj == 'undefined')) {
      return prefix + '=';
    } else if (toString.call(obj) == '[object Array]') {
      return stringifyArray(obj, prefix);
    } else if (toString.call(obj) == '[object Object]') {
      return stringifyObject(obj, prefix);
    } else if (toString.call(obj) == '[object Date]') {
      return obj.toISOString();
    } else if (prefix) {
      // string inside array or hash
      return prefix + '=' + encodeURIComponent(String(obj));
    } else if (String(obj).indexOf('=') !== -1) {
      // string with equal sign
      return String(obj);
    } else {
      throw new TypeError('Cannot build a querystring out of: ' + obj);
    }
  }
  function stringifyArray(arr, prefix) {
    var ret = [];
    for (var i = 0, len = arr.length; i < len; i++) {
      if (prefix) ret.push(stringify(arr[i], prefix + '[]'));else ret.push(stringify(arr[i]));
    }
    return ret.join('&');
  }
  function stringifyObject(obj, prefix) {
    var ret = [];
    Object.keys(obj).forEach(function (key) {
      ret.push(stringify(obj[key], prefix ? prefix + '[' + encodeURIComponent(key) + ']' : encodeURIComponent(key)));
    });
    return ret.join('&');
  }
  querystring.build = stringify;
  return querystring;
}

var multipart = {};

var hasRequiredMultipart;
function requireMultipart() {
  if (hasRequiredMultipart) return multipart;
  hasRequiredMultipart = 1;
  var readFile = require$$0$5.readFile,
    basename = require$$1$1.basename;
  multipart.build = function (data, boundary, callback) {
    if (typeof data != 'object' || typeof data.pipe == 'function') return callback(new Error('Multipart builder expects data as key/val object.'));
    var body = '',
      object = flatten(data),
      count = Object.keys(object).length;
    if (count === 0) return callback(new Error('Empty multipart body. Invalid data.'));
    function done(err, section) {
      if (err) return callback(err);
      if (section) body += section;
      --count || callback(null, body + '--' + boundary + '--');
    }
    for (var key in object) {
      var value = object[key];
      if (value === null || typeof value == 'undefined') {
        done();
      } else if (Buffer.isBuffer(value)) {
        var part = {
          buffer: value,
          content_type: 'application/octet-stream'
        };
        generate_part(key, part, boundary, done);
      } else {
        var part = value.buffer || value.file || value.content_type ? value : {
          value: value
        };
        generate_part(key, part, boundary, done);
      }
    }
  };
  function generate_part(name, part, boundary, callback) {
    var return_part = '--' + boundary + '\r\n';
    return_part += 'Content-Disposition: form-data; name="' + name + '"';
    function append(data, filename) {
      if (data) {
        var binary = part.content_type.indexOf('text') == -1;
        return_part += '; filename="' + encodeURIComponent(filename) + '"\r\n';
        if (binary) return_part += 'Content-Transfer-Encoding: binary\r\n';
        return_part += 'Content-Type: ' + part.content_type + '\r\n\r\n';
        return_part += binary ? data.toString('binary') : data.toString('utf8');
      }
      callback(null, return_part + '\r\n');
    }
    if ((part.file || part.buffer) && part.content_type) {
      var filename = part.filename ? part.filename : part.file ? basename(part.file) : name;
      if (part.buffer) return append(part.buffer, filename);
      readFile(part.file, function (err, data) {
        if (err) return callback(err);
        append(data, filename);
      });
    } else {
      if (typeof part.value == 'object') return callback(new Error('Object received for ' + name + ', expected string.'));
      if (part.content_type) {
        return_part += '\r\n';
        return_part += 'Content-Type: ' + part.content_type;
      }
      return_part += '\r\n\r\n';
      return_part += Buffer.from(String(part.value), 'utf8').toString('binary');
      append();
    }
  }

  // flattens nested objects for multipart body
  function flatten(object, into, prefix) {
    into = into || {};
    for (var key in object) {
      var prefix_key = prefix ? prefix + '[' + key + ']' : key;
      var prop = object[key];
      if (prop && typeof prop === 'object' && !(prop.buffer || prop.file || prop.content_type)) flatten(prop, into, prefix_key);else into[prefix_key] = prop;
    }
    return into;
  }
  return multipart;
}

var auth;
var hasRequiredAuth;
function requireAuth() {
  if (hasRequiredAuth) return auth;
  hasRequiredAuth = 1;
  var createHash = require$$0$8.createHash;
  function get_header(header, credentials, opts) {
    var type = header.split(' ')[0],
      user = credentials[0],
      pass = credentials[1];
    if (type == 'Digest') {
      return digest.generate(header, user, pass, opts.method, opts.path);
    } else if (type == 'Basic') {
      return basic(user, pass);
    }
  }

  ////////////////////
  // basic

  function md5(string) {
    return createHash('md5').update(string).digest('hex');
  }
  function basic(user, pass) {
    var str = typeof pass == 'undefined' ? user : [user, pass].join(':');
    return 'Basic ' + Buffer.from(str).toString('base64');
  }

  ////////////////////
  // digest
  // logic inspired from https://github.com/simme/node-http-digest-client

  var digest = {};
  digest.parse_header = function (header) {
    var challenge = {},
      matches = header.match(/([a-z0-9_-]+)="?([a-z0-9_=\/\.@\s-\+:)()]+)"?/gi);
    for (var i = 0, l = matches.length; i < l; i++) {
      var parts = matches[i].split('='),
        key = parts.shift(),
        val = parts.join('=').replace(/^"/, '').replace(/"$/, '');
      challenge[key] = val;
    }
    return challenge;
  };
  digest.update_nc = function (nc) {
    var max = 99999999;
    nc++;
    if (nc > max) nc = 1;
    var padding = new Array(8).join('0') + '';
    nc = nc + '';
    return padding.substr(0, 8 - nc.length) + nc;
  };
  digest.generate = function (header, user, pass, method, path) {
    var nc = 1,
      cnonce = null,
      challenge = digest.parse_header(header);
    var ha1 = md5(user + ':' + challenge.realm + ':' + pass),
      ha2 = md5(method.toUpperCase() + ':' + path),
      resp = [ha1, challenge.nonce];
    if (typeof challenge.qop === 'string') {
      cnonce = md5(Math.random().toString(36)).substr(0, 8);
      nc = digest.update_nc(nc);
      resp = resp.concat(nc, cnonce);
      resp = resp.concat(challenge.qop, ha2);
    } else {
      resp = resp.concat(ha2);
    }
    var params = {
      uri: path,
      realm: challenge.realm,
      nonce: challenge.nonce,
      username: user,
      response: md5(resp.join(':'))
    };
    if (challenge.qop) {
      params.qop = challenge.qop;
    }
    if (challenge.opaque) {
      params.opaque = challenge.opaque;
    }
    if (cnonce) {
      params.nc = nc;
      params.cnonce = cnonce;
    }
    header = [];
    for (var k in params) header.push(k + '="' + params[k] + '"');
    return 'Digest ' + header.join(', ');
  };
  auth = {
    header: get_header,
    basic: basic,
    digest: digest.generate
  };
  return auth;
}

var cookies = {};

var hasRequiredCookies;
function requireCookies() {
  if (hasRequiredCookies) return cookies;
  hasRequiredCookies = 1;
  //  Simple cookie handling implementation based on the standard RFC 6265.
  //
  //  This module just has two functionalities:
  //    - Parse a set-cookie-header as a key value object
  //    - Write a cookie-string from a key value object
  //
  //  All cookie attributes are ignored.

  var unescape = require$$0$9.unescape;
  var COOKIE_PAIR = /^([^=\s]+)\s*=\s*("?)\s*(.*)\s*\2\s*$/;
  var EXCLUDED_CHARS = /[\x00-\x1F\x7F\x3B\x3B\s\"\,\\"%]/g;

  // i know these should be 'const', but I'd like to keep
  // supporting earlier node.js versions as long as I can. :)

  var KEY_INDEX = 1; // index of key from COOKIE_PAIR match
  var VALUE_INDEX = 3; // index of value from COOKIE_PAIR match

  // Returns a copy str trimmed and without trainling semicolon.
  function cleanCookieString(str) {
    return str.trim().replace(/\x3B+$/, '');
  }
  function getFirstPair(str) {
    var index = str.indexOf('\x3B');
    return index === -1 ? str : str.substr(0, index);
  }

  // Returns a encoded copy of str based on RFC6265 S4.1.1.
  function encodeCookieComponent(str) {
    return str.toString().replace(EXCLUDED_CHARS, encodeURIComponent);
  }

  // Parses a set-cookie-string based on the standard defined in RFC6265 S4.1.1.
  function parseSetCookieString(str) {
    str = cleanCookieString(str);
    str = getFirstPair(str);
    var res = COOKIE_PAIR.exec(str);
    if (!res || !res[VALUE_INDEX]) return null;
    return {
      name: unescape(res[KEY_INDEX]),
      value: unescape(res[VALUE_INDEX])
    };
  }

  // Parses a set-cookie-header and returns a key/value object.
  // Each key represents the name of a cookie.
  function parseSetCookieHeader(header) {
    if (!header) return {};
    header = Array.isArray(header) ? header : [header];
    return header.reduce(function (res, str) {
      var cookie = parseSetCookieString(str);
      if (cookie) res[cookie.name] = cookie.value;
      return res;
    }, {});
  }

  // Writes a set-cookie-string based on the standard definded in RFC6265 S4.1.1.
  function writeCookieString(obj) {
    return Object.keys(obj).reduce(function (str, name) {
      var encodedName = encodeCookieComponent(name);
      var encodedValue = encodeCookieComponent(obj[name]);
      str += (str ? '; ' : '') + encodedName + '=' + encodedValue;
      return str;
    }, '');
  }

  // returns a key/val object from an array of cookie strings
  cookies.read = parseSetCookieHeader;

  // writes a cookie string header
  cookies.write = writeCookieString;
  return cookies;
}

var parsers = {exports: {}};

var hasRequiredParsers;
function requireParsers() {
  if (hasRequiredParsers) return parsers.exports;
  hasRequiredParsers = 1;
  //////////////////////////////////////////
  // Defines mappings between content-type
  // and the appropriate parsers.
  //////////////////////////////////////////

  var Transform = require$$0$4.Transform;
  var sax = requireSax();
  function parseXML(str, cb) {
    var obj,
      current,
      parser = sax.parser(true, {
        trim: true,
        lowercase: true
      });
    parser.onerror = parser.onend = done;
    function done(err) {
      parser.onerror = parser.onend = function () {};
      cb(err, obj);
    }
    function newElement(name, attributes) {
      return {
        name: name || '',
        value: '',
        attributes: attributes || {},
        children: []
      };
    }
    parser.oncdata = parser.ontext = function (t) {
      if (current) current.value += t;
    };
    parser.onopentag = function (node) {
      var element = newElement(node.name, node.attributes);
      if (current) {
        element.parent = current;
        current.children.push(element);
      } else {
        // root object
        obj = element;
      }
      current = element;
    };
    parser.onclosetag = function () {
      if (typeof current.parent !== 'undefined') {
        var just_closed = current;
        current = current.parent;
        delete just_closed.parent;
      }
    };
    parser.write(str).close();
  }
  function parserFactory(name, fn) {
    function parser() {
      var chunks = [],
        stream = new Transform({
          objectMode: true
        });

      // Buffer all our data
      stream._transform = function (chunk, encoding, done) {
        chunks.push(chunk);
        done();
      };

      // And call the parser when all is there.
      stream._flush = function (done) {
        var self = this,
          data = Buffer.concat(chunks);
        try {
          fn(data, function (err, result) {
            if (err) throw err;
            self.push(result);
          });
        } catch (err) {
          self.push(data); // just pass the original data
        } finally {
          done();
        }
      };
      return stream;
    }
    return {
      fn: parser,
      name: name
    };
  }
  var parsers$1 = {};
  function buildParser(name, types, fn) {
    var parser = parserFactory(name, fn);
    types.forEach(function (type) {
      parsers$1[type] = parser;
    });
  }
  buildParser('json', ['application/json', 'application/hal+json', 'text/javascript', 'application/vnd.api+json'], function (buffer, cb) {
    var err, data;
    try {
      data = JSON.parse(buffer);
    } catch (e) {
      err = e;
    }
    cb(err, data);
  });
  buildParser('xml', ['text/xml', 'application/xml', 'application/rdf+xml', 'application/rss+xml', 'application/atom+xml'], function (buffer, cb) {
    parseXML(buffer.toString(), function (err, obj) {
      cb(err, obj);
    });
  });
  parsers.exports = parsers$1;
  parsers.exports.use = buildParser;
  return parsers.exports;
}

var lib$1 = {exports: {}};

/* eslint-disable node/no-deprecated-api */
var safer_1;
var hasRequiredSafer;
function requireSafer() {
  if (hasRequiredSafer) return safer_1;
  hasRequiredSafer = 1;
  var buffer = require$$0$a;
  var Buffer = buffer.Buffer;
  var safer = {};
  var key;
  for (key in buffer) {
    if (!buffer.hasOwnProperty(key)) continue;
    if (key === 'SlowBuffer' || key === 'Buffer') continue;
    safer[key] = buffer[key];
  }
  var Safer = safer.Buffer = {};
  for (key in Buffer) {
    if (!Buffer.hasOwnProperty(key)) continue;
    if (key === 'allocUnsafe' || key === 'allocUnsafeSlow') continue;
    Safer[key] = Buffer[key];
  }
  safer.Buffer.prototype = Buffer.prototype;
  if (!Safer.from || Safer.from === Uint8Array.from) {
    Safer.from = function (value, encodingOrOffset, length) {
      if (typeof value === 'number') {
        throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
      }
      if (value && typeof value.length === 'undefined') {
        throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value);
      }
      return Buffer(value, encodingOrOffset, length);
    };
  }
  if (!Safer.alloc) {
    Safer.alloc = function (size, fill, encoding) {
      if (typeof size !== 'number') {
        throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
      }
      if (size < 0 || size >= 2 * (1 << 30)) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
      var buf = Buffer(size);
      if (!fill || fill.length === 0) {
        buf.fill(0);
      } else if (typeof encoding === 'string') {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
      return buf;
    };
  }
  if (!safer.kStringMaxLength) {
    try {
      safer.kStringMaxLength = process.binding('buffer').kStringMaxLength;
    } catch (e) {
      // we can't determine kStringMaxLength in environments where process.binding
      // is unsupported, so let's not set it
    }
  }
  if (!safer.constants) {
    safer.constants = {
      MAX_LENGTH: safer.kMaxLength
    };
    if (safer.kStringMaxLength) {
      safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
    }
  }
  safer_1 = safer;
  return safer_1;
}

var bomHandling = {};

var hasRequiredBomHandling;
function requireBomHandling() {
  if (hasRequiredBomHandling) return bomHandling;
  hasRequiredBomHandling = 1;
  var BOMChar = '\uFEFF';
  bomHandling.PrependBOM = PrependBOMWrapper;
  function PrependBOMWrapper(encoder, options) {
    this.encoder = encoder;
    this.addBOM = true;
  }
  PrependBOMWrapper.prototype.write = function (str) {
    if (this.addBOM) {
      str = BOMChar + str;
      this.addBOM = false;
    }
    return this.encoder.write(str);
  };
  PrependBOMWrapper.prototype.end = function () {
    return this.encoder.end();
  };

  //------------------------------------------------------------------------------

  bomHandling.StripBOM = StripBOMWrapper;
  function StripBOMWrapper(decoder, options) {
    this.decoder = decoder;
    this.pass = false;
    this.options = options || {};
  }
  StripBOMWrapper.prototype.write = function (buf) {
    var res = this.decoder.write(buf);
    if (this.pass || !res) return res;
    if (res[0] === BOMChar) {
      res = res.slice(1);
      if (typeof this.options.stripBOM === 'function') this.options.stripBOM();
    }
    this.pass = true;
    return res;
  };
  StripBOMWrapper.prototype.end = function () {
    return this.decoder.end();
  };
  return bomHandling;
}

var encodings = {};

var internal;
var hasRequiredInternal;
function requireInternal() {
  if (hasRequiredInternal) return internal;
  hasRequiredInternal = 1;
  var Buffer = requireSafer().Buffer;

  // Export Node.js internal encodings.

  internal = {
    // Encodings
    utf8: {
      type: "_internal",
      bomAware: true
    },
    cesu8: {
      type: "_internal",
      bomAware: true
    },
    unicode11utf8: "utf8",
    ucs2: {
      type: "_internal",
      bomAware: true
    },
    utf16le: "ucs2",
    binary: {
      type: "_internal"
    },
    base64: {
      type: "_internal"
    },
    hex: {
      type: "_internal"
    },
    // Codec.
    _internal: InternalCodec
  };

  //------------------------------------------------------------------------------

  function InternalCodec(codecOptions, iconv) {
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;
    if (this.enc === "base64") this.encoder = InternalEncoderBase64;else if (this.enc === "cesu8") {
      this.enc = "utf8"; // Use utf8 for decoding.
      this.encoder = InternalEncoderCesu8;

      // Add decoder for versions of Node not supporting CESU-8
      if (Buffer.from('eda0bdedb2a9', 'hex').toString() !== '') {
        this.decoder = InternalDecoderCesu8;
        this.defaultCharUnicode = iconv.defaultCharUnicode;
      }
    }
  }
  InternalCodec.prototype.encoder = InternalEncoder;
  InternalCodec.prototype.decoder = InternalDecoder;

  //------------------------------------------------------------------------------

  // We use node.js internal decoder. Its signature is the same as ours.
  var StringDecoder = require$$1$5.StringDecoder;
  if (!StringDecoder.prototype.end)
    // Node v0.8 doesn't have this method.
    StringDecoder.prototype.end = function () {};
  function InternalDecoder(options, codec) {
    this.decoder = new StringDecoder(codec.enc);
  }
  InternalDecoder.prototype.write = function (buf) {
    if (!Buffer.isBuffer(buf)) {
      buf = Buffer.from(buf);
    }
    return this.decoder.write(buf);
  };
  InternalDecoder.prototype.end = function () {
    return this.decoder.end();
  };

  //------------------------------------------------------------------------------
  // Encoder is mostly trivial

  function InternalEncoder(options, codec) {
    this.enc = codec.enc;
  }
  InternalEncoder.prototype.write = function (str) {
    return Buffer.from(str, this.enc);
  };
  InternalEncoder.prototype.end = function () {};

  //------------------------------------------------------------------------------
  // Except base64 encoder, which must keep its state.

  function InternalEncoderBase64(options, codec) {
    this.prevStr = '';
  }
  InternalEncoderBase64.prototype.write = function (str) {
    str = this.prevStr + str;
    var completeQuads = str.length - str.length % 4;
    this.prevStr = str.slice(completeQuads);
    str = str.slice(0, completeQuads);
    return Buffer.from(str, "base64");
  };
  InternalEncoderBase64.prototype.end = function () {
    return Buffer.from(this.prevStr, "base64");
  };

  //------------------------------------------------------------------------------
  // CESU-8 encoder is also special.

  function InternalEncoderCesu8(options, codec) {}
  InternalEncoderCesu8.prototype.write = function (str) {
    var buf = Buffer.alloc(str.length * 3),
      bufIdx = 0;
    for (var i = 0; i < str.length; i++) {
      var charCode = str.charCodeAt(i);
      // Naive implementation, but it works because CESU-8 is especially easy
      // to convert from UTF-16 (which all JS strings are encoded in).
      if (charCode < 0x80) buf[bufIdx++] = charCode;else if (charCode < 0x800) {
        buf[bufIdx++] = 0xC0 + (charCode >>> 6);
        buf[bufIdx++] = 0x80 + (charCode & 0x3f);
      } else {
        // charCode will always be < 0x10000 in javascript.
        buf[bufIdx++] = 0xE0 + (charCode >>> 12);
        buf[bufIdx++] = 0x80 + (charCode >>> 6 & 0x3f);
        buf[bufIdx++] = 0x80 + (charCode & 0x3f);
      }
    }
    return buf.slice(0, bufIdx);
  };
  InternalEncoderCesu8.prototype.end = function () {};

  //------------------------------------------------------------------------------
  // CESU-8 decoder is not implemented in Node v4.0+

  function InternalDecoderCesu8(options, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
  }
  InternalDecoderCesu8.prototype.write = function (buf) {
    var acc = this.acc,
      contBytes = this.contBytes,
      accBytes = this.accBytes,
      res = '';
    for (var i = 0; i < buf.length; i++) {
      var curByte = buf[i];
      if ((curByte & 0xC0) !== 0x80) {
        // Leading byte
        if (contBytes > 0) {
          // Previous code is invalid
          res += this.defaultCharUnicode;
          contBytes = 0;
        }
        if (curByte < 0x80) {
          // Single-byte code
          res += String.fromCharCode(curByte);
        } else if (curByte < 0xE0) {
          // Two-byte code
          acc = curByte & 0x1F;
          contBytes = 1;
          accBytes = 1;
        } else if (curByte < 0xF0) {
          // Three-byte code
          acc = curByte & 0x0F;
          contBytes = 2;
          accBytes = 1;
        } else {
          // Four or more are not supported for CESU-8.
          res += this.defaultCharUnicode;
        }
      } else {
        // Continuation byte
        if (contBytes > 0) {
          // We're waiting for it.
          acc = acc << 6 | curByte & 0x3f;
          contBytes--;
          accBytes++;
          if (contBytes === 0) {
            // Check for overlong encoding, but support Modified UTF-8 (encoding NULL as C0 80)
            if (accBytes === 2 && acc < 0x80 && acc > 0) res += this.defaultCharUnicode;else if (accBytes === 3 && acc < 0x800) res += this.defaultCharUnicode;else
              // Actually add character.
              res += String.fromCharCode(acc);
          }
        } else {
          // Unexpected continuation byte
          res += this.defaultCharUnicode;
        }
      }
    }
    this.acc = acc;
    this.contBytes = contBytes;
    this.accBytes = accBytes;
    return res;
  };
  InternalDecoderCesu8.prototype.end = function () {
    var res = 0;
    if (this.contBytes > 0) res += this.defaultCharUnicode;
    return res;
  };
  return internal;
}

var utf32 = {};

var hasRequiredUtf32;
function requireUtf32() {
  if (hasRequiredUtf32) return utf32;
  hasRequiredUtf32 = 1;
  var Buffer = requireSafer().Buffer;

  // == UTF32-LE/BE codec. ==========================================================

  utf32._utf32 = Utf32Codec;
  function Utf32Codec(codecOptions, iconv) {
    this.iconv = iconv;
    this.bomAware = true;
    this.isLE = codecOptions.isLE;
  }
  utf32.utf32le = {
    type: '_utf32',
    isLE: true
  };
  utf32.utf32be = {
    type: '_utf32',
    isLE: false
  };

  // Aliases
  utf32.ucs4le = 'utf32le';
  utf32.ucs4be = 'utf32be';
  Utf32Codec.prototype.encoder = Utf32Encoder;
  Utf32Codec.prototype.decoder = Utf32Decoder;

  // -- Encoding

  function Utf32Encoder(options, codec) {
    this.isLE = codec.isLE;
    this.highSurrogate = 0;
  }
  Utf32Encoder.prototype.write = function (str) {
    var src = Buffer.from(str, 'ucs2');
    var dst = Buffer.alloc(src.length * 2);
    var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;
    var offset = 0;
    for (var i = 0; i < src.length; i += 2) {
      var code = src.readUInt16LE(i);
      var isHighSurrogate = 0xD800 <= code && code < 0xDC00;
      var isLowSurrogate = 0xDC00 <= code && code < 0xE000;
      if (this.highSurrogate) {
        if (isHighSurrogate || !isLowSurrogate) {
          // There shouldn't be two high surrogates in a row, nor a high surrogate which isn't followed by a low
          // surrogate. If this happens, keep the pending high surrogate as a stand-alone semi-invalid character
          // (technically wrong, but expected by some applications, like Windows file names).
          write32.call(dst, this.highSurrogate, offset);
          offset += 4;
        } else {
          // Create 32-bit value from high and low surrogates;
          var codepoint = (this.highSurrogate - 0xD800 << 10 | code - 0xDC00) + 0x10000;
          write32.call(dst, codepoint, offset);
          offset += 4;
          this.highSurrogate = 0;
          continue;
        }
      }
      if (isHighSurrogate) this.highSurrogate = code;else {
        // Even if the current character is a low surrogate, with no previous high surrogate, we'll
        // encode it as a semi-invalid stand-alone character for the same reasons expressed above for
        // unpaired high surrogates.
        write32.call(dst, code, offset);
        offset += 4;
        this.highSurrogate = 0;
      }
    }
    if (offset < dst.length) dst = dst.slice(0, offset);
    return dst;
  };
  Utf32Encoder.prototype.end = function () {
    // Treat any leftover high surrogate as a semi-valid independent character.
    if (!this.highSurrogate) return;
    var buf = Buffer.alloc(4);
    if (this.isLE) buf.writeUInt32LE(this.highSurrogate, 0);else buf.writeUInt32BE(this.highSurrogate, 0);
    this.highSurrogate = 0;
    return buf;
  };

  // -- Decoding

  function Utf32Decoder(options, codec) {
    this.isLE = codec.isLE;
    this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);
    this.overflow = [];
  }
  Utf32Decoder.prototype.write = function (src) {
    if (src.length === 0) return '';
    var i = 0;
    var codepoint = 0;
    var dst = Buffer.alloc(src.length + 4);
    var offset = 0;
    var isLE = this.isLE;
    var overflow = this.overflow;
    var badChar = this.badChar;
    if (overflow.length > 0) {
      for (; i < src.length && overflow.length < 4; i++) overflow.push(src[i]);
      if (overflow.length === 4) {
        // NOTE: codepoint is a signed int32 and can be negative.
        // NOTE: We copied this block from below to help V8 optimize it (it works with array, not buffer).
        if (isLE) {
          codepoint = overflow[i] | overflow[i + 1] << 8 | overflow[i + 2] << 16 | overflow[i + 3] << 24;
        } else {
          codepoint = overflow[i + 3] | overflow[i + 2] << 8 | overflow[i + 1] << 16 | overflow[i] << 24;
        }
        overflow.length = 0;
        offset = _writeCodepoint(dst, offset, codepoint, badChar);
      }
    }

    // Main loop. Should be as optimized as possible.
    for (; i < src.length - 3; i += 4) {
      // NOTE: codepoint is a signed int32 and can be negative.
      if (isLE) {
        codepoint = src[i] | src[i + 1] << 8 | src[i + 2] << 16 | src[i + 3] << 24;
      } else {
        codepoint = src[i + 3] | src[i + 2] << 8 | src[i + 1] << 16 | src[i] << 24;
      }
      offset = _writeCodepoint(dst, offset, codepoint, badChar);
    }

    // Keep overflowing bytes.
    for (; i < src.length; i++) {
      overflow.push(src[i]);
    }
    return dst.slice(0, offset).toString('ucs2');
  };
  function _writeCodepoint(dst, offset, codepoint, badChar) {
    // NOTE: codepoint is signed int32 and can be negative. We keep it that way to help V8 with optimizations.
    if (codepoint < 0 || codepoint > 0x10FFFF) {
      // Not a valid Unicode codepoint
      codepoint = badChar;
    }

    // Ephemeral Planes: Write high surrogate.
    if (codepoint >= 0x10000) {
      codepoint -= 0x10000;
      var high = 0xD800 | codepoint >> 10;
      dst[offset++] = high & 0xff;
      dst[offset++] = high >> 8;

      // Low surrogate is written below.
      var codepoint = 0xDC00 | codepoint & 0x3FF;
    }

    // Write BMP char or low surrogate.
    dst[offset++] = codepoint & 0xff;
    dst[offset++] = codepoint >> 8;
    return offset;
  }
  Utf32Decoder.prototype.end = function () {
    this.overflow.length = 0;
  };

  // == UTF-32 Auto codec =============================================================
  // Decoder chooses automatically from UTF-32LE and UTF-32BE using BOM and space-based heuristic.
  // Defaults to UTF-32LE. http://en.wikipedia.org/wiki/UTF-32
  // Encoder/decoder default can be changed: iconv.decode(buf, 'utf32', {defaultEncoding: 'utf-32be'});

  // Encoder prepends BOM (which can be overridden with (addBOM: false}).

  utf32.utf32 = Utf32AutoCodec;
  utf32.ucs4 = 'utf32';
  function Utf32AutoCodec(options, iconv) {
    this.iconv = iconv;
  }
  Utf32AutoCodec.prototype.encoder = Utf32AutoEncoder;
  Utf32AutoCodec.prototype.decoder = Utf32AutoDecoder;

  // -- Encoding

  function Utf32AutoEncoder(options, codec) {
    options = options || {};
    if (options.addBOM === undefined) options.addBOM = true;
    this.encoder = codec.iconv.getEncoder(options.defaultEncoding || 'utf-32le', options);
  }
  Utf32AutoEncoder.prototype.write = function (str) {
    return this.encoder.write(str);
  };
  Utf32AutoEncoder.prototype.end = function () {
    return this.encoder.end();
  };

  // -- Decoding

  function Utf32AutoDecoder(options, codec) {
    this.decoder = null;
    this.initialBufs = [];
    this.initialBufsLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
  }
  Utf32AutoDecoder.prototype.write = function (buf) {
    if (!this.decoder) {
      // Codec is not chosen yet. Accumulate initial bytes.
      this.initialBufs.push(buf);
      this.initialBufsLen += buf.length;
      if (this.initialBufsLen < 32)
        // We need more bytes to use space heuristic (see below)
        return '';

      // We have enough bytes -> detect endianness.
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = '';
      for (var i = 0; i < this.initialBufs.length; i++) resStr += this.decoder.write(this.initialBufs[i]);
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.write(buf);
  };
  Utf32AutoDecoder.prototype.end = function () {
    if (!this.decoder) {
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = '';
      for (var i = 0; i < this.initialBufs.length; i++) resStr += this.decoder.write(this.initialBufs[i]);
      var trail = this.decoder.end();
      if (trail) resStr += trail;
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.end();
  };
  function detectEncoding(bufs, defaultEncoding) {
    var b = [];
    var charsProcessed = 0;
    var invalidLE = 0,
      invalidBE = 0; // Number of invalid chars when decoded as LE or BE.
    var bmpCharsLE = 0,
      bmpCharsBE = 0; // Number of BMP chars when decoded as LE or BE.

    outer_loop: for (var i = 0; i < bufs.length; i++) {
      var buf = bufs[i];
      for (var j = 0; j < buf.length; j++) {
        b.push(buf[j]);
        if (b.length === 4) {
          if (charsProcessed === 0) {
            // Check BOM first.
            if (b[0] === 0xFF && b[1] === 0xFE && b[2] === 0 && b[3] === 0) {
              return 'utf-32le';
            }
            if (b[0] === 0 && b[1] === 0 && b[2] === 0xFE && b[3] === 0xFF) {
              return 'utf-32be';
            }
          }
          if (b[0] !== 0 || b[1] > 0x10) invalidBE++;
          if (b[3] !== 0 || b[2] > 0x10) invalidLE++;
          if (b[0] === 0 && b[1] === 0 && (b[2] !== 0 || b[3] !== 0)) bmpCharsBE++;
          if ((b[0] !== 0 || b[1] !== 0) && b[2] === 0 && b[3] === 0) bmpCharsLE++;
          b.length = 0;
          charsProcessed++;
          if (charsProcessed >= 100) {
            break outer_loop;
          }
        }
      }
    }

    // Make decisions.
    if (bmpCharsBE - invalidBE > bmpCharsLE - invalidLE) return 'utf-32be';
    if (bmpCharsBE - invalidBE < bmpCharsLE - invalidLE) return 'utf-32le';

    // Couldn't decide (likely all zeros or not enough data).
    return defaultEncoding || 'utf-32le';
  }
  return utf32;
}

var utf16 = {};

var hasRequiredUtf16;
function requireUtf16() {
  if (hasRequiredUtf16) return utf16;
  hasRequiredUtf16 = 1;
  var Buffer = requireSafer().Buffer;

  // Note: UTF16-LE (or UCS2) codec is Node.js native. See encodings/internal.js

  // == UTF16-BE codec. ==========================================================

  utf16.utf16be = Utf16BECodec;
  function Utf16BECodec() {}
  Utf16BECodec.prototype.encoder = Utf16BEEncoder;
  Utf16BECodec.prototype.decoder = Utf16BEDecoder;
  Utf16BECodec.prototype.bomAware = true;

  // -- Encoding

  function Utf16BEEncoder() {}
  Utf16BEEncoder.prototype.write = function (str) {
    var buf = Buffer.from(str, 'ucs2');
    for (var i = 0; i < buf.length; i += 2) {
      var tmp = buf[i];
      buf[i] = buf[i + 1];
      buf[i + 1] = tmp;
    }
    return buf;
  };
  Utf16BEEncoder.prototype.end = function () {};

  // -- Decoding

  function Utf16BEDecoder() {
    this.overflowByte = -1;
  }
  Utf16BEDecoder.prototype.write = function (buf) {
    if (buf.length == 0) return '';
    var buf2 = Buffer.alloc(buf.length + 1),
      i = 0,
      j = 0;
    if (this.overflowByte !== -1) {
      buf2[0] = buf[0];
      buf2[1] = this.overflowByte;
      i = 1;
      j = 2;
    }
    for (; i < buf.length - 1; i += 2, j += 2) {
      buf2[j] = buf[i + 1];
      buf2[j + 1] = buf[i];
    }
    this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
    return buf2.slice(0, j).toString('ucs2');
  };
  Utf16BEDecoder.prototype.end = function () {
    this.overflowByte = -1;
  };

  // == UTF-16 codec =============================================================
  // Decoder chooses automatically from UTF-16LE and UTF-16BE using BOM and space-based heuristic.
  // Defaults to UTF-16LE, as it's prevalent and default in Node.
  // http://en.wikipedia.org/wiki/UTF-16 and http://encoding.spec.whatwg.org/#utf-16le
  // Decoder default can be changed: iconv.decode(buf, 'utf16', {defaultEncoding: 'utf-16be'});

  // Encoder uses UTF-16LE and prepends BOM (which can be overridden with addBOM: false).

  utf16.utf16 = Utf16Codec;
  function Utf16Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf16Codec.prototype.encoder = Utf16Encoder;
  Utf16Codec.prototype.decoder = Utf16Decoder;

  // -- Encoding (pass-through)

  function Utf16Encoder(options, codec) {
    options = options || {};
    if (options.addBOM === undefined) options.addBOM = true;
    this.encoder = codec.iconv.getEncoder('utf-16le', options);
  }
  Utf16Encoder.prototype.write = function (str) {
    return this.encoder.write(str);
  };
  Utf16Encoder.prototype.end = function () {
    return this.encoder.end();
  };

  // -- Decoding

  function Utf16Decoder(options, codec) {
    this.decoder = null;
    this.initialBufs = [];
    this.initialBufsLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
  }
  Utf16Decoder.prototype.write = function (buf) {
    if (!this.decoder) {
      // Codec is not chosen yet. Accumulate initial bytes.
      this.initialBufs.push(buf);
      this.initialBufsLen += buf.length;
      if (this.initialBufsLen < 16)
        // We need more bytes to use space heuristic (see below)
        return '';

      // We have enough bytes -> detect endianness.
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = '';
      for (var i = 0; i < this.initialBufs.length; i++) resStr += this.decoder.write(this.initialBufs[i]);
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.write(buf);
  };
  Utf16Decoder.prototype.end = function () {
    if (!this.decoder) {
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = '';
      for (var i = 0; i < this.initialBufs.length; i++) resStr += this.decoder.write(this.initialBufs[i]);
      var trail = this.decoder.end();
      if (trail) resStr += trail;
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.end();
  };
  function detectEncoding(bufs, defaultEncoding) {
    var b = [];
    var charsProcessed = 0;
    var asciiCharsLE = 0,
      asciiCharsBE = 0; // Number of ASCII chars when decoded as LE or BE.

    outer_loop: for (var i = 0; i < bufs.length; i++) {
      var buf = bufs[i];
      for (var j = 0; j < buf.length; j++) {
        b.push(buf[j]);
        if (b.length === 2) {
          if (charsProcessed === 0) {
            // Check BOM first.
            if (b[0] === 0xFF && b[1] === 0xFE) return 'utf-16le';
            if (b[0] === 0xFE && b[1] === 0xFF) return 'utf-16be';
          }
          if (b[0] === 0 && b[1] !== 0) asciiCharsBE++;
          if (b[0] !== 0 && b[1] === 0) asciiCharsLE++;
          b.length = 0;
          charsProcessed++;
          if (charsProcessed >= 100) {
            break outer_loop;
          }
        }
      }
    }

    // Make decisions.
    // Most of the time, the content has ASCII chars (U+00**), but the opposite (U+**00) is uncommon.
    // So, we count ASCII as if it was LE or BE, and decide from that.
    if (asciiCharsBE > asciiCharsLE) return 'utf-16be';
    if (asciiCharsBE < asciiCharsLE) return 'utf-16le';

    // Couldn't decide (likely all zeros or not enough data).
    return defaultEncoding || 'utf-16le';
  }
  return utf16;
}

var utf7 = {};

var hasRequiredUtf7;
function requireUtf7() {
  if (hasRequiredUtf7) return utf7;
  hasRequiredUtf7 = 1;
  var Buffer = requireSafer().Buffer;

  // UTF-7 codec, according to https://tools.ietf.org/html/rfc2152
  // See also below a UTF-7-IMAP codec, according to http://tools.ietf.org/html/rfc3501#section-5.1.3

  utf7.utf7 = Utf7Codec;
  utf7.unicode11utf7 = 'utf7'; // Alias UNICODE-1-1-UTF-7
  function Utf7Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7Codec.prototype.encoder = Utf7Encoder;
  Utf7Codec.prototype.decoder = Utf7Decoder;
  Utf7Codec.prototype.bomAware = true;

  // -- Encoding

  var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
  function Utf7Encoder(options, codec) {
    this.iconv = codec.iconv;
  }
  Utf7Encoder.prototype.write = function (str) {
    // Naive implementation.
    // Non-direct chars are encoded as "+<base64>-"; single "+" char is encoded as "+-".
    return Buffer.from(str.replace(nonDirectChars, function (chunk) {
      return "+" + (chunk === '+' ? '' : this.iconv.encode(chunk, 'utf16-be').toString('base64').replace(/=+$/, '')) + "-";
    }.bind(this)));
  };
  Utf7Encoder.prototype.end = function () {};

  // -- Decoding

  function Utf7Decoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = '';
  }
  var base64Regex = /[A-Za-z0-9\/+]/;
  var base64Chars = [];
  for (var i = 0; i < 256; i++) base64Chars[i] = base64Regex.test(String.fromCharCode(i));
  var plusChar = '+'.charCodeAt(0),
    minusChar = '-'.charCodeAt(0),
    andChar = '&'.charCodeAt(0);
  Utf7Decoder.prototype.write = function (buf) {
    var res = "",
      lastI = 0,
      inBase64 = this.inBase64,
      base64Accum = this.base64Accum;

    // The decoder is more involved as we must handle chunks in stream.

    for (var i = 0; i < buf.length; i++) {
      if (!inBase64) {
        // We're in direct mode.
        // Write direct chars until '+'
        if (buf[i] == plusChar) {
          res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
          lastI = i + 1;
          inBase64 = true;
        }
      } else {
        // We decode base64.
        if (!base64Chars[buf[i]]) {
          // Base64 ended.
          if (i == lastI && buf[i] == minusChar) {
            // "+-" -> "+"
            res += "+";
          } else {
            var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i), "ascii");
            res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
          }
          if (buf[i] != minusChar)
            // Minus is absorbed after base64.
            i--;
          lastI = i + 1;
          inBase64 = false;
          base64Accum = '';
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
    } else {
      var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii");
      var canBeDecoded = b64str.length - b64str.length % 8; // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
      base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7Decoder.prototype.end = function () {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = '';
    return res;
  };

  // UTF-7-IMAP codec.
  // RFC3501 Sec. 5.1.3 Modified UTF-7 (http://tools.ietf.org/html/rfc3501#section-5.1.3)
  // Differences:
  //  * Base64 part is started by "&" instead of "+"
  //  * Direct characters are 0x20-0x7E, except "&" (0x26)
  //  * In Base64, "," is used instead of "/"
  //  * Base64 must not be used to represent direct characters.
  //  * No implicit shift back from Base64 (should always end with '-')
  //  * String must end in non-shifted position.
  //  * "-&" while in base64 is not allowed.

  utf7.utf7imap = Utf7IMAPCodec;
  function Utf7IMAPCodec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
  Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
  Utf7IMAPCodec.prototype.bomAware = true;

  // -- Encoding

  function Utf7IMAPEncoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = Buffer.alloc(6);
    this.base64AccumIdx = 0;
  }
  Utf7IMAPEncoder.prototype.write = function (str) {
    var inBase64 = this.inBase64,
      base64Accum = this.base64Accum,
      base64AccumIdx = this.base64AccumIdx,
      buf = Buffer.alloc(str.length * 5 + 10),
      bufIdx = 0;
    for (var i = 0; i < str.length; i++) {
      var uChar = str.charCodeAt(i);
      if (0x20 <= uChar && uChar <= 0x7E) {
        // Direct character or '&'.
        if (inBase64) {
          if (base64AccumIdx > 0) {
            bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
            base64AccumIdx = 0;
          }
          buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
          inBase64 = false;
        }
        if (!inBase64) {
          buf[bufIdx++] = uChar; // Write direct character

          if (uChar === andChar)
            // Ampersand -> '&-'
            buf[bufIdx++] = minusChar;
        }
      } else {
        // Non-direct character
        if (!inBase64) {
          buf[bufIdx++] = andChar; // Write '&', then go to base64 mode.
          inBase64 = true;
        }
        if (inBase64) {
          base64Accum[base64AccumIdx++] = uChar >> 8;
          base64Accum[base64AccumIdx++] = uChar & 0xFF;
          if (base64AccumIdx == base64Accum.length) {
            bufIdx += buf.write(base64Accum.toString('base64').replace(/\//g, ','), bufIdx);
            base64AccumIdx = 0;
          }
        }
      }
    }
    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;
    return buf.slice(0, bufIdx);
  };
  Utf7IMAPEncoder.prototype.end = function () {
    var buf = Buffer.alloc(10),
      bufIdx = 0;
    if (this.inBase64) {
      if (this.base64AccumIdx > 0) {
        bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
        this.base64AccumIdx = 0;
      }
      buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
      this.inBase64 = false;
    }
    return buf.slice(0, bufIdx);
  };

  // -- Decoding

  function Utf7IMAPDecoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = '';
  }
  var base64IMAPChars = base64Chars.slice();
  base64IMAPChars[','.charCodeAt(0)] = true;
  Utf7IMAPDecoder.prototype.write = function (buf) {
    var res = "",
      lastI = 0,
      inBase64 = this.inBase64,
      base64Accum = this.base64Accum;

    // The decoder is more involved as we must handle chunks in stream.
    // It is forgiving, closer to standard UTF-7 (for example, '-' is optional at the end).

    for (var i = 0; i < buf.length; i++) {
      if (!inBase64) {
        // We're in direct mode.
        // Write direct chars until '&'
        if (buf[i] == andChar) {
          res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
          lastI = i + 1;
          inBase64 = true;
        }
      } else {
        // We decode base64.
        if (!base64IMAPChars[buf[i]]) {
          // Base64 ended.
          if (i == lastI && buf[i] == minusChar) {
            // "&-" -> "&"
            res += "&";
          } else {
            var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i), "ascii").replace(/,/g, '/');
            res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
          }
          if (buf[i] != minusChar)
            // Minus may be absorbed after base64.
            i--;
          lastI = i + 1;
          inBase64 = false;
          base64Accum = '';
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
    } else {
      var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii").replace(/,/g, '/');
      var canBeDecoded = b64str.length - b64str.length % 8; // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
      base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7IMAPDecoder.prototype.end = function () {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = '';
    return res;
  };
  return utf7;
}

var sbcsCodec = {};

var hasRequiredSbcsCodec;
function requireSbcsCodec() {
  if (hasRequiredSbcsCodec) return sbcsCodec;
  hasRequiredSbcsCodec = 1;
  var Buffer = requireSafer().Buffer;

  // Single-byte codec. Needs a 'chars' string parameter that contains 256 or 128 chars that
  // correspond to encoded bytes (if 128 - then lower half is ASCII). 

  sbcsCodec._sbcs = SBCSCodec;
  function SBCSCodec(codecOptions, iconv) {
    if (!codecOptions) throw new Error("SBCS codec is called without the data.");

    // Prepare char buffer for decoding.
    if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256) throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
    if (codecOptions.chars.length === 128) {
      var asciiString = "";
      for (var i = 0; i < 128; i++) asciiString += String.fromCharCode(i);
      codecOptions.chars = asciiString + codecOptions.chars;
    }
    this.decodeBuf = Buffer.from(codecOptions.chars, 'ucs2');

    // Encoding buffer.
    var encodeBuf = Buffer.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
    for (var i = 0; i < codecOptions.chars.length; i++) encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
    this.encodeBuf = encodeBuf;
  }
  SBCSCodec.prototype.encoder = SBCSEncoder;
  SBCSCodec.prototype.decoder = SBCSDecoder;
  function SBCSEncoder(options, codec) {
    this.encodeBuf = codec.encodeBuf;
  }
  SBCSEncoder.prototype.write = function (str) {
    var buf = Buffer.alloc(str.length);
    for (var i = 0; i < str.length; i++) buf[i] = this.encodeBuf[str.charCodeAt(i)];
    return buf;
  };
  SBCSEncoder.prototype.end = function () {};
  function SBCSDecoder(options, codec) {
    this.decodeBuf = codec.decodeBuf;
  }
  SBCSDecoder.prototype.write = function (buf) {
    // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.
    var decodeBuf = this.decodeBuf;
    var newBuf = Buffer.alloc(buf.length * 2);
    var idx1 = 0,
      idx2 = 0;
    for (var i = 0; i < buf.length; i++) {
      idx1 = buf[i] * 2;
      idx2 = i * 2;
      newBuf[idx2] = decodeBuf[idx1];
      newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
    }
    return newBuf.toString('ucs2');
  };
  SBCSDecoder.prototype.end = function () {};
  return sbcsCodec;
}

var sbcsData;
var hasRequiredSbcsData;
function requireSbcsData() {
  if (hasRequiredSbcsData) return sbcsData;
  hasRequiredSbcsData = 1;

  // Manually added data to be used by sbcs codec in addition to generated one.

  sbcsData = {
    // Not supported by iconv, not sure why.
    "10029": "maccenteuro",
    "maccenteuro": {
      "type": "_sbcs",
      "chars": ""
    },
    "808": "cp808",
    "ibm808": "cp808",
    "cp808": {
      "type": "_sbcs",
      "chars": ""
    },
    "mik": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp720": {
      "type": "_sbcs",
      "chars": "\x80\x81\x84\x86\x8d\x8e\x8f\x90\u0651\u0652\u064b\u064c\u064d\u064e\u064f\u0650\u00a0"
    },
    // Aliases of generated encodings.
    "ascii8bit": "ascii",
    "usascii": "ascii",
    "ansix34": "ascii",
    "ansix341968": "ascii",
    "ansix341986": "ascii",
    "csascii": "ascii",
    "cp367": "ascii",
    "ibm367": "ascii",
    "isoir6": "ascii",
    "iso646us": "ascii",
    "iso646irv": "ascii",
    "us": "ascii",
    "latin1": "iso88591",
    "latin2": "iso88592",
    "latin3": "iso88593",
    "latin4": "iso88594",
    "latin5": "iso88599",
    "latin6": "iso885910",
    "latin7": "iso885913",
    "latin8": "iso885914",
    "latin9": "iso885915",
    "latin10": "iso885916",
    "csisolatin1": "iso88591",
    "csisolatin2": "iso88592",
    "csisolatin3": "iso88593",
    "csisolatin4": "iso88594",
    "csisolatincyrillic": "iso88595",
    "csisolatinarabic": "iso88596",
    "csisolatingreek": "iso88597",
    "csisolatinhebrew": "iso88598",
    "csisolatin5": "iso88599",
    "csisolatin6": "iso885910",
    "l1": "iso88591",
    "l2": "iso88592",
    "l3": "iso88593",
    "l4": "iso88594",
    "l5": "iso88599",
    "l6": "iso885910",
    "l7": "iso885913",
    "l8": "iso885914",
    "l9": "iso885915",
    "l10": "iso885916",
    "isoir14": "iso646jp",
    "isoir57": "iso646cn",
    "isoir100": "iso88591",
    "isoir101": "iso88592",
    "isoir109": "iso88593",
    "isoir110": "iso88594",
    "isoir144": "iso88595",
    "isoir127": "iso88596",
    "isoir126": "iso88597",
    "isoir138": "iso88598",
    "isoir148": "iso88599",
    "isoir157": "iso885910",
    "isoir166": "tis620",
    "isoir179": "iso885913",
    "isoir199": "iso885914",
    "isoir203": "iso885915",
    "isoir226": "iso885916",
    "cp819": "iso88591",
    "ibm819": "iso88591",
    "cyrillic": "iso88595",
    "arabic": "iso88596",
    "arabic8": "iso88596",
    "ecma114": "iso88596",
    "asmo708": "iso88596",
    "greek": "iso88597",
    "greek8": "iso88597",
    "ecma118": "iso88597",
    "elot928": "iso88597",
    "hebrew": "iso88598",
    "hebrew8": "iso88598",
    "turkish": "iso88599",
    "turkish8": "iso88599",
    "thai": "iso885911",
    "thai8": "iso885911",
    "celtic": "iso885914",
    "celtic8": "iso885914",
    "isoceltic": "iso885914",
    "tis6200": "tis620",
    "tis62025291": "tis620",
    "tis62025330": "tis620",
    "10000": "macroman",
    "10006": "macgreek",
    "10007": "maccyrillic",
    "10079": "maciceland",
    "10081": "macturkish",
    "cspc8codepage437": "cp437",
    "cspc775baltic": "cp775",
    "cspc850multilingual": "cp850",
    "cspcp852": "cp852",
    "cspc862latinhebrew": "cp862",
    "cpgr": "cp869",
    "msee": "cp1250",
    "mscyrl": "cp1251",
    "msansi": "cp1252",
    "msgreek": "cp1253",
    "msturk": "cp1254",
    "mshebr": "cp1255",
    "msarab": "cp1256",
    "winbaltrim": "cp1257",
    "cp20866": "koi8r",
    "20866": "koi8r",
    "ibm878": "koi8r",
    "cskoi8r": "koi8r",
    "cp21866": "koi8u",
    "21866": "koi8u",
    "ibm1168": "koi8u",
    "strk10482002": "rk1048",
    "tcvn5712": "tcvn",
    "tcvn57121": "tcvn",
    "gb198880": "iso646cn",
    "cn": "iso646cn",
    "csiso14jisc6220ro": "iso646jp",
    "jisc62201969ro": "iso646jp",
    "jp": "iso646jp",
    "cshproman8": "hproman8",
    "r8": "hproman8",
    "roman8": "hproman8",
    "xroman8": "hproman8",
    "ibm1051": "hproman8",
    "mac": "macintosh",
    "csmacintosh": "macintosh"
  };
  return sbcsData;
}

var sbcsDataGenerated;
var hasRequiredSbcsDataGenerated;
function requireSbcsDataGenerated() {
  if (hasRequiredSbcsDataGenerated) return sbcsDataGenerated;
  hasRequiredSbcsDataGenerated = 1;

  // Generated data for sbcs codec. Don't edit manually. Regenerate using generation/gen-sbcs.js script.
  sbcsDataGenerated = {
    "437": "cp437",
    "737": "cp737",
    "775": "cp775",
    "850": "cp850",
    "852": "cp852",
    "855": "cp855",
    "856": "cp856",
    "857": "cp857",
    "858": "cp858",
    "860": "cp860",
    "861": "cp861",
    "862": "cp862",
    "863": "cp863",
    "864": "cp864",
    "865": "cp865",
    "866": "cp866",
    "869": "cp869",
    "874": "windows874",
    "922": "cp922",
    "1046": "cp1046",
    "1124": "cp1124",
    "1125": "cp1125",
    "1129": "cp1129",
    "1133": "cp1133",
    "1161": "cp1161",
    "1162": "cp1162",
    "1163": "cp1163",
    "1250": "windows1250",
    "1251": "windows1251",
    "1252": "windows1252",
    "1253": "windows1253",
    "1254": "windows1254",
    "1255": "windows1255",
    "1256": "windows1256",
    "1257": "windows1257",
    "1258": "windows1258",
    "28591": "iso88591",
    "28592": "iso88592",
    "28593": "iso88593",
    "28594": "iso88594",
    "28595": "iso88595",
    "28596": "iso88596",
    "28597": "iso88597",
    "28598": "iso88598",
    "28599": "iso88599",
    "28600": "iso885910",
    "28601": "iso885911",
    "28603": "iso885913",
    "28604": "iso885914",
    "28605": "iso885915",
    "28606": "iso885916",
    "windows874": {
      "type": "_sbcs",
      "chars": ""
    },
    "win874": "windows874",
    "cp874": "windows874",
    "windows1250": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1250": "windows1250",
    "cp1250": "windows1250",
    "windows1251": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1251": "windows1251",
    "cp1251": "windows1251",
    "windows1252": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1252": "windows1252",
    "cp1252": "windows1252",
    "windows1253": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1253": "windows1253",
    "cp1253": "windows1253",
    "windows1254": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1254": "windows1254",
    "cp1254": "windows1254",
    "windows1255": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1255": "windows1255",
    "cp1255": "windows1255",
    "windows1256": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1256": "windows1256",
    "cp1256": "windows1256",
    "windows1257": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1257": "windows1257",
    "cp1257": "windows1257",
    "windows1258": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1258": "windows1258",
    "cp1258": "windows1258",
    "iso88591": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28591": "iso88591",
    "iso88592": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28592": "iso88592",
    "iso88593": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28593": "iso88593",
    "iso88594": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28594": "iso88594",
    "iso88595": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28595": "iso88595",
    "iso88596": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28596": "iso88596",
    "iso88597": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28597": "iso88597",
    "iso88598": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28598": "iso88598",
    "iso88599": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28599": "iso88599",
    "iso885910": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28600": "iso885910",
    "iso885911": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28601": "iso885911",
    "iso885913": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28603": "iso885913",
    "iso885914": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28604": "iso885914",
    "iso885915": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28605": "iso885915",
    "iso885916": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28606": "iso885916",
    "cp437": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm437": "cp437",
    "csibm437": "cp437",
    "cp737": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm737": "cp737",
    "csibm737": "cp737",
    "cp775": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm775": "cp775",
    "csibm775": "cp775",
    "cp850": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm850": "cp850",
    "csibm850": "cp850",
    "cp852": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm852": "cp852",
    "csibm852": "cp852",
    "cp855": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm855": "cp855",
    "csibm855": "cp855",
    "cp856": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm856": "cp856",
    "csibm856": "cp856",
    "cp857": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm857": "cp857",
    "csibm857": "cp857",
    "cp858": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm858": "cp858",
    "csibm858": "cp858",
    "cp860": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm860": "cp860",
    "csibm860": "cp860",
    "cp861": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm861": "cp861",
    "csibm861": "cp861",
    "cp862": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm862": "cp862",
    "csibm862": "cp862",
    "cp863": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm863": "cp863",
    "csibm863": "cp863",
    "cp864": {
      "type": "_sbcs",
      "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "ibm864": "cp864",
    "csibm864": "cp864",
    "cp865": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm865": "cp865",
    "csibm865": "cp865",
    "cp866": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm866": "cp866",
    "csibm866": "cp866",
    "cp869": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm869": "cp869",
    "csibm869": "cp869",
    "cp922": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm922": "cp922",
    "csibm922": "cp922",
    "cp1046": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1046": "cp1046",
    "csibm1046": "cp1046",
    "cp1124": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1124": "cp1124",
    "csibm1124": "cp1124",
    "cp1125": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1125": "cp1125",
    "csibm1125": "cp1125",
    "cp1129": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1129": "cp1129",
    "csibm1129": "cp1129",
    "cp1133": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1133": "cp1133",
    "csibm1133": "cp1133",
    "cp1161": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1161": "cp1161",
    "csibm1161": "cp1161",
    "cp1162": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1162": "cp1162",
    "csibm1162": "cp1162",
    "cp1163": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1163": "cp1163",
    "csibm1163": "cp1163",
    "maccroatian": {
      "type": "_sbcs",
      "chars": ""
    },
    "maccyrillic": {
      "type": "_sbcs",
      "chars": ""
    },
    "macgreek": {
      "type": "_sbcs",
      "chars": ""
    },
    "maciceland": {
      "type": "_sbcs",
      "chars": ""
    },
    "macroman": {
      "type": "_sbcs",
      "chars": ""
    },
    "macromania": {
      "type": "_sbcs",
      "chars": ""
    },
    "macthai": {
      "type": "_sbcs",
      "chars": ""
    },
    "macturkish": {
      "type": "_sbcs",
      "chars": ""
    },
    "macukraine": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8r": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8u": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8ru": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8t": {
      "type": "_sbcs",
      "chars": ""
    },
    "armscii8": {
      "type": "_sbcs",
      "chars": ")(.,-"
    },
    "rk1048": {
      "type": "_sbcs",
      "chars": ""
    },
    "tcvn": {
      "type": "_sbcs",
      "chars": "\u0000\u0003\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "georgianacademy": {
      "type": "_sbcs",
      "chars": ""
    },
    "georgianps": {
      "type": "_sbcs",
      "chars": ""
    },
    "pt154": {
      "type": "_sbcs",
      "chars": ""
    },
    "viscii": {
      "type": "_sbcs",
      "chars": "\u0000\u0001\u0003\u0004\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0015\u0016\u0017\u0018\u001a\u001b\u001c\u001d\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "iso646cn": {
      "type": "_sbcs",
      "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
    },
    "iso646jp": {
      "type": "_sbcs",
      "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
    },
    "hproman8": {
      "type": "_sbcs",
      "chars": ""
    },
    "macintosh": {
      "type": "_sbcs",
      "chars": ""
    },
    "ascii": {
      "type": "_sbcs",
      "chars": ""
    },
    "tis620": {
      "type": "_sbcs",
      "chars": ""
    }
  };
  return sbcsDataGenerated;
}

var dbcsCodec = {};

var hasRequiredDbcsCodec;
function requireDbcsCodec() {
  if (hasRequiredDbcsCodec) return dbcsCodec;
  hasRequiredDbcsCodec = 1;
  var Buffer = requireSafer().Buffer;

  // Multibyte codec. In this scheme, a character is represented by 1 or more bytes.
  // Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.
  // To save memory and loading time, we read table files only when requested.

  dbcsCodec._dbcs = DBCSCodec;
  var UNASSIGNED = -1,
    GB18030_CODE = -2,
    SEQ_START = -10,
    NODE_START = -1000,
    UNASSIGNED_NODE = new Array(0x100),
    DEF_CHAR = -1;
  for (var i = 0; i < 0x100; i++) UNASSIGNED_NODE[i] = UNASSIGNED;

  // Class DBCSCodec reads and initializes mapping tables.
  function DBCSCodec(codecOptions, iconv) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions) throw new Error("DBCS codec is called without the data.");
    if (!codecOptions.table) throw new Error("Encoding '" + this.encodingName + "' has no data.");

    // Load tables.
    var mappingTable = codecOptions.table();

    // Decode tables: MBCS -> Unicode.

    // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.
    // Trie root is decodeTables[0].
    // Values: >=  0 -> unicode character code. can be > 0xFFFF
    //         == UNASSIGNED -> unknown/unassigned sequence.
    //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.
    //         <= NODE_START -> index of the next node in our trie to process next byte.
    //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.
    this.decodeTables = [];
    this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.

    // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. 
    this.decodeTableSeq = [];

    // Actual mapping tables consist of chunks. Use them to fill up decode tables.
    for (var i = 0; i < mappingTable.length; i++) this._addDecodeChunk(mappingTable[i]);

    // Load & create GB18030 tables when needed.
    if (typeof codecOptions.gb18030 === 'function') {
      this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.

      // Add GB18030 common decode nodes.
      var commonThirdByteNodeIdx = this.decodeTables.length;
      this.decodeTables.push(UNASSIGNED_NODE.slice(0));
      var commonFourthByteNodeIdx = this.decodeTables.length;
      this.decodeTables.push(UNASSIGNED_NODE.slice(0));

      // Fill out the tree
      var firstByteNode = this.decodeTables[0];
      for (var i = 0x81; i <= 0xFE; i++) {
        var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i]];
        for (var j = 0x30; j <= 0x39; j++) {
          if (secondByteNode[j] === UNASSIGNED) {
            secondByteNode[j] = NODE_START - commonThirdByteNodeIdx;
          } else if (secondByteNode[j] > NODE_START) {
            throw new Error("gb18030 decode tables conflict at byte 2");
          }
          var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j]];
          for (var k = 0x81; k <= 0xFE; k++) {
            if (thirdByteNode[k] === UNASSIGNED) {
              thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx;
            } else if (thirdByteNode[k] === NODE_START - commonFourthByteNodeIdx) {
              continue;
            } else if (thirdByteNode[k] > NODE_START) {
              throw new Error("gb18030 decode tables conflict at byte 3");
            }
            var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k]];
            for (var l = 0x30; l <= 0x39; l++) {
              if (fourthByteNode[l] === UNASSIGNED) fourthByteNode[l] = GB18030_CODE;
            }
          }
        }
      }
    }
    this.defaultCharUnicode = iconv.defaultCharUnicode;

    // Encode tables: Unicode -> DBCS.

    // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.
    // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.
    // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).
    //         == UNASSIGNED -> no conversion found. Output a default char.
    //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.
    this.encodeTable = [];

    // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of
    // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key
    // means end of sequence (needed when one sequence is a strict subsequence of another).
    // Objects are kept separately from encodeTable to increase performance.
    this.encodeTableSeq = [];

    // Some chars can be decoded, but need not be encoded.
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals) for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {
      var val = codecOptions.encodeSkipVals[i];
      if (typeof val === 'number') skipEncodeChars[val] = true;else for (var j = val.from; j <= val.to; j++) skipEncodeChars[j] = true;
    }

    // Use decode trie to recursively fill out encode tables.
    this._fillEncodeTable(0, 0, skipEncodeChars);

    // Add more encoding pairs when needed.
    if (codecOptions.encodeAdd) {
      for (var uChar in codecOptions.encodeAdd) if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar)) this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    }
    this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
  }
  DBCSCodec.prototype.encoder = DBCSEncoder;
  DBCSCodec.prototype.decoder = DBCSDecoder;

  // Decoder helpers
  DBCSCodec.prototype._getDecodeTrieNode = function (addr) {
    var bytes = [];
    for (; addr > 0; addr >>>= 8) bytes.push(addr & 0xFF);
    if (bytes.length == 0) bytes.push(0);
    var node = this.decodeTables[0];
    for (var i = bytes.length - 1; i > 0; i--) {
      // Traverse nodes deeper into the trie.
      var val = node[bytes[i]];
      if (val == UNASSIGNED) {
        // Create new node.
        node[bytes[i]] = NODE_START - this.decodeTables.length;
        this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
      } else if (val <= NODE_START) {
        // Existing node.
        node = this.decodeTables[NODE_START - val];
      } else throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
    }
    return node;
  };
  DBCSCodec.prototype._addDecodeChunk = function (chunk) {
    // First element of chunk is the hex mbcs code where we start.
    var curAddr = parseInt(chunk[0], 16);

    // Choose the decoding node where we'll write our chars.
    var writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 0xFF;

    // Write all other elements of the chunk to the table.
    for (var k = 1; k < chunk.length; k++) {
      var part = chunk[k];
      if (typeof part === "string") {
        // String, write as-is.
        for (var l = 0; l < part.length;) {
          var code = part.charCodeAt(l++);
          if (0xD800 <= code && code < 0xDC00) {
            // Decode surrogate
            var codeTrail = part.charCodeAt(l++);
            if (0xDC00 <= codeTrail && codeTrail < 0xE000) writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);else throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
          } else if (0x0FF0 < code && code <= 0x0FFF) {
            // Character sequence (our own encoding used)
            var len = 0xFFF - code + 2;
            var seq = [];
            for (var m = 0; m < len; m++) seq.push(part.charCodeAt(l++)); // Simple variation: don't support surrogates or subsequences in seq.

            writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
            this.decodeTableSeq.push(seq);
          } else writeTable[curAddr++] = code; // Basic char
        }
      } else if (typeof part === "number") {
        // Integer, meaning increasing sequence starting with prev character.
        var charCode = writeTable[curAddr - 1] + 1;
        for (var l = 0; l < part; l++) writeTable[curAddr++] = charCode++;
      } else throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
    }
    if (curAddr > 0xFF) throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
  };

  // Encoder helpers
  DBCSCodec.prototype._getEncodeBucket = function (uCode) {
    var high = uCode >> 8; // This could be > 0xFF because of astral characters.
    if (this.encodeTable[high] === undefined) this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.
    return this.encodeTable[high];
  };
  DBCSCodec.prototype._setEncodeChar = function (uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 0xFF;
    if (bucket[low] <= SEQ_START) this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.
    else if (bucket[low] == UNASSIGNED) bucket[low] = dbcsCode;
  };
  DBCSCodec.prototype._setEncodeSequence = function (seq, dbcsCode) {
    // Get the root of character tree according to first character of the sequence.
    var uCode = seq[0];
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 0xFF;
    var node;
    if (bucket[low] <= SEQ_START) {
      // There's already a sequence with  - use it.
      node = this.encodeTableSeq[SEQ_START - bucket[low]];
    } else {
      // There was no sequence object - allocate a new one.
      node = {};
      if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.
      bucket[low] = SEQ_START - this.encodeTableSeq.length;
      this.encodeTableSeq.push(node);
    }

    // Traverse the character tree, allocating new nodes as needed.
    for (var j = 1; j < seq.length - 1; j++) {
      var oldVal = node[uCode];
      if (typeof oldVal === 'object') node = oldVal;else {
        node = node[uCode] = {};
        if (oldVal !== undefined) node[DEF_CHAR] = oldVal;
      }
    }

    // Set the leaf to given dbcsCode.
    uCode = seq[seq.length - 1];
    node[uCode] = dbcsCode;
  };
  DBCSCodec.prototype._fillEncodeTable = function (nodeIdx, prefix, skipEncodeChars) {
    var node = this.decodeTables[nodeIdx];
    var hasValues = false;
    var subNodeEmpty = {};
    for (var i = 0; i < 0x100; i++) {
      var uCode = node[i];
      var mbCode = prefix + i;
      if (skipEncodeChars[mbCode]) continue;
      if (uCode >= 0) {
        this._setEncodeChar(uCode, mbCode);
        hasValues = true;
      } else if (uCode <= NODE_START) {
        var subNodeIdx = NODE_START - uCode;
        if (!subNodeEmpty[subNodeIdx]) {
          // Skip empty subtrees (they are too large in gb18030).
          var newPrefix = mbCode << 8 >>> 0; // NOTE: '>>> 0' keeps 32-bit num positive.
          if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars)) hasValues = true;else subNodeEmpty[subNodeIdx] = true;
        }
      } else if (uCode <= SEQ_START) {
        this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
        hasValues = true;
      }
    }
    return hasValues;
  };

  // == Encoder ==================================================================

  function DBCSEncoder(options, codec) {
    // Encoder state
    this.leadSurrogate = -1;
    this.seqObj = undefined;

    // Static data
    this.encodeTable = codec.encodeTable;
    this.encodeTableSeq = codec.encodeTableSeq;
    this.defaultCharSingleByte = codec.defCharSB;
    this.gb18030 = codec.gb18030;
  }
  DBCSEncoder.prototype.write = function (str) {
    var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3)),
      leadSurrogate = this.leadSurrogate,
      seqObj = this.seqObj,
      nextChar = -1,
      i = 0,
      j = 0;
    while (true) {
      // 0. Get next character.
      if (nextChar === -1) {
        if (i == str.length) break;
        var uCode = str.charCodeAt(i++);
      } else {
        var uCode = nextChar;
        nextChar = -1;
      }

      // 1. Handle surrogates.
      if (0xD800 <= uCode && uCode < 0xE000) {
        // Char is one of surrogates.
        if (uCode < 0xDC00) {
          // We've got lead surrogate.
          if (leadSurrogate === -1) {
            leadSurrogate = uCode;
            continue;
          } else {
            leadSurrogate = uCode;
            // Double lead surrogate found.
            uCode = UNASSIGNED;
          }
        } else {
          // We've got trail surrogate.
          if (leadSurrogate !== -1) {
            uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);
            leadSurrogate = -1;
          } else {
            // Incomplete surrogate pair - only trail surrogate found.
            uCode = UNASSIGNED;
          }
        }
      } else if (leadSurrogate !== -1) {
        // Incomplete surrogate pair - only lead surrogate found.
        nextChar = uCode;
        uCode = UNASSIGNED; // Write an error, then current char.
        leadSurrogate = -1;
      }

      // 2. Convert uCode character.
      var dbcsCode = UNASSIGNED;
      if (seqObj !== undefined && uCode != UNASSIGNED) {
        // We are in the middle of the sequence
        var resCode = seqObj[uCode];
        if (typeof resCode === 'object') {
          // Sequence continues.
          seqObj = resCode;
          continue;
        } else if (typeof resCode == 'number') {
          // Sequence finished. Write it.
          dbcsCode = resCode;
        } else if (resCode == undefined) {
          // Current character is not part of the sequence.

          // Try default character for this sequence
          resCode = seqObj[DEF_CHAR];
          if (resCode !== undefined) {
            dbcsCode = resCode; // Found. Write it.
            nextChar = uCode; // Current character will be written too in the next iteration.
          }
        }
        seqObj = undefined;
      } else if (uCode >= 0) {
        // Regular character
        var subtable = this.encodeTable[uCode >> 8];
        if (subtable !== undefined) dbcsCode = subtable[uCode & 0xFF];
        if (dbcsCode <= SEQ_START) {
          // Sequence start
          seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
          continue;
        }
        if (dbcsCode == UNASSIGNED && this.gb18030) {
          // Use GB18030 algorithm to find character(s) to write.
          var idx = findIdx(this.gb18030.uChars, uCode);
          if (idx != -1) {
            var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
            newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600);
            dbcsCode = dbcsCode % 12600;
            newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260);
            dbcsCode = dbcsCode % 1260;
            newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10);
            dbcsCode = dbcsCode % 10;
            newBuf[j++] = 0x30 + dbcsCode;
            continue;
          }
        }
      }

      // 3. Write dbcsCode character.
      if (dbcsCode === UNASSIGNED) dbcsCode = this.defaultCharSingleByte;
      if (dbcsCode < 0x100) {
        newBuf[j++] = dbcsCode;
      } else if (dbcsCode < 0x10000) {
        newBuf[j++] = dbcsCode >> 8; // high byte
        newBuf[j++] = dbcsCode & 0xFF; // low byte
      } else if (dbcsCode < 0x1000000) {
        newBuf[j++] = dbcsCode >> 16;
        newBuf[j++] = dbcsCode >> 8 & 0xFF;
        newBuf[j++] = dbcsCode & 0xFF;
      } else {
        newBuf[j++] = dbcsCode >>> 24;
        newBuf[j++] = dbcsCode >>> 16 & 0xFF;
        newBuf[j++] = dbcsCode >>> 8 & 0xFF;
        newBuf[j++] = dbcsCode & 0xFF;
      }
    }
    this.seqObj = seqObj;
    this.leadSurrogate = leadSurrogate;
    return newBuf.slice(0, j);
  };
  DBCSEncoder.prototype.end = function () {
    if (this.leadSurrogate === -1 && this.seqObj === undefined) return; // All clean. Most often case.

    var newBuf = Buffer.alloc(10),
      j = 0;
    if (this.seqObj) {
      // We're in the sequence.
      var dbcsCode = this.seqObj[DEF_CHAR];
      if (dbcsCode !== undefined) {
        // Write beginning of the sequence.
        if (dbcsCode < 0x100) {
          newBuf[j++] = dbcsCode;
        } else {
          newBuf[j++] = dbcsCode >> 8; // high byte
          newBuf[j++] = dbcsCode & 0xFF; // low byte
        }
      }
      this.seqObj = undefined;
    }
    if (this.leadSurrogate !== -1) {
      // Incomplete surrogate pair - only lead surrogate found.
      newBuf[j++] = this.defaultCharSingleByte;
      this.leadSurrogate = -1;
    }
    return newBuf.slice(0, j);
  };

  // Export for testing
  DBCSEncoder.prototype.findIdx = findIdx;

  // == Decoder ==================================================================

  function DBCSDecoder(options, codec) {
    // Decoder state
    this.nodeIdx = 0;
    this.prevBytes = [];

    // Static data
    this.decodeTables = codec.decodeTables;
    this.decodeTableSeq = codec.decodeTableSeq;
    this.defaultCharUnicode = codec.defaultCharUnicode;
    this.gb18030 = codec.gb18030;
  }
  DBCSDecoder.prototype.write = function (buf) {
    var newBuf = Buffer.alloc(buf.length * 2),
      nodeIdx = this.nodeIdx,
      prevBytes = this.prevBytes,
      prevOffset = this.prevBytes.length,
      seqStart = -this.prevBytes.length,
      // idx of the start of current parsed sequence.
      uCode;
    for (var i = 0, j = 0; i < buf.length; i++) {
      var curByte = i >= 0 ? buf[i] : prevBytes[i + prevOffset];

      // Lookup in current trie node.
      var uCode = this.decodeTables[nodeIdx][curByte];
      if (uCode >= 0) ; else if (uCode === UNASSIGNED) {
        // Unknown char.
        // TODO: Callback with seq.
        uCode = this.defaultCharUnicode.charCodeAt(0);
        i = seqStart; // Skip one byte ('i' will be incremented by the for loop) and try to parse again.
      } else if (uCode === GB18030_CODE) {
        if (i >= 3) {
          var ptr = (buf[i - 3] - 0x81) * 12600 + (buf[i - 2] - 0x30) * 1260 + (buf[i - 1] - 0x81) * 10 + (curByte - 0x30);
        } else {
          var ptr = (prevBytes[i - 3 + prevOffset] - 0x81) * 12600 + ((i - 2 >= 0 ? buf[i - 2] : prevBytes[i - 2 + prevOffset]) - 0x30) * 1260 + ((i - 1 >= 0 ? buf[i - 1] : prevBytes[i - 1 + prevOffset]) - 0x81) * 10 + (curByte - 0x30);
        }
        var idx = findIdx(this.gb18030.gbChars, ptr);
        uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
      } else if (uCode <= NODE_START) {
        // Go to next trie node.
        nodeIdx = NODE_START - uCode;
        continue;
      } else if (uCode <= SEQ_START) {
        // Output a sequence of chars.
        var seq = this.decodeTableSeq[SEQ_START - uCode];
        for (var k = 0; k < seq.length - 1; k++) {
          uCode = seq[k];
          newBuf[j++] = uCode & 0xFF;
          newBuf[j++] = uCode >> 8;
        }
        uCode = seq[seq.length - 1];
      } else throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);

      // Write the character to buffer, handling higher planes using surrogate pair.
      if (uCode >= 0x10000) {
        uCode -= 0x10000;
        var uCodeLead = 0xD800 | uCode >> 10;
        newBuf[j++] = uCodeLead & 0xFF;
        newBuf[j++] = uCodeLead >> 8;
        uCode = 0xDC00 | uCode & 0x3FF;
      }
      newBuf[j++] = uCode & 0xFF;
      newBuf[j++] = uCode >> 8;

      // Reset trie node.
      nodeIdx = 0;
      seqStart = i + 1;
    }
    this.nodeIdx = nodeIdx;
    this.prevBytes = seqStart >= 0 ? Array.prototype.slice.call(buf, seqStart) : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf));
    return newBuf.slice(0, j).toString('ucs2');
  };
  DBCSDecoder.prototype.end = function () {
    var ret = '';

    // Try to parse all remaining chars.
    while (this.prevBytes.length > 0) {
      // Skip 1 character in the buffer.
      ret += this.defaultCharUnicode;
      var bytesArr = this.prevBytes.slice(1);

      // Parse remaining as usual.
      this.prevBytes = [];
      this.nodeIdx = 0;
      if (bytesArr.length > 0) ret += this.write(bytesArr);
    }
    this.prevBytes = [];
    this.nodeIdx = 0;
    return ret;
  };

  // Binary search for GB18030. Returns largest i such that table[i] <= val.
  function findIdx(table, val) {
    if (table[0] > val) return -1;
    var l = 0,
      r = table.length;
    while (l < r - 1) {
      // always table[l] <= val < table[r]
      var mid = l + (r - l + 1 >> 1);
      if (table[mid] <= val) l = mid;else r = mid;
    }
    return l;
  }
  return dbcsCodec;
}

var require$$0$1 = [
	[
		"0",
		"\u0000",
		128
	],
	[
		"a1",
		"",
		62
	],
	[
		"8140",
		"",
		9,
		""
	],
	[
		"8180",
		""
	],
	[
		"81b8",
		""
	],
	[
		"81c8",
		""
	],
	[
		"81da",
		""
	],
	[
		"81f0",
		""
	],
	[
		"81fc",
		""
	],
	[
		"824f",
		"",
		9
	],
	[
		"8260",
		"",
		25
	],
	[
		"8281",
		"",
		25
	],
	[
		"829f",
		"",
		82
	],
	[
		"8340",
		"",
		62
	],
	[
		"8380",
		"",
		22
	],
	[
		"839f",
		"",
		16,
		"",
		6
	],
	[
		"83bf",
		"",
		16,
		"",
		6
	],
	[
		"8440",
		"",
		5,
		"",
		25
	],
	[
		"8470",
		"",
		5,
		"",
		7
	],
	[
		"8480",
		"",
		17
	],
	[
		"849f",
		""
	],
	[
		"8740",
		"",
		19,
		"",
		9
	],
	[
		"875f",
		""
	],
	[
		"877e",
		""
	],
	[
		"8780",
		"",
		4,
		""
	],
	[
		"889f",
		""
	],
	[
		"8940",
		""
	],
	[
		"8980",
		""
	],
	[
		"8a40",
		""
	],
	[
		"8a80",
		""
	],
	[
		"8b40",
		""
	],
	[
		"8b80",
		""
	],
	[
		"8c40",
		""
	],
	[
		"8c80",
		""
	],
	[
		"8d40",
		""
	],
	[
		"8d80",
		""
	],
	[
		"8e40",
		""
	],
	[
		"8e80",
		""
	],
	[
		"8f40",
		""
	],
	[
		"8f80",
		""
	],
	[
		"9040",
		""
	],
	[
		"9080",
		""
	],
	[
		"9140",
		""
	],
	[
		"9180",
		""
	],
	[
		"9240",
		""
	],
	[
		"9280",
		""
	],
	[
		"9340",
		""
	],
	[
		"9380",
		""
	],
	[
		"9440",
		""
	],
	[
		"9480",
		""
	],
	[
		"9540",
		""
	],
	[
		"9580",
		""
	],
	[
		"9640",
		""
	],
	[
		"9680",
		""
	],
	[
		"9740",
		""
	],
	[
		"9780",
		""
	],
	[
		"9840",
		""
	],
	[
		"989f",
		""
	],
	[
		"9940",
		""
	],
	[
		"9980",
		""
	],
	[
		"9a40",
		""
	],
	[
		"9a80",
		""
	],
	[
		"9b40",
		""
	],
	[
		"9b80",
		""
	],
	[
		"9c40",
		""
	],
	[
		"9c80",
		""
	],
	[
		"9d40",
		""
	],
	[
		"9d80",
		""
	],
	[
		"9e40",
		""
	],
	[
		"9e80",
		""
	],
	[
		"9f40",
		""
	],
	[
		"9f80",
		""
	],
	[
		"e040",
		""
	],
	[
		"e080",
		""
	],
	[
		"e140",
		""
	],
	[
		"e180",
		""
	],
	[
		"e240",
		""
	],
	[
		"e280",
		""
	],
	[
		"e340",
		""
	],
	[
		"e380",
		""
	],
	[
		"e440",
		""
	],
	[
		"e480",
		""
	],
	[
		"e540",
		""
	],
	[
		"e580",
		""
	],
	[
		"e640",
		""
	],
	[
		"e680",
		""
	],
	[
		"e740",
		""
	],
	[
		"e780",
		""
	],
	[
		"e840",
		""
	],
	[
		"e880",
		""
	],
	[
		"e940",
		""
	],
	[
		"e980",
		""
	],
	[
		"ea40",
		""
	],
	[
		"ea80",
		""
	],
	[
		"ed40",
		""
	],
	[
		"ed80",
		""
	],
	[
		"ee40",
		""
	],
	[
		"ee80",
		""
	],
	[
		"eeef",
		"",
		9,
		""
	],
	[
		"f040",
		"",
		62
	],
	[
		"f080",
		"",
		124
	],
	[
		"f140",
		"",
		62
	],
	[
		"f180",
		"",
		124
	],
	[
		"f240",
		"",
		62
	],
	[
		"f280",
		"",
		124
	],
	[
		"f340",
		"",
		62
	],
	[
		"f380",
		"",
		124
	],
	[
		"f440",
		"",
		62
	],
	[
		"f480",
		"",
		124
	],
	[
		"f540",
		"",
		62
	],
	[
		"f580",
		"",
		124
	],
	[
		"f640",
		"",
		62
	],
	[
		"f680",
		"",
		124
	],
	[
		"f740",
		"",
		62
	],
	[
		"f780",
		"",
		124
	],
	[
		"f840",
		"",
		62
	],
	[
		"f880",
		"",
		124
	],
	[
		"f940",
		""
	],
	[
		"fa40",
		"",
		9,
		"",
		9,
		""
	],
	[
		"fa80",
		""
	],
	[
		"fb40",
		""
	],
	[
		"fb80",
		""
	],
	[
		"fc40",
		""
	]
];

var require$$1 = [
	[
		"0",
		"\u0000",
		127
	],
	[
		"8ea1",
		"",
		62
	],
	[
		"a1a1",
		"",
		9,
		""
	],
	[
		"a2a1",
		""
	],
	[
		"a2ba",
		""
	],
	[
		"a2ca",
		""
	],
	[
		"a2dc",
		""
	],
	[
		"a2f2",
		""
	],
	[
		"a2fe",
		""
	],
	[
		"a3b0",
		"",
		9
	],
	[
		"a3c1",
		"",
		25
	],
	[
		"a3e1",
		"",
		25
	],
	[
		"a4a1",
		"",
		82
	],
	[
		"a5a1",
		"",
		85
	],
	[
		"a6a1",
		"",
		16,
		"",
		6
	],
	[
		"a6c1",
		"",
		16,
		"",
		6
	],
	[
		"a7a1",
		"",
		5,
		"",
		25
	],
	[
		"a7d1",
		"",
		5,
		"",
		25
	],
	[
		"a8a1",
		""
	],
	[
		"ada1",
		"",
		19,
		"",
		9
	],
	[
		"adc0",
		""
	],
	[
		"addf",
		"",
		4,
		""
	],
	[
		"b0a1",
		""
	],
	[
		"b1a1",
		""
	],
	[
		"b2a1",
		""
	],
	[
		"b3a1",
		""
	],
	[
		"b4a1",
		""
	],
	[
		"b5a1",
		""
	],
	[
		"b6a1",
		""
	],
	[
		"b7a1",
		""
	],
	[
		"b8a1",
		""
	],
	[
		"b9a1",
		""
	],
	[
		"baa1",
		""
	],
	[
		"bba1",
		""
	],
	[
		"bca1",
		""
	],
	[
		"bda1",
		""
	],
	[
		"bea1",
		""
	],
	[
		"bfa1",
		""
	],
	[
		"c0a1",
		""
	],
	[
		"c1a1",
		""
	],
	[
		"c2a1",
		""
	],
	[
		"c3a1",
		""
	],
	[
		"c4a1",
		""
	],
	[
		"c5a1",
		""
	],
	[
		"c6a1",
		""
	],
	[
		"c7a1",
		""
	],
	[
		"c8a1",
		""
	],
	[
		"c9a1",
		""
	],
	[
		"caa1",
		""
	],
	[
		"cba1",
		""
	],
	[
		"cca1",
		""
	],
	[
		"cda1",
		""
	],
	[
		"cea1",
		""
	],
	[
		"cfa1",
		""
	],
	[
		"d0a1",
		""
	],
	[
		"d1a1",
		""
	],
	[
		"d2a1",
		""
	],
	[
		"d3a1",
		""
	],
	[
		"d4a1",
		""
	],
	[
		"d5a1",
		""
	],
	[
		"d6a1",
		""
	],
	[
		"d7a1",
		""
	],
	[
		"d8a1",
		""
	],
	[
		"d9a1",
		""
	],
	[
		"daa1",
		""
	],
	[
		"dba1",
		""
	],
	[
		"dca1",
		""
	],
	[
		"dda1",
		""
	],
	[
		"dea1",
		""
	],
	[
		"dfa1",
		""
	],
	[
		"e0a1",
		""
	],
	[
		"e1a1",
		""
	],
	[
		"e2a1",
		""
	],
	[
		"e3a1",
		""
	],
	[
		"e4a1",
		""
	],
	[
		"e5a1",
		""
	],
	[
		"e6a1",
		""
	],
	[
		"e7a1",
		""
	],
	[
		"e8a1",
		""
	],
	[
		"e9a1",
		""
	],
	[
		"eaa1",
		""
	],
	[
		"eba1",
		""
	],
	[
		"eca1",
		""
	],
	[
		"eda1",
		""
	],
	[
		"eea1",
		""
	],
	[
		"efa1",
		""
	],
	[
		"f0a1",
		""
	],
	[
		"f1a1",
		""
	],
	[
		"f2a1",
		""
	],
	[
		"f3a1",
		""
	],
	[
		"f4a1",
		""
	],
	[
		"f9a1",
		""
	],
	[
		"faa1",
		""
	],
	[
		"fba1",
		""
	],
	[
		"fca1",
		""
	],
	[
		"fcf1",
		"",
		9,
		""
	],
	[
		"8fa2af",
		""
	],
	[
		"8fa2c2",
		""
	],
	[
		"8fa2eb",
		""
	],
	[
		"8fa6e1",
		""
	],
	[
		"8fa6e7",
		""
	],
	[
		"8fa6e9",
		""
	],
	[
		"8fa6ec",
		""
	],
	[
		"8fa6f1",
		""
	],
	[
		"8fa7c2",
		"",
		10,
		""
	],
	[
		"8fa7f2",
		"",
		10,
		""
	],
	[
		"8fa9a1",
		""
	],
	[
		"8fa9a4",
		""
	],
	[
		"8fa9a6",
		""
	],
	[
		"8fa9a8",
		""
	],
	[
		"8fa9ab",
		""
	],
	[
		"8fa9af",
		""
	],
	[
		"8fa9c1",
		""
	],
	[
		"8faaa1",
		""
	],
	[
		"8faaba",
		""
	],
	[
		"8faba1",
		""
	],
	[
		"8fabbd",
		""
	],
	[
		"8fabc5",
		""
	],
	[
		"8fb0a1",
		""
	],
	[
		"8fb1a1",
		""
	],
	[
		"8fb2a1",
		"",
		4,
		""
	],
	[
		"8fb3a1",
		""
	],
	[
		"8fb4a1",
		""
	],
	[
		"8fb5a1",
		""
	],
	[
		"8fb6a1",
		"",
		5,
		"",
		4,
		""
	],
	[
		"8fb7a1",
		"",
		4,
		""
	],
	[
		"8fb8a1",
		""
	],
	[
		"8fb9a1",
		""
	],
	[
		"8fbaa1",
		"",
		4,
		""
	],
	[
		"8fbba1",
		""
	],
	[
		"8fbca1",
		"",
		4,
		""
	],
	[
		"8fbda1",
		"",
		4,
		""
	],
	[
		"8fbea1",
		"",
		4,
		""
	],
	[
		"8fbfa1",
		""
	],
	[
		"8fc0a1",
		""
	],
	[
		"8fc1a1",
		""
	],
	[
		"8fc2a1",
		""
	],
	[
		"8fc3a1",
		"",
		4,
		""
	],
	[
		"8fc4a1",
		""
	],
	[
		"8fc5a1",
		""
	],
	[
		"8fc6a1",
		""
	],
	[
		"8fc7a1",
		""
	],
	[
		"8fc8a1",
		""
	],
	[
		"8fc9a1",
		"",
		4,
		"",
		4,
		""
	],
	[
		"8fcaa1",
		""
	],
	[
		"8fcba1",
		""
	],
	[
		"8fcca1",
		"",
		9,
		""
	],
	[
		"8fcda1",
		"",
		5,
		""
	],
	[
		"8fcea1",
		"",
		6,
		""
	],
	[
		"8fcfa1",
		""
	],
	[
		"8fd0a1",
		""
	],
	[
		"8fd1a1",
		""
	],
	[
		"8fd2a1",
		"",
		5
	],
	[
		"8fd3a1",
		""
	],
	[
		"8fd4a1",
		"",
		4,
		""
	],
	[
		"8fd5a1",
		""
	],
	[
		"8fd6a1",
		""
	],
	[
		"8fd7a1",
		""
	],
	[
		"8fd8a1",
		""
	],
	[
		"8fd9a1",
		"",
		4,
		"",
		6,
		""
	],
	[
		"8fdaa1",
		"",
		4,
		""
	],
	[
		"8fdba1",
		"",
		6,
		""
	],
	[
		"8fdca1",
		"",
		4,
		""
	],
	[
		"8fdda1",
		"",
		4,
		""
	],
	[
		"8fdea1",
		"",
		4,
		""
	],
	[
		"8fdfa1",
		""
	],
	[
		"8fe0a1",
		""
	],
	[
		"8fe1a1",
		"",
		4,
		""
	],
	[
		"8fe2a1",
		""
	],
	[
		"8fe3a1",
		"",
		5,
		"",
		4,
		""
	],
	[
		"8fe4a1",
		"",
		4,
		""
	],
	[
		"8fe5a1",
		"",
		4,
		""
	],
	[
		"8fe6a1",
		""
	],
	[
		"8fe7a1",
		""
	],
	[
		"8fe8a1",
		"",
		4,
		""
	],
	[
		"8fe9a1",
		"",
		4
	],
	[
		"8feaa1",
		"",
		4,
		""
	],
	[
		"8feba1",
		"",
		4,
		""
	],
	[
		"8feca1",
		""
	],
	[
		"8feda1",
		"",
		4,
		"",
		4,
		""
	]
];

var require$$2 = [
	[
		"0",
		"\u0000",
		127,
		""
	],
	[
		"8140",
		"",
		5,
		"",
		9,
		"",
		6,
		""
	],
	[
		"8180",
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		5,
		""
	],
	[
		"8240",
		"",
		4,
		"",
		8,
		"",
		4,
		"",
		11
	],
	[
		"8280",
		"",
		10,
		"",
		4,
		"",
		7,
		"",
		5,
		"",
		8,
		"",
		20,
		"",
		4,
		"",
		6,
		""
	],
	[
		"8340",
		"",
		17,
		"",
		5,
		"",
		10,
		"",
		4,
		"",
		9,
		""
	],
	[
		"8380",
		"",
		5,
		"",
		13,
		"",
		28,
		"",
		4,
		"",
		4,
		"",
		5
	],
	[
		"8440",
		"",
		5,
		"",
		5,
		""
	],
	[
		"8480",
		"",
		9,
		"",
		4,
		"",
		6,
		"",
		6,
		"",
		9,
		"",
		5,
		"",
		10,
		"",
		7,
		""
	],
	[
		"8540",
		"",
		9,
		""
	],
	[
		"8580",
		"",
		4,
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		7,
		""
	],
	[
		"8640",
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		5,
		""
	],
	[
		"8680",
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		6,
		"",
		8,
		"",
		4,
		"",
		4,
		"",
		4,
		""
	],
	[
		"8740",
		"",
		7,
		"",
		11,
		"",
		4,
		"",
		4
	],
	[
		"8780",
		"",
		7,
		"",
		6,
		"",
		14,
		"",
		10,
		"",
		6,
		"",
		12,
		"",
		8,
		"",
		5,
		"",
		6
	],
	[
		"8840",
		"",
		9,
		"",
		4,
		"",
		4,
		""
	],
	[
		"8880",
		"",
		4,
		"",
		6,
		"",
		8,
		"",
		6,
		"",
		7,
		"",
		4,
		"",
		4,
		"",
		7
	],
	[
		"8940",
		"",
		5,
		"",
		6,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		16,
		""
	],
	[
		"8980",
		"",
		4,
		"",
		4,
		"",
		7,
		"",
		17,
		"",
		10,
		"",
		13,
		"",
		5,
		"",
		7,
		"",
		4,
		""
	],
	[
		"8a40",
		"",
		4,
		"",
		12,
		""
	],
	[
		"8a80",
		"",
		5,
		"",
		6,
		"",
		4,
		"",
		11,
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		9,
		"",
		5
	],
	[
		"8b40",
		"",
		8,
		"",
		17,
		"",
		6,
		"",
		13,
		""
	],
	[
		"8b80",
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		22,
		"",
		11,
		"",
		25,
		"",
		7,
		"",
		6
	],
	[
		"8c40",
		"",
		7,
		""
	],
	[
		"8c80",
		"",
		8,
		"",
		4,
		"",
		6,
		"",
		6,
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		4
	],
	[
		"8d40",
		"",
		5,
		"",
		5,
		"",
		5,
		"",
		6,
		"",
		9,
		"",
		4
	],
	[
		"8d80",
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		4,
		"",
		7,
		"",
		7,
		"",
		10,
		"",
		10,
		"",
		12,
		"",
		21,
		""
	],
	[
		"8e40",
		"",
		21,
		"",
		12,
		"",
		6,
		"",
		12,
		""
	],
	[
		"8e80",
		"",
		4,
		"",
		7,
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		6,
		"",
		4,
		"",
		14,
		"",
		4,
		"",
		4,
		"",
		6
	],
	[
		"8f40",
		"",
		5,
		"",
		11,
		"",
		8,
		""
	],
	[
		"8f80",
		"",
		6,
		"",
		14,
		"",
		5,
		"",
		5,
		"",
		4,
		""
	],
	[
		"9040",
		"",
		4,
		"",
		4,
		"",
		6,
		""
	],
	[
		"9080",
		"",
		7,
		"",
		4,
		"",
		4,
		"",
		4,
		"",
		4,
		"",
		18,
		"",
		6
	],
	[
		"9140",
		"",
		6,
		"",
		6,
		"",
		18,
		"",
		4,
		""
	],
	[
		"9180",
		"",
		6,
		"",
		8,
		"",
		9,
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		16,
		"",
		13,
		"",
		8,
		"",
		5,
		"",
		4,
		""
	],
	[
		"9240",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9280",
		"",
		5,
		"",
		7,
		"",
		6,
		""
	],
	[
		"9340",
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		5,
		""
	],
	[
		"9380",
		"",
		5,
		"",
		4,
		"",
		6,
		"",
		4,
		"",
		7,
		"",
		9,
		"",
		6,
		"",
		8,
		"",
		4,
		"",
		6,
		""
	],
	[
		"9440",
		"",
		24,
		"",
		7,
		"",
		7,
		"",
		4,
		"",
		8
	],
	[
		"9480",
		"",
		4,
		"",
		4,
		"",
		14,
		"",
		7,
		"",
		7,
		""
	],
	[
		"9540",
		"",
		4,
		"",
		4,
		"",
		6,
		""
	],
	[
		"9580",
		"",
		4,
		"",
		4,
		"",
		8,
		"",
		4,
		"",
		4,
		"",
		25,
		"",
		7,
		"",
		5,
		""
	],
	[
		"9640",
		"",
		5,
		"",
		4,
		""
	],
	[
		"9680",
		"",
		7,
		"",
		9,
		"",
		7,
		"",
		4,
		"",
		6,
		"",
		6,
		"",
		5
	],
	[
		"9740",
		"",
		7,
		"",
		8,
		"",
		7,
		"",
		9,
		""
	],
	[
		"9780",
		"",
		6,
		"",
		5,
		"",
		4,
		"",
		9,
		"",
		4,
		"",
		11,
		"",
		7,
		"",
		16,
		""
	],
	[
		"9840",
		"",
		4,
		"",
		5,
		"",
		9,
		""
	],
	[
		"9880",
		"",
		7,
		"",
		5,
		"",
		11,
		"",
		9,
		"",
		9,
		"",
		11,
		"",
		5,
		"",
		5,
		"",
		6,
		"",
		4,
		"",
		7,
		"",
		6,
		""
	],
	[
		"9940",
		"",
		4,
		"",
		10,
		"",
		6,
		"",
		8,
		"",
		4,
		"",
		7,
		"",
		5
	],
	[
		"9980",
		"",
		114,
		"",
		6
	],
	[
		"9a40",
		"",
		11,
		"",
		7,
		"",
		13,
		""
	],
	[
		"9a80",
		"",
		4,
		"",
		7,
		"",
		7,
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		7,
		"",
		6,
		"",
		4,
		"",
		4,
		""
	],
	[
		"9b40",
		"",
		4,
		""
	],
	[
		"9b80",
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		5,
		""
	],
	[
		"9c40",
		"",
		7,
		""
	],
	[
		"9c80",
		"",
		7,
		"",
		7,
		"",
		10,
		"",
		14,
		"",
		4,
		"",
		6,
		"",
		5
	],
	[
		"9d40",
		"",
		7,
		"",
		4,
		"",
		9,
		"",
		6,
		""
	],
	[
		"9d80",
		"",
		9,
		"",
		5,
		"",
		6,
		"",
		12,
		"",
		4,
		"",
		10,
		"",
		5,
		"",
		5,
		"",
		6,
		"",
		10,
		""
	],
	[
		"9e40",
		"",
		7,
		"",
		32,
		"",
		7,
		"",
		6,
		"",
		6
	],
	[
		"9e80",
		"",
		9,
		"",
		17,
		"",
		13,
		"",
		11,
		"",
		12,
		"",
		12,
		""
	],
	[
		"9f40",
		"",
		6,
		"",
		10,
		"",
		4,
		"",
		10,
		"",
		7,
		""
	],
	[
		"9f80",
		"",
		13,
		"",
		12,
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		8,
		"",
		9,
		"",
		4
	],
	[
		"a040",
		"",
		9,
		"",
		5,
		"",
		9,
		"",
		11,
		"",
		19
	],
	[
		"a080",
		"",
		9,
		"",
		6,
		"",
		4,
		"",
		11,
		"",
		11,
		"",
		6,
		""
	],
	[
		"a1a1",
		"",
		7,
		""
	],
	[
		"a2a1",
		"",
		9
	],
	[
		"a2b1",
		"",
		19,
		"",
		19,
		"",
		9
	],
	[
		"a2e5",
		"",
		9
	],
	[
		"a2f1",
		"",
		11
	],
	[
		"a3a1",
		"",
		88,
		""
	],
	[
		"a4a1",
		"",
		82
	],
	[
		"a5a1",
		"",
		85
	],
	[
		"a6a1",
		"",
		16,
		"",
		6
	],
	[
		"a6c1",
		"",
		16,
		"",
		6
	],
	[
		"a6e0",
		""
	],
	[
		"a6ee",
		""
	],
	[
		"a6f4",
		""
	],
	[
		"a7a1",
		"",
		5,
		"",
		25
	],
	[
		"a7d1",
		"",
		5,
		"",
		25
	],
	[
		"a840",
		"",
		35,
		"",
		6
	],
	[
		"a880",
		"",
		7,
		""
	],
	[
		"a8a1",
		""
	],
	[
		"a8bd",
		""
	],
	[
		"a8c0",
		""
	],
	[
		"a8c5",
		"",
		36
	],
	[
		"a940",
		"",
		8,
		""
	],
	[
		"a959",
		""
	],
	[
		"a95c",
		""
	],
	[
		"a960",
		"",
		9,
		"",
		8
	],
	[
		"a980",
		"",
		4,
		""
	],
	[
		"a996",
		""
	],
	[
		"a9a4",
		"",
		75
	],
	[
		"aa40",
		"",
		5,
		"",
		5,
		"",
		8
	],
	[
		"aa80",
		"",
		7,
		"",
		10,
		""
	],
	[
		"ab40",
		"",
		11,
		"",
		4,
		"",
		5,
		"",
		4
	],
	[
		"ab80",
		"",
		6,
		"",
		4
	],
	[
		"ac40",
		"",
		10,
		"",
		8,
		"",
		5,
		"",
		4,
		"",
		11
	],
	[
		"ac80",
		"",
		6,
		"",
		12,
		"",
		4,
		""
	],
	[
		"ad40",
		"",
		10,
		"",
		7,
		"",
		15,
		"",
		12
	],
	[
		"ad80",
		"",
		9,
		"",
		8,
		"",
		6,
		""
	],
	[
		"ae40",
		"",
		6,
		"",
		7,
		"",
		4,
		""
	],
	[
		"ae80",
		"",
		7,
		"",
		6,
		"",
		4,
		""
	],
	[
		"af40",
		"",
		4,
		""
	],
	[
		"af80",
		""
	],
	[
		"b040",
		"",
		6,
		"",
		5,
		"",
		4,
		"",
		6,
		"",
		7,
		""
	],
	[
		"b080",
		"",
		7,
		"",
		8,
		"",
		9,
		""
	],
	[
		"b140",
		"",
		4,
		"",
		7,
		"",
		10,
		""
	],
	[
		"b180",
		"",
		4,
		"",
		7,
		"",
		7,
		""
	],
	[
		"b240",
		"",
		11,
		"",
		5,
		"",
		11,
		"",
		4
	],
	[
		"b280",
		"",
		12,
		"",
		8,
		"",
		4,
		""
	],
	[
		"b340",
		"",
		5,
		""
	],
	[
		"b380",
		"",
		11,
		"",
		7,
		"",
		6,
		""
	],
	[
		"b440",
		"",
		7,
		"",
		9
	],
	[
		"b480",
		"",
		4,
		"",
		5,
		"",
		6,
		""
	],
	[
		"b540",
		"",
		5,
		"",
		9,
		"",
		4,
		"",
		14,
		"",
		4,
		"",
		8,
		""
	],
	[
		"b580",
		"",
		6,
		"",
		4,
		""
	],
	[
		"b640",
		"",
		6,
		"",
		11,
		"",
		10,
		"",
		4,
		"",
		5,
		""
	],
	[
		"b680",
		"",
		6,
		"",
		4,
		""
	],
	[
		"b740",
		"",
		14,
		"",
		5,
		"",
		9,
		"",
		4,
		"",
		16
	],
	[
		"b780",
		"",
		6,
		""
	],
	[
		"b840",
		"",
		4,
		"",
		10,
		"",
		10,
		"",
		9,
		"",
		5,
		""
	],
	[
		"b880",
		"",
		4,
		""
	],
	[
		"b940",
		"",
		5,
		"",
		10,
		"",
		6,
		""
	],
	[
		"b980",
		"",
		7,
		""
	],
	[
		"ba40",
		"",
		4,
		"",
		4,
		"",
		7,
		"",
		5,
		""
	],
	[
		"ba80",
		"",
		4,
		"",
		5,
		"",
		12,
		"",
		5,
		""
	],
	[
		"bb40",
		"",
		9,
		"",
		36,
		"",
		5,
		"",
		9
	],
	[
		"bb80",
		"",
		6,
		"",
		4,
		""
	],
	[
		"bc40",
		"",
		6,
		"",
		6,
		"",
		5,
		"",
		7,
		"",
		13,
		"",
		5
	],
	[
		"bc80",
		"",
		14,
		"",
		6,
		""
	],
	[
		"bd40",
		"",
		54,
		"",
		7
	],
	[
		"bd80",
		"",
		32,
		""
	],
	[
		"be40",
		"",
		12,
		"",
		6,
		"",
		42
	],
	[
		"be80",
		"",
		32,
		""
	],
	[
		"bf40",
		"",
		62
	],
	[
		"bf80",
		"",
		4,
		"",
		4,
		"",
		21,
		""
	],
	[
		"c040",
		"",
		35,
		"",
		23,
		""
	],
	[
		"c080",
		"",
		6,
		"",
		9,
		""
	],
	[
		"c140",
		"",
		4,
		"",
		7,
		"",
		4,
		"",
		4,
		"",
		6,
		""
	],
	[
		"c180",
		"",
		4,
		"",
		4,
		"",
		5,
		""
	],
	[
		"c240",
		"",
		6,
		"",
		5,
		""
	],
	[
		"c280",
		"",
		13,
		"",
		5,
		"",
		11,
		""
	],
	[
		"c340",
		"",
		5,
		"",
		4,
		"",
		6,
		""
	],
	[
		"c380",
		"",
		12,
		"",
		4,
		""
	],
	[
		"c440",
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		4,
		""
	],
	[
		"c480",
		"",
		7,
		"",
		5,
		"",
		6,
		""
	],
	[
		"c540",
		"",
		14,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		5,
		""
	],
	[
		"c580",
		"",
		7,
		"",
		7,
		""
	],
	[
		"c640",
		""
	],
	[
		"c680",
		"",
		4,
		"",
		9,
		""
	],
	[
		"c740",
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		6,
		"",
		6,
		""
	],
	[
		"c780",
		""
	],
	[
		"c840",
		"",
		4,
		"",
		5,
		"",
		5,
		"",
		7,
		"",
		5,
		"",
		7,
		""
	],
	[
		"c880",
		"",
		6,
		"",
		4,
		"",
		4,
		""
	],
	[
		"c940",
		"",
		4,
		"",
		7,
		"",
		12,
		""
	],
	[
		"c980",
		"",
		4,
		"",
		4,
		"",
		10,
		""
	],
	[
		"ca40",
		"",
		8,
		"",
		8,
		"",
		9,
		"",
		4,
		"",
		10
	],
	[
		"ca80",
		"",
		4,
		"",
		8,
		""
	],
	[
		"cb40",
		"",
		6,
		"",
		10,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		6,
		"",
		4,
		""
	],
	[
		"cb80",
		"",
		5,
		"",
		6,
		"",
		14,
		""
	],
	[
		"cc40",
		"",
		4,
		"",
		10,
		"",
		15,
		"",
		13,
		""
	],
	[
		"cc80",
		"",
		11,
		"",
		4,
		"",
		7,
		""
	],
	[
		"cd40",
		"",
		6,
		"",
		6,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		4,
		""
	],
	[
		"cd80",
		""
	],
	[
		"ce40",
		"",
		6,
		"",
		5,
		"",
		7,
		""
	],
	[
		"ce80",
		"",
		4,
		"",
		6,
		"",
		4,
		""
	],
	[
		"cf40",
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		9
	],
	[
		"cf80",
		"",
		5,
		"",
		7,
		"",
		4,
		""
	],
	[
		"d040",
		"",
		13,
		"",
		5,
		"",
		5,
		"",
		5,
		"",
		6,
		""
	],
	[
		"d080",
		"",
		4,
		"",
		4,
		"",
		5,
		""
	],
	[
		"d140",
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		5
	],
	[
		"d180",
		"",
		4,
		"",
		4,
		"",
		4,
		""
	],
	[
		"d240",
		"",
		8,
		"",
		24,
		"",
		5,
		"",
		19,
		""
	],
	[
		"d280",
		"",
		26,
		""
	],
	[
		"d340",
		"",
		30,
		"",
		6
	],
	[
		"d380",
		"",
		4,
		"",
		5,
		"",
		21,
		""
	],
	[
		"d440",
		"",
		31,
		"",
		8,
		"",
		21
	],
	[
		"d480",
		"",
		25,
		"",
		6,
		""
	],
	[
		"d540",
		"",
		7,
		"",
		7,
		"",
		46
	],
	[
		"d580",
		"",
		32,
		""
	],
	[
		"d640",
		"",
		34,
		"",
		27
	],
	[
		"d680",
		"",
		30,
		""
	],
	[
		"d740",
		"",
		31,
		"",
		4,
		"",
		25
	],
	[
		"d780",
		"",
		24,
		""
	],
	[
		"d840",
		"",
		8,
		"",
		7,
		"",
		5,
		"",
		6,
		"",
		6,
		"",
		6,
		""
	],
	[
		"d880",
		"",
		6,
		"",
		20,
		""
	],
	[
		"d940",
		"",
		62
	],
	[
		"d980",
		"",
		32,
		""
	],
	[
		"da40",
		"",
		14,
		"",
		8,
		"",
		4,
		"",
		9,
		""
	],
	[
		"da80",
		"",
		12,
		""
	],
	[
		"db40",
		"",
		6,
		"",
		7,
		"",
		4,
		""
	],
	[
		"db80",
		"",
		4,
		"",
		5,
		"",
		11,
		""
	],
	[
		"dc40",
		"",
		4,
		"",
		6,
		"",
		6,
		"",
		11,
		"",
		6,
		"",
		7
	],
	[
		"dc80",
		"",
		10,
		"",
		21,
		""
	],
	[
		"dd40",
		"",
		62
	],
	[
		"dd80",
		"",
		32,
		""
	],
	[
		"de40",
		"",
		32,
		""
	],
	[
		"de80",
		"",
		4,
		""
	],
	[
		"df40",
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		6,
		""
	],
	[
		"df80",
		"",
		4,
		""
	],
	[
		"e040",
		"",
		19,
		""
	],
	[
		"e080",
		"",
		10,
		"",
		6,
		"",
		8,
		""
	],
	[
		"e140",
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		5,
		""
	],
	[
		"e180",
		"",
		10,
		"",
		9,
		"",
		8,
		""
	],
	[
		"e240",
		"",
		62
	],
	[
		"e280",
		"",
		32,
		"",
		5,
		""
	],
	[
		"e340",
		"",
		45,
		"",
		16
	],
	[
		"e380",
		"",
		7,
		"",
		24,
		""
	],
	[
		"e440",
		"",
		5,
		"",
		24,
		"",
		31
	],
	[
		"e480",
		"",
		32,
		""
	],
	[
		"e540",
		"",
		51,
		"",
		10
	],
	[
		"e580",
		"",
		31,
		""
	],
	[
		"e640",
		"",
		34,
		"",
		27
	],
	[
		"e680",
		"",
		29,
		""
	],
	[
		"e740",
		"",
		7,
		"",
		54
	],
	[
		"e780",
		"",
		32,
		"",
		6,
		"",
		4,
		""
	],
	[
		"e840",
		"",
		14,
		"",
		43,
		""
	],
	[
		"e880",
		"",
		20,
		""
	],
	[
		"e940",
		"",
		7,
		"",
		42
	],
	[
		"e980",
		"",
		32,
		""
	],
	[
		"ea40",
		"",
		27,
		"",
		6,
		""
	],
	[
		"ea80",
		"",
		4,
		"",
		12,
		""
	],
	[
		"eb40",
		"",
		9,
		"",
		7,
		"",
		9,
		"",
		6,
		""
	],
	[
		"eb80",
		"",
		4,
		""
	],
	[
		"ec40",
		"",
		8,
		"",
		4,
		"",
		18,
		"",
		7
	],
	[
		"ec80",
		"",
		4,
		"",
		7,
		"",
		4,
		"",
		4,
		""
	],
	[
		"ed40",
		"",
		6,
		"",
		46
	],
	[
		"ed80",
		"",
		4,
		"",
		23,
		""
	],
	[
		"ee40",
		"",
		62
	],
	[
		"ee80",
		"",
		32,
		"",
		4,
		"",
		6,
		""
	],
	[
		"ef40",
		"",
		5,
		"",
		37,
		"",
		4
	],
	[
		"ef80",
		"",
		30,
		"",
		4,
		"",
		8,
		""
	],
	[
		"f040",
		"",
		4,
		"",
		28,
		"",
		26
	],
	[
		"f080",
		"",
		9,
		"",
		12,
		"",
		4,
		"",
		6,
		""
	],
	[
		"f140",
		"",
		10,
		"",
		47
	],
	[
		"f180",
		"",
		32,
		""
	],
	[
		"f240",
		"",
		62
	],
	[
		"f280",
		"",
		32,
		""
	],
	[
		"f340",
		"",
		17,
		"",
		6,
		"",
		4,
		""
	],
	[
		"f380",
		"",
		8,
		"",
		6,
		""
	],
	[
		"f440",
		"",
		5,
		"",
		10,
		"",
		10,
		"",
		7,
		"",
		5
	],
	[
		"f480",
		"",
		32,
		""
	],
	[
		"f540",
		"",
		62
	],
	[
		"f580",
		"",
		32,
		""
	],
	[
		"f640",
		"",
		62
	],
	[
		"f680",
		"",
		32,
		"",
		5,
		"",
		5,
		"",
		4,
		"",
		7,
		""
	],
	[
		"f740",
		"",
		62
	],
	[
		"f780",
		"",
		4,
		"",
		4,
		""
	],
	[
		"f840",
		"",
		62
	],
	[
		"f880",
		"",
		32
	],
	[
		"f940",
		"",
		62
	],
	[
		"f980",
		"",
		32
	],
	[
		"fa40",
		"",
		62
	],
	[
		"fa80",
		"",
		32
	],
	[
		"fb40",
		"",
		27,
		"",
		9,
		""
	],
	[
		"fb80",
		"",
		5,
		"",
		8,
		"",
		5,
		""
	],
	[
		"fc40",
		"",
		8,
		"",
		4,
		"",
		8,
		"",
		6
	],
	[
		"fc80",
		"",
		4,
		"",
		5,
		"",
		8,
		""
	],
	[
		"fd40",
		"",
		4,
		"",
		4,
		"",
		10,
		"",
		38
	],
	[
		"fd80",
		"",
		5,
		"",
		11,
		"",
		4,
		""
	],
	[
		"fe40",
		""
	]
];

var require$$3 = [
	[
		"a140",
		"",
		62
	],
	[
		"a180",
		"",
		32
	],
	[
		"a240",
		"",
		62
	],
	[
		"a280",
		"",
		32
	],
	[
		"a2ab",
		"",
		5
	],
	[
		"a2e3",
		""
	],
	[
		"a2ef",
		""
	],
	[
		"a2fd",
		""
	],
	[
		"a340",
		"",
		62
	],
	[
		"a380",
		"",
		31,
		""
	],
	[
		"a440",
		"",
		62
	],
	[
		"a480",
		"",
		32
	],
	[
		"a4f4",
		"",
		10
	],
	[
		"a540",
		"",
		62
	],
	[
		"a580",
		"",
		32
	],
	[
		"a5f7",
		"",
		7
	],
	[
		"a640",
		"",
		62
	],
	[
		"a680",
		"",
		32
	],
	[
		"a6b9",
		"",
		7
	],
	[
		"a6d9",
		"",
		6
	],
	[
		"a6ec",
		""
	],
	[
		"a6f3",
		""
	],
	[
		"a6f6",
		"",
		8
	],
	[
		"a740",
		"",
		62
	],
	[
		"a780",
		"",
		32
	],
	[
		"a7c2",
		"",
		14
	],
	[
		"a7f2",
		"",
		12
	],
	[
		"a896",
		"",
		10
	],
	[
		"a8bc",
		""
	],
	[
		"a8bf",
		""
	],
	[
		"a8c1",
		""
	],
	[
		"a8ea",
		"",
		20
	],
	[
		"a958",
		""
	],
	[
		"a95b",
		""
	],
	[
		"a95d",
		""
	],
	[
		"a989",
		"",
		11
	],
	[
		"a997",
		"",
		12
	],
	[
		"a9f0",
		"",
		14
	],
	[
		"aaa1",
		"",
		93
	],
	[
		"aba1",
		"",
		93
	],
	[
		"aca1",
		"",
		93
	],
	[
		"ada1",
		"",
		93
	],
	[
		"aea1",
		"",
		93
	],
	[
		"afa1",
		"",
		93
	],
	[
		"d7fa",
		"",
		4
	],
	[
		"f8a1",
		"",
		93
	],
	[
		"f9a1",
		"",
		93
	],
	[
		"faa1",
		"",
		93
	],
	[
		"fba1",
		"",
		93
	],
	[
		"fca1",
		"",
		93
	],
	[
		"fda1",
		"",
		93
	],
	[
		"fe50",
		""
	],
	[
		"fe80",
		"",
		6,
		"",
		93
	],
	[
		"8135f437",
		""
	]
];

var uChars = [
	128,
	165,
	169,
	178,
	184,
	216,
	226,
	235,
	238,
	244,
	248,
	251,
	253,
	258,
	276,
	284,
	300,
	325,
	329,
	334,
	364,
	463,
	465,
	467,
	469,
	471,
	473,
	475,
	477,
	506,
	594,
	610,
	712,
	716,
	730,
	930,
	938,
	962,
	970,
	1026,
	1104,
	1106,
	8209,
	8215,
	8218,
	8222,
	8231,
	8241,
	8244,
	8246,
	8252,
	8365,
	8452,
	8454,
	8458,
	8471,
	8482,
	8556,
	8570,
	8596,
	8602,
	8713,
	8720,
	8722,
	8726,
	8731,
	8737,
	8740,
	8742,
	8748,
	8751,
	8760,
	8766,
	8777,
	8781,
	8787,
	8802,
	8808,
	8816,
	8854,
	8858,
	8870,
	8896,
	8979,
	9322,
	9372,
	9548,
	9588,
	9616,
	9622,
	9634,
	9652,
	9662,
	9672,
	9676,
	9680,
	9702,
	9735,
	9738,
	9793,
	9795,
	11906,
	11909,
	11913,
	11917,
	11928,
	11944,
	11947,
	11951,
	11956,
	11960,
	11964,
	11979,
	12284,
	12292,
	12312,
	12319,
	12330,
	12351,
	12436,
	12447,
	12535,
	12543,
	12586,
	12842,
	12850,
	12964,
	13200,
	13215,
	13218,
	13253,
	13263,
	13267,
	13270,
	13384,
	13428,
	13727,
	13839,
	13851,
	14617,
	14703,
	14801,
	14816,
	14964,
	15183,
	15471,
	15585,
	16471,
	16736,
	17208,
	17325,
	17330,
	17374,
	17623,
	17997,
	18018,
	18212,
	18218,
	18301,
	18318,
	18760,
	18811,
	18814,
	18820,
	18823,
	18844,
	18848,
	18872,
	19576,
	19620,
	19738,
	19887,
	40870,
	59244,
	59336,
	59367,
	59413,
	59417,
	59423,
	59431,
	59437,
	59443,
	59452,
	59460,
	59478,
	59493,
	63789,
	63866,
	63894,
	63976,
	63986,
	64016,
	64018,
	64021,
	64025,
	64034,
	64037,
	64042,
	65074,
	65093,
	65107,
	65112,
	65127,
	65132,
	65375,
	65510,
	65536
];
var gbChars = [
	0,
	36,
	38,
	45,
	50,
	81,
	89,
	95,
	96,
	100,
	103,
	104,
	105,
	109,
	126,
	133,
	148,
	172,
	175,
	179,
	208,
	306,
	307,
	308,
	309,
	310,
	311,
	312,
	313,
	341,
	428,
	443,
	544,
	545,
	558,
	741,
	742,
	749,
	750,
	805,
	819,
	820,
	7922,
	7924,
	7925,
	7927,
	7934,
	7943,
	7944,
	7945,
	7950,
	8062,
	8148,
	8149,
	8152,
	8164,
	8174,
	8236,
	8240,
	8262,
	8264,
	8374,
	8380,
	8381,
	8384,
	8388,
	8390,
	8392,
	8393,
	8394,
	8396,
	8401,
	8406,
	8416,
	8419,
	8424,
	8437,
	8439,
	8445,
	8482,
	8485,
	8496,
	8521,
	8603,
	8936,
	8946,
	9046,
	9050,
	9063,
	9066,
	9076,
	9092,
	9100,
	9108,
	9111,
	9113,
	9131,
	9162,
	9164,
	9218,
	9219,
	11329,
	11331,
	11334,
	11336,
	11346,
	11361,
	11363,
	11366,
	11370,
	11372,
	11375,
	11389,
	11682,
	11686,
	11687,
	11692,
	11694,
	11714,
	11716,
	11723,
	11725,
	11730,
	11736,
	11982,
	11989,
	12102,
	12336,
	12348,
	12350,
	12384,
	12393,
	12395,
	12397,
	12510,
	12553,
	12851,
	12962,
	12973,
	13738,
	13823,
	13919,
	13933,
	14080,
	14298,
	14585,
	14698,
	15583,
	15847,
	16318,
	16434,
	16438,
	16481,
	16729,
	17102,
	17122,
	17315,
	17320,
	17402,
	17418,
	17859,
	17909,
	17911,
	17915,
	17916,
	17936,
	17939,
	17961,
	18664,
	18703,
	18814,
	18962,
	19043,
	33469,
	33470,
	33471,
	33484,
	33485,
	33490,
	33497,
	33501,
	33505,
	33513,
	33520,
	33536,
	33550,
	37845,
	37921,
	37948,
	38029,
	38038,
	38064,
	38065,
	38066,
	38069,
	38075,
	38076,
	38078,
	39108,
	39109,
	39113,
	39114,
	39115,
	39116,
	39265,
	39394,
	189000
];
var require$$4 = {
	uChars: uChars,
	gbChars: gbChars
};

var require$$5 = [
	[
		"0",
		"\u0000",
		127
	],
	[
		"8141",
		"",
		4,
		"",
		6,
		""
	],
	[
		"8161",
		"",
		9,
		"",
		5,
		""
	],
	[
		"8181",
		"",
		18,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		7,
		"",
		7,
		"",
		4,
		"",
		4,
		""
	],
	[
		"8241",
		"",
		7,
		"",
		5
	],
	[
		"8261",
		"",
		6,
		"",
		5,
		""
	],
	[
		"8281",
		"",
		7,
		"",
		7,
		"",
		4,
		"",
		10,
		"",
		5,
		"",
		17,
		"",
		7,
		"",
		6,
		"",
		7,
		"",
		18
	],
	[
		"8341",
		"",
		5,
		"",
		5,
		"",
		7
	],
	[
		"8361",
		"",
		18,
		""
	],
	[
		"8381",
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		5,
		"",
		46,
		"",
		6,
		"",
		5,
		"",
		8
	],
	[
		"8441",
		"",
		5,
		"",
		8
	],
	[
		"8461",
		"",
		18
	],
	[
		"8481",
		"",
		7,
		"",
		6,
		"",
		5,
		"",
		10,
		"",
		5,
		"",
		18,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		26,
		""
	],
	[
		"8541",
		"",
		5,
		"",
		4,
		"",
		6,
		"",
		4
	],
	[
		"8561",
		"",
		5,
		"",
		5,
		"",
		6,
		""
	],
	[
		"8581",
		"",
		6,
		"",
		6,
		"",
		9,
		"",
		26,
		"",
		29,
		"",
		6,
		"",
		5,
		""
	],
	[
		"8641",
		"",
		6,
		"",
		5,
		""
	],
	[
		"8661",
		"",
		6,
		"",
		10
	],
	[
		"8681",
		"",
		22,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		22,
		"",
		4,
		""
	],
	[
		"8741",
		"",
		9,
		"",
		15
	],
	[
		"8761",
		"",
		18,
		""
	],
	[
		"8781",
		"",
		5,
		"",
		7,
		"",
		7,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		18,
		"",
		6,
		"",
		26,
		"",
		6,
		"",
		4
	],
	[
		"8841",
		"",
		4,
		"",
		5,
		"",
		6,
		"",
		4
	],
	[
		"8861",
		"",
		4,
		""
	],
	[
		"8881",
		"",
		15,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		54,
		""
	],
	[
		"8941",
		"",
		6,
		"",
		5,
		""
	],
	[
		"8961",
		"",
		10,
		"",
		5,
		""
	],
	[
		"8981",
		"",
		21,
		"",
		18,
		"",
		18,
		"",
		6,
		"",
		6,
		"",
		7,
		"",
		15
	],
	[
		"8a41",
		"",
		10,
		"",
		6,
		""
	],
	[
		"8a61",
		"",
		4,
		"",
		18,
		""
	],
	[
		"8a81",
		"",
		4,
		"",
		19,
		"",
		5,
		"",
		7,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		4,
		"",
		5,
		"",
		26,
		""
	],
	[
		"8b41",
		"",
		5,
		"",
		4,
		"",
		6,
		""
	],
	[
		"8b61",
		"",
		6,
		"",
		8
	],
	[
		"8b81",
		"",
		52,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		18,
		"",
		18
	],
	[
		"8c41",
		"",
		15,
		"",
		4
	],
	[
		"8c61",
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5
	],
	[
		"8c81",
		"",
		12,
		"",
		26,
		"",
		50,
		"",
		5,
		"",
		16
	],
	[
		"8d41",
		"",
		16,
		"",
		8
	],
	[
		"8d61",
		"",
		17,
		""
	],
	[
		"8d81",
		"",
		4,
		"",
		33,
		"",
		6,
		"",
		7,
		"",
		6,
		"",
		9,
		"",
		6,
		"",
		5,
		"",
		6,
		""
	],
	[
		"8e41",
		"",
		6,
		"",
		5,
		"",
		8
	],
	[
		"8e61",
		"",
		4,
		"",
		19
	],
	[
		"8e81",
		"",
		13,
		"",
		6,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		11,
		"",
		7,
		"",
		6,
		"",
		5,
		"",
		7
	],
	[
		"8f41",
		"",
		7,
		"",
		17
	],
	[
		"8f61",
		"",
		7,
		"",
		6,
		"",
		4
	],
	[
		"8f81",
		"",
		5,
		"",
		7,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		18,
		"",
		6,
		"",
		26,
		"",
		6,
		"",
		5
	],
	[
		"9041",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9061",
		"",
		5,
		"",
		15
	],
	[
		"9081",
		"",
		12,
		"",
		6,
		"",
		5,
		"",
		4,
		"",
		6,
		"",
		4,
		"",
		5,
		"",
		11,
		"",
		33,
		""
	],
	[
		"9141",
		"",
		6,
		"",
		5
	],
	[
		"9161",
		"",
		9,
		"",
		5
	],
	[
		"9181",
		"",
		20,
		"",
		4,
		"",
		5,
		"",
		14,
		"",
		33,
		"",
		7,
		"",
		5,
		"",
		6
	],
	[
		"9241",
		"",
		7,
		"",
		4,
		""
	],
	[
		"9261",
		"",
		7,
		"",
		7,
		"",
		4
	],
	[
		"9281",
		"",
		21,
		"",
		18,
		"",
		6,
		"",
		7,
		"",
		6,
		"",
		35,
		""
	],
	[
		"9341",
		"",
		4,
		""
	],
	[
		"9361",
		"",
		6,
		"",
		8
	],
	[
		"9381",
		"",
		37,
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		7,
		"",
		22,
		""
	],
	[
		"9441",
		"",
		5,
		"",
		5,
		"",
		8
	],
	[
		"9461",
		"",
		5,
		"",
		6,
		"",
		12
	],
	[
		"9481",
		"",
		5,
		"",
		6,
		"",
		6,
		"",
		9,
		"",
		22,
		"",
		4,
		"",
		6,
		"",
		10,
		"",
		6,
		"",
		24
	],
	[
		"9541",
		"",
		11,
		"",
		5,
		""
	],
	[
		"9561",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9581",
		"",
		6,
		"",
		35,
		"",
		4,
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		13,
		"",
		14
	],
	[
		"9641",
		"",
		23,
		""
	],
	[
		"9661",
		"",
		6,
		"",
		5,
		"",
		8
	],
	[
		"9681",
		"",
		10,
		"",
		5,
		"",
		13,
		"",
		33,
		"",
		6,
		"",
		44
	],
	[
		"9741",
		"",
		16,
		"",
		8
	],
	[
		"9761",
		"",
		17,
		"",
		7
	],
	[
		"9781",
		"",
		11,
		"",
		5,
		"",
		6,
		"",
		89,
		""
	],
	[
		"9841",
		"",
		16,
		"",
		5,
		""
	],
	[
		"9861",
		"",
		6,
		"",
		15
	],
	[
		"9881",
		"",
		21,
		"",
		6,
		"",
		5,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5,
		""
	],
	[
		"9941",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9961",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9981",
		"",
		8,
		"",
		5,
		"",
		4,
		"",
		11,
		"",
		5,
		"",
		6,
		"",
		6,
		"",
		6,
		"",
		7,
		"",
		6,
		"",
		5,
		""
	],
	[
		"9a41",
		"",
		16
	],
	[
		"9a61",
		"",
		6,
		"",
		6,
		""
	],
	[
		"9a81",
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		5,
		"",
		33,
		"",
		5,
		"",
		6,
		""
	],
	[
		"9b41",
		"",
		6,
		"",
		8
	],
	[
		"9b61",
		"",
		17,
		"",
		7
	],
	[
		"9b81",
		"",
		25,
		"",
		4,
		"",
		5,
		"",
		50,
		"",
		22,
		""
	],
	[
		"9c41",
		"",
		4,
		"",
		5,
		"",
		5
	],
	[
		"9c61",
		"",
		8,
		"",
		6,
		"",
		9
	],
	[
		"9c81",
		"",
		8,
		"",
		6,
		"",
		6,
		"",
		9,
		"",
		26,
		"",
		6,
		"",
		5,
		"",
		18,
		"",
		6,
		"",
		12
	],
	[
		"9d41",
		"",
		13,
		"",
		8
	],
	[
		"9d61",
		"",
		25
	],
	[
		"9d81",
		"",
		8,
		"",
		5,
		"",
		9,
		"",
		6,
		"",
		10,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5,
		""
	],
	[
		"9e41",
		"",
		7,
		"",
		9,
		""
	],
	[
		"9e61",
		"",
		4,
		"",
		6,
		""
	],
	[
		"9e81",
		"",
		6,
		"",
		6,
		"",
		6,
		"",
		5,
		"",
		10,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		6,
		""
	],
	[
		"9f41",
		"",
		5,
		"",
		4,
		"",
		5,
		""
	],
	[
		"9f61",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9f81",
		"",
		4,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		4,
		"",
		6,
		"",
		7,
		"",
		4,
		"",
		4,
		""
	],
	[
		"a041",
		"",
		5,
		"",
		6,
		""
	],
	[
		"a061",
		"",
		5,
		"",
		13
	],
	[
		"a081",
		"",
		4,
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		26,
		"",
		4,
		"",
		5,
		"",
		7,
		""
	],
	[
		"a141",
		"",
		18,
		""
	],
	[
		"a161",
		"",
		6,
		"",
		5,
		""
	],
	[
		"a181",
		"",
		14,
		"",
		5,
		"",
		4,
		"",
		9,
		""
	],
	[
		"a241",
		"",
		5,
		"",
		18
	],
	[
		"a261",
		"",
		6,
		"",
		18
	],
	[
		"a281",
		"",
		7,
		"",
		6,
		"",
		7,
		""
	],
	[
		"a341",
		"",
		6,
		"",
		10,
		""
	],
	[
		"a361",
		"",
		6,
		"",
		16
	],
	[
		"a381",
		"",
		16,
		"",
		4,
		"",
		58,
		"",
		32,
		""
	],
	[
		"a441",
		"",
		5,
		""
	],
	[
		"a461",
		"",
		5,
		"",
		12
	],
	[
		"a481",
		"",
		28,
		"",
		93
	],
	[
		"a541",
		"",
		4,
		"",
		6,
		"",
		5,
		""
	],
	[
		"a561",
		"",
		17,
		"",
		5,
		""
	],
	[
		"a581",
		"",
		16,
		"",
		14,
		"",
		9
	],
	[
		"a5b0",
		"",
		9
	],
	[
		"a5c1",
		"",
		16,
		"",
		6
	],
	[
		"a5e1",
		"",
		16,
		"",
		6
	],
	[
		"a641",
		"",
		19,
		""
	],
	[
		"a661",
		"",
		5,
		"",
		5,
		"",
		6
	],
	[
		"a681",
		"",
		6,
		"",
		18,
		"",
		7
	],
	[
		"a741",
		"",
		4,
		"",
		6,
		"",
		7
	],
	[
		"a761",
		"",
		22,
		""
	],
	[
		"a781",
		"",
		6,
		"",
		5,
		"",
		7,
		"",
		9,
		"",
		9,
		"",
		4,
		"",
		5,
		"",
		4,
		""
	],
	[
		"a841",
		"",
		10,
		"",
		14
	],
	[
		"a861",
		"",
		18,
		"",
		6
	],
	[
		"a881",
		"",
		19,
		"",
		11,
		""
	],
	[
		"a8a6",
		""
	],
	[
		"a8a8",
		""
	],
	[
		"a8b1",
		"",
		27,
		"",
		25,
		"",
		14,
		""
	],
	[
		"a941",
		"",
		14,
		"",
		10
	],
	[
		"a961",
		"",
		18
	],
	[
		"a981",
		"",
		14,
		"",
		6,
		"",
		27,
		"",
		25,
		"",
		14,
		""
	],
	[
		"aa41",
		"",
		6,
		"",
		4,
		""
	],
	[
		"aa61",
		"",
		4,
		"",
		5,
		"",
		6,
		""
	],
	[
		"aa81",
		"",
		29,
		"",
		82
	],
	[
		"ab41",
		"",
		6,
		"",
		5,
		""
	],
	[
		"ab61",
		"",
		6,
		"",
		5,
		"",
		5
	],
	[
		"ab81",
		"",
		8,
		"",
		6,
		"",
		12,
		"",
		85
	],
	[
		"ac41",
		"",
		5,
		"",
		6,
		""
	],
	[
		"ac61",
		"",
		11,
		"",
		4
	],
	[
		"ac81",
		"",
		28,
		"",
		5,
		"",
		25
	],
	[
		"acd1",
		"",
		5,
		"",
		25
	],
	[
		"ad41",
		"",
		6,
		"",
		5,
		"",
		7
	],
	[
		"ad61",
		"",
		6,
		"",
		10,
		""
	],
	[
		"ad81",
		"",
		5,
		"",
		18,
		""
	],
	[
		"ae41",
		"",
		5,
		"",
		16
	],
	[
		"ae61",
		"",
		5,
		"",
		6,
		"",
		4
	],
	[
		"ae81",
		"",
		6,
		"",
		5,
		""
	],
	[
		"af41",
		"",
		19
	],
	[
		"af61",
		"",
		13,
		"",
		5,
		""
	],
	[
		"af81",
		"",
		5,
		"",
		6,
		"",
		5,
		""
	],
	[
		"b041",
		"",
		5,
		"",
		5,
		"",
		12
	],
	[
		"b061",
		"",
		5,
		"",
		19
	],
	[
		"b081",
		"",
		13,
		"",
		6,
		"",
		5,
		"",
		7,
		"",
		4,
		""
	],
	[
		"b141",
		"",
		6,
		"",
		5,
		""
	],
	[
		"b161",
		"",
		6,
		"",
		5,
		"",
		11
	],
	[
		"b181",
		"",
		14,
		"",
		6,
		""
	],
	[
		"b241",
		"",
		6,
		"",
		5,
		""
	],
	[
		"b261",
		"",
		18,
		"",
		5,
		""
	],
	[
		"b281",
		"",
		5,
		"",
		18,
		"",
		6,
		""
	],
	[
		"b341",
		"",
		19,
		""
	],
	[
		"b361",
		"",
		5,
		"",
		5,
		"",
		5
	],
	[
		"b381",
		"",
		5,
		"",
		5,
		"",
		19,
		"",
		4,
		""
	],
	[
		"b441",
		"",
		5,
		"",
		6,
		"",
		5
	],
	[
		"b461",
		"",
		6,
		"",
		10,
		""
	],
	[
		"b481",
		"",
		6,
		"",
		18,
		"",
		4,
		"",
		4,
		""
	],
	[
		"b541",
		"",
		14,
		"",
		5
	],
	[
		"b561",
		"",
		5,
		"",
		5,
		"",
		4
	],
	[
		"b581",
		"",
		6,
		"",
		5,
		"",
		11,
		""
	],
	[
		"b641",
		"",
		7,
		"",
		17
	],
	[
		"b661",
		"",
		15,
		""
	],
	[
		"b681",
		"",
		5,
		"",
		6,
		"",
		5,
		""
	],
	[
		"b741",
		"",
		13,
		"",
		6,
		""
	],
	[
		"b761",
		"",
		20,
		""
	],
	[
		"b781",
		"",
		6,
		"",
		14,
		""
	],
	[
		"b841",
		"",
		7,
		"",
		17
	],
	[
		"b861",
		"",
		8,
		"",
		13
	],
	[
		"b881",
		"",
		5,
		"",
		24,
		"",
		4,
		""
	],
	[
		"b941",
		"",
		6,
		"",
		5,
		""
	],
	[
		"b961",
		"",
		14,
		"",
		6,
		""
	],
	[
		"b981",
		"",
		22,
		"",
		4,
		"",
		4,
		""
	],
	[
		"ba41",
		"",
		5,
		"",
		6,
		""
	],
	[
		"ba61",
		"",
		5,
		"",
		4,
		"",
		5
	],
	[
		"ba81",
		"",
		6,
		"",
		9,
		""
	],
	[
		"bb41",
		"",
		4,
		"",
		5,
		"",
		4,
		""
	],
	[
		"bb61",
		"",
		6,
		"",
		5,
		""
	],
	[
		"bb81",
		"",
		31,
		""
	],
	[
		"bc41",
		"",
		17,
		""
	],
	[
		"bc61",
		"",
		5,
		"",
		6,
		""
	],
	[
		"bc81",
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		5,
		"",
		4,
		""
	],
	[
		"bd41",
		"",
		7,
		"",
		7,
		""
	],
	[
		"bd61",
		"",
		5,
		"",
		13
	],
	[
		"bd81",
		"",
		5,
		"",
		25,
		""
	],
	[
		"be41",
		"",
		7,
		"",
		14
	],
	[
		"be61",
		"",
		7,
		"",
		7,
		""
	],
	[
		"be81",
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		8,
		"",
		6,
		""
	],
	[
		"bf41",
		"",
		10,
		"",
		14
	],
	[
		"bf61",
		"",
		18,
		""
	],
	[
		"bf81",
		"",
		5,
		"",
		7,
		"",
		6,
		"",
		5,
		""
	],
	[
		"c041",
		"",
		5,
		"",
		6,
		"",
		5
	],
	[
		"c061",
		"",
		25
	],
	[
		"c081",
		"",
		6,
		"",
		5,
		"",
		7,
		""
	],
	[
		"c141",
		"",
		5,
		"",
		6,
		""
	],
	[
		"c161",
		"",
		19,
		""
	],
	[
		"c181",
		"",
		31,
		""
	],
	[
		"c241",
		"",
		4,
		"",
		5,
		""
	],
	[
		"c261",
		"",
		4,
		"",
		5,
		"",
		6,
		""
	],
	[
		"c281",
		"",
		5,
		"",
		7,
		"",
		9,
		""
	],
	[
		"c341",
		"",
		4
	],
	[
		"c361",
		"",
		4,
		"",
		5,
		"",
		11
	],
	[
		"c381",
		"",
		5,
		"",
		7,
		"",
		5,
		""
	],
	[
		"c441",
		"",
		7,
		"",
		7,
		""
	],
	[
		"c461",
		"",
		5,
		"",
		4
	],
	[
		"c481",
		"",
		5,
		"",
		11,
		""
	],
	[
		"c541",
		"",
		6,
		"",
		5,
		""
	],
	[
		"c561",
		"",
		6,
		"",
		5,
		"",
		4
	],
	[
		"c581",
		"",
		6,
		"",
		5,
		""
	],
	[
		"c641",
		"",
		6,
		"",
		5
	],
	[
		"c6a1",
		""
	],
	[
		"c7a1",
		""
	],
	[
		"c8a1",
		""
	],
	[
		"caa1",
		""
	],
	[
		"cba1",
		""
	],
	[
		"cca1",
		""
	],
	[
		"cda1",
		""
	],
	[
		"cea1",
		""
	],
	[
		"cfa1",
		""
	],
	[
		"d0a1",
		""
	],
	[
		"d1a1",
		"",
		5,
		"",
		4,
		""
	],
	[
		"d2a1",
		"",
		4,
		"",
		5,
		"",
		10,
		"",
		7,
		"",
		5,
		""
	],
	[
		"d3a1",
		""
	],
	[
		"d4a1",
		""
	],
	[
		"d5a1",
		""
	],
	[
		"d6a1",
		""
	],
	[
		"d7a1",
		""
	],
	[
		"d8a1",
		""
	],
	[
		"d9a1",
		""
	],
	[
		"daa1",
		""
	],
	[
		"dba1",
		""
	],
	[
		"dca1",
		""
	],
	[
		"dda1",
		""
	],
	[
		"dea1",
		""
	],
	[
		"dfa1",
		""
	],
	[
		"e0a1",
		""
	],
	[
		"e1a1",
		""
	],
	[
		"e2a1",
		""
	],
	[
		"e3a1",
		""
	],
	[
		"e4a1",
		""
	],
	[
		"e5a1",
		""
	],
	[
		"e6a1",
		""
	],
	[
		"e7a1",
		""
	],
	[
		"e8a1",
		""
	],
	[
		"e9a1",
		""
	],
	[
		"eaa1",
		""
	],
	[
		"eba1",
		""
	],
	[
		"eca1",
		""
	],
	[
		"eda1",
		""
	],
	[
		"eea1",
		""
	],
	[
		"efa1",
		""
	],
	[
		"f0a1",
		""
	],
	[
		"f1a1",
		""
	],
	[
		"f2a1",
		""
	],
	[
		"f3a1",
		""
	],
	[
		"f4a1",
		""
	],
	[
		"f5a1",
		""
	],
	[
		"f6a1",
		""
	],
	[
		"f7a1",
		""
	],
	[
		"f8a1",
		""
	],
	[
		"f9a1",
		""
	],
	[
		"faa1",
		""
	],
	[
		"fba1",
		""
	],
	[
		"fca1",
		""
	],
	[
		"fda1",
		""
	]
];

var require$$6 = [
	[
		"0",
		"\u0000",
		127
	],
	[
		"a140",
		""
	],
	[
		"a1a1",
		"",
		4,
		""
	],
	[
		"a240",
		"",
		7,
		""
	],
	[
		"a2a1",
		"",
		9,
		"",
		9,
		"",
		8,
		"",
		25,
		"",
		21
	],
	[
		"a340",
		"",
		16,
		"",
		6,
		"",
		16,
		"",
		6,
		"",
		10
	],
	[
		"a3a1",
		"",
		25,
		""
	],
	[
		"a3e1",
		""
	],
	[
		"a440",
		""
	],
	[
		"a4a1",
		""
	],
	[
		"a540",
		""
	],
	[
		"a5a1",
		""
	],
	[
		"a640",
		""
	],
	[
		"a6a1",
		""
	],
	[
		"a740",
		""
	],
	[
		"a7a1",
		""
	],
	[
		"a840",
		""
	],
	[
		"a8a1",
		""
	],
	[
		"a940",
		""
	],
	[
		"a9a1",
		""
	],
	[
		"aa40",
		""
	],
	[
		"aaa1",
		""
	],
	[
		"ab40",
		""
	],
	[
		"aba1",
		""
	],
	[
		"ac40",
		""
	],
	[
		"aca1",
		""
	],
	[
		"ad40",
		""
	],
	[
		"ada1",
		""
	],
	[
		"ae40",
		""
	],
	[
		"aea1",
		""
	],
	[
		"af40",
		""
	],
	[
		"afa1",
		""
	],
	[
		"b040",
		""
	],
	[
		"b0a1",
		""
	],
	[
		"b140",
		""
	],
	[
		"b1a1",
		""
	],
	[
		"b240",
		""
	],
	[
		"b2a1",
		""
	],
	[
		"b340",
		""
	],
	[
		"b3a1",
		""
	],
	[
		"b440",
		""
	],
	[
		"b4a1",
		""
	],
	[
		"b540",
		""
	],
	[
		"b5a1",
		""
	],
	[
		"b640",
		""
	],
	[
		"b6a1",
		""
	],
	[
		"b740",
		""
	],
	[
		"b7a1",
		""
	],
	[
		"b840",
		""
	],
	[
		"b8a1",
		""
	],
	[
		"b940",
		""
	],
	[
		"b9a1",
		""
	],
	[
		"ba40",
		""
	],
	[
		"baa1",
		""
	],
	[
		"bb40",
		""
	],
	[
		"bba1",
		""
	],
	[
		"bc40",
		""
	],
	[
		"bca1",
		""
	],
	[
		"bd40",
		""
	],
	[
		"bda1",
		""
	],
	[
		"be40",
		""
	],
	[
		"bea1",
		""
	],
	[
		"bf40",
		""
	],
	[
		"bfa1",
		""
	],
	[
		"c040",
		""
	],
	[
		"c0a1",
		""
	],
	[
		"c140",
		""
	],
	[
		"c1a1",
		""
	],
	[
		"c240",
		""
	],
	[
		"c2a1",
		""
	],
	[
		"c340",
		""
	],
	[
		"c3a1",
		""
	],
	[
		"c440",
		""
	],
	[
		"c4a1",
		""
	],
	[
		"c540",
		""
	],
	[
		"c5a1",
		""
	],
	[
		"c640",
		""
	],
	[
		"c940",
		""
	],
	[
		"c9a1",
		""
	],
	[
		"ca40",
		""
	],
	[
		"caa1",
		""
	],
	[
		"cb40",
		""
	],
	[
		"cba1",
		""
	],
	[
		"cc40",
		""
	],
	[
		"cca1",
		""
	],
	[
		"cd40",
		""
	],
	[
		"cda1",
		""
	],
	[
		"ce40",
		""
	],
	[
		"cea1",
		""
	],
	[
		"cf40",
		""
	],
	[
		"cfa1",
		""
	],
	[
		"d040",
		""
	],
	[
		"d0a1",
		""
	],
	[
		"d140",
		""
	],
	[
		"d1a1",
		""
	],
	[
		"d240",
		""
	],
	[
		"d2a1",
		""
	],
	[
		"d340",
		""
	],
	[
		"d3a1",
		""
	],
	[
		"d440",
		""
	],
	[
		"d4a1",
		""
	],
	[
		"d540",
		""
	],
	[
		"d5a1",
		""
	],
	[
		"d640",
		""
	],
	[
		"d6a1",
		""
	],
	[
		"d740",
		""
	],
	[
		"d7a1",
		""
	],
	[
		"d840",
		""
	],
	[
		"d8a1",
		""
	],
	[
		"d940",
		""
	],
	[
		"d9a1",
		""
	],
	[
		"da40",
		""
	],
	[
		"daa1",
		""
	],
	[
		"db40",
		""
	],
	[
		"dba1",
		""
	],
	[
		"dc40",
		""
	],
	[
		"dca1",
		""
	],
	[
		"dd40",
		""
	],
	[
		"dda1",
		""
	],
	[
		"de40",
		""
	],
	[
		"dea1",
		""
	],
	[
		"df40",
		""
	],
	[
		"dfa1",
		""
	],
	[
		"e040",
		""
	],
	[
		"e0a1",
		""
	],
	[
		"e140",
		""
	],
	[
		"e1a1",
		""
	],
	[
		"e240",
		""
	],
	[
		"e2a1",
		""
	],
	[
		"e340",
		""
	],
	[
		"e3a1",
		""
	],
	[
		"e440",
		""
	],
	[
		"e4a1",
		""
	],
	[
		"e540",
		""
	],
	[
		"e5a1",
		""
	],
	[
		"e640",
		""
	],
	[
		"e6a1",
		""
	],
	[
		"e740",
		""
	],
	[
		"e7a1",
		""
	],
	[
		"e840",
		""
	],
	[
		"e8a1",
		""
	],
	[
		"e940",
		""
	],
	[
		"e9a1",
		""
	],
	[
		"ea40",
		""
	],
	[
		"eaa1",
		""
	],
	[
		"eb40",
		""
	],
	[
		"eba1",
		""
	],
	[
		"ec40",
		""
	],
	[
		"eca1",
		""
	],
	[
		"ed40",
		""
	],
	[
		"eda1",
		""
	],
	[
		"ee40",
		""
	],
	[
		"eea1",
		""
	],
	[
		"ef40",
		""
	],
	[
		"efa1",
		""
	],
	[
		"f040",
		""
	],
	[
		"f0a1",
		""
	],
	[
		"f140",
		""
	],
	[
		"f1a1",
		""
	],
	[
		"f240",
		""
	],
	[
		"f2a1",
		""
	],
	[
		"f340",
		""
	],
	[
		"f3a1",
		""
	],
	[
		"f440",
		""
	],
	[
		"f4a1",
		""
	],
	[
		"f540",
		""
	],
	[
		"f5a1",
		""
	],
	[
		"f640",
		""
	],
	[
		"f6a1",
		""
	],
	[
		"f740",
		""
	],
	[
		"f7a1",
		""
	],
	[
		"f840",
		""
	],
	[
		"f8a1",
		""
	],
	[
		"f940",
		""
	],
	[
		"f9a1",
		""
	]
];

var require$$7 = [
	[
		"8740",
		""
	],
	[
		"8767",
		""
	],
	[
		"87a1",
		""
	],
	[
		"8840",
		"",
		4,
		""
	],
	[
		"88a1",
		""
	],
	[
		"8940",
		""
	],
	[
		"8943",
		""
	],
	[
		"8946",
		""
	],
	[
		"894c",
		""
	],
	[
		"89a1",
		""
	],
	[
		"89ab",
		""
	],
	[
		"89b0",
		""
	],
	[
		"89b5",
		""
	],
	[
		"89c1",
		""
	],
	[
		"89c5",
		""
	],
	[
		"8a40",
		""
	],
	[
		"8a43",
		""
	],
	[
		"8a64",
		""
	],
	[
		"8a76",
		""
	],
	[
		"8aa1",
		""
	],
	[
		"8aac",
		""
	],
	[
		"8ab2",
		""
	],
	[
		"8abb",
		""
	],
	[
		"8ac9",
		""
	],
	[
		"8ace",
		""
	],
	[
		"8adf",
		""
	],
	[
		"8af6",
		""
	],
	[
		"8b40",
		""
	],
	[
		"8b55",
		""
	],
	[
		"8ba1",
		""
	],
	[
		"8bde",
		""
	],
	[
		"8c40",
		""
	],
	[
		"8ca1",
		""
	],
	[
		"8ca7",
		""
	],
	[
		"8cc9",
		""
	],
	[
		"8cce",
		""
	],
	[
		"8ce6",
		""
	],
	[
		"8d40",
		""
	],
	[
		"8d42",
		""
	],
	[
		"8da1",
		""
	],
	[
		"8e40",
		""
	],
	[
		"8ea1",
		""
	],
	[
		"8f40",
		""
	],
	[
		"8fa1",
		""
	],
	[
		"9040",
		""
	],
	[
		"90a1",
		""
	],
	[
		"9140",
		""
	],
	[
		"91a1",
		""
	],
	[
		"9240",
		""
	],
	[
		"92a1",
		""
	],
	[
		"9340",
		""
	],
	[
		"93a1",
		""
	],
	[
		"9440",
		""
	],
	[
		"94a1",
		""
	],
	[
		"9540",
		""
	],
	[
		"95a1",
		""
	],
	[
		"9640",
		""
	],
	[
		"96a1",
		""
	],
	[
		"9740",
		""
	],
	[
		"97a1",
		""
	],
	[
		"9840",
		""
	],
	[
		"98a1",
		""
	],
	[
		"9940",
		""
	],
	[
		"99a1",
		""
	],
	[
		"9a40",
		""
	],
	[
		"9aa1",
		""
	],
	[
		"9b40",
		""
	],
	[
		"9b62",
		""
	],
	[
		"9ba1",
		""
	],
	[
		"9c40",
		""
	],
	[
		"9ca1",
		""
	],
	[
		"9d40",
		""
	],
	[
		"9da1",
		""
	],
	[
		"9e40",
		""
	],
	[
		"9ea1",
		""
	],
	[
		"9ead",
		""
	],
	[
		"9ec5",
		""
	],
	[
		"9ef5",
		""
	],
	[
		"9f40",
		""
	],
	[
		"9f4f",
		""
	],
	[
		"9fa1",
		""
	],
	[
		"9fae",
		""
	],
	[
		"9fb2",
		""
	],
	[
		"9fc1",
		""
	],
	[
		"9fc9",
		""
	],
	[
		"9fdb",
		""
	],
	[
		"9fe7",
		""
	],
	[
		"9feb",
		""
	],
	[
		"9ff0",
		""
	],
	[
		"a040",
		""
	],
	[
		"a055",
		""
	],
	[
		"a058",
		""
	],
	[
		"a05b",
		""
	],
	[
		"a063",
		""
	],
	[
		"a073",
		""
	],
	[
		"a0a1",
		""
	],
	[
		"a0a6",
		""
	],
	[
		"a0ae",
		""
	],
	[
		"a0b0",
		""
	],
	[
		"a0d4",
		""
	],
	[
		"a0e2",
		""
	],
	[
		"a3c0",
		"",
		31,
		""
	],
	[
		"c6a1",
		"",
		9,
		"",
		9,
		"",
		9,
		"",
		23
	],
	[
		"c740",
		"",
		58,
		""
	],
	[
		"c7a1",
		"",
		81,
		"",
		5,
		"",
		4
	],
	[
		"c840",
		"",
		26,
		"",
		25,
		""
	],
	[
		"c8a1",
		""
	],
	[
		"c8cd",
		""
	],
	[
		"c8f5",
		""
	],
	[
		"f9fe",
		""
	],
	[
		"fa40",
		""
	],
	[
		"faa1",
		""
	],
	[
		"fb40",
		""
	],
	[
		"fba1",
		""
	],
	[
		"fc40",
		""
	],
	[
		"fca1",
		""
	],
	[
		"fd40",
		""
	],
	[
		"fda1",
		""
	],
	[
		"fe40",
		""
	],
	[
		"fea1",
		""
	]
];

var dbcsData;
var hasRequiredDbcsData;
function requireDbcsData() {
  if (hasRequiredDbcsData) return dbcsData;
  hasRequiredDbcsData = 1;

  // Description of supported double byte encodings and aliases.
  // Tables are not require()-d until they are needed to speed up library load.
  // require()-s are direct to support Browserify.

  dbcsData = {
    // == Japanese/ShiftJIS ====================================================
    // All japanese encodings are based on JIS X set of standards:
    // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
    //              Has several variations in 1978, 1983, 1990 and 1997.
    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
    //              2 planes, first is superset of 0208, second - revised 0212.
    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)

    // Byte encodings are:
    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
    //               0x00-0x7F       - lower part of 0201
    //               0x8E, 0xA1-0xDF - upper part of 0201
    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
    //               Used as-is in ISO2022 family.
    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
    //                0201-1976 Roman, 0208-1978, 0208-1983.
    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
    //
    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
    //
    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html

    'shiftjis': {
      type: '_dbcs',
      table: function () {
        return require$$0$1;
      },
      encodeAdd: {
        '\u00a5': 0x5C,
        '\u203E': 0x7E
      },
      encodeSkipVals: [{
        from: 0xED40,
        to: 0xF940
      }]
    },
    'csshiftjis': 'shiftjis',
    'mskanji': 'shiftjis',
    'sjis': 'shiftjis',
    'windows31j': 'shiftjis',
    'ms31j': 'shiftjis',
    'xsjis': 'shiftjis',
    'windows932': 'shiftjis',
    'ms932': 'shiftjis',
    '932': 'shiftjis',
    'cp932': 'shiftjis',
    'eucjp': {
      type: '_dbcs',
      table: function () {
        return require$$1;
      },
      encodeAdd: {
        '\u00a5': 0x5C,
        '\u203E': 0x7E
      }
    },
    // TODO: KDDI extension to Shift_JIS
    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.

    // == Chinese/GBK ==========================================================
    // http://en.wikipedia.org/wiki/GBK
    // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder

    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
    'gb2312': 'cp936',
    'gb231280': 'cp936',
    'gb23121980': 'cp936',
    'csgb2312': 'cp936',
    'csiso58gb231280': 'cp936',
    'euccn': 'cp936',
    // Microsoft's CP936 is a subset and approximation of GBK.
    'windows936': 'cp936',
    'ms936': 'cp936',
    '936': 'cp936',
    'cp936': {
      type: '_dbcs',
      table: function () {
        return require$$2;
      }
    },
    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
    'gbk': {
      type: '_dbcs',
      table: function () {
        return require$$2.concat(require$$3);
      }
    },
    'xgbk': 'gbk',
    'isoir58': 'gbk',
    // GB18030 is an algorithmic extension of GBK.
    // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
    // http://icu-project.org/docs/papers/gb18030.html
    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
    'gb18030': {
      type: '_dbcs',
      table: function () {
        return require$$2.concat(require$$3);
      },
      gb18030: function () {
        return require$$4;
      },
      encodeSkipVals: [0x80],
      encodeAdd: {
        '': 0xA2E3
      }
    },
    'chinese': 'gb18030',
    // == Korean ===============================================================
    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
    'windows949': 'cp949',
    'ms949': 'cp949',
    '949': 'cp949',
    'cp949': {
      type: '_dbcs',
      table: function () {
        return require$$5;
      }
    },
    'cseuckr': 'cp949',
    'csksc56011987': 'cp949',
    'euckr': 'cp949',
    'isoir149': 'cp949',
    'korean': 'cp949',
    'ksc56011987': 'cp949',
    'ksc56011989': 'cp949',
    'ksc5601': 'cp949',
    // == Big5/Taiwan/Hong Kong ================================================
    // There are lots of tables for Big5 and cp950. Please see the following links for history:
    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
    // Variations, in roughly number of defined chars:
    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
    //    Plus, it has 4 combining sequences.
    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
    // 
    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.

    'windows950': 'cp950',
    'ms950': 'cp950',
    '950': 'cp950',
    'cp950': {
      type: '_dbcs',
      table: function () {
        return require$$6;
      }
    },
    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
    'big5': 'big5hkscs',
    'big5hkscs': {
      type: '_dbcs',
      table: function () {
        return require$$6.concat(require$$7);
      },
      encodeSkipVals: [
      // Although Encoding Standard says we should avoid encoding to HKSCS area (See Step 1 of
      // https://encoding.spec.whatwg.org/#index-big5-pointer), we still do it to increase compatibility with ICU.
      // But if a single unicode point can be encoded both as HKSCS and regular Big5, we prefer the latter.
      0x8e69, 0x8e6f, 0x8e7e, 0x8eab, 0x8eb4, 0x8ecd, 0x8ed0, 0x8f57, 0x8f69, 0x8f6e, 0x8fcb, 0x8ffe, 0x906d, 0x907a, 0x90c4, 0x90dc, 0x90f1, 0x91bf, 0x92af, 0x92b0, 0x92b1, 0x92b2, 0x92d1, 0x9447, 0x94ca, 0x95d9, 0x96fc, 0x9975, 0x9b76, 0x9b78, 0x9b7b, 0x9bc6, 0x9bde, 0x9bec, 0x9bf6, 0x9c42, 0x9c53, 0x9c62, 0x9c68, 0x9c6b, 0x9c77, 0x9cbc, 0x9cbd, 0x9cd0, 0x9d57, 0x9d5a, 0x9dc4, 0x9def, 0x9dfb, 0x9ea9, 0x9eef, 0x9efd, 0x9f60, 0x9fcb, 0xa077, 0xa0dc, 0xa0df, 0x8fcc, 0x92c8, 0x9644, 0x96ed,
      // Step 2 of https://encoding.spec.whatwg.org/#index-big5-pointer: Use last pointer for U+2550, U+255E, U+2561, U+256A, U+5341, or U+5345
      0xa2a4, 0xa2a5, 0xa2a7, 0xa2a6, 0xa2cc, 0xa2ce]
    },
    'cnbig5': 'big5hkscs',
    'csbig5': 'big5hkscs',
    'xxbig5': 'big5hkscs'
  };
  return dbcsData;
}

var hasRequiredEncodings;
function requireEncodings() {
  if (hasRequiredEncodings) return encodings;
  hasRequiredEncodings = 1;
  (function (exports) {

    // Update this array if you add/rename/remove files in this directory.
    // We support Browserify by skipping automatic module discovery and requiring modules directly.
    var modules = [requireInternal(), requireUtf32(), requireUtf16(), requireUtf7(), requireSbcsCodec(), requireSbcsData(), requireSbcsDataGenerated(), requireDbcsCodec(), requireDbcsData()];

    // Put all encoding/alias/codec definitions to single object and export it.
    for (var i = 0; i < modules.length; i++) {
      var module = modules[i];
      for (var enc in module) if (Object.prototype.hasOwnProperty.call(module, enc)) exports[enc] = module[enc];
    }
  })(encodings);
  return encodings;
}

var streams;
var hasRequiredStreams;
function requireStreams() {
  if (hasRequiredStreams) return streams;
  hasRequiredStreams = 1;
  var Buffer = requireSafer().Buffer;

  // NOTE: Due to 'stream' module being pretty large (~100Kb, significant in browser environments), 
  // we opt to dependency-inject it instead of creating a hard dependency.
  streams = function (stream_module) {
    var Transform = stream_module.Transform;

    // == Encoder stream =======================================================

    function IconvLiteEncoderStream(conv, options) {
      this.conv = conv;
      options = options || {};
      options.decodeStrings = false; // We accept only strings, so we don't need to decode them.
      Transform.call(this, options);
    }
    IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
      constructor: {
        value: IconvLiteEncoderStream
      }
    });
    IconvLiteEncoderStream.prototype._transform = function (chunk, encoding, done) {
      if (typeof chunk != 'string') return done(new Error("Iconv encoding stream needs strings as its input."));
      try {
        var res = this.conv.write(chunk);
        if (res && res.length) this.push(res);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteEncoderStream.prototype._flush = function (done) {
      try {
        var res = this.conv.end();
        if (res && res.length) this.push(res);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteEncoderStream.prototype.collect = function (cb) {
      var chunks = [];
      this.on('error', cb);
      this.on('data', function (chunk) {
        chunks.push(chunk);
      });
      this.on('end', function () {
        cb(null, Buffer.concat(chunks));
      });
      return this;
    };

    // == Decoder stream =======================================================

    function IconvLiteDecoderStream(conv, options) {
      this.conv = conv;
      options = options || {};
      options.encoding = this.encoding = 'utf8'; // We output strings.
      Transform.call(this, options);
    }
    IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
      constructor: {
        value: IconvLiteDecoderStream
      }
    });
    IconvLiteDecoderStream.prototype._transform = function (chunk, encoding, done) {
      if (!Buffer.isBuffer(chunk) && !(chunk instanceof Uint8Array)) return done(new Error("Iconv decoding stream needs buffers as its input."));
      try {
        var res = this.conv.write(chunk);
        if (res && res.length) this.push(res, this.encoding);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteDecoderStream.prototype._flush = function (done) {
      try {
        var res = this.conv.end();
        if (res && res.length) this.push(res, this.encoding);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteDecoderStream.prototype.collect = function (cb) {
      var res = '';
      this.on('error', cb);
      this.on('data', function (chunk) {
        res += chunk;
      });
      this.on('end', function () {
        cb(null, res);
      });
      return this;
    };
    return {
      IconvLiteEncoderStream: IconvLiteEncoderStream,
      IconvLiteDecoderStream: IconvLiteDecoderStream
    };
  };
  return streams;
}

var hasRequiredLib$1;
function requireLib$1() {
  if (hasRequiredLib$1) return lib$1.exports;
  hasRequiredLib$1 = 1;
  (function (module) {

    var Buffer = requireSafer().Buffer;
    var bomHandling = requireBomHandling(),
      iconv = module.exports;

    // All codecs and aliases are kept here, keyed by encoding name/alias.
    // They are lazy loaded in `iconv.getCodec` from `encodings/index.js`.
    iconv.encodings = null;

    // Characters emitted in case of error.
    iconv.defaultCharUnicode = '';
    iconv.defaultCharSingleByte = '?';

    // Public API.
    iconv.encode = function encode(str, encoding, options) {
      str = "" + (str || ""); // Ensure string.

      var encoder = iconv.getEncoder(encoding, options);
      var res = encoder.write(str);
      var trail = encoder.end();
      return trail && trail.length > 0 ? Buffer.concat([res, trail]) : res;
    };
    iconv.decode = function decode(buf, encoding, options) {
      if (typeof buf === 'string') {
        if (!iconv.skipDecodeWarning) {
          console.error('Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding');
          iconv.skipDecodeWarning = true;
        }
        buf = Buffer.from("" + (buf || ""), "binary"); // Ensure buffer.
      }
      var decoder = iconv.getDecoder(encoding, options);
      var res = decoder.write(buf);
      var trail = decoder.end();
      return trail ? res + trail : res;
    };
    iconv.encodingExists = function encodingExists(enc) {
      try {
        iconv.getCodec(enc);
        return true;
      } catch (e) {
        return false;
      }
    };

    // Legacy aliases to convert functions
    iconv.toEncoding = iconv.encode;
    iconv.fromEncoding = iconv.decode;

    // Search for a codec in iconv.encodings. Cache codec data in iconv._codecDataCache.
    iconv._codecDataCache = {};
    iconv.getCodec = function getCodec(encoding) {
      if (!iconv.encodings) iconv.encodings = requireEncodings(); // Lazy load all encoding definitions.

      // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
      var enc = iconv._canonicalizeEncoding(encoding);

      // Traverse iconv.encodings to find actual codec.
      var codecOptions = {};
      while (true) {
        var codec = iconv._codecDataCache[enc];
        if (codec) return codec;
        var codecDef = iconv.encodings[enc];
        switch (typeof codecDef) {
          case "string":
            // Direct alias to other encoding.
            enc = codecDef;
            break;
          case "object":
            // Alias with options. Can be layered.
            for (var key in codecDef) codecOptions[key] = codecDef[key];
            if (!codecOptions.encodingName) codecOptions.encodingName = enc;
            enc = codecDef.type;
            break;
          case "function":
            // Codec itself.
            if (!codecOptions.encodingName) codecOptions.encodingName = enc;

            // The codec function must load all tables and return object with .encoder and .decoder methods.
            // It'll be called only once (for each different options object).
            codec = new codecDef(codecOptions, iconv);
            iconv._codecDataCache[codecOptions.encodingName] = codec; // Save it to be reused later.
            return codec;
          default:
            throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
        }
      }
    };
    iconv._canonicalizeEncoding = function (encoding) {
      // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
      return ('' + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
    };
    iconv.getEncoder = function getEncoder(encoding, options) {
      var codec = iconv.getCodec(encoding),
        encoder = new codec.encoder(options, codec);
      if (codec.bomAware && options && options.addBOM) encoder = new bomHandling.PrependBOM(encoder, options);
      return encoder;
    };
    iconv.getDecoder = function getDecoder(encoding, options) {
      var codec = iconv.getCodec(encoding),
        decoder = new codec.decoder(options, codec);
      if (codec.bomAware && !(options && options.stripBOM === false)) decoder = new bomHandling.StripBOM(decoder, options);
      return decoder;
    };

    // Streaming API
    // NOTE: Streaming API naturally depends on 'stream' module from Node.js. Unfortunately in browser environments this module can add
    // up to 100Kb to the output bundle. To avoid unnecessary code bloat, we don't enable Streaming API in browser by default.
    // If you would like to enable it explicitly, please add the following code to your app:
    // > iconv.enableStreamingAPI(require('stream'));
    iconv.enableStreamingAPI = function enableStreamingAPI(stream_module) {
      if (iconv.supportsStreams) return;

      // Dependency-inject stream module to create IconvLite stream classes.
      var streams = requireStreams()(stream_module);

      // Not public API yet, but expose the stream classes.
      iconv.IconvLiteEncoderStream = streams.IconvLiteEncoderStream;
      iconv.IconvLiteDecoderStream = streams.IconvLiteDecoderStream;

      // Streaming API.
      iconv.encodeStream = function encodeStream(encoding, options) {
        return new iconv.IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
      };
      iconv.decodeStream = function decodeStream(encoding, options) {
        return new iconv.IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
      };
      iconv.supportsStreams = true;
    };

    // Enable Streaming API automatically if 'stream' module is available and non-empty (the majority of environments).
    var stream_module;
    try {
      stream_module = require("stream");
    } catch (e) {}
    if (stream_module && stream_module.Transform) {
      iconv.enableStreamingAPI(stream_module);
    } else {
      // In rare cases where 'stream' module is not available by default, throw a helpful exception.
      iconv.encodeStream = iconv.decodeStream = function () {
        throw new Error("iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.");
      };
    }
  })(lib$1);
  return lib$1.exports;
}

var decoder;
var hasRequiredDecoder;
function requireDecoder() {
  if (hasRequiredDecoder) return decoder;
  hasRequiredDecoder = 1;
  var iconv,
    inherits = require$$5$1.inherits,
    stream = require$$0$4;
  var regex = /(?:charset|encoding)\s*=\s*['"]? *([\w\-]+)/i;
  inherits(StreamDecoder, stream.Transform);
  function StreamDecoder(charset) {
    if (!(this instanceof StreamDecoder)) return new StreamDecoder(charset);
    stream.Transform.call(this, charset);
    this.charset = charset;
    this.parsed_chunk = false;
  }
  StreamDecoder.prototype._transform = function (chunk, encoding, done) {
    // try to get charset from chunk, but just once
    if (!this.parsed_chunk && (this.charset == 'utf-8' || this.charset == 'utf8')) {
      this.parsed_chunk = true;
      var matches = regex.exec(chunk.toString());
      if (matches) {
        var found = matches[1].toLowerCase().replace('utf8', 'utf-8'); // canonicalize;
        // set charset, but only if iconv can handle it
        if (iconv.encodingExists(found)) this.charset = found;
      }
    }

    // if charset is already utf-8 or given encoding isn't supported, just pass through
    if (this.charset == 'utf-8' || !iconv.encodingExists(this.charset)) {
      this.push(chunk);
      return done();
    }

    // initialize stream decoder if not present
    var self = this;
    if (!this.decoder) {
      this.decoder = iconv.decodeStream(this.charset);
      this.decoder.on('data', function (decoded_chunk) {
        self.push(decoded_chunk);
      });
    }
    this.decoder.write(chunk);
    done();
  };
  decoder = function (charset) {
    try {
      if (!iconv) iconv = requireLib$1();
    } catch (e) {
      /* iconv not found */
    }
    if (iconv) return new StreamDecoder(charset);else return new stream.PassThrough();
  };
  return decoder;
}

var utils$1;
var hasRequiredUtils$1;
function requireUtils$1() {
  if (hasRequiredUtils$1) return utils$1;
  hasRequiredUtils$1 = 1;
  var fs = require$$0$5,
    url = require$$1$2,
    stream = require$$0$4;
  function resolve_url(href, base) {
    if (url.URL) return new url.URL(href, base);

    // older Node version (< v6.13)
    return base ? url.resolve(base, href) : href;
  }
  function host_and_ports_match(url1, url2) {
    if (url1.indexOf('http') < 0) url1 = 'http://' + url1;
    if (url2.indexOf('http') < 0) url2 = 'http://' + url2;
    var a = url.parse(url1),
      b = url.parse(url2);
    return a.host == b.host && String(a.port || (a.protocol == 'https:' ? 443 : 80)) == String(b.port || (b.protocol == 'https:' ? 443 : 80));
  }

  // returns false if a no_proxy host or pattern matches given url
  function should_proxy_to(uri) {
    var no_proxy = get_env_var(['NO_PROXY'], true);
    if (!no_proxy) return true;

    // previous (naive, simple) strategy
    // var host, hosts = no_proxy.split(',');
    // for (var i in hosts) {
    //   host = hosts[i];
    //   if (host_and_ports_match(host, uri)) {
    //     return false;
    //   }
    // }

    var pattern,
      pattern_list = no_proxy.split(/[\s,]+/);
    for (var i in pattern_list) {
      pattern = pattern_list[i];
      if (pattern.trim().length == 0) continue;

      // replace leading dot by asterisk, escape dots and finally replace asterisk by .*
      var regex = new RegExp(pattern.replace(/^\./, "*").replace(/[.]/g, '\\$&').replace(/\*/g, '.*'));
      if (uri.match(regex)) return false;
    }
    return true;
  }
  function get_env_var(keys, try_lower) {
    var val,
      i = -1,
      env = process.env;
    while (!val && i < keys.length - 1) {
      val = env[keys[++i]];
      if (!val && try_lower) {
        val = env[keys[i].toLowerCase()];
      }
    }
    return val;
  }
  function parse_content_type(header) {
    if (!header || header === '') return {};
    var found,
      charset = 'utf8',
      arr = header.split(';');
    if (arr.length > 1 && (found = arr[1].match(/charset=(.+)/))) charset = found[1];
    return {
      type: arr[0],
      charset: charset
    };
  }
  function is_stream(obj) {
    return typeof obj.pipe === 'function';
  }
  function get_stream_length(stream, given_length, cb) {
    if (given_length > 0) return cb(given_length);
    if (stream.end !== void 0 && stream.end !== Infinity && stream.start !== void 0) return cb(stream.end + 1 - (stream.start || 0));
    fs.stat(stream.path, function (err, stat) {
      cb(stat ? stat.size - (stream.start || 0) : null);
    });
  }
  function pump_streams(streams, cb) {
    if (stream.pipeline) return stream.pipeline.apply(null, streams.concat(cb));
    var tmp = streams.shift();
    while (streams.length) {
      tmp = tmp.pipe(streams.shift());
      tmp.once('error', function (e) {
        cb && cb(e);
        cb = null;
      });
    }
  }
  utils$1 = {
    resolve_url: resolve_url,
    get_env_var: get_env_var,
    host_and_ports_match: host_and_ports_match,
    should_proxy_to: should_proxy_to,
    parse_content_type: parse_content_type,
    is_stream: is_stream,
    get_stream_length: get_stream_length,
    pump_streams: pump_streams
  };
  return utils$1;
}

var name$1 = "needle";
var version$1 = "3.3.1";
var description$1 = "The leanest and most handsome HTTP client in the Nodelands.";
var keywords$1 = [
	"http",
	"https",
	"simple",
	"request",
	"client",
	"multipart",
	"upload",
	"proxy",
	"deflate",
	"timeout",
	"charset",
	"iconv",
	"cookie",
	"redirect"
];
var tags = [
	"http",
	"https",
	"simple",
	"request",
	"client",
	"multipart",
	"upload",
	"proxy",
	"deflate",
	"timeout",
	"charset",
	"iconv",
	"cookie",
	"redirect"
];
var author$1 = "Toms Pollak <tomas@forkhq.com>";
var repository$1 = {
	type: "git",
	url: "https://github.com/tomas/needle.git"
};
var dependencies$1 = {
	"iconv-lite": "^0.6.3",
	sax: "^1.2.4"
};
var devDependencies$1 = {
	JSONStream: "^1.3.5",
	jschardet: "^1.6.0",
	mocha: "^5.2.0",
	pump: "^3.0.0",
	q: "^1.5.1",
	should: "^13.2.3",
	sinon: "^2.3.0",
	xml2js: "^0.4.19"
};
var scripts$1 = {
	test: "mocha test"
};
var directories$1 = {
	lib: "./lib"
};
var main$1 = "./lib/needle";
var bin$1 = {
	needle: "./bin/needle"
};
var license$1 = "MIT";
var engines$1 = {
	node: ">= 4.4.x"
};
var require$$13 = {
	name: name$1,
	version: version$1,
	description: description$1,
	keywords: keywords$1,
	tags: tags,
	author: author$1,
	repository: repository$1,
	dependencies: dependencies$1,
	devDependencies: devDependencies$1,
	scripts: scripts$1,
	directories: directories$1,
	main: main$1,
	bin: bin$1,
	license: license$1,
	engines: engines$1
};

var hasRequiredNeedle;
function requireNeedle() {
  if (hasRequiredNeedle) return needle.exports;
  hasRequiredNeedle = 1;
  (function (module) {
    //////////////////////////////////////////
    // Needle -- HTTP Client for Node.js
    // Written by Toms Pollak <tomas@forkhq.com>
    // (c) 2012-2023 - Fork Ltd.
    // MIT Licensed
    //////////////////////////////////////////

    var fs = require$$0$5,
      http = require$$0$7,
      https = require$$1$3,
      url = require$$1$2,
      stream = require$$0$4,
      debug = require$$5$1.debuglog('needle'),
      stringify = requireQuerystring().build,
      multipart = requireMultipart(),
      auth = requireAuth(),
      cookies = requireCookies(),
      parsers = requireParsers(),
      decoder = requireDecoder(),
      utils = requireUtils$1();

    //////////////////////////////////////////
    // variabilia

    var version = require$$13.version;
    var user_agent = 'Needle/' + version;
    user_agent += ' (Node.js ' + process.version + '; ' + process.platform + ' ' + process.arch + ')';
    var tls_options = 'pfx key passphrase cert ca ciphers rejectUnauthorized secureProtocol checkServerIdentity family';

    // older versions of node (< 0.11.4) prevent the runtime from exiting
    // because of connections in keep-alive state. so if this is the case
    // we'll default new requests to set a Connection: close header.
    var close_by_default = !http.Agent || http.Agent.defaultMaxSockets != Infinity;

    // see if we have Object.assign. otherwise fall back to util._extend
    var extend = Object.assign ? Object.assign : require$$5$1._extend;

    // these are the status codes that Needle interprets as redirects.
    var redirect_codes = [301, 302, 303, 307, 308];

    //////////////////////////////////////////
    // decompressors for gzip/deflate/br bodies

    function bind_opts(fn, options) {
      return fn.bind(null, options);
    }
    var decompressors = {};
    try {
      var zlib = require('zlib');

      // Enable Z_SYNC_FLUSH to avoid Z_BUF_ERROR errors (Node PR #2595)
      var zlib_options = {
        flush: zlib.Z_SYNC_FLUSH,
        finishFlush: zlib.Z_SYNC_FLUSH
      };
      var br_options = {
        flush: zlib.BROTLI_OPERATION_FLUSH,
        finishFlush: zlib.BROTLI_OPERATION_FLUSH
      };
      decompressors['x-deflate'] = bind_opts(zlib.Inflate, zlib_options);
      decompressors['deflate'] = bind_opts(zlib.Inflate, zlib_options);
      decompressors['x-gzip'] = bind_opts(zlib.Gunzip, zlib_options);
      decompressors['gzip'] = bind_opts(zlib.Gunzip, zlib_options);
      if (typeof zlib.BrotliDecompress === 'function') {
        decompressors['br'] = bind_opts(zlib.BrotliDecompress, br_options);
      }
    } catch (e) {/* zlib not available */}

    //////////////////////////////////////////
    // options and aliases

    var defaults = {
      // data
      boundary: '--------------------NODENEEDLEHTTPCLIENT',
      encoding: 'utf8',
      parse_response: 'all',
      // same as true. valid options: 'json', 'xml' or false/null
      proxy: null,
      // agent & headers
      agent: null,
      headers: {},
      accept: '*/*',
      user_agent: user_agent,
      // numbers
      open_timeout: 10000,
      response_timeout: 0,
      read_timeout: 0,
      follow_max: 0,
      stream_length: -1,
      // abort signal
      signal: null,
      // booleans
      compressed: false,
      decode_response: true,
      parse_cookies: true,
      follow_set_cookies: false,
      follow_set_referer: false,
      follow_keep_method: false,
      follow_if_same_host: false,
      follow_if_same_protocol: false,
      follow_if_same_location: false,
      use_proxy_from_env_var: true
    };
    var aliased = {
      options: {
        decode: 'decode_response',
        parse: 'parse_response',
        timeout: 'open_timeout',
        follow: 'follow_max'
      },
      inverted: {}
    };

    // only once, invert aliased keys so we can get passed options.
    Object.keys(aliased.options).map(function (k) {
      var value = aliased.options[k];
      aliased.inverted[value] = k;
    });

    //////////////////////////////////////////
    // helpers

    function keys_by_type(type) {
      return Object.keys(defaults).map(function (el) {
        if (defaults[el] !== null && defaults[el].constructor == type) return el;
      }).filter(function (el) {
        return el;
      });
    }

    //////////////////////////////////////////
    // the main act

    function Needle(method, uri, data, options, callback) {
      // if (!(this instanceof Needle)) {
      //   return new Needle(method, uri, data, options, callback);
      // }

      if (typeof uri !== 'string') throw new TypeError('URL must be a string, not ' + uri);
      this.method = method.toLowerCase();
      this.uri = uri;
      this.data = data;
      if (typeof options == 'function') {
        this.callback = options;
        this.options = {};
      } else {
        this.callback = callback;
        this.options = options;
      }
    }
    Needle.prototype.setup = function (uri, options) {
      function get_option(key, fallback) {
        // if original is in options, return that value
        if (typeof options[key] != 'undefined') return options[key];

        // otherwise, return value from alias or fallback/undefined
        return typeof options[aliased.inverted[key]] != 'undefined' ? options[aliased.inverted[key]] : fallback;
      }
      function check_value(expected, key) {
        var value = get_option(key),
          type = typeof value;
        if (type != 'undefined' && type != expected) throw new TypeError(type + ' received for ' + key + ', but expected a ' + expected);
        return type == expected ? value : defaults[key];
      }

      //////////////////////////////////////////////////
      // the basics

      var config = {
        http_opts: {
          agent: get_option('agent', defaults.agent),
          localAddress: get_option('localAddress', undefined),
          lookup: get_option('lookup', undefined),
          signal: get_option('signal', defaults.signal)
        },
        // passed later to http.request() directly
        headers: {},
        output: options.output,
        proxy: get_option('proxy', defaults.proxy),
        parser: get_option('parse_response', defaults.parse_response),
        encoding: options.encoding || (options.multipart ? 'binary' : defaults.encoding)
      };
      keys_by_type(Boolean).forEach(function (key) {
        config[key] = check_value('boolean', key);
      });
      keys_by_type(Number).forEach(function (key) {
        config[key] = check_value('number', key);
      });
      if (config.http_opts.signal && !(config.http_opts.signal instanceof AbortSignal)) throw new TypeError(typeof config.http_opts.signal + ' received for signal, but expected an AbortSignal');

      // populate http_opts with given TLS options
      tls_options.split(' ').forEach(function (key) {
        if (typeof options[key] != 'undefined') {
          if (config.http_opts.agent) {
            // pass option to existing agent
            config.http_opts.agent.options[key] = options[key];
          } else {
            config.http_opts[key] = options[key];
          }
        }
      });

      //////////////////////////////////////////////////
      // headers, cookies

      for (var key in defaults.headers) config.headers[key] = defaults.headers[key];
      config.headers['accept'] = options.accept || defaults.accept;
      config.headers['user-agent'] = options.user_agent || defaults.user_agent;
      if (options.content_type) config.headers['content-type'] = options.content_type;

      // set connection header if opts.connection was passed, or if node < 0.11.4 (close)
      if (options.connection || close_by_default) config.headers['connection'] = options.connection || 'close';
      if ((options.compressed || defaults.compressed) && typeof zlib != 'undefined') config.headers['accept-encoding'] = decompressors['br'] ? 'gzip, deflate, br' : 'gzip, deflate';
      if (options.cookies) config.headers['cookie'] = cookies.write(options.cookies);

      //////////////////////////////////////////////////
      // basic/digest auth

      if (uri.match(/[^\/]@/)) {
        // url contains user:pass@host, so parse it.
        var parts = (url.parse(uri).auth || '').split(':');
        options.username = parts[0];
        options.password = parts[1];
      }
      if (options.username) {
        if (options.auth && (options.auth == 'auto' || options.auth == 'digest')) {
          config.credentials = [options.username, options.password];
        } else {
          config.headers['authorization'] = auth.basic(options.username, options.password);
        }
      }
      if (config.use_proxy_from_env_var) {
        var env_proxy = utils.get_env_var(['HTTP_PROXY', 'HTTPS_PROXY'], true);
        if (!config.proxy && env_proxy) config.proxy = env_proxy;
      }

      // if proxy is present, set auth header from either url or proxy_user option.
      if (config.proxy) {
        if (!config.use_proxy_from_env_var || utils.should_proxy_to(uri)) {
          if (config.proxy.indexOf('http') === -1) config.proxy = 'http://' + config.proxy;
          if (config.proxy.indexOf('@') !== -1) {
            var proxy = (url.parse(config.proxy).auth || '').split(':');
            options.proxy_user = proxy[0];
            options.proxy_pass = proxy[1];
          }
          if (options.proxy_user) config.headers['proxy-authorization'] = auth.basic(options.proxy_user, options.proxy_pass);
        } else {
          delete config.proxy;
        }
      }

      // now that all our headers are set, overwrite them if instructed.
      for (var h in options.headers) config.headers[h.toLowerCase()] = options.headers[h];
      config.uri_modifier = get_option('uri_modifier', null);
      return config;
    };
    Needle.prototype.start = function () {
      var out = new stream.PassThrough({
          objectMode: false
        }),
        uri = this.uri,
        data = this.data,
        method = this.method,
        callback = typeof this.options == 'function' ? this.options : this.callback,
        options = this.options || {};

      // if no 'http' is found on URL, prepend it.
      if (uri.indexOf('http') === -1) uri = uri.replace(/^(\/\/)?/, 'http://');
      var self = this,
        body,
        waiting = false,
        config = this.setup(uri, options);

      // unless options.json was set to false, assume boss also wants JSON if content-type matches.
      var json = options.json || options.json !== false && config.headers['content-type'] == 'application/json';
      if (data) {
        if (options.multipart) {
          // boss says we do multipart. so we do it.
          var boundary = options.boundary || defaults.boundary;
          waiting = true;
          multipart.build(data, boundary, function (err, parts) {
            if (err) throw err;
            config.headers['content-type'] = 'multipart/form-data; boundary=' + boundary;
            next(parts);
          });
        } else if (utils.is_stream(data)) {
          if (method == 'get') throw new Error('Refusing to pipe() a stream via GET. Did you mean .post?');
          if (config.stream_length > 0 || config.stream_length === 0 && data.path) {
            // ok, let's get the stream's length and set it as the content-length header.
            // this prevents some servers from cutting us off before all the data is sent.
            waiting = true;
            utils.get_stream_length(data, config.stream_length, function (length) {
              data.length = length;
              next(data);
            });
          } else {
            // if the boss doesn't want us to get the stream's length, or if it doesn't
            // have a file descriptor for that purpose, then just head on.
            body = data;
          }
        } else if (Buffer.isBuffer(data)) {
          body = data; // use the raw buffer as request body.
        } else if (method == 'get' && !json) {
          // append the data to the URI as a querystring.
          uri = uri.replace(/\?.*|$/, '?' + stringify(data));
        } else {
          // string or object data, no multipart.

          // if string, leave it as it is, otherwise, stringify.
          body = typeof data === 'string' ? data : json ? JSON.stringify(data) : stringify(data);

          // ensure we have a buffer so bytecount is correct.
          body = Buffer.from(body, config.encoding);
        }
      }
      function next(body) {
        if (body) {
          if (body.length) config.headers['content-length'] = body.length;

          // if no content-type was passed, determine if json or not.
          if (!config.headers['content-type']) {
            config.headers['content-type'] = json ? 'application/json; charset=utf-8' : 'application/x-www-form-urlencoded'; // no charset says W3 spec.
          }
        }

        // unless a specific accept header was set, assume json: true wants JSON back.
        if (options.json && !options.accept && !(options.headers || {}).accept) config.headers['accept'] = 'application/json';
        self.send_request(1, method, uri, config, body, out, callback);
      }
      if (!waiting) next(body);
      return out;
    };
    Needle.prototype.get_request_opts = function (method, uri, config) {
      var opts = config.http_opts,
        proxy = config.proxy,
        remote = proxy ? url.parse(proxy) : url.parse(uri);
      opts.protocol = remote.protocol;
      opts.host = remote.hostname;
      opts.port = remote.port || (remote.protocol == 'https:' ? 443 : 80);
      opts.path = proxy ? uri : remote.pathname + (remote.search || '');
      opts.method = method;
      opts.headers = config.headers;
      if (!opts.headers['host']) {
        // if using proxy, make sure the host header shows the final destination
        var target = proxy ? url.parse(uri) : remote;
        opts.headers['host'] = target.hostname;

        // and if a non standard port was passed, append it to the port header
        if (target.port && [80, 443].indexOf(target.port) === -1) {
          opts.headers['host'] += ':' + target.port;
        }
      }
      return opts;
    };
    Needle.prototype.should_follow = function (location, config, original) {
      if (!location) return false;

      // returns true if location contains matching property (host or protocol)
      function matches(property) {
        var property = original[property];
        return location.indexOf(property) !== -1;
      }

      // first, check whether the requested location is actually different from the original
      if (!config.follow_if_same_location && location === original) return false;
      if (config.follow_if_same_host && !matches('host')) return false; // host does not match, so not following

      if (config.follow_if_same_protocol && !matches('protocol')) return false; // procotol does not match, so not following

      return true;
    };
    Needle.prototype.send_request = function (count, method, uri, config, post_data, out, callback) {
      if (typeof config.uri_modifier === 'function') {
        var modified_uri = config.uri_modifier(uri);
        debug('Modifying request URI', uri + ' => ' + modified_uri);
        uri = modified_uri;
      }
      var request,
        timer,
        returned = 0,
        self = this,
        request_opts = this.get_request_opts(method, uri, config),
        protocol = request_opts.protocol == 'https:' ? https : http,
        signal = request_opts.signal;
      function done(err, resp) {
        if (returned++ > 0) return debug('Already finished, stopping here.');
        if (timer) clearTimeout(timer);
        request.removeListener('error', had_error);
        out.done = true;

        // An error can still be fired after closing.  In particular, on macOS.
        // See also:
        //  - https://github.com/tomas/needle/issues/391
        //  - https://github.com/less/less.js/issues/3693
        //  - https://github.com/nodejs/node/issues/27916
        request.once('error', function () {});
        if (callback) return callback(err, resp, resp ? resp.body : undefined);

        // NOTE: this event used to be called 'end', but the behaviour was confusing
        // when errors ocurred, because the stream would still emit an 'end' event.
        out.emit('done', err);

        // trigger the 'done' event on streams we're being piped to, if any
        var pipes = out._readableState.pipes || [];
        if (!pipes.forEach) pipes = [pipes];
        pipes.forEach(function (st) {
          st.emit('done', err);
        });
      }
      function had_error(err) {
        debug('Request error', err);
        out.emit('err', err);
        done(err || new Error('Unknown error when making request.'));
      }
      function abort_handler() {
        out.emit('err', new Error('Aborted by signal.'));
        request.destroy();
      }
      function set_timeout(type, milisecs) {
        if (timer) clearTimeout(timer);
        if (milisecs <= 0) return;
        timer = setTimeout(function () {
          out.emit('timeout', type);
          request.destroy();
          // also invoke done() to terminate job on read_timeout
          if (type == 'read') done(new Error(type + ' timeout'));
          signal && signal.removeEventListener('abort', abort_handler);
        }, milisecs);
      }
      debug('Making request #' + count, request_opts);
      request = protocol.request(request_opts, function (resp) {
        var headers = resp.headers;
        debug('Got response', resp.statusCode, headers);
        out.emit('response', resp);
        set_timeout('read', config.read_timeout);

        // if we got cookies, parse them unless we were instructed not to. make sure to include any
        // cookies that might have been set on previous redirects.
        if (config.parse_cookies && (headers['set-cookie'] || config.previous_resp_cookies)) {
          resp.cookies = extend(config.previous_resp_cookies || {}, cookies.read(headers['set-cookie']));
          debug('Got cookies', resp.cookies);
        }

        // if redirect code is found, determine if we should follow it according to the given options.
        if (redirect_codes.indexOf(resp.statusCode) !== -1 && self.should_follow(headers.location, config, uri)) {
          // clear timer before following redirects to prevent unexpected setTimeout consequence
          clearTimeout(timer);
          if (count <= config.follow_max) {
            out.emit('redirect', headers.location);

            // unless 'follow_keep_method' is true, rewrite the request to GET before continuing.
            if (!config.follow_keep_method) {
              method = 'GET';
              post_data = null;
              delete config.headers['content-length']; // in case the original was a multipart POST request.
            }

            // if follow_set_cookies is true, insert cookies in the next request's headers.
            // we set both the original request cookies plus any response cookies we might have received.
            if (config.follow_set_cookies && utils.host_and_ports_match(headers.location, uri)) {
              var request_cookies = cookies.read(config.headers['cookie']);
              config.previous_resp_cookies = resp.cookies;
              if (Object.keys(request_cookies).length || Object.keys(resp.cookies || {}).length) {
                config.headers['cookie'] = cookies.write(extend(request_cookies, resp.cookies));
              }
            } else if (config.headers['cookie']) {
              debug('Clearing original request cookie', config.headers['cookie']);
              delete config.headers['cookie'];
            }
            if (config.follow_set_referer) config.headers['referer'] = encodeURI(uri); // the original, not the destination URL.

            config.headers['host'] = null; // clear previous Host header to avoid conflicts.

            var redirect_url = utils.resolve_url(headers.location, uri);
            debug('Redirecting to ' + redirect_url.toString());
            return self.send_request(++count, method, redirect_url.toString(), config, post_data, out, callback);
          } else if (config.follow_max > 0) {
            return done(new Error('Max redirects reached. Possible loop in: ' + headers.location));
          }
        }

        // if auth is requested and credentials were not passed, resend request, provided we have user/pass.
        if (resp.statusCode == 401 && headers['www-authenticate'] && config.credentials) {
          if (!config.headers['authorization']) {
            // only if authentication hasn't been sent
            var auth_header = auth.header(headers['www-authenticate'], config.credentials, request_opts);
            if (auth_header) {
              config.headers['authorization'] = auth_header;
              return self.send_request(count, method, uri, config, post_data, out, callback);
            }
          }
        }

        // ok, so we got a valid (non-redirect & authorized) response. let's notify the stream guys.
        out.emit('header', resp.statusCode, headers);
        out.emit('headers', headers);
        var pipeline = [],
          mime = utils.parse_content_type(headers['content-type']),
          text_response = mime.type && (mime.type.indexOf('text/') != -1 || !!mime.type.match(/(\/|\+)(xml|json)$/));

        // To start, if our body is compressed and we're able to inflate it, do it.
        if (headers['content-encoding'] && decompressors[headers['content-encoding']]) {
          var decompressor = decompressors[headers['content-encoding']]();

          // make sure we catch errors triggered by the decompressor.
          decompressor.on('error', had_error);
          pipeline.push(decompressor);
        }

        // If parse is enabled and we have a parser for it, then go for it.
        if (config.parser && parsers[mime.type]) {
          // If a specific parser was requested, make sure we don't parse other types.
          var parser_name = config.parser.toString().toLowerCase();
          if (['xml', 'json'].indexOf(parser_name) == -1 || parsers[mime.type].name == parser_name) {
            // OK, so either we're parsing all content types or the one requested matches.
            out.parser = parsers[mime.type].name;
            pipeline.push(parsers[mime.type].fn());

            // Set objectMode on out stream to improve performance.
            out._writableState.objectMode = true;
            out._readableState.objectMode = true;
          }

          // If we're not parsing, and unless decoding was disabled, we'll try
          // decoding non UTF-8 bodies to UTF-8, using the iconv-lite library.
        } else if (text_response && config.decode_response && mime.charset) {
          pipeline.push(decoder(mime.charset));
        }

        // And `out` is the stream we finally push the decoded/parsed output to.
        pipeline.push(out);

        // Now, release the kraken!
        utils.pump_streams([resp].concat(pipeline), function (err) {
          if (err) debug(err);

          // on node v8.x, if an error ocurrs on the receiving end,
          // then we want to abort the request to avoid having dangling sockets
          if (err && err.message == 'write after end') request.destroy();
        });

        // If the user has requested and output file, pipe the output stream to it.
        // In stream mode, we will still get the response stream to play with.
        if (config.output && resp.statusCode == 200) {
          // for some reason, simply piping resp to the writable stream doesn't
          // work all the time (stream gets cut in the middle with no warning).
          // so we'll manually need to do the readable/write(chunk) trick.
          var file = fs.createWriteStream(config.output);
          file.on('error', had_error);
          out.on('end', function () {
            if (file.writable) file.end();
          });
          file.on('close', function () {
            delete out.file;
          });
          out.on('readable', function () {
            var chunk;
            while ((chunk = this.read()) !== null) {
              if (file.writable) file.write(chunk);

              // if callback was requested, also push it to resp.body
              if (resp.body) resp.body.push(chunk);
            }
          });
          out.file = file;
        }

        // Only aggregate the full body if a callback was requested.
        if (callback) {
          resp.raw = [];
          resp.body = [];
          resp.bytes = 0;

          // Gather and count the amount of (raw) bytes using a PassThrough stream.
          var clean_pipe = new stream.PassThrough();
          clean_pipe.on('readable', function () {
            var chunk;
            while ((chunk = this.read()) != null) {
              resp.bytes += chunk.length;
              resp.raw.push(chunk);
            }
          });
          utils.pump_streams([resp, clean_pipe], function (err) {
            if (err) debug(err);
          });

          // Listen on the 'readable' event to aggregate the chunks, but only if
          // file output wasn't requested. Otherwise we'd have two stream readers.
          if (!config.output || resp.statusCode != 200) {
            out.on('readable', function () {
              var chunk;
              while ((chunk = this.read()) !== null) {
                // We're either pushing buffers or objects, never strings.
                if (typeof chunk == 'string') chunk = Buffer.from(chunk);

                // Push all chunks to resp.body. We'll bind them in resp.end().
                resp.body.push(chunk);
              }
            });
          }
        }

        // And set the .body property once all data is in.
        out.on('end', function () {
          if (resp.body) {
            // callback mode

            // we want to be able to access to the raw data later, so keep a reference.
            resp.raw = Buffer.concat(resp.raw);

            // if parse was successful, we should have an array with one object
            if (resp.body[0] !== undefined && !Buffer.isBuffer(resp.body[0])) {
              // that's our body right there.
              resp.body = resp.body[0];

              // set the parser property on our response. we may want to check.
              if (out.parser) resp.parser = out.parser;
            } else {
              // we got one or several buffers. string or binary.
              resp.body = Buffer.concat(resp.body);

              // if we're here and parsed is true, it means we tried to but it didn't work.
              // so given that we got a text response, let's stringify it.
              if (text_response || out.parser) {
                resp.body = resp.body.toString();
              }
            }
          }

          // if an output file is being written to, make sure the callback
          // is triggered after all data has been written to it.
          if (out.file) {
            out.file.on('close', function () {
              done(null, resp);
            });
          } else {
            // elvis has left the building.
            done(null, resp);
          }
        });

        // out.on('error', function(err) {
        //   had_error(err);
        //   if (err.code == 'ERR_STREAM_DESTROYED' || err.code == 'ERR_STREAM_PREMATURE_CLOSE') {
        //     request.abort();
        //   }
        // })
      }); // end request call

      // unless open_timeout was disabled, set a timeout to abort the request.
      set_timeout('open', config.open_timeout);

      // handle errors on the request object. things might get bumpy.
      request.on('error', had_error);

      // make sure timer is cleared if request is aborted (issue #257)
      request.once('abort', function () {
        if (timer) clearTimeout(timer);
      });

      // set response timeout once we get a valid socket
      request.once('socket', function (socket) {
        if (socket.connecting) {
          socket.once('connect', function () {
            set_timeout('response', config.response_timeout);
          });
        } else {
          set_timeout('response', config.response_timeout);
        }
      });
      if (post_data) {
        if (utils.is_stream(post_data)) {
          utils.pump_streams([post_data, request], function (err) {
            if (err) debug(err);
          });
        } else {
          request.write(post_data, config.encoding);
          request.end();
        }
      } else {
        request.end();
      }
      if (signal) {
        // abort signal given, so handle it
        if (signal.aborted === true) {
          abort_handler();
        } else {
          signal.addEventListener('abort', abort_handler, {
            once: true
          });
        }
      }
      out.abort = function () {
        request.destroy();
      }; // easier access
      out.request = request;
      return out;
    };

    //////////////////////////////////////////
    // exports

    if (typeof Promise !== 'undefined') {
      module.exports = function () {
        var verb,
          args = [].slice.call(arguments);
        if (args[0].match(/\.|\//))
          // first argument looks like a URL
          verb = args.length > 2 ? 'post' : 'get';else verb = args.shift();
        if (verb.match(/get|head/i) && args.length == 2) args.splice(1, 0, null); // assume no data if head/get with two args (url, options)

        return new Promise(function (resolve, reject) {
          module.exports.request(verb, args[0], args[1], args[2], function (err, resp) {
            return err ? reject(err) : resolve(resp);
          });
        });
      };
    }
    module.exports.version = version;
    module.exports.defaults = function (obj) {
      for (var key in obj) {
        var target_key = aliased.options[key] || key;
        if (defaults.hasOwnProperty(target_key) && typeof obj[key] != 'undefined') {
          if (target_key != 'parse_response' && target_key != 'proxy' && target_key != 'agent' && target_key != 'signal') {
            // ensure type matches the original, except for proxy/parse_response that can be null/bool or string, and signal that can be null/AbortSignal
            var valid_type = defaults[target_key].constructor.name;
            if (obj[key].constructor.name != valid_type) throw new TypeError('Invalid type for ' + key + ', should be ' + valid_type);
          } else if (target_key === 'signal' && obj[key] !== null && !(obj[key] instanceof AbortSignal)) {
            throw new TypeError('Invalid type for ' + key + ', should be AbortSignal');
          }
          defaults[target_key] = obj[key];
        } else {
          throw new Error('Invalid property for defaults:' + target_key);
        }
      }
      return defaults;
    };
    'head get'.split(' ').forEach(function (method) {
      module.exports[method] = function (uri, options, callback) {
        return new Needle(method, uri, null, options, callback).start();
      };
    });
    'post put patch delete'.split(' ').forEach(function (method) {
      module.exports[method] = function (uri, data, options, callback) {
        return new Needle(method, uri, data, options, callback).start();
      };
    });
    module.exports.request = function (method, uri, data, opts, callback) {
      return new Needle(method, uri, data, opts, callback).start();
    };
  })(needle);
  return needle.exports;
}

var hasRequiredUrlFileManager;
function requireUrlFileManager() {
  if (hasRequiredUrlFileManager) return urlFileManager;
  hasRequiredUrlFileManager = 1;
  Object.defineProperty(urlFileManager, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  /* eslint-disable no-unused-vars */
  /**
   * @todo - remove top eslint rule when FileManagers have JSDoc type
   * and are TS-type-checked
   */
  var isUrlRe = /^(?:https?:)?\/\//i;
  var url_1 = tslib_1.__importDefault(require$$1$2);
  var request;
  var abstract_file_manager_js_1 = tslib_1.__importDefault(requireAbstractFileManager());
  var logger_1 = tslib_1.__importDefault(requireLogger());
  var UrlFileManager = function () {};
  UrlFileManager.prototype = Object.assign(new abstract_file_manager_js_1.default(), {
    supports: function (filename, currentDirectory, options, environment) {
      return isUrlRe.test(filename) || isUrlRe.test(currentDirectory);
    },
    loadFile: function (filename, currentDirectory, options, environment) {
      return new Promise(function (fulfill, reject) {
        if (request === undefined) {
          try {
            request = requireNeedle();
          } catch (e) {
            request = null;
          }
        }
        if (!request) {
          reject({
            type: 'File',
            message: 'optional dependency \'needle\' required to import over http(s)\n'
          });
          return;
        }
        var urlStr = isUrlRe.test(filename) ? filename : url_1.default.resolve(currentDirectory, filename);
        /** native-request currently has a bug */
        var hackUrlStr = urlStr.indexOf('?') === -1 ? urlStr + '?' : urlStr;
        request.get(hackUrlStr, {
          follow_max: 5
        }, function (err, resp, body) {
          if (err || resp && resp.statusCode >= 400) {
            var message = resp && resp.statusCode === 404 ? "resource '".concat(urlStr, "' was not found\n") : "resource '".concat(urlStr, "' gave this Error:\n  ").concat(err || resp.statusMessage || resp.statusCode, "\n");
            reject({
              type: 'File',
              message: message
            });
            return;
          }
          if (resp.statusCode >= 300) {
            reject({
              type: 'File',
              message: "resource '".concat(urlStr, "' caused too many redirects")
            });
            return;
          }
          body = body.toString('utf8');
          if (!body) {
            logger_1.default.warn("Warning: Empty body (HTTP ".concat(resp.statusCode, ") returned by \"").concat(urlStr, "\""));
          }
          fulfill({
            contents: body || '',
            filename: urlStr
          });
        });
      });
    }
  });
  urlFileManager.default = UrlFileManager;
  return urlFileManager;
}

var less$1 = {};

var environment = {};

var hasRequiredEnvironment;
function requireEnvironment() {
  if (hasRequiredEnvironment) return environment;
  hasRequiredEnvironment = 1;
  /**
   * @todo Document why this abstraction exists, and the relationship between
   *       environment, file managers, and plugin manager
   */
  Object.defineProperty(environment, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var logger_1 = tslib_1.__importDefault(requireLogger());
  var Environment = /** @class */function () {
    function Environment(externalEnvironment, fileManagers) {
      this.fileManagers = fileManagers || [];
      externalEnvironment = externalEnvironment || {};
      var optionalFunctions = ['encodeBase64', 'mimeLookup', 'charsetLookup', 'getSourceMapGenerator'];
      var requiredFunctions = [];
      var functions = requiredFunctions.concat(optionalFunctions);
      for (var i = 0; i < functions.length; i++) {
        var propName = functions[i];
        var environmentFunc = externalEnvironment[propName];
        if (environmentFunc) {
          this[propName] = environmentFunc.bind(externalEnvironment);
        } else if (i < requiredFunctions.length) {
          this.warn("missing required function in environment - ".concat(propName));
        }
      }
    }
    Environment.prototype.getFileManager = function (filename, currentDirectory, options, environment, isSync) {
      if (!filename) {
        logger_1.default.warn('getFileManager called with no filename.. Please report this issue. continuing.');
      }
      if (currentDirectory === undefined) {
        logger_1.default.warn('getFileManager called with null directory.. Please report this issue. continuing.');
      }
      var fileManagers = this.fileManagers;
      if (options.pluginManager) {
        fileManagers = [].concat(fileManagers).concat(options.pluginManager.getFileManagers());
      }
      for (var i = fileManagers.length - 1; i >= 0; i--) {
        var fileManager = fileManagers[i];
        if (fileManager[isSync ? 'supportsSync' : 'supports'](filename, currentDirectory, options, environment)) {
          return fileManager;
        }
      }
      return null;
    };
    Environment.prototype.addFileManager = function (fileManager) {
      this.fileManagers.push(fileManager);
    };
    Environment.prototype.clearFileManagers = function () {
      this.fileManagers = [];
    };
    return Environment;
  }();
  environment.default = Environment;
  return environment;
}

var data = {};

var colors = {};

var hasRequiredColors;
function requireColors() {
  if (hasRequiredColors) return colors;
  hasRequiredColors = 1;
  Object.defineProperty(colors, "__esModule", {
    value: true
  });
  colors.default = {
    'aliceblue': '#f0f8ff',
    'antiquewhite': '#faebd7',
    'aqua': '#00ffff',
    'aquamarine': '#7fffd4',
    'azure': '#f0ffff',
    'beige': '#f5f5dc',
    'bisque': '#ffe4c4',
    'black': '#000000',
    'blanchedalmond': '#ffebcd',
    'blue': '#0000ff',
    'blueviolet': '#8a2be2',
    'brown': '#a52a2a',
    'burlywood': '#deb887',
    'cadetblue': '#5f9ea0',
    'chartreuse': '#7fff00',
    'chocolate': '#d2691e',
    'coral': '#ff7f50',
    'cornflowerblue': '#6495ed',
    'cornsilk': '#fff8dc',
    'crimson': '#dc143c',
    'cyan': '#00ffff',
    'darkblue': '#00008b',
    'darkcyan': '#008b8b',
    'darkgoldenrod': '#b8860b',
    'darkgray': '#a9a9a9',
    'darkgrey': '#a9a9a9',
    'darkgreen': '#006400',
    'darkkhaki': '#bdb76b',
    'darkmagenta': '#8b008b',
    'darkolivegreen': '#556b2f',
    'darkorange': '#ff8c00',
    'darkorchid': '#9932cc',
    'darkred': '#8b0000',
    'darksalmon': '#e9967a',
    'darkseagreen': '#8fbc8f',
    'darkslateblue': '#483d8b',
    'darkslategray': '#2f4f4f',
    'darkslategrey': '#2f4f4f',
    'darkturquoise': '#00ced1',
    'darkviolet': '#9400d3',
    'deeppink': '#ff1493',
    'deepskyblue': '#00bfff',
    'dimgray': '#696969',
    'dimgrey': '#696969',
    'dodgerblue': '#1e90ff',
    'firebrick': '#b22222',
    'floralwhite': '#fffaf0',
    'forestgreen': '#228b22',
    'fuchsia': '#ff00ff',
    'gainsboro': '#dcdcdc',
    'ghostwhite': '#f8f8ff',
    'gold': '#ffd700',
    'goldenrod': '#daa520',
    'gray': '#808080',
    'grey': '#808080',
    'green': '#008000',
    'greenyellow': '#adff2f',
    'honeydew': '#f0fff0',
    'hotpink': '#ff69b4',
    'indianred': '#cd5c5c',
    'indigo': '#4b0082',
    'ivory': '#fffff0',
    'khaki': '#f0e68c',
    'lavender': '#e6e6fa',
    'lavenderblush': '#fff0f5',
    'lawngreen': '#7cfc00',
    'lemonchiffon': '#fffacd',
    'lightblue': '#add8e6',
    'lightcoral': '#f08080',
    'lightcyan': '#e0ffff',
    'lightgoldenrodyellow': '#fafad2',
    'lightgray': '#d3d3d3',
    'lightgrey': '#d3d3d3',
    'lightgreen': '#90ee90',
    'lightpink': '#ffb6c1',
    'lightsalmon': '#ffa07a',
    'lightseagreen': '#20b2aa',
    'lightskyblue': '#87cefa',
    'lightslategray': '#778899',
    'lightslategrey': '#778899',
    'lightsteelblue': '#b0c4de',
    'lightyellow': '#ffffe0',
    'lime': '#00ff00',
    'limegreen': '#32cd32',
    'linen': '#faf0e6',
    'magenta': '#ff00ff',
    'maroon': '#800000',
    'mediumaquamarine': '#66cdaa',
    'mediumblue': '#0000cd',
    'mediumorchid': '#ba55d3',
    'mediumpurple': '#9370d8',
    'mediumseagreen': '#3cb371',
    'mediumslateblue': '#7b68ee',
    'mediumspringgreen': '#00fa9a',
    'mediumturquoise': '#48d1cc',
    'mediumvioletred': '#c71585',
    'midnightblue': '#191970',
    'mintcream': '#f5fffa',
    'mistyrose': '#ffe4e1',
    'moccasin': '#ffe4b5',
    'navajowhite': '#ffdead',
    'navy': '#000080',
    'oldlace': '#fdf5e6',
    'olive': '#808000',
    'olivedrab': '#6b8e23',
    'orange': '#ffa500',
    'orangered': '#ff4500',
    'orchid': '#da70d6',
    'palegoldenrod': '#eee8aa',
    'palegreen': '#98fb98',
    'paleturquoise': '#afeeee',
    'palevioletred': '#d87093',
    'papayawhip': '#ffefd5',
    'peachpuff': '#ffdab9',
    'peru': '#cd853f',
    'pink': '#ffc0cb',
    'plum': '#dda0dd',
    'powderblue': '#b0e0e6',
    'purple': '#800080',
    'rebeccapurple': '#663399',
    'red': '#ff0000',
    'rosybrown': '#bc8f8f',
    'royalblue': '#4169e1',
    'saddlebrown': '#8b4513',
    'salmon': '#fa8072',
    'sandybrown': '#f4a460',
    'seagreen': '#2e8b57',
    'seashell': '#fff5ee',
    'sienna': '#a0522d',
    'silver': '#c0c0c0',
    'skyblue': '#87ceeb',
    'slateblue': '#6a5acd',
    'slategray': '#708090',
    'slategrey': '#708090',
    'snow': '#fffafa',
    'springgreen': '#00ff7f',
    'steelblue': '#4682b4',
    'tan': '#d2b48c',
    'teal': '#008080',
    'thistle': '#d8bfd8',
    'tomato': '#ff6347',
    'turquoise': '#40e0d0',
    'violet': '#ee82ee',
    'wheat': '#f5deb3',
    'white': '#ffffff',
    'whitesmoke': '#f5f5f5',
    'yellow': '#ffff00',
    'yellowgreen': '#9acd32'
  };
  return colors;
}

var unitConversions = {};

var hasRequiredUnitConversions;
function requireUnitConversions() {
  if (hasRequiredUnitConversions) return unitConversions;
  hasRequiredUnitConversions = 1;
  Object.defineProperty(unitConversions, "__esModule", {
    value: true
  });
  unitConversions.default = {
    length: {
      'm': 1,
      'cm': 0.01,
      'mm': 0.001,
      'in': 0.0254,
      'px': 0.0254 / 96,
      'pt': 0.0254 / 72,
      'pc': 0.0254 / 72 * 12
    },
    duration: {
      's': 1,
      'ms': 0.001
    },
    angle: {
      'rad': 1 / (2 * Math.PI),
      'deg': 1 / 360,
      'grad': 1 / 400,
      'turn': 1
    }
  };
  return unitConversions;
}

var hasRequiredData;
function requireData() {
  if (hasRequiredData) return data;
  hasRequiredData = 1;
  Object.defineProperty(data, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var colors_1 = tslib_1.__importDefault(requireColors());
  var unit_conversions_1 = tslib_1.__importDefault(requireUnitConversions());
  data.default = {
    colors: colors_1.default,
    unitConversions: unit_conversions_1.default
  };
  return data;
}

var tree = {};

var node = {};

var hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node;
  hasRequiredNode = 1;
  Object.defineProperty(node, "__esModule", {
    value: true
  });
  /**
   * The reason why Node is a class and other nodes simply do not extend
   * from Node (since we're transpiling) is due to this issue:
   *
   * @see https://github.com/less/less.js/issues/3434
   */
  var Node = /** @class */function () {
    function Node() {
      this.parent = null;
      this.visibilityBlocks = undefined;
      this.nodeVisible = undefined;
      this.rootNode = null;
      this.parsed = null;
    }
    Object.defineProperty(Node.prototype, "currentFileInfo", {
      get: function () {
        return this.fileInfo();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Node.prototype, "index", {
      get: function () {
        return this.getIndex();
      },
      enumerable: false,
      configurable: true
    });
    Node.prototype.setParent = function (nodes, parent) {
      function set(node) {
        if (node && node instanceof Node) {
          node.parent = parent;
        }
      }
      if (Array.isArray(nodes)) {
        nodes.forEach(set);
      } else {
        set(nodes);
      }
    };
    Node.prototype.getIndex = function () {
      return this._index || this.parent && this.parent.getIndex() || 0;
    };
    Node.prototype.fileInfo = function () {
      return this._fileInfo || this.parent && this.parent.fileInfo() || {};
    };
    Node.prototype.isRulesetLike = function () {
      return false;
    };
    Node.prototype.toCSS = function (context) {
      var strs = [];
      this.genCSS(context, {
        // remove when genCSS has JSDoc types
        // eslint-disable-next-line no-unused-vars
        add: function (chunk, fileInfo, index) {
          strs.push(chunk);
        },
        isEmpty: function () {
          return strs.length === 0;
        }
      });
      return strs.join('');
    };
    Node.prototype.genCSS = function (context, output) {
      output.add(this.value);
    };
    Node.prototype.accept = function (visitor) {
      this.value = visitor.visit(this.value);
    };
    Node.prototype.eval = function () {
      return this;
    };
    Node.prototype._operate = function (context, op, a, b) {
      switch (op) {
        case '+':
          return a + b;
        case '-':
          return a - b;
        case '*':
          return a * b;
        case '/':
          return a / b;
      }
    };
    Node.prototype.fround = function (context, value) {
      var precision = context && context.numPrecision;
      // add "epsilon" to ensure numbers like 1.000000005 (represented as 1.000000004999...) are properly rounded:
      return precision ? Number((value + 2e-16).toFixed(precision)) : value;
    };
    Node.compare = function (a, b) {
      /* returns:
       -1: a < b
       0: a = b
       1: a > b
       and *any* other value for a != b (e.g. undefined, NaN, -2 etc.) */
      if (a.compare &&
      // for "symmetric results" force toCSS-based comparison
      // of Quoted or Anonymous if either value is one of those
      !(b.type === 'Quoted' || b.type === 'Anonymous')) {
        return a.compare(b);
      } else if (b.compare) {
        return -b.compare(a);
      } else if (a.type !== b.type) {
        return undefined;
      }
      a = a.value;
      b = b.value;
      if (!Array.isArray(a)) {
        return a === b ? 0 : undefined;
      }
      if (a.length !== b.length) {
        return undefined;
      }
      for (var i = 0; i < a.length; i++) {
        if (Node.compare(a[i], b[i]) !== 0) {
          return undefined;
        }
      }
      return 0;
    };
    Node.numericCompare = function (a, b) {
      return a < b ? -1 : a === b ? 0 : a > b ? 1 : undefined;
    };
    // Returns true if this node represents root of ast imported by reference
    Node.prototype.blocksVisibility = function () {
      if (this.visibilityBlocks === undefined) {
        this.visibilityBlocks = 0;
      }
      return this.visibilityBlocks !== 0;
    };
    Node.prototype.addVisibilityBlock = function () {
      if (this.visibilityBlocks === undefined) {
        this.visibilityBlocks = 0;
      }
      this.visibilityBlocks = this.visibilityBlocks + 1;
    };
    Node.prototype.removeVisibilityBlock = function () {
      if (this.visibilityBlocks === undefined) {
        this.visibilityBlocks = 0;
      }
      this.visibilityBlocks = this.visibilityBlocks - 1;
    };
    // Turns on node visibility - if called node will be shown in output regardless
    // of whether it comes from import by reference or not
    Node.prototype.ensureVisibility = function () {
      this.nodeVisible = true;
    };
    // Turns off node visibility - if called node will NOT be shown in output regardless
    // of whether it comes from import by reference or not
    Node.prototype.ensureInvisibility = function () {
      this.nodeVisible = false;
    };
    // return values:
    // false - the node must not be visible
    // true - the node must be visible
    // undefined or null - the node has the same visibility as its parent
    Node.prototype.isVisible = function () {
      return this.nodeVisible;
    };
    Node.prototype.visibilityInfo = function () {
      return {
        visibilityBlocks: this.visibilityBlocks,
        nodeVisible: this.nodeVisible
      };
    };
    Node.prototype.copyVisibilityInfo = function (info) {
      if (!info) {
        return;
      }
      this.visibilityBlocks = info.visibilityBlocks;
      this.nodeVisible = info.nodeVisible;
    };
    return Node;
  }();
  node.default = Node;
  return node;
}

var color$1 = {};

var hasRequiredColor$1;
function requireColor$1() {
  if (hasRequiredColor$1) return color$1;
  hasRequiredColor$1 = 1;
  Object.defineProperty(color$1, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var node_1 = tslib_1.__importDefault(requireNode());
  var colors_1 = tslib_1.__importDefault(requireColors());
  //
  // RGB Colors - #ff0014, #eee
  //
  var Color = function (rgb, a, originalForm) {
    var self = this;
    //
    // The end goal here, is to parse the arguments
    // into an integer triplet, such as `128, 255, 0`
    //
    // This facilitates operations and conversions.
    //
    if (Array.isArray(rgb)) {
      this.rgb = rgb;
    } else if (rgb.length >= 6) {
      this.rgb = [];
      rgb.match(/.{2}/g).map(function (c, i) {
        if (i < 3) {
          self.rgb.push(parseInt(c, 16));
        } else {
          self.alpha = parseInt(c, 16) / 255;
        }
      });
    } else {
      this.rgb = [];
      rgb.split('').map(function (c, i) {
        if (i < 3) {
          self.rgb.push(parseInt(c + c, 16));
        } else {
          self.alpha = parseInt(c + c, 16) / 255;
        }
      });
    }
    this.alpha = this.alpha || (typeof a === 'number' ? a : 1);
    if (typeof originalForm !== 'undefined') {
      this.value = originalForm;
    }
  };
  Color.prototype = Object.assign(new node_1.default(), {
    type: 'Color',
    luma: function () {
      var r = this.rgb[0] / 255,
        g = this.rgb[1] / 255,
        b = this.rgb[2] / 255;
      r = r <= 0.03928 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
      g = g <= 0.03928 ? g / 12.92 : Math.pow((g + 0.055) / 1.055, 2.4);
      b = b <= 0.03928 ? b / 12.92 : Math.pow((b + 0.055) / 1.055, 2.4);
      return 0.2126 * r + 0.7152 * g + 0.0722 * b;
    },
    genCSS: function (context, output) {
      output.add(this.toCSS(context));
    },
    toCSS: function (context, doNotCompress) {
      var compress = context && context.compress && !doNotCompress;
      var color;
      var alpha;
      var colorFunction;
      var args = [];
      // `value` is set if this color was originally
      // converted from a named color string so we need
      // to respect this and try to output named color too.
      alpha = this.fround(context, this.alpha);
      if (this.value) {
        if (this.value.indexOf('rgb') === 0) {
          if (alpha < 1) {
            colorFunction = 'rgba';
          }
        } else if (this.value.indexOf('hsl') === 0) {
          if (alpha < 1) {
            colorFunction = 'hsla';
          } else {
            colorFunction = 'hsl';
          }
        } else {
          return this.value;
        }
      } else {
        if (alpha < 1) {
          colorFunction = 'rgba';
        }
      }
      switch (colorFunction) {
        case 'rgba':
          args = this.rgb.map(function (c) {
            return clamp(Math.round(c), 255);
          }).concat(clamp(alpha, 1));
          break;
        case 'hsla':
          args.push(clamp(alpha, 1));
        // eslint-disable-next-line no-fallthrough
        case 'hsl':
          color = this.toHSL();
          args = [this.fround(context, color.h), "".concat(this.fround(context, color.s * 100), "%"), "".concat(this.fround(context, color.l * 100), "%")].concat(args);
      }
      if (colorFunction) {
        // Values are capped between `0` and `255`, rounded and zero-padded.
        return "".concat(colorFunction, "(").concat(args.join(",".concat(compress ? '' : ' ')), ")");
      }
      color = this.toRGB();
      if (compress) {
        var splitcolor = color.split('');
        // Convert color to short format
        if (splitcolor[1] === splitcolor[2] && splitcolor[3] === splitcolor[4] && splitcolor[5] === splitcolor[6]) {
          color = "#".concat(splitcolor[1]).concat(splitcolor[3]).concat(splitcolor[5]);
        }
      }
      return color;
    },
    //
    // Operations have to be done per-channel, if not,
    // channels will spill onto each other. Once we have
    // our result, in the form of an integer triplet,
    // we create a new Color node to hold the result.
    //
    operate: function (context, op, other) {
      var rgb = new Array(3);
      var alpha = this.alpha * (1 - other.alpha) + other.alpha;
      for (var c = 0; c < 3; c++) {
        rgb[c] = this._operate(context, op, this.rgb[c], other.rgb[c]);
      }
      return new Color(rgb, alpha);
    },
    toRGB: function () {
      return toHex(this.rgb);
    },
    toHSL: function () {
      var r = this.rgb[0] / 255,
        g = this.rgb[1] / 255,
        b = this.rgb[2] / 255,
        a = this.alpha;
      var max = Math.max(r, g, b),
        min = Math.min(r, g, b);
      var h;
      var s;
      var l = (max + min) / 2;
      var d = max - min;
      if (max === min) {
        h = s = 0;
      } else {
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r:
            h = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h = (b - r) / d + 2;
            break;
          case b:
            h = (r - g) / d + 4;
            break;
        }
        h /= 6;
      }
      return {
        h: h * 360,
        s: s,
        l: l,
        a: a
      };
    },
    // Adapted from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript
    toHSV: function () {
      var r = this.rgb[0] / 255,
        g = this.rgb[1] / 255,
        b = this.rgb[2] / 255,
        a = this.alpha;
      var max = Math.max(r, g, b),
        min = Math.min(r, g, b);
      var h;
      var s;
      var v = max;
      var d = max - min;
      if (max === 0) {
        s = 0;
      } else {
        s = d / max;
      }
      if (max === min) {
        h = 0;
      } else {
        switch (max) {
          case r:
            h = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h = (b - r) / d + 2;
            break;
          case b:
            h = (r - g) / d + 4;
            break;
        }
        h /= 6;
      }
      return {
        h: h * 360,
        s: s,
        v: v,
        a: a
      };
    },
    toARGB: function () {
      return toHex([this.alpha * 255].concat(this.rgb));
    },
    compare: function (x) {
      return x.rgb && x.rgb[0] === this.rgb[0] && x.rgb[1] === this.rgb[1] && x.rgb[2] === this.rgb[2] && x.alpha === this.alpha ? 0 : undefined;
    }
  });
  Color.fromKeyword = function (keyword) {
    var c;
    var key = keyword.toLowerCase();
    // eslint-disable-next-line no-prototype-builtins
    if (colors_1.default.hasOwnProperty(key)) {
      c = new Color(colors_1.default[key].slice(1));
    } else if (key === 'transparent') {
      c = new Color([0, 0, 0], 0);
    }
    if (c) {
      c.value = keyword;
      return c;
    }
  };
  function clamp(v, max) {
    return Math.min(Math.max(v, 0), max);
  }
  function toHex(v) {
    return "#".concat(v.map(function (c) {
      c = clamp(Math.round(c), 255);
      return (c < 16 ? '0' : '') + c.toString(16);
    }).join(''));
  }
  color$1.default = Color;
  return color$1;
}

var atrule = {};

var selector = {};

var element = {};

var paren = {};

var hasRequiredParen;
function requireParen() {
  if (hasRequiredParen) return paren;
  hasRequiredParen = 1;
  Object.defineProperty(paren, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var node_1 = tslib_1.__importDefault(requireNode());
  var Paren = function (node) {
    this.value = node;
  };
  Paren.prototype = Object.assign(new node_1.default(), {
    type: 'Paren',
    genCSS: function (context, output) {
      output.add('(');
      this.value.genCSS(context, output);
      output.add(')');
    },
    eval: function (context) {
      return new Paren(this.value.eval(context));
    }
  });
  paren.default = Paren;
  return paren;
}

var combinator = {};

var hasRequiredCombinator;
function requireCombinator() {
  if (hasRequiredCombinator) return combinator;
  hasRequiredCombinator = 1;
  Object.defineProperty(combinator, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var node_1 = tslib_1.__importDefault(requireNode());
  var _noSpaceCombinators = {
    '': true,
    ' ': true,
    '|': true
  };
  var Combinator = function (value) {
    if (value === ' ') {
      this.value = ' ';
      this.emptyOrWhitespace = true;
    } else {
      this.value = value ? value.trim() : '';
      this.emptyOrWhitespace = this.value === '';
    }
  };
  Combinator.prototype = Object.assign(new node_1.default(), {
    type: 'Combinator',
    genCSS: function (context, output) {
      var spaceOrEmpty = context.compress || _noSpaceCombinators[this.value] ? '' : ' ';
      output.add(spaceOrEmpty + this.value + spaceOrEmpty);
    }
  });
  combinator.default = Combinator;
  return combinator;
}

var hasRequiredElement;
function requireElement() {
  if (hasRequiredElement) return element;
  hasRequiredElement = 1;
  Object.defineProperty(element, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var node_1 = tslib_1.__importDefault(requireNode());
  var paren_1 = tslib_1.__importDefault(requireParen());
  var combinator_1 = tslib_1.__importDefault(requireCombinator());
  var Element = function (combinator, value, isVariable, index, currentFileInfo, visibilityInfo) {
    this.combinator = combinator instanceof combinator_1.default ? combinator : new combinator_1.default(combinator);
    if (typeof value === 'string') {
      this.value = value.trim();
    } else if (value) {
      this.value = value;
    } else {
      this.value = '';
    }
    this.isVariable = isVariable;
    this._index = index;
    this._fileInfo = currentFileInfo;
    this.copyVisibilityInfo(visibilityInfo);
    this.setParent(this.combinator, this);
  };
  Element.prototype = Object.assign(new node_1.default(), {
    type: 'Element',
    accept: function (visitor) {
      var value = this.value;
      this.combinator = visitor.visit(this.combinator);
      if (typeof value === 'object') {
        this.value = visitor.visit(value);
      }
    },
    eval: function (context) {
      return new Element(this.combinator, this.value.eval ? this.value.eval(context) : this.value, this.isVariable, this.getIndex(), this.fileInfo(), this.visibilityInfo());
    },
    clone: function () {
      return new Element(this.combinator, this.value, this.isVariable, this.getIndex(), this.fileInfo(), this.visibilityInfo());
    },
    genCSS: function (context, output) {
      output.add(this.toCSS(context), this.fileInfo(), this.getIndex());
    },
    toCSS: function (context) {
      context = context || {};
      var value = this.value;
      var firstSelector = context.firstSelector;
      if (value instanceof paren_1.default) {
        // selector in parens should not be affected by outer selector
        // flags (breaks only interpolated selectors - see #1973)
        context.firstSelector = true;
      }
      value = value.toCSS ? value.toCSS(context) : value;
      context.firstSelector = firstSelector;
      if (value === '' && this.combinator.value.charAt(0) === '&') {
        return '';
      } else {
        return this.combinator.toCSS(context) + value;
      }
    }
  });
  element.default = Element;
  return element;
}

var lessError = {};

var utils = {};

var constants = {};

var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants) return constants;
  hasRequiredConstants = 1;
  Object.defineProperty(constants, "__esModule", {
    value: true
  });
  constants.RewriteUrls = constants.Math = void 0;
  constants.Math = {
    ALWAYS: 0,
    PARENS_DIVISION: 1,
    PARENS: 2
    // removed - STRICT_LEGACY: 3
  };
  constants.RewriteUrls = {
    OFF: 0,
    LOCAL: 1,
    ALL: 2
  };
  return constants;
}

var dist = {};

/**
 * Returns the object type of the given payload
 *
 * @param {*} payload
 * @returns {string}
 */
function getType(payload) {
  return Object.prototype.toString.call(payload).slice(8, -1);
}
/**
 * Returns whether the payload is undefined
 *
 * @param {*} payload
 * @returns {payload is undefined}
 */
function isUndefined(payload) {
  return getType(payload) === 'Undefined';
}
/**
 * Returns whether the payload is null
 *
 * @param {*} payload
 * @returns {payload is null}
 */
function isNull(payload) {
  return getType(payload) === 'Null';
}
/**
 * Returns whether the payload is a plain JavaScript object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is PlainObject}
 */
function isPlainObject(payload) {
  if (getType(payload) !== 'Object') return false;
  return payload.constructor === Object && Object.getPrototypeOf(payload) === Object.prototype;
}
/**
 * Returns whether the payload is a plain JavaScript object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is PlainObject}
 */
function isObject(payload) {
  return isPlainObject(payload);
}
/**
 * Returns whether the payload is a an empty object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is { [K in any]: never }}
 */
function isEmptyObject(payload) {
  return isPlainObject(payload) && Object.keys(payload).length === 0;
}
/**
 * Returns whether the payload is a an empty object (excluding special classes or objects with other prototypes)
 *
 * @param {*} payload
 * @returns {payload is PlainObject}
 */
function isFullObject(payload) {
  return isPlainObject(payload) && Object.keys(payload).length > 0;
}
/**
 * Returns whether the payload is an any kind of object (including special classes or objects with different prototypes)
 *
 * @param {*} payload
 * @returns {payload is PlainObject}
 */
function isAnyObject(payload) {
  return getType(payload) === 'Object';
}
/**
 * Returns whether the payload is an object like a type passed in < >
 *
 * Usage: isObjectLike<{id: any}>(payload) // will make sure it's an object and has an `id` prop.
 *
 * @template T this must be passed in < >
 * @param {*} payload
 * @returns {payload is T}
 */
function isObjectLike(payload) {
  return isAnyObject(payload);
}
/**
 * Returns whether the payload is a function (regular or async)
 *
 * @param {*} payload
 * @returns {payload is AnyFunction}
 */
function isFunction(payload) {
  return typeof payload === 'function';
}
/**
 * Returns whether the payload is an array
 *
 * @param {any} payload
 * @returns {payload is any[]}
 */
function isArray(payload) {
  return getType(payload) === 'Array';
}
/**
 * Returns whether the payload is a an array with at least 1 item
 *
 * @param {*} payload
 * @returns {payload is any[]}
 */
function isFullArray(payload) {
  return isArray(payload) && payload.length > 0;
}
/**
 * Returns whether the payload is a an empty array
 *
 * @param {*} payload
 * @returns {payload is []}
 */
function isEmptyArray(payload) {
  return isArray(payload) && payload.length === 0;
}
/**
 * Returns whether the payload is a string
 *
 * @param {*} payload
 * @returns {payload is string}
 */
function isString(payload) {
  return getType(payload) === 'String';
}
/**
 * Returns whether the payload is a string, BUT returns false for ''
 *
 * @param {*} payload
 * @returns {payload is string}
 */
function isFullString(payload) {
  return isString(payload) && payload !== '';
}
/**
 * Returns whether the payload is ''
 *
 * @param {*} payload
 * @returns {payload is string}
 */
function isEmptyString(payload) {
  return payload === '';
}
/**
 * Returns whether the payload is a number (but not NaN)
 *
 * This will return `false` for `NaN`!!
 *
 * @param {*} payload
 * @returns {payload is number}
 */
function isNumber(payload) {
  return getType(payload) === 'Number' && !isNaN(payload);
}
/**
 * Returns whether the payload is a boolean
 *
 * @param {*} payload
 * @returns {payload is boolean}
 */
function isBoolean(payload) {
  return getType(payload) === 'Boolean';
}
/**
 * Returns whether the payload is a regular expression (RegExp)
 *
 * @param {*} payload
 * @returns {payload is RegExp}
 */
function isRegExp(payload) {
  return getType(payload) === 'RegExp';
}
/**
 * Returns whether the payload is a Map
 *
 * @param {*} payload
 * @returns {payload is Map<any, any>}
 */
function isMap(payload) {
  return getType(payload) === 'Map';
}
/**
 * Returns whether the payload is a WeakMap
 *
 * @param {*} payload
 * @returns {payload is WeakMap<any, any>}
 */
function isWeakMap(payload) {
  return getType(payload) === 'WeakMap';
}
/**
 * Returns whether the payload is a Set
 *
 * @param {*} payload
 * @returns {payload is Set<any>}
 */
function isSet(payload) {
  return getType(payload) === 'Set';
}
/**
 * Returns whether the payload is a WeakSet
 *
 * @param {*} payload
 * @returns {payload is WeakSet<any>}
 */
function isWeakSet(payload) {
  return getType(payload) === 'WeakSet';
}
/**
 * Returns whether the payload is a Symbol
 *
 * @param {*} payload
 * @returns {payload is symbol}
 */
function isSymbol(payload) {
  return getType(payload) === 'Symbol';
}
/**
 * Returns whether the payload is a Date, and that the date is valid
 *
 * @param {*} payload
 * @returns {payload is Date}
 */
function isDate(payload) {
  return getType(payload) === 'Date' && !isNaN(payload);
}
/**
 * Returns whether the payload is a Blob
 *
 * @param {*} payload
 * @returns {payload is Blob}
 */
function isBlob(payload) {
  return getType(payload) === 'Blob';
}
/**
 * Returns whether the payload is a File
 *
 * @param {*} payload
 * @returns {payload is File}
 */
function isFile(payload) {
  return getType(payload) === 'File';
}
/**
 * Returns whether the payload is a Promise
 *
 * @param {*} payload
 * @returns {payload is Promise<any>}
 */
function isPromise(payload) {
  return getType(payload) === 'Promise';
}
/**
 * Returns whether the payload is an Error
 *
 * @param {*} payload
 * @returns {payload is Error}
 */
function isError(payload) {
  return getType(payload) === 'Error';
}
/**
 * Returns whether the payload is literally the value `NaN` (it's `NaN` and also a `number`)
 *
 * @param {*} payload
 * @returns {payload is typeof NaN}
 */
function isNaNValue(payload) {
  return getType(payload) === 'Number' && isNaN(payload);
}
/**
 * Returns whether the payload is a primitive type (eg. Boolean | Null | Undefined | Number | String | Symbol)
 *
 * @param {*} payload
 * @returns {(payload is boolean | null | undefined | number | string | symbol)}
 */
function isPrimitive(payload) {
  return isBoolean(payload) || isNull(payload) || isUndefined(payload) || isNumber(payload) || isString(payload) || isSymbol(payload);
}
/**
 * Returns true whether the payload is null or undefined
 *
 * @param {*} payload
 * @returns {(payload is null | undefined)}
 */
var isNullOrUndefined = isOneOf(isNull, isUndefined);
function isOneOf(a, b, c, d, e) {
  return function (value) {
    return a(value) || b(value) || !!c && c(value) || !!d && d(value) || !!e && e(value);
  };
}
/**
 * Does a generic check to check that the given payload is of a given type.
 * In cases like Number, it will return true for NaN as NaN is a Number (thanks javascript!);
 * It will, however, differentiate between object and null
 *
 * @template T
 * @param {*} payload
 * @param {T} type
 * @throws {TypeError} Will throw type error if type is an invalid type
 * @returns {payload is T}
 */
function isType(payload, type) {
  if (!(type instanceof Function)) {
    throw new TypeError('Type must be a function');
  }
  if (!Object.prototype.hasOwnProperty.call(type, 'prototype')) {
    throw new TypeError('Type is not a class');
  }
  // Classes usually have names (as functions usually have names)
  var name = type.name;
  return getType(payload) === name || Boolean(payload && payload.constructor === type);
}

var index_esm = /*#__PURE__*/Object.freeze({
	__proto__: null,
	getType: getType,
	isAnyObject: isAnyObject,
	isArray: isArray,
	isBlob: isBlob,
	isBoolean: isBoolean,
	isDate: isDate,
	isEmptyArray: isEmptyArray,
	isEmptyObject: isEmptyObject,
	isEmptyString: isEmptyString,
	isError: isError,
	isFile: isFile,
	isFullArray: isFullArray,
	isFullObject: isFullObject,
	isFullString: isFullString,
	isFunction: isFunction,
	isMap: isMap,
	isNaNValue: isNaNValue,
	isNull: isNull,
	isNullOrUndefined: isNullOrUndefined,
	isNumber: isNumber,
	isObject: isObject,
	isObjectLike: isObjectLike,
	isOneOf: isOneOf,
	isPlainObject: isPlainObject,
	isPrimitive: isPrimitive,
	isPromise: isPromise,
	isRegExp: isRegExp,
	isSet: isSet,
	isString: isString,
	isSymbol: isSymbol,
	isType: isType,
	isUndefined: isUndefined,
	isWeakMap: isWeakMap,
	isWeakSet: isWeakSet
});

var require$$0 = /*@__PURE__*/getAugmentedNamespace(index_esm);

var hasRequiredDist;
function requireDist() {
  if (hasRequiredDist) return dist;
  hasRequiredDist = 1;
  Object.defineProperty(dist, '__esModule', {
    value: true
  });
  var isWhat = require$$0;
  function assignProp(carry, key, newVal, originalObject, includeNonenumerable) {
    const propType = {}.propertyIsEnumerable.call(originalObject, key) ? 'enumerable' : 'nonenumerable';
    if (propType === 'enumerable') carry[key] = newVal;
    if (includeNonenumerable && propType === 'nonenumerable') {
      Object.defineProperty(carry, key, {
        value: newVal,
        enumerable: false,
        writable: true,
        configurable: true
      });
    }
  }
  /**
   * Copy (clone) an object and all its props recursively to get rid of any prop referenced of the original object. Arrays are also cloned, however objects inside arrays are still linked.
   *
   * @export
   * @template T
   * @param {T} target Target can be anything
   * @param {Options} [options = {}] Options can be `props` or `nonenumerable`
   * @returns {T} the target with replaced values
   * @export
   */
  function copy(target, options = {}) {
    if (isWhat.isArray(target)) {
      return target.map(item => copy(item, options));
    }
    if (!isWhat.isPlainObject(target)) {
      return target;
    }
    const props = Object.getOwnPropertyNames(target);
    const symbols = Object.getOwnPropertySymbols(target);
    return [...props, ...symbols].reduce((carry, key) => {
      if (isWhat.isArray(options.props) && !options.props.includes(key)) {
        return carry;
      }
      const val = target[key];
      const newVal = copy(val, options);
      assignProp(carry, key, newVal, target, options.nonenumerable);
      return carry;
    }, {});
  }
  dist.copy = copy;
  return dist;
}

var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  Object.defineProperty(utils, "__esModule", {
    value: true
  });
  utils.isNullOrUndefined = utils.flattenArray = utils.merge = utils.copyOptions = utils.defaults = utils.clone = utils.copyArray = utils.getLocation = void 0;
  var tslib_1 = require$$0$2;
  /* jshint proto: true */
  var Constants = tslib_1.__importStar(requireConstants());
  var copy_anything_1 = /*@__PURE__*/requireDist();
  function getLocation(index, inputStream) {
    var n = index + 1;
    var line = null;
    var column = -1;
    while (--n >= 0 && inputStream.charAt(n) !== '\n') {
      column++;
    }
    if (typeof index === 'number') {
      line = (inputStream.slice(0, index).match(/\n/g) || '').length;
    }
    return {
      line: line,
      column: column
    };
  }
  utils.getLocation = getLocation;
  function copyArray(arr) {
    var i;
    var length = arr.length;
    var copy = new Array(length);
    for (i = 0; i < length; i++) {
      copy[i] = arr[i];
    }
    return copy;
  }
  utils.copyArray = copyArray;
  function clone(obj) {
    var cloned = {};
    for (var prop in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, prop)) {
        cloned[prop] = obj[prop];
      }
    }
    return cloned;
  }
  utils.clone = clone;
  function defaults(obj1, obj2) {
    var newObj = obj2 || {};
    if (!obj2._defaults) {
      newObj = {};
      var defaults_1 = (0, copy_anything_1.copy)(obj1);
      newObj._defaults = defaults_1;
      var cloned = obj2 ? (0, copy_anything_1.copy)(obj2) : {};
      Object.assign(newObj, defaults_1, cloned);
    }
    return newObj;
  }
  utils.defaults = defaults;
  function copyOptions(obj1, obj2) {
    if (obj2 && obj2._defaults) {
      return obj2;
    }
    var opts = defaults(obj1, obj2);
    if (opts.strictMath) {
      opts.math = Constants.Math.PARENS;
    }
    // Back compat with changed relativeUrls option
    if (opts.relativeUrls) {
      opts.rewriteUrls = Constants.RewriteUrls.ALL;
    }
    if (typeof opts.math === 'string') {
      switch (opts.math.toLowerCase()) {
        case 'always':
          opts.math = Constants.Math.ALWAYS;
          break;
        case 'parens-division':
          opts.math = Constants.Math.PARENS_DIVISION;
          break;
        case 'strict':
        case 'parens':
          opts.math = Constants.Math.PARENS;
          break;
        default:
          opts.math = Constants.Math.PARENS;
      }
    }
    if (typeof opts.rewriteUrls === 'string') {
      switch (opts.rewriteUrls.toLowerCase()) {
        case 'off':
          opts.rewriteUrls = Constants.RewriteUrls.OFF;
          break;
        case 'local':
          opts.rewriteUrls = Constants.RewriteUrls.LOCAL;
          break;
        case 'all':
          opts.rewriteUrls = Constants.RewriteUrls.ALL;
          break;
      }
    }
    return opts;
  }
  utils.copyOptions = copyOptions;
  function merge(obj1, obj2) {
    for (var prop in obj2) {
      if (Object.prototype.hasOwnProperty.call(obj2, prop)) {
        obj1[prop] = obj2[prop];
      }
    }
    return obj1;
  }
  utils.merge = merge;
  function flattenArray(arr, result) {
    if (result === void 0) {
      result = [];
    }
    for (var i = 0, length_1 = arr.length; i < length_1; i++) {
      var value = arr[i];
      if (Array.isArray(value)) {
        flattenArray(value, result);
      } else {
        if (value !== undefined) {
          result.push(value);
        }
      }
    }
    return result;
  }
  utils.flattenArray = flattenArray;
  function isNullOrUndefined(val) {
    return val === null || val === undefined;
  }
  utils.isNullOrUndefined = isNullOrUndefined;
  return utils;
}

var hasRequiredLessError;
function requireLessError() {
  if (hasRequiredLessError) return lessError;
  hasRequiredLessError = 1;
  Object.defineProperty(lessError, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var utils = tslib_1.__importStar(requireUtils());
  var anonymousFunc = /(<anonymous>|Function):(\d+):(\d+)/;
  /**
   * This is a centralized class of any error that could be thrown internally (mostly by the parser).
   * Besides standard .message it keeps some additional data like a path to the file where the error
   * occurred along with line and column numbers.
   *
   * @class
   * @extends Error
   * @type {module.LessError}
   *
   * @prop {string} type
   * @prop {string} filename
   * @prop {number} index
   * @prop {number} line
   * @prop {number} column
   * @prop {number} callLine
   * @prop {number} callExtract
   * @prop {string[]} extract
   *
   * @param {Object} e              - An error object to wrap around or just a descriptive object
   * @param {Object} fileContentMap - An object with file contents in 'contents' property (like importManager) @todo - move to fileManager?
   * @param {string} [currentFilename]
   */
  var LessError = function (e, fileContentMap, currentFilename) {
    Error.call(this);
    var filename = e.filename || currentFilename;
    this.message = e.message;
    this.stack = e.stack;
    if (fileContentMap && filename) {
      var input = fileContentMap.contents[filename];
      var loc = utils.getLocation(e.index, input);
      var line = loc.line;
      var col = loc.column;
      var callLine = e.call && utils.getLocation(e.call, input).line;
      var lines = input ? input.split('\n') : '';
      this.type = e.type || 'Syntax';
      this.filename = filename;
      this.index = e.index;
      this.line = typeof line === 'number' ? line + 1 : null;
      this.column = col;
      if (!this.line && this.stack) {
        var found = this.stack.match(anonymousFunc);
        /**
         * We have to figure out how this environment stringifies anonymous functions
         * so we can correctly map plugin errors.
         *
         * Note, in Node 8, the output of anonymous funcs varied based on parameters
         * being present or not, so we inject dummy params.
         */
        var func = new Function('a', 'throw new Error()');
        var lineAdjust = 0;
        try {
          func();
        } catch (e) {
          var match = e.stack.match(anonymousFunc);
          lineAdjust = 1 - parseInt(match[2]);
        }
        if (found) {
          if (found[2]) {
            this.line = parseInt(found[2]) + lineAdjust;
          }
          if (found[3]) {
            this.column = parseInt(found[3]);
          }
        }
      }
      this.callLine = callLine + 1;
      this.callExtract = lines[callLine];
      this.extract = [lines[this.line - 2], lines[this.line - 1], lines[this.line]];
    }
  };
  if (typeof Object.create === 'undefined') {
    var F = function () {};
    F.prototype = Error.prototype;
    LessError.prototype = new F();
  } else {
    LessError.prototype = Object.create(Error.prototype);
  }
  LessError.prototype.constructor = LessError;
  /**
   * An overridden version of the default Object.prototype.toString
   * which uses additional information to create a helpful message.
   *
   * @param {Object} options
   * @returns {string}
   */
  LessError.prototype.toString = function (options) {
    options = options || {};
    var message = '';
    var extract = this.extract || [];
    var error = [];
    var stylize = function (str) {
      return str;
    };
    if (options.stylize) {
      var type = typeof options.stylize;
      if (type !== 'function') {
        throw Error("options.stylize should be a function, got a ".concat(type, "!"));
      }
      stylize = options.stylize;
    }
    if (this.line !== null) {
      if (typeof extract[0] === 'string') {
        error.push(stylize("".concat(this.line - 1, " ").concat(extract[0]), 'grey'));
      }
      if (typeof extract[1] === 'string') {
        var errorTxt = "".concat(this.line, " ");
        if (extract[1]) {
          errorTxt += extract[1].slice(0, this.column) + stylize(stylize(stylize(extract[1].substr(this.column, 1), 'bold') + extract[1].slice(this.column + 1), 'red'), 'inverse');
        }
        error.push(errorTxt);
      }
      if (typeof extract[2] === 'string') {
        error.push(stylize("".concat(this.line + 1, " ").concat(extract[2]), 'grey'));
      }
      error = "".concat(error.join('\n') + stylize('', 'reset'), "\n");
    }
    message += stylize("".concat(this.type, "Error: ").concat(this.message), 'red');
    if (this.filename) {
      message += stylize(' in ', 'red') + this.filename;
    }
    if (this.line) {
      message += stylize(" on line ".concat(this.line, ", column ").concat(this.column + 1, ":"), 'grey');
    }
    message += "\n".concat(error);
    if (this.callLine) {
      message += "".concat(stylize('from ', 'red') + (this.filename || ''), "/n");
      message += "".concat(stylize(this.callLine, 'grey'), " ").concat(this.callExtract, "/n");
    }
    return message;
  };
  lessError.default = LessError;
  return lessError;
}

var parser = {};

var visitors = {};

var visitor = {};

var hasRequiredVisitor;
function requireVisitor() {
  if (hasRequiredVisitor) return visitor;
  hasRequiredVisitor = 1;
  Object.defineProperty(visitor, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var tree_1 = tslib_1.__importDefault(requireTree());
  var _visitArgs = {
    visitDeeper: true
  };
  var _hasIndexed = false;
  function _noop(node) {
    return node;
  }
  function indexNodeTypes(parent, ticker) {
    // add .typeIndex to tree node types for lookup table
    var key, child;
    for (key in parent) {
      /* eslint guard-for-in: 0 */
      child = parent[key];
      switch (typeof child) {
        case 'function':
          // ignore bound functions directly on tree which do not have a prototype
          // or aren't nodes
          if (child.prototype && child.prototype.type) {
            child.prototype.typeIndex = ticker++;
          }
          break;
        case 'object':
          ticker = indexNodeTypes(child, ticker);
          break;
      }
    }
    return ticker;
  }
  var Visitor = /** @class */function () {
    function Visitor(implementation) {
      this._implementation = implementation;
      this._visitInCache = {};
      this._visitOutCache = {};
      if (!_hasIndexed) {
        indexNodeTypes(tree_1.default, 1);
        _hasIndexed = true;
      }
    }
    Visitor.prototype.visit = function (node) {
      if (!node) {
        return node;
      }
      var nodeTypeIndex = node.typeIndex;
      if (!nodeTypeIndex) {
        // MixinCall args aren't a node type?
        if (node.value && node.value.typeIndex) {
          this.visit(node.value);
        }
        return node;
      }
      var impl = this._implementation;
      var func = this._visitInCache[nodeTypeIndex];
      var funcOut = this._visitOutCache[nodeTypeIndex];
      var visitArgs = _visitArgs;
      var fnName;
      visitArgs.visitDeeper = true;
      if (!func) {
        fnName = "visit".concat(node.type);
        func = impl[fnName] || _noop;
        funcOut = impl["".concat(fnName, "Out")] || _noop;
        this._visitInCache[nodeTypeIndex] = func;
        this._visitOutCache[nodeTypeIndex] = funcOut;
      }
      if (func !== _noop) {
        var newNode = func.call(impl, node, visitArgs);
        if (node && impl.isReplacing) {
          node = newNode;
        }
      }
      if (visitArgs.visitDeeper && node) {
        if (node.length) {
          for (var i = 0, cnt = node.length; i < cnt; i++) {
            if (node[i].accept) {
              node[i].accept(this);
            }
          }
        } else if (node.accept) {
          node.accept(this);
        }
      }
      if (funcOut != _noop) {
        funcOut.call(impl, node);
      }
      return node;
    };
    Visitor.prototype.visitArray = function (nodes, nonReplacing) {
      if (!nodes) {
        return nodes;
      }
      var cnt = nodes.length;
      var i;
      // Non-replacing
      if (nonReplacing || !this._implementation.isReplacing) {
        for (i = 0; i < cnt; i++) {
          this.visit(nodes[i]);
        }
        return nodes;
      }
      // Replacing
      var out = [];
      for (i = 0; i < cnt; i++) {
        var evald = this.visit(nodes[i]);
        if (evald === undefined) {
          continue;
        }
        if (!evald.splice) {
          out.push(evald);
        } else if (evald.length) {
          this.flatten(evald, out);
        }
      }
      return out;
    };
    Visitor.prototype.flatten = function (arr, out) {
      if (!out) {
        out = [];
      }
      var cnt, i, item, nestedCnt, j, nestedItem;
      for (i = 0, cnt = arr.length; i < cnt; i++) {
        item = arr[i];
        if (item === undefined) {
          continue;
        }
        if (!item.splice) {
          out.push(item);
          continue;
        }
        for (j = 0, nestedCnt = item.length; j < nestedCnt; j++) {
          nestedItem = item[j];
          if (nestedItem === undefined) {
            continue;
          }
          if (!nestedItem.splice) {
            out.push(nestedItem);
          } else if (nestedItem.length) {
            this.flatten(nestedItem, out);
          }
        }
      }
      return out;
    };
    return Visitor;
  }();
  visitor.default = Visitor;
  return visitor;
}

var importVisitor = {};

var contexts = {};

var hasRequiredContexts;
function requireContexts() {
  if (hasRequiredContexts) return contexts;
  hasRequiredContexts = 1;
  Object.defineProperty(contexts, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var contexts$1 = {};
  contexts.default = contexts$1;
  var Constants = tslib_1.__importStar(requireConstants());
  var copyFromOriginal = function copyFromOriginal(original, destination, propertiesToCopy) {
    if (!original) {
      return;
    }
    for (var i = 0; i < propertiesToCopy.length; i++) {
      if (Object.prototype.hasOwnProperty.call(original, propertiesToCopy[i])) {
        destination[propertiesToCopy[i]] = original[propertiesToCopy[i]];
      }
    }
  };
  /*
   parse is used whilst parsing
   */
  var parseCopyProperties = [
  // options
  'paths', 'rewriteUrls', 'rootpath', 'strictImports', 'insecure', 'dumpLineNumbers', 'compress', 'syncImport', 'chunkInput', 'mime', 'useFileCache',
  // context
  'processImports',
  // Used by the import manager to stop multiple import visitors being created.
  'pluginManager' // Used as the plugin manager for the session
  ];
  contexts$1.Parse = function (options) {
    copyFromOriginal(options, this, parseCopyProperties);
    if (typeof this.paths === 'string') {
      this.paths = [this.paths];
    }
  };
  var evalCopyProperties = ['paths', 'compress', 'math', 'strictUnits', 'sourceMap', 'importMultiple', 'urlArgs', 'javascriptEnabled', 'pluginManager', 'importantScope', 'rewriteUrls' // option - whether to adjust URL's to be relative
  ];
  contexts$1.Eval = function (options, frames) {
    copyFromOriginal(options, this, evalCopyProperties);
    if (typeof this.paths === 'string') {
      this.paths = [this.paths];
    }
    this.frames = frames || [];
    this.importantScope = this.importantScope || [];
  };
  contexts$1.Eval.prototype.enterCalc = function () {
    if (!this.calcStack) {
      this.calcStack = [];
    }
    this.calcStack.push(true);
    this.inCalc = true;
  };
  contexts$1.Eval.prototype.exitCalc = function () {
    this.calcStack.pop();
    if (!this.calcStack.length) {
      this.inCalc = false;
    }
  };
  contexts$1.Eval.prototype.inParenthesis = function () {
    if (!this.parensStack) {
      this.parensStack = [];
    }
    this.parensStack.push(true);
  };
  contexts$1.Eval.prototype.outOfParenthesis = function () {
    this.parensStack.pop();
  };
  contexts$1.Eval.prototype.inCalc = false;
  contexts$1.Eval.prototype.mathOn = true;
  contexts$1.Eval.prototype.isMathOn = function (op) {
    if (!this.mathOn) {
      return false;
    }
    if (op === '/' && this.math !== Constants.Math.ALWAYS && (!this.parensStack || !this.parensStack.length)) {
      return false;
    }
    if (this.math > Constants.Math.PARENS_DIVISION) {
      return this.parensStack && this.parensStack.length;
    }
    return true;
  };
  contexts$1.Eval.prototype.pathRequiresRewrite = function (path) {
    var isRelative = this.rewriteUrls === Constants.RewriteUrls.LOCAL ? isPathLocalRelative : isPathRelative;
    return isRelative(path);
  };
  contexts$1.Eval.prototype.rewritePath = function (path, rootpath) {
    var newPath;
    rootpath = rootpath || '';
    newPath = this.normalizePath(rootpath + path);
    // If a path was explicit relative and the rootpath was not an absolute path
    // we must ensure that the new path is also explicit relative.
    if (isPathLocalRelative(path) && isPathRelative(rootpath) && isPathLocalRelative(newPath) === false) {
      newPath = "./".concat(newPath);
    }
    return newPath;
  };
  contexts$1.Eval.prototype.normalizePath = function (path) {
    var segments = path.split('/').reverse();
    var segment;
    path = [];
    while (segments.length !== 0) {
      segment = segments.pop();
      switch (segment) {
        case '.':
          break;
        case '..':
          if (path.length === 0 || path[path.length - 1] === '..') {
            path.push(segment);
          } else {
            path.pop();
          }
          break;
        default:
          path.push(segment);
          break;
      }
    }
    return path.join('/');
  };
  function isPathRelative(path) {
    return !/^(?:[a-z-]+:|\/|#)/i.test(path);
  }
  function isPathLocalRelative(path) {
    return path.charAt(0) === '.';
  }
  // todo - do the same for the toCSS ?

  return contexts;
}

var importSequencer = {};

var hasRequiredImportSequencer;
function requireImportSequencer() {
  if (hasRequiredImportSequencer) return importSequencer;
  hasRequiredImportSequencer = 1;
  Object.defineProperty(importSequencer, "__esModule", {
    value: true
  });
  var ImportSequencer = /** @class */function () {
    function ImportSequencer(onSequencerEmpty) {
      this.imports = [];
      this.variableImports = [];
      this._onSequencerEmpty = onSequencerEmpty;
      this._currentDepth = 0;
    }
    ImportSequencer.prototype.addImport = function (callback) {
      var importSequencer = this,
        importItem = {
          callback: callback,
          args: null,
          isReady: false
        };
      this.imports.push(importItem);
      return function () {
        importItem.args = Array.prototype.slice.call(arguments, 0);
        importItem.isReady = true;
        importSequencer.tryRun();
      };
    };
    ImportSequencer.prototype.addVariableImport = function (callback) {
      this.variableImports.push(callback);
    };
    ImportSequencer.prototype.tryRun = function () {
      this._currentDepth++;
      try {
        while (true) {
          while (this.imports.length > 0) {
            var importItem = this.imports[0];
            if (!importItem.isReady) {
              return;
            }
            this.imports = this.imports.slice(1);
            importItem.callback.apply(null, importItem.args);
          }
          if (this.variableImports.length === 0) {
            break;
          }
          var variableImport = this.variableImports[0];
          this.variableImports = this.variableImports.slice(1);
          variableImport();
        }
      } finally {
        this._currentDepth--;
      }
      if (this._currentDepth === 0 && this._onSequencerEmpty) {
        this._onSequencerEmpty();
      }
    };
    return ImportSequencer;
  }();
  importSequencer.default = ImportSequencer;
  return importSequencer;
}

var hasRequiredImportVisitor;
function requireImportVisitor() {
  if (hasRequiredImportVisitor) return importVisitor;
  hasRequiredImportVisitor = 1;
  Object.defineProperty(importVisitor, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  /* eslint-disable no-unused-vars */
  /**
   * @todo - Remove unused when JSDoc types are added for visitor methods
   */
  var contexts_1 = tslib_1.__importDefault(requireContexts());
  var visitor_1 = tslib_1.__importDefault(requireVisitor());
  var import_sequencer_1 = tslib_1.__importDefault(requireImportSequencer());
  var utils = tslib_1.__importStar(requireUtils());
  var ImportVisitor = function (importer, finish) {
    this._visitor = new visitor_1.default(this);
    this._importer = importer;
    this._finish = finish;
    this.context = new contexts_1.default.Eval();
    this.importCount = 0;
    this.onceFileDetectionMap = {};
    this.recursionDetector = {};
    this._sequencer = new import_sequencer_1.default(this._onSequencerEmpty.bind(this));
  };
  ImportVisitor.prototype = {
    isReplacing: false,
    run: function (root) {
      try {
        // process the contents
        this._visitor.visit(root);
      } catch (e) {
        this.error = e;
      }
      this.isFinished = true;
      this._sequencer.tryRun();
    },
    _onSequencerEmpty: function () {
      if (!this.isFinished) {
        return;
      }
      this._finish(this.error);
    },
    visitImport: function (importNode, visitArgs) {
      var inlineCSS = importNode.options.inline;
      if (!importNode.css || inlineCSS) {
        var context = new contexts_1.default.Eval(this.context, utils.copyArray(this.context.frames));
        var importParent = context.frames[0];
        this.importCount++;
        if (importNode.isVariableImport()) {
          this._sequencer.addVariableImport(this.processImportNode.bind(this, importNode, context, importParent));
        } else {
          this.processImportNode(importNode, context, importParent);
        }
      }
      visitArgs.visitDeeper = false;
    },
    processImportNode: function (importNode, context, importParent) {
      var evaldImportNode;
      var inlineCSS = importNode.options.inline;
      try {
        evaldImportNode = importNode.evalForImport(context);
      } catch (e) {
        if (!e.filename) {
          e.index = importNode.getIndex();
          e.filename = importNode.fileInfo().filename;
        }
        // attempt to eval properly and treat as css
        importNode.css = true;
        // if that fails, this error will be thrown
        importNode.error = e;
      }
      if (evaldImportNode && (!evaldImportNode.css || inlineCSS)) {
        if (evaldImportNode.options.multiple) {
          context.importMultiple = true;
        }
        // try appending if we haven't determined if it is css or not
        var tryAppendLessExtension = evaldImportNode.css === undefined;
        for (var i = 0; i < importParent.rules.length; i++) {
          if (importParent.rules[i] === importNode) {
            importParent.rules[i] = evaldImportNode;
            break;
          }
        }
        var onImported = this.onImported.bind(this, evaldImportNode, context),
          sequencedOnImported = this._sequencer.addImport(onImported);
        this._importer.push(evaldImportNode.getPath(), tryAppendLessExtension, evaldImportNode.fileInfo(), evaldImportNode.options, sequencedOnImported);
      } else {
        this.importCount--;
        if (this.isFinished) {
          this._sequencer.tryRun();
        }
      }
    },
    onImported: function (importNode, context, e, root, importedAtRoot, fullPath) {
      if (e) {
        if (!e.filename) {
          e.index = importNode.getIndex();
          e.filename = importNode.fileInfo().filename;
        }
        this.error = e;
      }
      var importVisitor = this,
        inlineCSS = importNode.options.inline,
        isPlugin = importNode.options.isPlugin,
        isOptional = importNode.options.optional,
        duplicateImport = importedAtRoot || fullPath in importVisitor.recursionDetector;
      if (!context.importMultiple) {
        if (duplicateImport) {
          importNode.skip = true;
        } else {
          importNode.skip = function () {
            if (fullPath in importVisitor.onceFileDetectionMap) {
              return true;
            }
            importVisitor.onceFileDetectionMap[fullPath] = true;
            return false;
          };
        }
      }
      if (!fullPath && isOptional) {
        importNode.skip = true;
      }
      if (root) {
        importNode.root = root;
        importNode.importedFilename = fullPath;
        if (!inlineCSS && !isPlugin && (context.importMultiple || !duplicateImport)) {
          importVisitor.recursionDetector[fullPath] = true;
          var oldContext = this.context;
          this.context = context;
          try {
            this._visitor.visit(root);
          } catch (e) {
            this.error = e;
          }
          this.context = oldContext;
        }
      }
      importVisitor.importCount--;
      if (importVisitor.isFinished) {
        importVisitor._sequencer.tryRun();
      }
    },
    visitDeclaration: function (declNode, visitArgs) {
      if (declNode.value.type === 'DetachedRuleset') {
        this.context.frames.unshift(declNode);
      } else {
        visitArgs.visitDeeper = false;
      }
    },
    visitDeclarationOut: function (declNode) {
      if (declNode.value.type === 'DetachedRuleset') {
        this.context.frames.shift();
      }
    },
    visitAtRule: function (atRuleNode, visitArgs) {
      this.context.frames.unshift(atRuleNode);
    },
    visitAtRuleOut: function (atRuleNode) {
      this.context.frames.shift();
    },
    visitMixinDefinition: function (mixinDefinitionNode, visitArgs) {
      this.context.frames.unshift(mixinDefinitionNode);
    },
    visitMixinDefinitionOut: function (mixinDefinitionNode) {
      this.context.frames.shift();
    },
    visitRuleset: function (rulesetNode, visitArgs) {
      this.context.frames.unshift(rulesetNode);
    },
    visitRulesetOut: function (rulesetNode) {
      this.context.frames.shift();
    },
    visitMedia: function (mediaNode, visitArgs) {
      this.context.frames.unshift(mediaNode.rules[0]);
    },
    visitMediaOut: function (mediaNode) {
      this.context.frames.shift();
    }
  };
  importVisitor.default = ImportVisitor;
  return importVisitor;
}

var setTreeVisibilityVisitor = {};

var hasRequiredSetTreeVisibilityVisitor;
function requireSetTreeVisibilityVisitor() {
  if (hasRequiredSetTreeVisibilityVisitor) return setTreeVisibilityVisitor;
  hasRequiredSetTreeVisibilityVisitor = 1;
  Object.defineProperty(setTreeVisibilityVisitor, "__esModule", {
    value: true
  });
  var SetTreeVisibilityVisitor = /** @class */function () {
    function SetTreeVisibilityVisitor(visible) {
      this.visible = visible;
    }
    SetTreeVisibilityVisitor.prototype.run = function (root) {
      this.visit(root);
    };
    SetTreeVisibilityVisitor.prototype.visitArray = function (nodes) {
      if (!nodes) {
        return nodes;
      }
      var cnt = nodes.length;
      var i;
      for (i = 0; i < cnt; i++) {
        this.visit(nodes[i]);
      }
      return nodes;
    };
    SetTreeVisibilityVisitor.prototype.visit = function (node) {
      if (!node) {
        return node;
      }
      if (node.constructor === Array) {
        return this.visitArray(node);
      }
      if (!node.blocksVisibility || node.blocksVisibility()) {
        return node;
      }
      if (this.visible) {
        node.ensureVisibility();
      } else {
        node.ensureInvisibility();
      }
      node.accept(this);
      return node;
    };
    return SetTreeVisibilityVisitor;
  }();
  setTreeVisibilityVisitor.default = SetTreeVisibilityVisitor;
  return setTreeVisibilityVisitor;
}

var extendVisitor = {};

var hasRequiredExtendVisitor;
function requireExtendVisitor() {
  if (hasRequiredExtendVisitor) return extendVisitor;
  hasRequiredExtendVisitor = 1;
  Object.defineProperty(extendVisitor, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  /* eslint-disable no-unused-vars */
  /**
   * @todo - Remove unused when JSDoc types are added for visitor methods
   */
  var tree_1 = tslib_1.__importDefault(requireTree());
  var visitor_1 = tslib_1.__importDefault(requireVisitor());
  var logger_1 = tslib_1.__importDefault(requireLogger());
  var utils = tslib_1.__importStar(requireUtils());
  /* jshint loopfunc:true */
  var ExtendFinderVisitor = /** @class */function () {
    function ExtendFinderVisitor() {
      this._visitor = new visitor_1.default(this);
      this.contexts = [];
      this.allExtendsStack = [[]];
    }
    ExtendFinderVisitor.prototype.run = function (root) {
      root = this._visitor.visit(root);
      root.allExtends = this.allExtendsStack[0];
      return root;
    };
    ExtendFinderVisitor.prototype.visitDeclaration = function (declNode, visitArgs) {
      visitArgs.visitDeeper = false;
    };
    ExtendFinderVisitor.prototype.visitMixinDefinition = function (mixinDefinitionNode, visitArgs) {
      visitArgs.visitDeeper = false;
    };
    ExtendFinderVisitor.prototype.visitRuleset = function (rulesetNode, visitArgs) {
      if (rulesetNode.root) {
        return;
      }
      var i;
      var j;
      var extend;
      var allSelectorsExtendList = [];
      var extendList;
      // get &:extend(.a); rules which apply to all selectors in this ruleset
      var rules = rulesetNode.rules,
        ruleCnt = rules ? rules.length : 0;
      for (i = 0; i < ruleCnt; i++) {
        if (rulesetNode.rules[i] instanceof tree_1.default.Extend) {
          allSelectorsExtendList.push(rules[i]);
          rulesetNode.extendOnEveryPath = true;
        }
      }
      // now find every selector and apply the extends that apply to all extends
      // and the ones which apply to an individual extend
      var paths = rulesetNode.paths;
      for (i = 0; i < paths.length; i++) {
        var selectorPath = paths[i],
          selector = selectorPath[selectorPath.length - 1],
          selExtendList = selector.extendList;
        extendList = selExtendList ? utils.copyArray(selExtendList).concat(allSelectorsExtendList) : allSelectorsExtendList;
        if (extendList) {
          extendList = extendList.map(function (allSelectorsExtend) {
            return allSelectorsExtend.clone();
          });
        }
        for (j = 0; j < extendList.length; j++) {
          this.foundExtends = true;
          extend = extendList[j];
          extend.findSelfSelectors(selectorPath);
          extend.ruleset = rulesetNode;
          if (j === 0) {
            extend.firstExtendOnThisSelectorPath = true;
          }
          this.allExtendsStack[this.allExtendsStack.length - 1].push(extend);
        }
      }
      this.contexts.push(rulesetNode.selectors);
    };
    ExtendFinderVisitor.prototype.visitRulesetOut = function (rulesetNode) {
      if (!rulesetNode.root) {
        this.contexts.length = this.contexts.length - 1;
      }
    };
    ExtendFinderVisitor.prototype.visitMedia = function (mediaNode, visitArgs) {
      mediaNode.allExtends = [];
      this.allExtendsStack.push(mediaNode.allExtends);
    };
    ExtendFinderVisitor.prototype.visitMediaOut = function (mediaNode) {
      this.allExtendsStack.length = this.allExtendsStack.length - 1;
    };
    ExtendFinderVisitor.prototype.visitAtRule = function (atRuleNode, visitArgs) {
      atRuleNode.allExtends = [];
      this.allExtendsStack.push(atRuleNode.allExtends);
    };
    ExtendFinderVisitor.prototype.visitAtRuleOut = function (atRuleNode) {
      this.allExtendsStack.length = this.allExtendsStack.length - 1;
    };
    return ExtendFinderVisitor;
  }();
  var ProcessExtendsVisitor = /** @class */function () {
    function ProcessExtendsVisitor() {
      this._visitor = new visitor_1.default(this);
    }
    ProcessExtendsVisitor.prototype.run = function (root) {
      var extendFinder = new ExtendFinderVisitor();
      this.extendIndices = {};
      extendFinder.run(root);
      if (!extendFinder.foundExtends) {
        return root;
      }
      root.allExtends = root.allExtends.concat(this.doExtendChaining(root.allExtends, root.allExtends));
      this.allExtendsStack = [root.allExtends];
      var newRoot = this._visitor.visit(root);
      this.checkExtendsForNonMatched(root.allExtends);
      return newRoot;
    };
    ProcessExtendsVisitor.prototype.checkExtendsForNonMatched = function (extendList) {
      var indices = this.extendIndices;
      extendList.filter(function (extend) {
        return !extend.hasFoundMatches && extend.parent_ids.length == 1;
      }).forEach(function (extend) {
        var selector = '_unknown_';
        try {
          selector = extend.selector.toCSS({});
        } catch (_) {}
        if (!indices["".concat(extend.index, " ").concat(selector)]) {
          indices["".concat(extend.index, " ").concat(selector)] = true;
          logger_1.default.warn("extend '".concat(selector, "' has no matches"));
        }
      });
    };
    ProcessExtendsVisitor.prototype.doExtendChaining = function (extendsList, extendsListTarget, iterationCount) {
      //
      // chaining is different from normal extension.. if we extend an extend then we are not just copying, altering
      // and pasting the selector we would do normally, but we are also adding an extend with the same target selector
      // this means this new extend can then go and alter other extends
      //
      // this method deals with all the chaining work - without it, extend is flat and doesn't work on other extend selectors
      // this is also the most expensive.. and a match on one selector can cause an extension of a selector we had already
      // processed if we look at each selector at a time, as is done in visitRuleset
      var extendIndex;
      var targetExtendIndex;
      var matches;
      var extendsToAdd = [];
      var newSelector;
      var extendVisitor = this;
      var selectorPath;
      var extend;
      var targetExtend;
      var newExtend;
      iterationCount = iterationCount || 0;
      // loop through comparing every extend with every target extend.
      // a target extend is the one on the ruleset we are looking at copy/edit/pasting in place
      // e.g.  .a:extend(.b) {}  and .b:extend(.c) {} then the first extend extends the second one
      // and the second is the target.
      // the separation into two lists allows us to process a subset of chains with a bigger set, as is the
      // case when processing media queries
      for (extendIndex = 0; extendIndex < extendsList.length; extendIndex++) {
        for (targetExtendIndex = 0; targetExtendIndex < extendsListTarget.length; targetExtendIndex++) {
          extend = extendsList[extendIndex];
          targetExtend = extendsListTarget[targetExtendIndex];
          // look for circular references
          if (extend.parent_ids.indexOf(targetExtend.object_id) >= 0) {
            continue;
          }
          // find a match in the target extends self selector (the bit before :extend)
          selectorPath = [targetExtend.selfSelectors[0]];
          matches = extendVisitor.findMatch(extend, selectorPath);
          if (matches.length) {
            extend.hasFoundMatches = true;
            // we found a match, so for each self selector..
            extend.selfSelectors.forEach(function (selfSelector) {
              var info = targetExtend.visibilityInfo();
              // process the extend as usual
              newSelector = extendVisitor.extendSelector(matches, selectorPath, selfSelector, extend.isVisible());
              // but now we create a new extend from it
              newExtend = new tree_1.default.Extend(targetExtend.selector, targetExtend.option, 0, targetExtend.fileInfo(), info);
              newExtend.selfSelectors = newSelector;
              // add the extend onto the list of extends for that selector
              newSelector[newSelector.length - 1].extendList = [newExtend];
              // record that we need to add it.
              extendsToAdd.push(newExtend);
              newExtend.ruleset = targetExtend.ruleset;
              // remember its parents for circular references
              newExtend.parent_ids = newExtend.parent_ids.concat(targetExtend.parent_ids, extend.parent_ids);
              // only process the selector once.. if we have :extend(.a,.b) then multiple
              // extends will look at the same selector path, so when extending
              // we know that any others will be duplicates in terms of what is added to the css
              if (targetExtend.firstExtendOnThisSelectorPath) {
                newExtend.firstExtendOnThisSelectorPath = true;
                targetExtend.ruleset.paths.push(newSelector);
              }
            });
          }
        }
      }
      if (extendsToAdd.length) {
        // try to detect circular references to stop a stack overflow.
        // may no longer be needed.
        this.extendChainCount++;
        if (iterationCount > 100) {
          var selectorOne = '{unable to calculate}';
          var selectorTwo = '{unable to calculate}';
          try {
            selectorOne = extendsToAdd[0].selfSelectors[0].toCSS();
            selectorTwo = extendsToAdd[0].selector.toCSS();
          } catch (e) {}
          throw {
            message: "extend circular reference detected. One of the circular extends is currently:".concat(selectorOne, ":extend(").concat(selectorTwo, ")")
          };
        }
        // now process the new extends on the existing rules so that we can handle a extending b extending c extending
        // d extending e...
        return extendsToAdd.concat(extendVisitor.doExtendChaining(extendsToAdd, extendsListTarget, iterationCount + 1));
      } else {
        return extendsToAdd;
      }
    };
    ProcessExtendsVisitor.prototype.visitDeclaration = function (ruleNode, visitArgs) {
      visitArgs.visitDeeper = false;
    };
    ProcessExtendsVisitor.prototype.visitMixinDefinition = function (mixinDefinitionNode, visitArgs) {
      visitArgs.visitDeeper = false;
    };
    ProcessExtendsVisitor.prototype.visitSelector = function (selectorNode, visitArgs) {
      visitArgs.visitDeeper = false;
    };
    ProcessExtendsVisitor.prototype.visitRuleset = function (rulesetNode, visitArgs) {
      if (rulesetNode.root) {
        return;
      }
      var matches;
      var pathIndex;
      var extendIndex;
      var allExtends = this.allExtendsStack[this.allExtendsStack.length - 1];
      var selectorsToAdd = [];
      var extendVisitor = this;
      var selectorPath;
      // look at each selector path in the ruleset, find any extend matches and then copy, find and replace
      for (extendIndex = 0; extendIndex < allExtends.length; extendIndex++) {
        for (pathIndex = 0; pathIndex < rulesetNode.paths.length; pathIndex++) {
          selectorPath = rulesetNode.paths[pathIndex];
          // extending extends happens initially, before the main pass
          if (rulesetNode.extendOnEveryPath) {
            continue;
          }
          var extendList = selectorPath[selectorPath.length - 1].extendList;
          if (extendList && extendList.length) {
            continue;
          }
          matches = this.findMatch(allExtends[extendIndex], selectorPath);
          if (matches.length) {
            allExtends[extendIndex].hasFoundMatches = true;
            allExtends[extendIndex].selfSelectors.forEach(function (selfSelector) {
              var extendedSelectors;
              extendedSelectors = extendVisitor.extendSelector(matches, selectorPath, selfSelector, allExtends[extendIndex].isVisible());
              selectorsToAdd.push(extendedSelectors);
            });
          }
        }
      }
      rulesetNode.paths = rulesetNode.paths.concat(selectorsToAdd);
    };
    ProcessExtendsVisitor.prototype.findMatch = function (extend, haystackSelectorPath) {
      //
      // look through the haystack selector path to try and find the needle - extend.selector
      // returns an array of selector matches that can then be replaced
      //
      var haystackSelectorIndex;
      var hackstackSelector;
      var hackstackElementIndex;
      var haystackElement;
      var targetCombinator;
      var i;
      var extendVisitor = this;
      var needleElements = extend.selector.elements;
      var potentialMatches = [];
      var potentialMatch;
      var matches = [];
      // loop through the haystack elements
      for (haystackSelectorIndex = 0; haystackSelectorIndex < haystackSelectorPath.length; haystackSelectorIndex++) {
        hackstackSelector = haystackSelectorPath[haystackSelectorIndex];
        for (hackstackElementIndex = 0; hackstackElementIndex < hackstackSelector.elements.length; hackstackElementIndex++) {
          haystackElement = hackstackSelector.elements[hackstackElementIndex];
          // if we allow elements before our match we can add a potential match every time. otherwise only at the first element.
          if (extend.allowBefore || haystackSelectorIndex === 0 && hackstackElementIndex === 0) {
            potentialMatches.push({
              pathIndex: haystackSelectorIndex,
              index: hackstackElementIndex,
              matched: 0,
              initialCombinator: haystackElement.combinator
            });
          }
          for (i = 0; i < potentialMatches.length; i++) {
            potentialMatch = potentialMatches[i];
            // selectors add " " onto the first element. When we use & it joins the selectors together, but if we don't
            // then each selector in haystackSelectorPath has a space before it added in the toCSS phase. so we need to
            // work out what the resulting combinator will be
            targetCombinator = haystackElement.combinator.value;
            if (targetCombinator === '' && hackstackElementIndex === 0) {
              targetCombinator = ' ';
            }
            // if we don't match, null our match to indicate failure
            if (!extendVisitor.isElementValuesEqual(needleElements[potentialMatch.matched].value, haystackElement.value) || potentialMatch.matched > 0 && needleElements[potentialMatch.matched].combinator.value !== targetCombinator) {
              potentialMatch = null;
            } else {
              potentialMatch.matched++;
            }
            // if we are still valid and have finished, test whether we have elements after and whether these are allowed
            if (potentialMatch) {
              potentialMatch.finished = potentialMatch.matched === needleElements.length;
              if (potentialMatch.finished && !extend.allowAfter && (hackstackElementIndex + 1 < hackstackSelector.elements.length || haystackSelectorIndex + 1 < haystackSelectorPath.length)) {
                potentialMatch = null;
              }
            }
            // if null we remove, if not, we are still valid, so either push as a valid match or continue
            if (potentialMatch) {
              if (potentialMatch.finished) {
                potentialMatch.length = needleElements.length;
                potentialMatch.endPathIndex = haystackSelectorIndex;
                potentialMatch.endPathElementIndex = hackstackElementIndex + 1; // index after end of match
                potentialMatches.length = 0; // we don't allow matches to overlap, so start matching again
                matches.push(potentialMatch);
              }
            } else {
              potentialMatches.splice(i, 1);
              i--;
            }
          }
        }
      }
      return matches;
    };
    ProcessExtendsVisitor.prototype.isElementValuesEqual = function (elementValue1, elementValue2) {
      if (typeof elementValue1 === 'string' || typeof elementValue2 === 'string') {
        return elementValue1 === elementValue2;
      }
      if (elementValue1 instanceof tree_1.default.Attribute) {
        if (elementValue1.op !== elementValue2.op || elementValue1.key !== elementValue2.key) {
          return false;
        }
        if (!elementValue1.value || !elementValue2.value) {
          if (elementValue1.value || elementValue2.value) {
            return false;
          }
          return true;
        }
        elementValue1 = elementValue1.value.value || elementValue1.value;
        elementValue2 = elementValue2.value.value || elementValue2.value;
        return elementValue1 === elementValue2;
      }
      elementValue1 = elementValue1.value;
      elementValue2 = elementValue2.value;
      if (elementValue1 instanceof tree_1.default.Selector) {
        if (!(elementValue2 instanceof tree_1.default.Selector) || elementValue1.elements.length !== elementValue2.elements.length) {
          return false;
        }
        for (var i = 0; i < elementValue1.elements.length; i++) {
          if (elementValue1.elements[i].combinator.value !== elementValue2.elements[i].combinator.value) {
            if (i !== 0 || (elementValue1.elements[i].combinator.value || ' ') !== (elementValue2.elements[i].combinator.value || ' ')) {
              return false;
            }
          }
          if (!this.isElementValuesEqual(elementValue1.elements[i].value, elementValue2.elements[i].value)) {
            return false;
          }
        }
        return true;
      }
      return false;
    };
    ProcessExtendsVisitor.prototype.extendSelector = function (matches, selectorPath, replacementSelector, isVisible) {
      // for a set of matches, replace each match with the replacement selector
      var currentSelectorPathIndex = 0,
        currentSelectorPathElementIndex = 0,
        path = [],
        matchIndex,
        selector,
        firstElement,
        match,
        newElements;
      for (matchIndex = 0; matchIndex < matches.length; matchIndex++) {
        match = matches[matchIndex];
        selector = selectorPath[match.pathIndex];
        firstElement = new tree_1.default.Element(match.initialCombinator, replacementSelector.elements[0].value, replacementSelector.elements[0].isVariable, replacementSelector.elements[0].getIndex(), replacementSelector.elements[0].fileInfo());
        if (match.pathIndex > currentSelectorPathIndex && currentSelectorPathElementIndex > 0) {
          path[path.length - 1].elements = path[path.length - 1].elements.concat(selectorPath[currentSelectorPathIndex].elements.slice(currentSelectorPathElementIndex));
          currentSelectorPathElementIndex = 0;
          currentSelectorPathIndex++;
        }
        newElements = selector.elements.slice(currentSelectorPathElementIndex, match.index).concat([firstElement]).concat(replacementSelector.elements.slice(1));
        if (currentSelectorPathIndex === match.pathIndex && matchIndex > 0) {
          path[path.length - 1].elements = path[path.length - 1].elements.concat(newElements);
        } else {
          path = path.concat(selectorPath.slice(currentSelectorPathIndex, match.pathIndex));
          path.push(new tree_1.default.Selector(newElements));
        }
        currentSelectorPathIndex = match.endPathIndex;
        currentSelectorPathElementIndex = match.endPathElementIndex;
        if (currentSelectorPathElementIndex >= selectorPath[currentSelectorPathIndex].elements.length) {
          currentSelectorPathElementIndex = 0;
          currentSelectorPathIndex++;
        }
      }
      if (currentSelectorPathIndex < selectorPath.length && currentSelectorPathElementIndex > 0) {
        path[path.length - 1].elements = path[path.length - 1].elements.concat(selectorPath[currentSelectorPathIndex].elements.slice(currentSelectorPathElementIndex));
        currentSelectorPathIndex++;
      }
      path = path.concat(selectorPath.slice(currentSelectorPathIndex, selectorPath.length));
      path = path.map(function (currentValue) {
        // we can re-use elements here, because the visibility property matters only for selectors
        var derived = currentValue.createDerived(currentValue.elements);
        if (isVisible) {
          derived.ensureVisibility();
        } else {
          derived.ensureInvisibility();
        }
        return derived;
      });
      return path;
    };
    ProcessExtendsVisitor.prototype.visitMedia = function (mediaNode, visitArgs) {
      var newAllExtends = mediaNode.allExtends.concat(this.allExtendsStack[this.allExtendsStack.length - 1]);
      newAllExtends = newAllExtends.concat(this.doExtendChaining(newAllExtends, mediaNode.allExtends));
      this.allExtendsStack.push(newAllExtends);
    };
    ProcessExtendsVisitor.prototype.visitMediaOut = function (mediaNode) {
      var lastIndex = this.allExtendsStack.length - 1;
      this.allExtendsStack.length = lastIndex;
    };
    ProcessExtendsVisitor.prototype.visitAtRule = function (atRuleNode, visitArgs) {
      var newAllExtends = atRuleNode.allExtends.concat(this.allExtendsStack[this.allExtendsStack.length - 1]);
      newAllExtends = newAllExtends.concat(this.doExtendChaining(newAllExtends, atRuleNode.allExtends));
      this.allExtendsStack.push(newAllExtends);
    };
    ProcessExtendsVisitor.prototype.visitAtRuleOut = function (atRuleNode) {
      var lastIndex = this.allExtendsStack.length - 1;
      this.allExtendsStack.length = lastIndex;
    };
    return ProcessExtendsVisitor;
  }();
  extendVisitor.default = ProcessExtendsVisitor;
  return extendVisitor;
}

var joinSelectorVisitor = {};

var hasRequiredJoinSelectorVisitor;
function requireJoinSelectorVisitor() {
  if (hasRequiredJoinSelectorVisitor) return joinSelectorVisitor;
  hasRequiredJoinSelectorVisitor = 1;
  Object.defineProperty(joinSelectorVisitor, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  /* eslint-disable no-unused-vars */
  /**
   * @todo - Remove unused when JSDoc types are added for visitor methods
   */
  var visitor_1 = tslib_1.__importDefault(requireVisitor());
  var JoinSelectorVisitor = /** @class */function () {
    function JoinSelectorVisitor() {
      this.contexts = [[]];
      this._visitor = new visitor_1.default(this);
    }
    JoinSelectorVisitor.prototype.run = function (root) {
      return this._visitor.visit(root);
    };
    JoinSelectorVisitor.prototype.visitDeclaration = function (declNode, visitArgs) {
      visitArgs.visitDeeper = false;
    };
    JoinSelectorVisitor.prototype.visitMixinDefinition = function (mixinDefinitionNode, visitArgs) {
      visitArgs.visitDeeper = false;
    };
    JoinSelectorVisitor.prototype.visitRuleset = function (rulesetNode, visitArgs) {
      var context = this.contexts[this.contexts.length - 1];
      var paths = [];
      var selectors;
      this.contexts.push(paths);
      if (!rulesetNode.root) {
        selectors = rulesetNode.selectors;
        if (selectors) {
          selectors = selectors.filter(function (selector) {
            return selector.getIsOutput();
          });
          rulesetNode.selectors = selectors.length ? selectors : selectors = null;
          if (selectors) {
            rulesetNode.joinSelectors(paths, context, selectors);
          }
        }
        if (!selectors) {
          rulesetNode.rules = null;
        }
        rulesetNode.paths = paths;
      }
    };
    JoinSelectorVisitor.prototype.visitRulesetOut = function (rulesetNode) {
      this.contexts.length = this.contexts.length - 1;
    };
    JoinSelectorVisitor.prototype.visitMedia = function (mediaNode, visitArgs) {
      var context = this.contexts[this.contexts.length - 1];
      mediaNode.rules[0].root = context.length === 0 || context[0].multiMedia;
    };
    JoinSelectorVisitor.prototype.visitAtRule = function (atRuleNode, visitArgs) {
      var context = this.contexts[this.contexts.length - 1];
      if (atRuleNode.rules && atRuleNode.rules.length) {
        atRuleNode.rules[0].root = atRuleNode.isRooted || context.length === 0 || null;
      }
    };
    return JoinSelectorVisitor;
  }();
  joinSelectorVisitor.default = JoinSelectorVisitor;
  return joinSelectorVisitor;
}

var toCssVisitor = {};

var hasRequiredToCssVisitor;
function requireToCssVisitor() {
  if (hasRequiredToCssVisitor) return toCssVisitor;
  hasRequiredToCssVisitor = 1;
  Object.defineProperty(toCssVisitor, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  /* eslint-disable no-unused-vars */
  /**
   * @todo - Remove unused when JSDoc types are added for visitor methods
   */
  var tree_1 = tslib_1.__importDefault(requireTree());
  var visitor_1 = tslib_1.__importDefault(requireVisitor());
  var CSSVisitorUtils = /** @class */function () {
    function CSSVisitorUtils(context) {
      this._visitor = new visitor_1.default(this);
      this._context = context;
    }
    CSSVisitorUtils.prototype.containsSilentNonBlockedChild = function (bodyRules) {
      var rule;
      if (!bodyRules) {
        return false;
      }
      for (var r = 0; r < bodyRules.length; r++) {
        rule = bodyRules[r];
        if (rule.isSilent && rule.isSilent(this._context) && !rule.blocksVisibility()) {
          // the atrule contains something that was referenced (likely by extend)
          // therefore it needs to be shown in output too
          return true;
        }
      }
      return false;
    };
    CSSVisitorUtils.prototype.keepOnlyVisibleChilds = function (owner) {
      if (owner && owner.rules) {
        owner.rules = owner.rules.filter(function (thing) {
          return thing.isVisible();
        });
      }
    };
    CSSVisitorUtils.prototype.isEmpty = function (owner) {
      return owner && owner.rules ? owner.rules.length === 0 : true;
    };
    CSSVisitorUtils.prototype.hasVisibleSelector = function (rulesetNode) {
      return rulesetNode && rulesetNode.paths ? rulesetNode.paths.length > 0 : false;
    };
    CSSVisitorUtils.prototype.resolveVisibility = function (node) {
      if (!node.blocksVisibility()) {
        if (this.isEmpty(node)) {
          return;
        }
        return node;
      }
      var compiledRulesBody = node.rules[0];
      this.keepOnlyVisibleChilds(compiledRulesBody);
      if (this.isEmpty(compiledRulesBody)) {
        return;
      }
      node.ensureVisibility();
      node.removeVisibilityBlock();
      return node;
    };
    CSSVisitorUtils.prototype.isVisibleRuleset = function (rulesetNode) {
      if (rulesetNode.firstRoot) {
        return true;
      }
      if (this.isEmpty(rulesetNode)) {
        return false;
      }
      if (!rulesetNode.root && !this.hasVisibleSelector(rulesetNode)) {
        return false;
      }
      return true;
    };
    return CSSVisitorUtils;
  }();
  var ToCSSVisitor = function (context) {
    this._visitor = new visitor_1.default(this);
    this._context = context;
    this.utils = new CSSVisitorUtils(context);
  };
  ToCSSVisitor.prototype = {
    isReplacing: true,
    run: function (root) {
      return this._visitor.visit(root);
    },
    visitDeclaration: function (declNode, visitArgs) {
      if (declNode.blocksVisibility() || declNode.variable) {
        return;
      }
      return declNode;
    },
    visitMixinDefinition: function (mixinNode, visitArgs) {
      // mixin definitions do not get eval'd - this means they keep state
      // so we have to clear that state here so it isn't used if toCSS is called twice
      mixinNode.frames = [];
    },
    visitExtend: function (extendNode, visitArgs) {},
    visitComment: function (commentNode, visitArgs) {
      if (commentNode.blocksVisibility() || commentNode.isSilent(this._context)) {
        return;
      }
      return commentNode;
    },
    visitMedia: function (mediaNode, visitArgs) {
      var originalRules = mediaNode.rules[0].rules;
      mediaNode.accept(this._visitor);
      visitArgs.visitDeeper = false;
      return this.utils.resolveVisibility(mediaNode, originalRules);
    },
    visitImport: function (importNode, visitArgs) {
      if (importNode.blocksVisibility()) {
        return;
      }
      return importNode;
    },
    visitAtRule: function (atRuleNode, visitArgs) {
      if (atRuleNode.rules && atRuleNode.rules.length) {
        return this.visitAtRuleWithBody(atRuleNode, visitArgs);
      } else {
        return this.visitAtRuleWithoutBody(atRuleNode, visitArgs);
      }
    },
    visitAnonymous: function (anonymousNode, visitArgs) {
      if (!anonymousNode.blocksVisibility()) {
        anonymousNode.accept(this._visitor);
        return anonymousNode;
      }
    },
    visitAtRuleWithBody: function (atRuleNode, visitArgs) {
      // if there is only one nested ruleset and that one has no path, then it is
      // just fake ruleset
      function hasFakeRuleset(atRuleNode) {
        var bodyRules = atRuleNode.rules;
        return bodyRules.length === 1 && (!bodyRules[0].paths || bodyRules[0].paths.length === 0);
      }
      function getBodyRules(atRuleNode) {
        var nodeRules = atRuleNode.rules;
        if (hasFakeRuleset(atRuleNode)) {
          return nodeRules[0].rules;
        }
        return nodeRules;
      }
      // it is still true that it is only one ruleset in array
      // this is last such moment
      // process childs
      var originalRules = getBodyRules(atRuleNode);
      atRuleNode.accept(this._visitor);
      visitArgs.visitDeeper = false;
      if (!this.utils.isEmpty(atRuleNode)) {
        this._mergeRules(atRuleNode.rules[0].rules);
      }
      return this.utils.resolveVisibility(atRuleNode, originalRules);
    },
    visitAtRuleWithoutBody: function (atRuleNode, visitArgs) {
      if (atRuleNode.blocksVisibility()) {
        return;
      }
      if (atRuleNode.name === '@charset') {
        // Only output the debug info together with subsequent @charset definitions
        // a comment (or @media statement) before the actual @charset atrule would
        // be considered illegal css as it has to be on the first line
        if (this.charset) {
          if (atRuleNode.debugInfo) {
            var comment = new tree_1.default.Comment("/* ".concat(atRuleNode.toCSS(this._context).replace(/\n/g, ''), " */\n"));
            comment.debugInfo = atRuleNode.debugInfo;
            return this._visitor.visit(comment);
          }
          return;
        }
        this.charset = true;
      }
      return atRuleNode;
    },
    checkValidNodes: function (rules, isRoot) {
      if (!rules) {
        return;
      }
      for (var i = 0; i < rules.length; i++) {
        var ruleNode = rules[i];
        if (isRoot && ruleNode instanceof tree_1.default.Declaration && !ruleNode.variable) {
          throw {
            message: 'Properties must be inside selector blocks. They cannot be in the root',
            index: ruleNode.getIndex(),
            filename: ruleNode.fileInfo() && ruleNode.fileInfo().filename
          };
        }
        if (ruleNode instanceof tree_1.default.Call) {
          throw {
            message: "Function '".concat(ruleNode.name, "' did not return a root node"),
            index: ruleNode.getIndex(),
            filename: ruleNode.fileInfo() && ruleNode.fileInfo().filename
          };
        }
        if (ruleNode.type && !ruleNode.allowRoot) {
          throw {
            message: "".concat(ruleNode.type, " node returned by a function is not valid here"),
            index: ruleNode.getIndex(),
            filename: ruleNode.fileInfo() && ruleNode.fileInfo().filename
          };
        }
      }
    },
    visitRuleset: function (rulesetNode, visitArgs) {
      // at this point rulesets are nested into each other
      var rule;
      var rulesets = [];
      this.checkValidNodes(rulesetNode.rules, rulesetNode.firstRoot);
      if (!rulesetNode.root) {
        // remove invisible paths
        this._compileRulesetPaths(rulesetNode);
        // remove rulesets from this ruleset body and compile them separately
        var nodeRules = rulesetNode.rules;
        var nodeRuleCnt = nodeRules ? nodeRules.length : 0;
        for (var i = 0; i < nodeRuleCnt;) {
          rule = nodeRules[i];
          if (rule && rule.rules) {
            // visit because we are moving them out from being a child
            rulesets.push(this._visitor.visit(rule));
            nodeRules.splice(i, 1);
            nodeRuleCnt--;
            continue;
          }
          i++;
        }
        // accept the visitor to remove rules and refactor itself
        // then we can decide nogw whether we want it or not
        // compile body
        if (nodeRuleCnt > 0) {
          rulesetNode.accept(this._visitor);
        } else {
          rulesetNode.rules = null;
        }
        visitArgs.visitDeeper = false;
      } else {
        // if (! rulesetNode.root) {
        rulesetNode.accept(this._visitor);
        visitArgs.visitDeeper = false;
      }
      if (rulesetNode.rules) {
        this._mergeRules(rulesetNode.rules);
        this._removeDuplicateRules(rulesetNode.rules);
      }
      // now decide whether we keep the ruleset
      if (this.utils.isVisibleRuleset(rulesetNode)) {
        rulesetNode.ensureVisibility();
        rulesets.splice(0, 0, rulesetNode);
      }
      if (rulesets.length === 1) {
        return rulesets[0];
      }
      return rulesets;
    },
    _compileRulesetPaths: function (rulesetNode) {
      if (rulesetNode.paths) {
        rulesetNode.paths = rulesetNode.paths.filter(function (p) {
          var i;
          if (p[0].elements[0].combinator.value === ' ') {
            p[0].elements[0].combinator = new tree_1.default.Combinator('');
          }
          for (i = 0; i < p.length; i++) {
            if (p[i].isVisible() && p[i].getIsOutput()) {
              return true;
            }
          }
          return false;
        });
      }
    },
    _removeDuplicateRules: function (rules) {
      if (!rules) {
        return;
      }
      // remove duplicates
      var ruleCache = {};
      var ruleList;
      var rule;
      var i;
      for (i = rules.length - 1; i >= 0; i--) {
        rule = rules[i];
        if (rule instanceof tree_1.default.Declaration) {
          if (!ruleCache[rule.name]) {
            ruleCache[rule.name] = rule;
          } else {
            ruleList = ruleCache[rule.name];
            if (ruleList instanceof tree_1.default.Declaration) {
              ruleList = ruleCache[rule.name] = [ruleCache[rule.name].toCSS(this._context)];
            }
            var ruleCSS = rule.toCSS(this._context);
            if (ruleList.indexOf(ruleCSS) !== -1) {
              rules.splice(i, 1);
            } else {
              ruleList.push(ruleCSS);
            }
          }
        }
      }
    },
    _mergeRules: function (rules) {
      if (!rules) {
        return;
      }
      var groups = {};
      var groupsArr = [];
      for (var i = 0; i < rules.length; i++) {
        var rule = rules[i];
        if (rule.merge) {
          var key = rule.name;
          groups[key] ? rules.splice(i--, 1) : groupsArr.push(groups[key] = []);
          groups[key].push(rule);
        }
      }
      groupsArr.forEach(function (group) {
        if (group.length > 0) {
          var result_1 = group[0];
          var space_1 = [];
          var comma_1 = [new tree_1.default.Expression(space_1)];
          group.forEach(function (rule) {
            if (rule.merge === '+' && space_1.length > 0) {
              comma_1.push(new tree_1.default.Expression(space_1 = []));
            }
            space_1.push(rule.value);
            result_1.important = result_1.important || rule.important;
          });
          result_1.value = new tree_1.default.Value(comma_1);
        }
      });
    }
  };
  toCssVisitor.default = ToCSSVisitor;
  return toCssVisitor;
}

var hasRequiredVisitors;
function requireVisitors() {
  if (hasRequiredVisitors) return visitors;
  hasRequiredVisitors = 1;
  Object.defineProperty(visitors, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var visitor_1 = tslib_1.__importDefault(requireVisitor());
  var import_visitor_1 = tslib_1.__importDefault(requireImportVisitor());
  var set_tree_visibility_visitor_1 = tslib_1.__importDefault(requireSetTreeVisibilityVisitor());
  var extend_visitor_1 = tslib_1.__importDefault(requireExtendVisitor());
  var join_selector_visitor_1 = tslib_1.__importDefault(requireJoinSelectorVisitor());
  var to_css_visitor_1 = tslib_1.__importDefault(requireToCssVisitor());
  visitors.default = {
    Visitor: visitor_1.default,
    ImportVisitor: import_visitor_1.default,
    MarkVisibleSelectorsVisitor: set_tree_visibility_visitor_1.default,
    ExtendVisitor: extend_visitor_1.default,
    JoinSelectorVisitor: join_selector_visitor_1.default,
    ToCSSVisitor: to_css_visitor_1.default
  };
  return visitors;
}

var parserInput = {};

var chunker = {};

var hasRequiredChunker;
function requireChunker() {
  if (hasRequiredChunker) return chunker;
  hasRequiredChunker = 1;
  Object.defineProperty(chunker, "__esModule", {
    value: true
  });
  // Split the input into chunks.
  function default_1(input, fail) {
    var len = input.length;
    var level = 0;
    var parenLevel = 0;
    var lastOpening;
    var lastOpeningParen;
    var lastMultiComment;
    var lastMultiCommentEndBrace;
    var chunks = [];
    var emitFrom = 0;
    var chunkerCurrentIndex;
    var currentChunkStartIndex;
    var cc;
    var cc2;
    var matched;
    function emitChunk(force) {
      var len = chunkerCurrentIndex - emitFrom;
      if (len < 512 && !force || !len) {
        return;
      }
      chunks.push(input.slice(emitFrom, chunkerCurrentIndex + 1));
      emitFrom = chunkerCurrentIndex + 1;
    }
    for (chunkerCurrentIndex = 0; chunkerCurrentIndex < len; chunkerCurrentIndex++) {
      cc = input.charCodeAt(chunkerCurrentIndex);
      if (cc >= 97 && cc <= 122 || cc < 34) {
        // a-z or whitespace
        continue;
      }
      switch (cc) {
        case 40:
          // (
          parenLevel++;
          lastOpeningParen = chunkerCurrentIndex;
          continue;
        case 41:
          // )
          if (--parenLevel < 0) {
            return fail('missing opening `(`', chunkerCurrentIndex);
          }
          continue;
        case 59:
          // ;
          if (!parenLevel) {
            emitChunk();
          }
          continue;
        case 123:
          // {
          level++;
          lastOpening = chunkerCurrentIndex;
          continue;
        case 125:
          // }
          if (--level < 0) {
            return fail('missing opening `{`', chunkerCurrentIndex);
          }
          if (!level && !parenLevel) {
            emitChunk();
          }
          continue;
        case 92:
          // \
          if (chunkerCurrentIndex < len - 1) {
            chunkerCurrentIndex++;
            continue;
          }
          return fail('unescaped `\\`', chunkerCurrentIndex);
        case 34:
        case 39:
        case 96:
          // ", ' and `
          matched = 0;
          currentChunkStartIndex = chunkerCurrentIndex;
          for (chunkerCurrentIndex = chunkerCurrentIndex + 1; chunkerCurrentIndex < len; chunkerCurrentIndex++) {
            cc2 = input.charCodeAt(chunkerCurrentIndex);
            if (cc2 > 96) {
              continue;
            }
            if (cc2 == cc) {
              matched = 1;
              break;
            }
            if (cc2 == 92) {
              // \
              if (chunkerCurrentIndex == len - 1) {
                return fail('unescaped `\\`', chunkerCurrentIndex);
              }
              chunkerCurrentIndex++;
            }
          }
          if (matched) {
            continue;
          }
          return fail("unmatched `".concat(String.fromCharCode(cc), "`"), currentChunkStartIndex);
        case 47:
          // /, check for comment
          if (parenLevel || chunkerCurrentIndex == len - 1) {
            continue;
          }
          cc2 = input.charCodeAt(chunkerCurrentIndex + 1);
          if (cc2 == 47) {
            // //, find lnfeed
            for (chunkerCurrentIndex = chunkerCurrentIndex + 2; chunkerCurrentIndex < len; chunkerCurrentIndex++) {
              cc2 = input.charCodeAt(chunkerCurrentIndex);
              if (cc2 <= 13 && (cc2 == 10 || cc2 == 13)) {
                break;
              }
            }
          } else if (cc2 == 42) {
            // /*, find */
            lastMultiComment = currentChunkStartIndex = chunkerCurrentIndex;
            for (chunkerCurrentIndex = chunkerCurrentIndex + 2; chunkerCurrentIndex < len - 1; chunkerCurrentIndex++) {
              cc2 = input.charCodeAt(chunkerCurrentIndex);
              if (cc2 == 125) {
                lastMultiCommentEndBrace = chunkerCurrentIndex;
              }
              if (cc2 != 42) {
                continue;
              }
              if (input.charCodeAt(chunkerCurrentIndex + 1) == 47) {
                break;
              }
            }
            if (chunkerCurrentIndex == len - 1) {
              return fail('missing closing `*/`', currentChunkStartIndex);
            }
            chunkerCurrentIndex++;
          }
          continue;
        case 42:
          // *, check for unmatched */
          if (chunkerCurrentIndex < len - 1 && input.charCodeAt(chunkerCurrentIndex + 1) == 47) {
            return fail('unmatched `/*`', chunkerCurrentIndex);
          }
          continue;
      }
    }
    if (level !== 0) {
      if (lastMultiComment > lastOpening && lastMultiCommentEndBrace > lastMultiComment) {
        return fail('missing closing `}` or `*/`', lastOpening);
      } else {
        return fail('missing closing `}`', lastOpening);
      }
    } else if (parenLevel !== 0) {
      return fail('missing closing `)`', lastOpeningParen);
    }
    emitChunk(true);
    return chunks;
  }
  chunker.default = default_1;
  return chunker;
}

var hasRequiredParserInput;
function requireParserInput() {
  if (hasRequiredParserInput) return parserInput;
  hasRequiredParserInput = 1;
  Object.defineProperty(parserInput, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var chunker_1 = tslib_1.__importDefault(requireChunker());
  parserInput.default = function () {
    var
    // Less input string
    input;
    var
    // current chunk
    j;
    var
    // holds state for backtracking
    saveStack = [];
    var
    // furthest index the parser has gone to
    furthest;
    var
    // if this is furthest we got to, this is the probably cause
    furthestPossibleErrorMessage;
    var
    // chunkified input
    chunks;
    var
    // current chunk
    current;
    var
    // index of current chunk, in `input`
    currentPos;
    var parserInput = {};
    var CHARCODE_SPACE = 32;
    var CHARCODE_TAB = 9;
    var CHARCODE_LF = 10;
    var CHARCODE_CR = 13;
    var CHARCODE_PLUS = 43;
    var CHARCODE_COMMA = 44;
    var CHARCODE_FORWARD_SLASH = 47;
    var CHARCODE_9 = 57;
    function skipWhitespace(length) {
      var oldi = parserInput.i;
      var oldj = j;
      var curr = parserInput.i - currentPos;
      var endIndex = parserInput.i + current.length - curr;
      var mem = parserInput.i += length;
      var inp = input;
      var c;
      var nextChar;
      var comment;
      for (; parserInput.i < endIndex; parserInput.i++) {
        c = inp.charCodeAt(parserInput.i);
        if (parserInput.autoCommentAbsorb && c === CHARCODE_FORWARD_SLASH) {
          nextChar = inp.charAt(parserInput.i + 1);
          if (nextChar === '/') {
            comment = {
              index: parserInput.i,
              isLineComment: true
            };
            var nextNewLine = inp.indexOf('\n', parserInput.i + 2);
            if (nextNewLine < 0) {
              nextNewLine = endIndex;
            }
            parserInput.i = nextNewLine;
            comment.text = inp.substr(comment.index, parserInput.i - comment.index);
            parserInput.commentStore.push(comment);
            continue;
          } else if (nextChar === '*') {
            var nextStarSlash = inp.indexOf('*/', parserInput.i + 2);
            if (nextStarSlash >= 0) {
              comment = {
                index: parserInput.i,
                text: inp.substr(parserInput.i, nextStarSlash + 2 - parserInput.i),
                isLineComment: false
              };
              parserInput.i += comment.text.length - 1;
              parserInput.commentStore.push(comment);
              continue;
            }
          }
          break;
        }
        if (c !== CHARCODE_SPACE && c !== CHARCODE_LF && c !== CHARCODE_TAB && c !== CHARCODE_CR) {
          break;
        }
      }
      current = current.slice(length + parserInput.i - mem + curr);
      currentPos = parserInput.i;
      if (!current.length) {
        if (j < chunks.length - 1) {
          current = chunks[++j];
          skipWhitespace(0); // skip space at the beginning of a chunk
          return true; // things changed
        }
        parserInput.finished = true;
      }
      return oldi !== parserInput.i || oldj !== j;
    }
    parserInput.save = function () {
      currentPos = parserInput.i;
      saveStack.push({
        current: current,
        i: parserInput.i,
        j: j
      });
    };
    parserInput.restore = function (possibleErrorMessage) {
      if (parserInput.i > furthest || parserInput.i === furthest && possibleErrorMessage && !furthestPossibleErrorMessage) {
        furthest = parserInput.i;
        furthestPossibleErrorMessage = possibleErrorMessage;
      }
      var state = saveStack.pop();
      current = state.current;
      currentPos = parserInput.i = state.i;
      j = state.j;
    };
    parserInput.forget = function () {
      saveStack.pop();
    };
    parserInput.isWhitespace = function (offset) {
      var pos = parserInput.i + (offset || 0);
      var code = input.charCodeAt(pos);
      return code === CHARCODE_SPACE || code === CHARCODE_CR || code === CHARCODE_TAB || code === CHARCODE_LF;
    };
    // Specialization of $(tok)
    parserInput.$re = function (tok) {
      if (parserInput.i > currentPos) {
        current = current.slice(parserInput.i - currentPos);
        currentPos = parserInput.i;
      }
      var m = tok.exec(current);
      if (!m) {
        return null;
      }
      skipWhitespace(m[0].length);
      if (typeof m === 'string') {
        return m;
      }
      return m.length === 1 ? m[0] : m;
    };
    parserInput.$char = function (tok) {
      if (input.charAt(parserInput.i) !== tok) {
        return null;
      }
      skipWhitespace(1);
      return tok;
    };
    parserInput.$peekChar = function (tok) {
      if (input.charAt(parserInput.i) !== tok) {
        return null;
      }
      return tok;
    };
    parserInput.$str = function (tok) {
      var tokLength = tok.length;
      // https://jsperf.com/string-startswith/21
      for (var i = 0; i < tokLength; i++) {
        if (input.charAt(parserInput.i + i) !== tok.charAt(i)) {
          return null;
        }
      }
      skipWhitespace(tokLength);
      return tok;
    };
    parserInput.$quoted = function (loc) {
      var pos = loc || parserInput.i;
      var startChar = input.charAt(pos);
      if (startChar !== '\'' && startChar !== '"') {
        return;
      }
      var length = input.length;
      var currentPosition = pos;
      for (var i = 1; i + currentPosition < length; i++) {
        var nextChar = input.charAt(i + currentPosition);
        switch (nextChar) {
          case '\\':
            i++;
            continue;
          case '\r':
          case '\n':
            break;
          case startChar:
            {
              var str = input.substr(currentPosition, i + 1);
              if (!loc && loc !== 0) {
                skipWhitespace(i + 1);
                return str;
              }
              return [startChar, str];
            }
        }
      }
      return null;
    };
    /**
     * Permissive parsing. Ignores everything except matching {} [] () and quotes
     * until matching token (outside of blocks)
     */
    parserInput.$parseUntil = function (tok) {
      var quote = '';
      var returnVal = null;
      var inComment = false;
      var blockDepth = 0;
      var blockStack = [];
      var parseGroups = [];
      var length = input.length;
      var startPos = parserInput.i;
      var lastPos = parserInput.i;
      var i = parserInput.i;
      var loop = true;
      var testChar;
      if (typeof tok === 'string') {
        testChar = function (char) {
          return char === tok;
        };
      } else {
        testChar = function (char) {
          return tok.test(char);
        };
      }
      do {
        var nextChar = input.charAt(i);
        if (blockDepth === 0 && testChar(nextChar)) {
          returnVal = input.substr(lastPos, i - lastPos);
          if (returnVal) {
            parseGroups.push(returnVal);
          } else {
            parseGroups.push(' ');
          }
          returnVal = parseGroups;
          skipWhitespace(i - startPos);
          loop = false;
        } else {
          if (inComment) {
            if (nextChar === '*' && input.charAt(i + 1) === '/') {
              i++;
              blockDepth--;
              inComment = false;
            }
            i++;
            continue;
          }
          switch (nextChar) {
            case '\\':
              i++;
              nextChar = input.charAt(i);
              parseGroups.push(input.substr(lastPos, i - lastPos + 1));
              lastPos = i + 1;
              break;
            case '/':
              if (input.charAt(i + 1) === '*') {
                i++;
                inComment = true;
                blockDepth++;
              }
              break;
            case '\'':
            case '"':
              quote = parserInput.$quoted(i);
              if (quote) {
                parseGroups.push(input.substr(lastPos, i - lastPos), quote);
                i += quote[1].length - 1;
                lastPos = i + 1;
              } else {
                skipWhitespace(i - startPos);
                returnVal = nextChar;
                loop = false;
              }
              break;
            case '{':
              blockStack.push('}');
              blockDepth++;
              break;
            case '(':
              blockStack.push(')');
              blockDepth++;
              break;
            case '[':
              blockStack.push(']');
              blockDepth++;
              break;
            case '}':
            case ')':
            case ']':
              {
                var expected = blockStack.pop();
                if (nextChar === expected) {
                  blockDepth--;
                } else {
                  // move the parser to the error and return expected
                  skipWhitespace(i - startPos);
                  returnVal = expected;
                  loop = false;
                }
              }
          }
          i++;
          if (i > length) {
            loop = false;
          }
        }
      } while (loop);
      return returnVal ? returnVal : null;
    };
    parserInput.autoCommentAbsorb = true;
    parserInput.commentStore = [];
    parserInput.finished = false;
    // Same as $(), but don't change the state of the parser,
    // just return the match.
    parserInput.peek = function (tok) {
      if (typeof tok === 'string') {
        // https://jsperf.com/string-startswith/21
        for (var i = 0; i < tok.length; i++) {
          if (input.charAt(parserInput.i + i) !== tok.charAt(i)) {
            return false;
          }
        }
        return true;
      } else {
        return tok.test(current);
      }
    };
    // Specialization of peek()
    // TODO remove or change some currentChar calls to peekChar
    parserInput.peekChar = function (tok) {
      return input.charAt(parserInput.i) === tok;
    };
    parserInput.currentChar = function () {
      return input.charAt(parserInput.i);
    };
    parserInput.prevChar = function () {
      return input.charAt(parserInput.i - 1);
    };
    parserInput.getInput = function () {
      return input;
    };
    parserInput.peekNotNumeric = function () {
      var c = input.charCodeAt(parserInput.i);
      // Is the first char of the dimension 0-9, '.', '+' or '-'
      return c > CHARCODE_9 || c < CHARCODE_PLUS || c === CHARCODE_FORWARD_SLASH || c === CHARCODE_COMMA;
    };
    parserInput.start = function (str, chunkInput, failFunction) {
      input = str;
      parserInput.i = j = currentPos = furthest = 0;
      // chunking apparently makes things quicker (but my tests indicate
      // it might actually make things slower in node at least)
      // and it is a non-perfect parse - it can't recognise
      // unquoted urls, meaning it can't distinguish comments
      // meaning comments with quotes or {}() in them get 'counted'
      // and then lead to parse errors.
      // In addition if the chunking chunks in the wrong place we might
      // not be able to parse a parser statement in one go
      // this is officially deprecated but can be switched on via an option
      // in the case it causes too much performance issues.
      if (chunkInput) {
        chunks = (0, chunker_1.default)(str, failFunction);
      } else {
        chunks = [str];
      }
      current = chunks[0];
      skipWhitespace(0);
    };
    parserInput.end = function () {
      var message;
      var isFinished = parserInput.i >= input.length;
      if (parserInput.i < furthest) {
        message = furthestPossibleErrorMessage;
        parserInput.i = furthest;
      }
      return {
        isFinished: isFinished,
        furthest: parserInput.i,
        furthestPossibleErrorMessage: message,
        furthestReachedEnd: parserInput.i >= input.length - 1,
        furthestChar: input[parserInput.i]
      };
    };
    return parserInput;
  };
  return parserInput;
}

var functionRegistry = {};

var hasRequiredFunctionRegistry;
function requireFunctionRegistry() {
  if (hasRequiredFunctionRegistry) return functionRegistry;
  hasRequiredFunctionRegistry = 1;
  Object.defineProperty(functionRegistry, "__esModule", {
    value: true
  });
  function makeRegistry(base) {
    return {
      _data: {},
      add: function (name, func) {
        // precautionary case conversion, as later querying of
        // the registry by function-caller uses lower case as well.
        name = name.toLowerCase();
        // eslint-disable-next-line no-prototype-builtins
        if (this._data.hasOwnProperty(name)) ;
        this._data[name] = func;
      },
      addMultiple: function (functions) {
        var _this = this;
        Object.keys(functions).forEach(function (name) {
          _this.add(name, functions[name]);
        });
      },
      get: function (name) {
        return this._data[name] || base && base.get(name);
      },
      getLocalFunctions: function () {
        return this._data;
      },
      inherit: function () {
        return makeRegistry(this);
      },
      create: function (base) {
        return makeRegistry(base);
      }
    };
  }
  functionRegistry.default = makeRegistry(null);
  return functionRegistry;
}

var atruleSyntax = {};

var hasRequiredAtruleSyntax;
function requireAtruleSyntax() {
  if (hasRequiredAtruleSyntax) return atruleSyntax;
  hasRequiredAtruleSyntax = 1;
  Object.defineProperty(atruleSyntax, "__esModule", {
    value: true
  });
  atruleSyntax.ContainerSyntaxOptions = atruleSyntax.MediaSyntaxOptions = void 0;
  atruleSyntax.MediaSyntaxOptions = {
    queryInParens: true
  };
  atruleSyntax.ContainerSyntaxOptions = {
    queryInParens: true
  };
  return atruleSyntax;
}

var hasRequiredParser;
function requireParser() {
  if (hasRequiredParser) return parser;
  hasRequiredParser = 1;
  Object.defineProperty(parser, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var less_error_1 = tslib_1.__importDefault(requireLessError());
  var tree_1 = tslib_1.__importDefault(requireTree());
  var visitors_1 = tslib_1.__importDefault(requireVisitors());
  var parser_input_1 = tslib_1.__importDefault(requireParserInput());
  var utils = tslib_1.__importStar(requireUtils());
  var function_registry_1 = tslib_1.__importDefault(requireFunctionRegistry());
  var atrule_syntax_1 = requireAtruleSyntax();
  //
  // less.js - parser
  //
  //    A relatively straight-forward predictive parser.
  //    There is no tokenization/lexing stage, the input is parsed
  //    in one sweep.
  //
  //    To make the parser fast enough to run in the browser, several
  //    optimization had to be made:
  //
  //    - Matching and slicing on a huge input is often cause of slowdowns.
  //      The solution is to chunkify the input into smaller strings.
  //      The chunks are stored in the `chunks` var,
  //      `j` holds the current chunk index, and `currentPos` holds
  //      the index of the current chunk in relation to `input`.
  //      This gives us an almost 4x speed-up.
  //
  //    - In many cases, we don't need to match individual tokens;
  //      for example, if a value doesn't hold any variables, operations
  //      or dynamic references, the parser can effectively 'skip' it,
  //      treating it as a literal.
  //      An example would be '1px solid #000' - which evaluates to itself,
  //      we don't need to know what the individual components are.
  //      The drawback, of course is that you don't get the benefits of
  //      syntax-checking on the CSS. This gives us a 50% speed-up in the parser,
  //      and a smaller speed-up in the code-gen.
  //
  //
  //    Token matching is done with the `$` function, which either takes
  //    a terminal string or regexp, or a non-terminal function to call.
  //    It also takes care of moving all the indices forwards.
  //
  var Parser = function Parser(context, imports, fileInfo, currentIndex) {
    currentIndex = currentIndex || 0;
    var parsers;
    var parserInput = (0, parser_input_1.default)();
    function error(msg, type) {
      throw new less_error_1.default({
        index: parserInput.i,
        filename: fileInfo.filename,
        type: type || 'Syntax',
        message: msg
      }, imports);
    }
    function expect(arg, msg) {
      // some older browsers return typeof 'function' for RegExp
      var result = arg instanceof Function ? arg.call(parsers) : parserInput.$re(arg);
      if (result) {
        return result;
      }
      error(msg || (typeof arg === 'string' ? "expected '".concat(arg, "' got '").concat(parserInput.currentChar(), "'") : 'unexpected token'));
    }
    // Specialization of expect()
    function expectChar(arg, msg) {
      if (parserInput.$char(arg)) {
        return arg;
      }
      error("expected '".concat(arg, "' got '").concat(parserInput.currentChar(), "'"));
    }
    function getDebugInfo(index) {
      var filename = fileInfo.filename;
      return {
        lineNumber: utils.getLocation(index, parserInput.getInput()).line + 1,
        fileName: filename
      };
    }
    /**
     *  Used after initial parsing to create nodes on the fly
     *
     *  @param {String} str          - string to parse
     *  @param {Array}  parseList    - array of parsers to run input through e.g. ["value", "important"]
     *  @param {Number} currentIndex - start number to begin indexing
     *  @param {Object} fileInfo     - fileInfo to attach to created nodes
     */
    function parseNode(str, parseList, callback) {
      var result;
      var returnNodes = [];
      var parser = parserInput;
      try {
        parser.start(str, false, function fail(msg, index) {
          callback({
            message: msg,
            index: index + currentIndex
          });
        });
        for (var x = 0, p = void 0; p = parseList[x]; x++) {
          result = parsers[p]();
          returnNodes.push(result || null);
        }
        var endInfo = parser.end();
        if (endInfo.isFinished) {
          callback(null, returnNodes);
        } else {
          callback(true, null);
        }
      } catch (e) {
        throw new less_error_1.default({
          index: e.index + currentIndex,
          message: e.message
        }, imports, fileInfo.filename);
      }
    }
    //
    // The Parser
    //
    return {
      parserInput: parserInput,
      imports: imports,
      fileInfo: fileInfo,
      parseNode: parseNode,
      //
      // Parse an input string into an abstract syntax tree,
      // @param str A string containing 'less' markup
      // @param callback call `callback` when done.
      // @param [additionalData] An optional map which can contains vars - a map (key, value) of variables to apply
      //
      parse: function (str, callback, additionalData) {
        var root;
        var err = null;
        var globalVars;
        var modifyVars;
        var ignored;
        var preText = '';
        // Optionally disable @plugin parsing
        if (additionalData && additionalData.disablePluginRule) {
          parsers.plugin = function () {
            var dir = parserInput.$re(/^@plugin?\s+/);
            if (dir) {
              error('@plugin statements are not allowed when disablePluginRule is set to true');
            }
          };
        }
        globalVars = additionalData && additionalData.globalVars ? "".concat(Parser.serializeVars(additionalData.globalVars), "\n") : '';
        modifyVars = additionalData && additionalData.modifyVars ? "\n".concat(Parser.serializeVars(additionalData.modifyVars)) : '';
        if (context.pluginManager) {
          var preProcessors = context.pluginManager.getPreProcessors();
          for (var i = 0; i < preProcessors.length; i++) {
            str = preProcessors[i].process(str, {
              context: context,
              imports: imports,
              fileInfo: fileInfo
            });
          }
        }
        if (globalVars || additionalData && additionalData.banner) {
          preText = (additionalData && additionalData.banner ? additionalData.banner : '') + globalVars;
          ignored = imports.contentsIgnoredChars;
          ignored[fileInfo.filename] = ignored[fileInfo.filename] || 0;
          ignored[fileInfo.filename] += preText.length;
        }
        str = str.replace(/\r\n?/g, '\n');
        // Remove potential UTF Byte Order Mark
        str = preText + str.replace(/^\uFEFF/, '') + modifyVars;
        imports.contents[fileInfo.filename] = str;
        // Start with the primary rule.
        // The whole syntax tree is held under a Ruleset node,
        // with the `root` property set to true, so no `{}` are
        // output. The callback is called when the input is parsed.
        try {
          parserInput.start(str, context.chunkInput, function fail(msg, index) {
            throw new less_error_1.default({
              index: index,
              type: 'Parse',
              message: msg,
              filename: fileInfo.filename
            }, imports);
          });
          tree_1.default.Node.prototype.parse = this;
          root = new tree_1.default.Ruleset(null, this.parsers.primary());
          tree_1.default.Node.prototype.rootNode = root;
          root.root = true;
          root.firstRoot = true;
          root.functionRegistry = function_registry_1.default.inherit();
        } catch (e) {
          return callback(new less_error_1.default(e, imports, fileInfo.filename));
        }
        // If `i` is smaller than the `input.length - 1`,
        // it means the parser wasn't able to parse the whole
        // string, so we've got a parsing error.
        //
        // We try to extract a \n delimited string,
        // showing the line where the parse error occurred.
        // We split it up into two parts (the part which parsed,
        // and the part which didn't), so we can color them differently.
        var endInfo = parserInput.end();
        if (!endInfo.isFinished) {
          var message = endInfo.furthestPossibleErrorMessage;
          if (!message) {
            message = 'Unrecognised input';
            if (endInfo.furthestChar === '}') {
              message += '. Possibly missing opening \'{\'';
            } else if (endInfo.furthestChar === ')') {
              message += '. Possibly missing opening \'(\'';
            } else if (endInfo.furthestReachedEnd) {
              message += '. Possibly missing something';
            }
          }
          err = new less_error_1.default({
            type: 'Parse',
            message: message,
            index: endInfo.furthest,
            filename: fileInfo.filename
          }, imports);
        }
        var finish = function (e) {
          e = err || e || imports.error;
          if (e) {
            if (!(e instanceof less_error_1.default)) {
              e = new less_error_1.default(e, imports, fileInfo.filename);
            }
            return callback(e);
          } else {
            return callback(null, root);
          }
        };
        if (context.processImports !== false) {
          new visitors_1.default.ImportVisitor(imports, finish).run(root);
        } else {
          return finish();
        }
      },
      //
      // Here in, the parsing rules/functions
      //
      // The basic structure of the syntax tree generated is as follows:
      //
      //   Ruleset ->  Declaration -> Value -> Expression -> Entity
      //
      // Here's some Less code:
      //
      //    .class {
      //      color: #fff;
      //      border: 1px solid #000;
      //      width: @w + 4px;
      //      > .child {...}
      //    }
      //
      // And here's what the parse tree might look like:
      //
      //     Ruleset (Selector '.class', [
      //         Declaration ("color",  Value ([Expression [Color #fff]]))
      //         Declaration ("border", Value ([Expression [Dimension 1px][Keyword "solid"][Color #000]]))
      //         Declaration ("width",  Value ([Expression [Operation " + " [Variable "@w"][Dimension 4px]]]))
      //         Ruleset (Selector [Element '>', '.child'], [...])
      //     ])
      //
      //  In general, most rules will try to parse a token with the `$re()` function, and if the return
      //  value is truly, will return a new node, of the relevant type. Sometimes, we need to check
      //  first, before parsing, that's when we use `peek()`.
      //
      parsers: parsers = {
        //
        // The `primary` rule is the *entry* and *exit* point of the parser.
        // The rules here can appear at any level of the parse tree.
        //
        // The recursive nature of the grammar is an interplay between the `block`
        // rule, which represents `{ ... }`, the `ruleset` rule, and this `primary` rule,
        // as represented by this simplified grammar:
        //
        //     primary    (ruleset | declaration)+
        //     ruleset    selector+ block
        //     block      '{' primary '}'
        //
        // Only at one point is the primary rule not called from the
        // block rule: at the root level.
        //
        primary: function () {
          var mixin = this.mixin;
          var root = [];
          var node;
          while (true) {
            while (true) {
              node = this.comment();
              if (!node) {
                break;
              }
              root.push(node);
            }
            // always process comments before deciding if finished
            if (parserInput.finished) {
              break;
            }
            if (parserInput.peek('}')) {
              break;
            }
            node = this.extendRule();
            if (node) {
              root = root.concat(node);
              continue;
            }
            node = mixin.definition() || this.declaration() || mixin.call(false, false) || this.ruleset() || this.variableCall() || this.entities.call() || this.atrule();
            if (node) {
              root.push(node);
            } else {
              var foundSemiColon = false;
              while (parserInput.$char(';')) {
                foundSemiColon = true;
              }
              if (!foundSemiColon) {
                break;
              }
            }
          }
          return root;
        },
        // comments are collected by the main parsing mechanism and then assigned to nodes
        // where the current structure allows it
        comment: function () {
          if (parserInput.commentStore.length) {
            var comment = parserInput.commentStore.shift();
            return new tree_1.default.Comment(comment.text, comment.isLineComment, comment.index + currentIndex, fileInfo);
          }
        },
        //
        // Entities are tokens which can be found inside an Expression
        //
        entities: {
          mixinLookup: function () {
            return parsers.mixin.call(true, true);
          },
          //
          // A string, which supports escaping " and '
          //
          //     "milky way" 'he\'s the one!'
          //
          quoted: function (forceEscaped) {
            var str;
            var index = parserInput.i;
            var isEscaped = false;
            parserInput.save();
            if (parserInput.$char('~')) {
              isEscaped = true;
            } else if (forceEscaped) {
              parserInput.restore();
              return;
            }
            str = parserInput.$quoted();
            if (!str) {
              parserInput.restore();
              return;
            }
            parserInput.forget();
            return new tree_1.default.Quoted(str.charAt(0), str.substr(1, str.length - 2), isEscaped, index + currentIndex, fileInfo);
          },
          //
          // A catch-all word, such as:
          //
          //     black border-collapse
          //
          keyword: function () {
            var k = parserInput.$char('%') || parserInput.$re(/^\[?(?:[\w-]|\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+\]?/);
            if (k) {
              return tree_1.default.Color.fromKeyword(k) || new tree_1.default.Keyword(k);
            }
          },
          //
          // A function call
          //
          //     rgb(255, 0, 255)
          //
          // The arguments are parsed with the `entities.arguments` parser.
          //
          call: function () {
            var name;
            var args;
            var func;
            var index = parserInput.i;
            // http://jsperf.com/case-insensitive-regex-vs-strtolower-then-regex/18
            if (parserInput.peek(/^url\(/i)) {
              return;
            }
            parserInput.save();
            name = parserInput.$re(/^([\w-]+|%|~|progid:[\w.]+)\(/);
            if (!name) {
              parserInput.forget();
              return;
            }
            name = name[1];
            func = this.customFuncCall(name);
            if (func) {
              args = func.parse();
              if (args && func.stop) {
                parserInput.forget();
                return args;
              }
            }
            args = this.arguments(args);
            if (!parserInput.$char(')')) {
              parserInput.restore('Could not parse call arguments or missing \')\'');
              return;
            }
            parserInput.forget();
            return new tree_1.default.Call(name, args, index + currentIndex, fileInfo);
          },
          declarationCall: function () {
            var validCall;
            var args;
            var index = parserInput.i;
            parserInput.save();
            validCall = parserInput.$re(/^[\w]+\(/);
            if (!validCall) {
              parserInput.forget();
              return;
            }
            validCall = validCall.substring(0, validCall.length - 1);
            var rule = this.ruleProperty();
            var value;
            if (rule) {
              value = this.value();
            }
            if (rule && value) {
              args = [new tree_1.default.Declaration(rule, value, null, null, parserInput.i + currentIndex, fileInfo, true)];
            }
            if (!parserInput.$char(')')) {
              parserInput.restore('Could not parse call arguments or missing \')\'');
              return;
            }
            parserInput.forget();
            return new tree_1.default.Call(validCall, args, index + currentIndex, fileInfo);
          },
          //
          // Parsing rules for functions with non-standard args, e.g.:
          //
          //     boolean(not(2 > 1))
          //
          //     This is a quick prototype, to be modified/improved when
          //     more custom-parsed funcs come (e.g. `selector(...)`)
          //
          customFuncCall: function (name) {
            /* Ideally the table is to be moved out of here for faster perf.,
               but it's quite tricky since it relies on all these `parsers`
               and `expect` available only here */
            return {
              alpha: f(parsers.ieAlpha, true),
              boolean: f(condition),
              'if': f(condition)
            }[name.toLowerCase()];
            function f(parse, stop) {
              return {
                parse: parse,
                stop: stop // when true - stop after parse() and return its result,
                // otherwise continue for plain args
              };
            }
            function condition() {
              return [expect(parsers.condition, 'expected condition')];
            }
          },
          arguments: function (prevArgs) {
            var argsComma = prevArgs || [];
            var argsSemiColon = [];
            var isSemiColonSeparated;
            var value;
            parserInput.save();
            while (true) {
              if (prevArgs) {
                prevArgs = false;
              } else {
                value = parsers.detachedRuleset() || this.assignment() || parsers.expression();
                if (!value) {
                  break;
                }
                if (value.value && value.value.length == 1) {
                  value = value.value[0];
                }
                argsComma.push(value);
              }
              if (parserInput.$char(',')) {
                continue;
              }
              if (parserInput.$char(';') || isSemiColonSeparated) {
                isSemiColonSeparated = true;
                value = argsComma.length < 1 ? argsComma[0] : new tree_1.default.Value(argsComma);
                argsSemiColon.push(value);
                argsComma = [];
              }
            }
            parserInput.forget();
            return isSemiColonSeparated ? argsSemiColon : argsComma;
          },
          literal: function () {
            return this.dimension() || this.color() || this.quoted() || this.unicodeDescriptor();
          },
          // Assignments are argument entities for calls.
          // They are present in ie filter properties as shown below.
          //
          //     filter: progid:DXImageTransform.Microsoft.Alpha( *opacity=50* )
          //
          assignment: function () {
            var key;
            var value;
            parserInput.save();
            key = parserInput.$re(/^\w+(?=\s?=)/i);
            if (!key) {
              parserInput.restore();
              return;
            }
            if (!parserInput.$char('=')) {
              parserInput.restore();
              return;
            }
            value = parsers.entity();
            if (value) {
              parserInput.forget();
              return new tree_1.default.Assignment(key, value);
            } else {
              parserInput.restore();
            }
          },
          //
          // Parse url() tokens
          //
          // We use a specific rule for urls, because they don't really behave like
          // standard function calls. The difference is that the argument doesn't have
          // to be enclosed within a string, so it can't be parsed as an Expression.
          //
          url: function () {
            var value;
            var index = parserInput.i;
            parserInput.autoCommentAbsorb = false;
            if (!parserInput.$str('url(')) {
              parserInput.autoCommentAbsorb = true;
              return;
            }
            value = this.quoted() || this.variable() || this.property() || parserInput.$re(/^(?:(?:\\[()'"])|[^()'"])+/) || '';
            parserInput.autoCommentAbsorb = true;
            expectChar(')');
            return new tree_1.default.URL(value.value !== undefined || value instanceof tree_1.default.Variable || value instanceof tree_1.default.Property ? value : new tree_1.default.Anonymous(value, index), index + currentIndex, fileInfo);
          },
          //
          // A Variable entity, such as `@fink`, in
          //
          //     width: @fink + 2px
          //
          // We use a different parser for variable definitions,
          // see `parsers.variable`.
          //
          variable: function () {
            var ch;
            var name;
            var index = parserInput.i;
            parserInput.save();
            if (parserInput.currentChar() === '@' && (name = parserInput.$re(/^@@?[\w-]+/))) {
              ch = parserInput.currentChar();
              if (ch === '(' || ch === '[' && !parserInput.prevChar().match(/^\s/)) {
                // this may be a VariableCall lookup
                var result = parsers.variableCall(name);
                if (result) {
                  parserInput.forget();
                  return result;
                }
              }
              parserInput.forget();
              return new tree_1.default.Variable(name, index + currentIndex, fileInfo);
            }
            parserInput.restore();
          },
          // A variable entity using the protective {} e.g. @{var}
          variableCurly: function () {
            var curly;
            var index = parserInput.i;
            if (parserInput.currentChar() === '@' && (curly = parserInput.$re(/^@\{([\w-]+)\}/))) {
              return new tree_1.default.Variable("@".concat(curly[1]), index + currentIndex, fileInfo);
            }
          },
          //
          // A Property accessor, such as `$color`, in
          //
          //     background-color: $color
          //
          property: function () {
            var name;
            var index = parserInput.i;
            if (parserInput.currentChar() === '$' && (name = parserInput.$re(/^\$[\w-]+/))) {
              return new tree_1.default.Property(name, index + currentIndex, fileInfo);
            }
          },
          // A property entity useing the protective {} e.g. ${prop}
          propertyCurly: function () {
            var curly;
            var index = parserInput.i;
            if (parserInput.currentChar() === '$' && (curly = parserInput.$re(/^\$\{([\w-]+)\}/))) {
              return new tree_1.default.Property("$".concat(curly[1]), index + currentIndex, fileInfo);
            }
          },
          //
          // A Hexadecimal color
          //
          //     #4F3C2F
          //
          // `rgb` and `hsl` colors are parsed through the `entities.call` parser.
          //
          color: function () {
            var rgb;
            parserInput.save();
            if (parserInput.currentChar() === '#' && (rgb = parserInput.$re(/^#([A-Fa-f0-9]{8}|[A-Fa-f0-9]{6}|[A-Fa-f0-9]{3,4})([\w.#[])?/))) {
              if (!rgb[2]) {
                parserInput.forget();
                return new tree_1.default.Color(rgb[1], undefined, rgb[0]);
              }
            }
            parserInput.restore();
          },
          colorKeyword: function () {
            parserInput.save();
            var autoCommentAbsorb = parserInput.autoCommentAbsorb;
            parserInput.autoCommentAbsorb = false;
            var k = parserInput.$re(/^[_A-Za-z-][_A-Za-z0-9-]+/);
            parserInput.autoCommentAbsorb = autoCommentAbsorb;
            if (!k) {
              parserInput.forget();
              return;
            }
            parserInput.restore();
            var color = tree_1.default.Color.fromKeyword(k);
            if (color) {
              parserInput.$str(k);
              return color;
            }
          },
          //
          // A Dimension, that is, a number and a unit
          //
          //     0.5em 95%
          //
          dimension: function () {
            if (parserInput.peekNotNumeric()) {
              return;
            }
            var value = parserInput.$re(/^([+-]?\d*\.?\d+)(%|[a-z_]+)?/i);
            if (value) {
              return new tree_1.default.Dimension(value[1], value[2]);
            }
          },
          //
          // A unicode descriptor, as is used in unicode-range
          //
          // U+0??  or U+00A1-00A9
          //
          unicodeDescriptor: function () {
            var ud;
            ud = parserInput.$re(/^U\+[0-9a-fA-F?]+(-[0-9a-fA-F?]+)?/);
            if (ud) {
              return new tree_1.default.UnicodeDescriptor(ud[0]);
            }
          },
          //
          // JavaScript code to be evaluated
          //
          //     `window.location.href`
          //
          javascript: function () {
            var js;
            var index = parserInput.i;
            parserInput.save();
            var escape = parserInput.$char('~');
            var jsQuote = parserInput.$char('`');
            if (!jsQuote) {
              parserInput.restore();
              return;
            }
            js = parserInput.$re(/^[^`]*`/);
            if (js) {
              parserInput.forget();
              return new tree_1.default.JavaScript(js.substr(0, js.length - 1), Boolean(escape), index + currentIndex, fileInfo);
            }
            parserInput.restore('invalid javascript definition');
          }
        },
        //
        // The variable part of a variable definition. Used in the `rule` parser
        //
        //     @fink:
        //
        variable: function () {
          var name;
          if (parserInput.currentChar() === '@' && (name = parserInput.$re(/^(@[\w-]+)\s*:/))) {
            return name[1];
          }
        },
        //
        // Call a variable value to retrieve a detached ruleset
        // or a value from a detached ruleset's rules.
        //
        //     @fink();
        //     @fink;
        //     color: @fink[@color];
        //
        variableCall: function (parsedName) {
          var lookups;
          var i = parserInput.i;
          var inValue = !!parsedName;
          var name = parsedName;
          parserInput.save();
          if (name || parserInput.currentChar() === '@' && (name = parserInput.$re(/^(@[\w-]+)(\(\s*\))?/))) {
            lookups = this.mixin.ruleLookups();
            if (!lookups && (inValue && parserInput.$str('()') !== '()' || name[2] !== '()')) {
              parserInput.restore('Missing \'[...]\' lookup in variable call');
              return;
            }
            if (!inValue) {
              name = name[1];
            }
            var call = new tree_1.default.VariableCall(name, i, fileInfo);
            if (!inValue && parsers.end()) {
              parserInput.forget();
              return call;
            } else {
              parserInput.forget();
              return new tree_1.default.NamespaceValue(call, lookups, i, fileInfo);
            }
          }
          parserInput.restore();
        },
        //
        // extend syntax - used to extend selectors
        //
        extend: function (isRule) {
          var elements;
          var e;
          var index = parserInput.i;
          var option;
          var extendList;
          var extend;
          if (!parserInput.$str(isRule ? '&:extend(' : ':extend(')) {
            return;
          }
          do {
            option = null;
            elements = null;
            while (!(option = parserInput.$re(/^(all)(?=\s*(\)|,))/))) {
              e = this.element();
              if (!e) {
                break;
              }
              if (elements) {
                elements.push(e);
              } else {
                elements = [e];
              }
            }
            option = option && option[1];
            if (!elements) {
              error('Missing target selector for :extend().');
            }
            extend = new tree_1.default.Extend(new tree_1.default.Selector(elements), option, index + currentIndex, fileInfo);
            if (extendList) {
              extendList.push(extend);
            } else {
              extendList = [extend];
            }
          } while (parserInput.$char(','));
          expect(/^\)/);
          if (isRule) {
            expect(/^;/);
          }
          return extendList;
        },
        //
        // extendRule - used in a rule to extend all the parent selectors
        //
        extendRule: function () {
          return this.extend(true);
        },
        //
        // Mixins
        //
        mixin: {
          //
          // A Mixin call, with an optional argument list
          //
          //     #mixins > .square(#fff);
          //     #mixins.square(#fff);
          //     .rounded(4px, black);
          //     .button;
          //
          // We can lookup / return a value using the lookup syntax:
          //
          //     color: #mixin.square(#fff)[@color];
          //
          // The `while` loop is there because mixins can be
          // namespaced, but we only support the child and descendant
          // selector for now.
          //
          call: function (inValue, getLookup) {
            var s = parserInput.currentChar();
            var important = false;
            var lookups;
            var index = parserInput.i;
            var elements;
            var args;
            var hasParens;
            if (s !== '.' && s !== '#') {
              return;
            }
            parserInput.save(); // stop us absorbing part of an invalid selector
            elements = this.elements();
            if (elements) {
              if (parserInput.$char('(')) {
                args = this.args(true).args;
                expectChar(')');
                hasParens = true;
              }
              if (getLookup !== false) {
                lookups = this.ruleLookups();
              }
              if (getLookup === true && !lookups) {
                parserInput.restore();
                return;
              }
              if (inValue && !lookups && !hasParens) {
                // This isn't a valid in-value mixin call
                parserInput.restore();
                return;
              }
              if (!inValue && parsers.important()) {
                important = true;
              }
              if (inValue || parsers.end()) {
                parserInput.forget();
                var mixin = new tree_1.default.mixin.Call(elements, args, index + currentIndex, fileInfo, !lookups && important);
                if (lookups) {
                  return new tree_1.default.NamespaceValue(mixin, lookups);
                } else {
                  return mixin;
                }
              }
            }
            parserInput.restore();
          },
          /**
           * Matching elements for mixins
           * (Start with . or # and can have > )
           */
          elements: function () {
            var elements;
            var e;
            var c;
            var elem;
            var elemIndex;
            var re = /^[#.](?:[\w-]|\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+/;
            while (true) {
              elemIndex = parserInput.i;
              e = parserInput.$re(re);
              if (!e) {
                break;
              }
              elem = new tree_1.default.Element(c, e, false, elemIndex + currentIndex, fileInfo);
              if (elements) {
                elements.push(elem);
              } else {
                elements = [elem];
              }
              c = parserInput.$char('>');
            }
            return elements;
          },
          args: function (isCall) {
            var entities = parsers.entities;
            var returner = {
              args: null,
              variadic: false
            };
            var expressions = [];
            var argsSemiColon = [];
            var argsComma = [];
            var isSemiColonSeparated;
            var expressionContainsNamed;
            var name;
            var nameLoop;
            var value;
            var arg;
            var expand;
            var hasSep = true;
            parserInput.save();
            while (true) {
              if (isCall) {
                arg = parsers.detachedRuleset() || parsers.expression();
              } else {
                parserInput.commentStore.length = 0;
                if (parserInput.$str('...')) {
                  returner.variadic = true;
                  if (parserInput.$char(';') && !isSemiColonSeparated) {
                    isSemiColonSeparated = true;
                  }
                  (isSemiColonSeparated ? argsSemiColon : argsComma).push({
                    variadic: true
                  });
                  break;
                }
                arg = entities.variable() || entities.property() || entities.literal() || entities.keyword() || this.call(true);
              }
              if (!arg || !hasSep) {
                break;
              }
              nameLoop = null;
              if (arg.throwAwayComments) {
                arg.throwAwayComments();
              }
              value = arg;
              var val = null;
              if (isCall) {
                // Variable
                if (arg.value && arg.value.length == 1) {
                  val = arg.value[0];
                }
              } else {
                val = arg;
              }
              if (val && (val instanceof tree_1.default.Variable || val instanceof tree_1.default.Property)) {
                if (parserInput.$char(':')) {
                  if (expressions.length > 0) {
                    if (isSemiColonSeparated) {
                      error('Cannot mix ; and , as delimiter types');
                    }
                    expressionContainsNamed = true;
                  }
                  value = parsers.detachedRuleset() || parsers.expression();
                  if (!value) {
                    if (isCall) {
                      error('could not understand value for named argument');
                    } else {
                      parserInput.restore();
                      returner.args = [];
                      return returner;
                    }
                  }
                  nameLoop = name = val.name;
                } else if (parserInput.$str('...')) {
                  if (!isCall) {
                    returner.variadic = true;
                    if (parserInput.$char(';') && !isSemiColonSeparated) {
                      isSemiColonSeparated = true;
                    }
                    (isSemiColonSeparated ? argsSemiColon : argsComma).push({
                      name: arg.name,
                      variadic: true
                    });
                    break;
                  } else {
                    expand = true;
                  }
                } else if (!isCall) {
                  name = nameLoop = val.name;
                  value = null;
                }
              }
              if (value) {
                expressions.push(value);
              }
              argsComma.push({
                name: nameLoop,
                value: value,
                expand: expand
              });
              if (parserInput.$char(',')) {
                hasSep = true;
                continue;
              }
              hasSep = parserInput.$char(';') === ';';
              if (hasSep || isSemiColonSeparated) {
                if (expressionContainsNamed) {
                  error('Cannot mix ; and , as delimiter types');
                }
                isSemiColonSeparated = true;
                if (expressions.length > 1) {
                  value = new tree_1.default.Value(expressions);
                }
                argsSemiColon.push({
                  name: name,
                  value: value,
                  expand: expand
                });
                name = null;
                expressions = [];
                expressionContainsNamed = false;
              }
            }
            parserInput.forget();
            returner.args = isSemiColonSeparated ? argsSemiColon : argsComma;
            return returner;
          },
          //
          // A Mixin definition, with a list of parameters
          //
          //     .rounded (@radius: 2px, @color) {
          //        ...
          //     }
          //
          // Until we have a finer grained state-machine, we have to
          // do a look-ahead, to make sure we don't have a mixin call.
          // See the `rule` function for more information.
          //
          // We start by matching `.rounded (`, and then proceed on to
          // the argument list, which has optional default values.
          // We store the parameters in `params`, with a `value` key,
          // if there is a value, such as in the case of `@radius`.
          //
          // Once we've got our params list, and a closing `)`, we parse
          // the `{...}` block.
          //
          definition: function () {
            var name;
            var params = [];
            var match;
            var ruleset;
            var cond;
            var variadic = false;
            if (parserInput.currentChar() !== '.' && parserInput.currentChar() !== '#' || parserInput.peek(/^[^{]*\}/)) {
              return;
            }
            parserInput.save();
            match = parserInput.$re(/^([#.](?:[\w-]|\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+)\s*\(/);
            if (match) {
              name = match[1];
              var argInfo = this.args(false);
              params = argInfo.args;
              variadic = argInfo.variadic;
              // .mixincall("@{a}");
              // looks a bit like a mixin definition..
              // also
              // .mixincall(@a: {rule: set;});
              // so we have to be nice and restore
              if (!parserInput.$char(')')) {
                parserInput.restore('Missing closing \')\'');
                return;
              }
              parserInput.commentStore.length = 0;
              if (parserInput.$str('when')) {
                // Guard
                cond = expect(parsers.conditions, 'expected condition');
              }
              ruleset = parsers.block();
              if (ruleset) {
                parserInput.forget();
                return new tree_1.default.mixin.Definition(name, params, ruleset, cond, variadic);
              } else {
                parserInput.restore();
              }
            } else {
              parserInput.restore();
            }
          },
          ruleLookups: function () {
            var rule;
            var lookups = [];
            if (parserInput.currentChar() !== '[') {
              return;
            }
            while (true) {
              parserInput.save();
              rule = this.lookupValue();
              if (!rule && rule !== '') {
                parserInput.restore();
                break;
              }
              lookups.push(rule);
              parserInput.forget();
            }
            if (lookups.length > 0) {
              return lookups;
            }
          },
          lookupValue: function () {
            parserInput.save();
            if (!parserInput.$char('[')) {
              parserInput.restore();
              return;
            }
            var name = parserInput.$re(/^(?:[@$]{0,2})[_a-zA-Z0-9-]*/);
            if (!parserInput.$char(']')) {
              parserInput.restore();
              return;
            }
            if (name || name === '') {
              parserInput.forget();
              return name;
            }
            parserInput.restore();
          }
        },
        //
        // Entities are the smallest recognized token,
        // and can be found inside a rule's value.
        //
        entity: function () {
          var entities = this.entities;
          return this.comment() || entities.literal() || entities.variable() || entities.url() || entities.property() || entities.call() || entities.keyword() || this.mixin.call(true) || entities.javascript();
        },
        //
        // A Declaration terminator. Note that we use `peek()` to check for '}',
        // because the `block` rule will be expecting it, but we still need to make sure
        // it's there, if ';' was omitted.
        //
        end: function () {
          return parserInput.$char(';') || parserInput.peek('}');
        },
        //
        // IE's alpha function
        //
        //     alpha(opacity=88)
        //
        ieAlpha: function () {
          var value;
          // http://jsperf.com/case-insensitive-regex-vs-strtolower-then-regex/18
          if (!parserInput.$re(/^opacity=/i)) {
            return;
          }
          value = parserInput.$re(/^\d+/);
          if (!value) {
            value = expect(parsers.entities.variable, 'Could not parse alpha');
            value = "@{".concat(value.name.slice(1), "}");
          }
          expectChar(')');
          return new tree_1.default.Quoted('', "alpha(opacity=".concat(value, ")"));
        },
        //
        // A Selector Element
        //
        //     div
        //     + h1
        //     #socks
        //     input[type="text"]
        //
        // Elements are the building blocks for Selectors,
        // they are made out of a `Combinator` (see combinator rule),
        // and an element name, such as a tag a class, or `*`.
        //
        element: function () {
          var e;
          var c;
          var v;
          var index = parserInput.i;
          c = this.combinator();
          e = parserInput.$re(/^(?:\d+\.\d+|\d+)%/) ||
          // eslint-disable-next-line no-control-regex
          parserInput.$re(/^(?:[.#]?|:*)(?:[\w-]|[^\x00-\x9f]|\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+/) || parserInput.$char('*') || parserInput.$char('&') || this.attribute() || parserInput.$re(/^\([^&()@]+\)/) || parserInput.$re(/^[.#:](?=@)/) || this.entities.variableCurly();
          if (!e) {
            parserInput.save();
            if (parserInput.$char('(')) {
              if ((v = this.selector(false)) && parserInput.$char(')')) {
                e = new tree_1.default.Paren(v);
                parserInput.forget();
              } else {
                parserInput.restore('Missing closing \')\'');
              }
            } else {
              parserInput.forget();
            }
          }
          if (e) {
            return new tree_1.default.Element(c, e, e instanceof tree_1.default.Variable, index + currentIndex, fileInfo);
          }
        },
        //
        // Combinators combine elements together, in a Selector.
        //
        // Because our parser isn't white-space sensitive, special care
        // has to be taken, when parsing the descendant combinator, ` `,
        // as it's an empty space. We have to check the previous character
        // in the input, to see if it's a ` ` character. More info on how
        // we deal with this in *combinator.js*.
        //
        combinator: function () {
          var c = parserInput.currentChar();
          if (c === '/') {
            parserInput.save();
            var slashedCombinator = parserInput.$re(/^\/[a-z]+\//i);
            if (slashedCombinator) {
              parserInput.forget();
              return new tree_1.default.Combinator(slashedCombinator);
            }
            parserInput.restore();
          }
          if (c === '>' || c === '+' || c === '~' || c === '|' || c === '^') {
            parserInput.i++;
            if (c === '^' && parserInput.currentChar() === '^') {
              c = '^^';
              parserInput.i++;
            }
            while (parserInput.isWhitespace()) {
              parserInput.i++;
            }
            return new tree_1.default.Combinator(c);
          } else if (parserInput.isWhitespace(-1)) {
            return new tree_1.default.Combinator(' ');
          } else {
            return new tree_1.default.Combinator(null);
          }
        },
        //
        // A CSS Selector
        // with less extensions e.g. the ability to extend and guard
        //
        //     .class > div + h1
        //     li a:hover
        //
        // Selectors are made out of one or more Elements, see above.
        //
        selector: function (isLess) {
          var index = parserInput.i;
          var elements;
          var extendList;
          var c;
          var e;
          var allExtends;
          var when;
          var condition;
          isLess = isLess !== false;
          while (isLess && (extendList = this.extend()) || isLess && (when = parserInput.$str('when')) || (e = this.element())) {
            if (when) {
              condition = expect(this.conditions, 'expected condition');
            } else if (condition) {
              error('CSS guard can only be used at the end of selector');
            } else if (extendList) {
              if (allExtends) {
                allExtends = allExtends.concat(extendList);
              } else {
                allExtends = extendList;
              }
            } else {
              if (allExtends) {
                error('Extend can only be used at the end of selector');
              }
              c = parserInput.currentChar();
              if (elements) {
                elements.push(e);
              } else {
                elements = [e];
              }
              e = null;
            }
            if (c === '{' || c === '}' || c === ';' || c === ',' || c === ')') {
              break;
            }
          }
          if (elements) {
            return new tree_1.default.Selector(elements, allExtends, condition, index + currentIndex, fileInfo);
          }
          if (allExtends) {
            error('Extend must be used to extend a selector, it cannot be used on its own');
          }
        },
        selectors: function () {
          var s;
          var selectors;
          while (true) {
            s = this.selector();
            if (!s) {
              break;
            }
            if (selectors) {
              selectors.push(s);
            } else {
              selectors = [s];
            }
            parserInput.commentStore.length = 0;
            if (s.condition && selectors.length > 1) {
              error('Guards are only currently allowed on a single selector.');
            }
            if (!parserInput.$char(',')) {
              break;
            }
            if (s.condition) {
              error('Guards are only currently allowed on a single selector.');
            }
            parserInput.commentStore.length = 0;
          }
          return selectors;
        },
        attribute: function () {
          if (!parserInput.$char('[')) {
            return;
          }
          var entities = this.entities;
          var key;
          var val;
          var op;
          //
          // case-insensitive flag
          // e.g. [attr operator value i]
          //
          var cif;
          if (!(key = entities.variableCurly())) {
            key = expect(/^(?:[_A-Za-z0-9-*]*\|)?(?:[_A-Za-z0-9-]|\\.)+/);
          }
          op = parserInput.$re(/^[|~*$^]?=/);
          if (op) {
            val = entities.quoted() || parserInput.$re(/^[0-9]+%/) || parserInput.$re(/^[\w-]+/) || entities.variableCurly();
            if (val) {
              cif = parserInput.$re(/^[iIsS]/);
            }
          }
          expectChar(']');
          return new tree_1.default.Attribute(key, op, val, cif);
        },
        //
        // The `block` rule is used by `ruleset` and `mixin.definition`.
        // It's a wrapper around the `primary` rule, with added `{}`.
        //
        block: function () {
          var content;
          if (parserInput.$char('{') && (content = this.primary()) && parserInput.$char('}')) {
            return content;
          }
        },
        blockRuleset: function () {
          var block = this.block();
          if (block) {
            block = new tree_1.default.Ruleset(null, block);
          }
          return block;
        },
        detachedRuleset: function () {
          var argInfo;
          var params;
          var variadic;
          parserInput.save();
          if (parserInput.$re(/^[.#]\(/)) {
            /**
             * DR args currently only implemented for each() function, and not
             * yet settable as `@dr: #(@arg) {}`
             * This should be done when DRs are merged with mixins.
             * See: https://github.com/less/less-meta/issues/16
             */
            argInfo = this.mixin.args(false);
            params = argInfo.args;
            variadic = argInfo.variadic;
            if (!parserInput.$char(')')) {
              parserInput.restore();
              return;
            }
          }
          var blockRuleset = this.blockRuleset();
          if (blockRuleset) {
            parserInput.forget();
            if (params) {
              return new tree_1.default.mixin.Definition(null, params, blockRuleset, null, variadic);
            }
            return new tree_1.default.DetachedRuleset(blockRuleset);
          }
          parserInput.restore();
        },
        //
        // div, .class, body > p {...}
        //
        ruleset: function () {
          var selectors;
          var rules;
          var debugInfo;
          parserInput.save();
          if (context.dumpLineNumbers) {
            debugInfo = getDebugInfo(parserInput.i);
          }
          selectors = this.selectors();
          if (selectors && (rules = this.block())) {
            parserInput.forget();
            var ruleset = new tree_1.default.Ruleset(selectors, rules, context.strictImports);
            if (context.dumpLineNumbers) {
              ruleset.debugInfo = debugInfo;
            }
            return ruleset;
          } else {
            parserInput.restore();
          }
        },
        declaration: function () {
          var name;
          var value;
          var index = parserInput.i;
          var hasDR;
          var c = parserInput.currentChar();
          var important;
          var merge;
          var isVariable;
          if (c === '.' || c === '#' || c === '&' || c === ':') {
            return;
          }
          parserInput.save();
          name = this.variable() || this.ruleProperty();
          if (name) {
            isVariable = typeof name === 'string';
            if (isVariable) {
              value = this.detachedRuleset();
              if (value) {
                hasDR = true;
              }
            }
            parserInput.commentStore.length = 0;
            if (!value) {
              // a name returned by this.ruleProperty() is always an array of the form:
              // [string-1, ..., string-n, ""] or [string-1, ..., string-n, "+"]
              // where each item is a tree.Keyword or tree.Variable
              merge = !isVariable && name.length > 1 && name.pop().value;
              // Custom property values get permissive parsing
              if (name[0].value && name[0].value.slice(0, 2) === '--') {
                value = this.permissiveValue(/[;}]/);
              }
              // Try to store values as anonymous
              // If we need the value later we'll re-parse it in ruleset.parseValue
              else {
                value = this.anonymousValue();
              }
              if (value) {
                parserInput.forget();
                // anonymous values absorb the end ';' which is required for them to work
                return new tree_1.default.Declaration(name, value, false, merge, index + currentIndex, fileInfo);
              }
              if (!value) {
                value = this.value();
              }
              if (value) {
                important = this.important();
              } else if (isVariable) {
                // As a last resort, try permissiveValue
                value = this.permissiveValue();
              }
            }
            if (value && (this.end() || hasDR)) {
              parserInput.forget();
              return new tree_1.default.Declaration(name, value, important, merge, index + currentIndex, fileInfo);
            } else {
              parserInput.restore();
            }
          } else {
            parserInput.restore();
          }
        },
        anonymousValue: function () {
          var index = parserInput.i;
          var match = parserInput.$re(/^([^.#@$+/'"*`(;{}-]*);/);
          if (match) {
            return new tree_1.default.Anonymous(match[1], index + currentIndex);
          }
        },
        /**
         * Used for custom properties, at-rules, and variables (as fallback)
         * Parses almost anything inside of {} [] () "" blocks
         * until it reaches outer-most tokens.
         *
         * First, it will try to parse comments and entities to reach
         * the end. This is mostly like the Expression parser except no
         * math is allowed.
         */
        permissiveValue: function (untilTokens) {
          var i;
          var e;
          var done;
          var value;
          var tok = untilTokens || ';';
          var index = parserInput.i;
          var result = [];
          function testCurrentChar() {
            var char = parserInput.currentChar();
            if (typeof tok === 'string') {
              return char === tok;
            } else {
              return tok.test(char);
            }
          }
          if (testCurrentChar()) {
            return;
          }
          value = [];
          do {
            e = this.comment();
            if (e) {
              value.push(e);
              continue;
            }
            e = this.entity();
            if (e) {
              value.push(e);
            }
            if (parserInput.peek(',')) {
              value.push(new tree_1.default.Anonymous(',', parserInput.i));
              parserInput.$char(',');
            }
          } while (e);
          done = testCurrentChar();
          if (value.length > 0) {
            value = new tree_1.default.Expression(value);
            if (done) {
              return value;
            } else {
              result.push(value);
            }
            // Preserve space before $parseUntil as it will not
            if (parserInput.prevChar() === ' ') {
              result.push(new tree_1.default.Anonymous(' ', index));
            }
          }
          parserInput.save();
          value = parserInput.$parseUntil(tok);
          if (value) {
            if (typeof value === 'string') {
              error("Expected '".concat(value, "'"), 'Parse');
            }
            if (value.length === 1 && value[0] === ' ') {
              parserInput.forget();
              return new tree_1.default.Anonymous('', index);
            }
            var item = void 0;
            for (i = 0; i < value.length; i++) {
              item = value[i];
              if (Array.isArray(item)) {
                // Treat actual quotes as normal quoted values
                result.push(new tree_1.default.Quoted(item[0], item[1], true, index, fileInfo));
              } else {
                if (i === value.length - 1) {
                  item = item.trim();
                }
                // Treat like quoted values, but replace vars like unquoted expressions
                var quote = new tree_1.default.Quoted('\'', item, true, index, fileInfo);
                quote.variableRegex = /@([\w-]+)/g;
                quote.propRegex = /\$([\w-]+)/g;
                result.push(quote);
              }
            }
            parserInput.forget();
            return new tree_1.default.Expression(result, true);
          }
          parserInput.restore();
        },
        //
        // An @import atrule
        //
        //     @import "lib";
        //
        // Depending on our environment, importing is done differently:
        // In the browser, it's an XHR request, in Node, it would be a
        // file-system operation. The function used for importing is
        // stored in `import`, which we pass to the Import constructor.
        //
        'import': function () {
          var path;
          var features;
          var index = parserInput.i;
          var dir = parserInput.$re(/^@import\s+/);
          if (dir) {
            var options = (dir ? this.importOptions() : null) || {};
            if (path = this.entities.quoted() || this.entities.url()) {
              features = this.mediaFeatures({});
              if (!parserInput.$char(';')) {
                parserInput.i = index;
                error('missing semi-colon or unrecognised media features on import');
              }
              features = features && new tree_1.default.Value(features);
              return new tree_1.default.Import(path, features, options, index + currentIndex, fileInfo);
            } else {
              parserInput.i = index;
              error('malformed import statement');
            }
          }
        },
        importOptions: function () {
          var o;
          var options = {};
          var optionName;
          var value;
          // list of options, surrounded by parens
          if (!parserInput.$char('(')) {
            return null;
          }
          do {
            o = this.importOption();
            if (o) {
              optionName = o;
              value = true;
              switch (optionName) {
                case 'css':
                  optionName = 'less';
                  value = false;
                  break;
                case 'once':
                  optionName = 'multiple';
                  value = false;
                  break;
              }
              options[optionName] = value;
              if (!parserInput.$char(',')) {
                break;
              }
            }
          } while (o);
          expectChar(')');
          return options;
        },
        importOption: function () {
          var opt = parserInput.$re(/^(less|css|multiple|once|inline|reference|optional)/);
          if (opt) {
            return opt[1];
          }
        },
        mediaFeature: function (syntaxOptions) {
          var entities = this.entities;
          var nodes = [];
          var e;
          var p;
          var rangeP;
          parserInput.save();
          do {
            e = entities.declarationCall.bind(this)() || entities.keyword() || entities.variable() || entities.mixinLookup();
            if (e) {
              nodes.push(e);
            } else if (parserInput.$char('(')) {
              p = this.property();
              parserInput.save();
              if (!p && syntaxOptions.queryInParens && parserInput.$re(/^[0-9a-z-]*\s*([<>]=|<=|>=|[<>]|=)/)) {
                parserInput.restore();
                p = this.condition();
                parserInput.save();
                rangeP = this.atomicCondition(null, p.rvalue);
                if (!rangeP) {
                  parserInput.restore();
                }
              } else {
                parserInput.restore();
                e = this.value();
              }
              if (parserInput.$char(')')) {
                if (p && !e) {
                  nodes.push(new tree_1.default.Paren(new tree_1.default.QueryInParens(p.op, p.lvalue, p.rvalue, rangeP ? rangeP.op : null, rangeP ? rangeP.rvalue : null, p._index)));
                  e = p;
                } else if (p && e) {
                  nodes.push(new tree_1.default.Paren(new tree_1.default.Declaration(p, e, null, null, parserInput.i + currentIndex, fileInfo, true)));
                } else if (e) {
                  nodes.push(new tree_1.default.Paren(e));
                } else {
                  error('badly formed media feature definition');
                }
              } else {
                error('Missing closing \')\'', 'Parse');
              }
            }
          } while (e);
          parserInput.forget();
          if (nodes.length > 0) {
            return new tree_1.default.Expression(nodes);
          }
        },
        mediaFeatures: function (syntaxOptions) {
          var entities = this.entities;
          var features = [];
          var e;
          do {
            e = this.mediaFeature(syntaxOptions);
            if (e) {
              features.push(e);
              if (!parserInput.$char(',')) {
                break;
              }
            } else {
              e = entities.variable() || entities.mixinLookup();
              if (e) {
                features.push(e);
                if (!parserInput.$char(',')) {
                  break;
                }
              }
            }
          } while (e);
          return features.length > 0 ? features : null;
        },
        prepareAndGetNestableAtRule: function (treeType, index, debugInfo, syntaxOptions) {
          var features = this.mediaFeatures(syntaxOptions);
          var rules = this.block();
          if (!rules) {
            error('media definitions require block statements after any features');
          }
          parserInput.forget();
          var atRule = new treeType(rules, features, index + currentIndex, fileInfo);
          if (context.dumpLineNumbers) {
            atRule.debugInfo = debugInfo;
          }
          return atRule;
        },
        nestableAtRule: function () {
          var debugInfo;
          var index = parserInput.i;
          if (context.dumpLineNumbers) {
            debugInfo = getDebugInfo(index);
          }
          parserInput.save();
          if (parserInput.$peekChar('@')) {
            if (parserInput.$str('@media')) {
              return this.prepareAndGetNestableAtRule(tree_1.default.Media, index, debugInfo, atrule_syntax_1.MediaSyntaxOptions);
            }
            if (parserInput.$str('@container')) {
              return this.prepareAndGetNestableAtRule(tree_1.default.Container, index, debugInfo, atrule_syntax_1.ContainerSyntaxOptions);
            }
          }
          parserInput.restore();
        },
        //
        // A @plugin directive, used to import plugins dynamically.
        //
        //     @plugin (args) "lib";
        //
        plugin: function () {
          var path;
          var args;
          var options;
          var index = parserInput.i;
          var dir = parserInput.$re(/^@plugin\s+/);
          if (dir) {
            args = this.pluginArgs();
            if (args) {
              options = {
                pluginArgs: args,
                isPlugin: true
              };
            } else {
              options = {
                isPlugin: true
              };
            }
            if (path = this.entities.quoted() || this.entities.url()) {
              if (!parserInput.$char(';')) {
                parserInput.i = index;
                error('missing semi-colon on @plugin');
              }
              return new tree_1.default.Import(path, null, options, index + currentIndex, fileInfo);
            } else {
              parserInput.i = index;
              error('malformed @plugin statement');
            }
          }
        },
        pluginArgs: function () {
          // list of options, surrounded by parens
          parserInput.save();
          if (!parserInput.$char('(')) {
            parserInput.restore();
            return null;
          }
          var args = parserInput.$re(/^\s*([^);]+)\)\s*/);
          if (args[1]) {
            parserInput.forget();
            return args[1].trim();
          } else {
            parserInput.restore();
            return null;
          }
        },
        //
        // A CSS AtRule
        //
        //     @charset "utf-8";
        //
        atrule: function () {
          var index = parserInput.i;
          var name;
          var value;
          var rules;
          var nonVendorSpecificName;
          var hasIdentifier;
          var hasExpression;
          var hasUnknown;
          var hasBlock = true;
          var isRooted = true;
          if (parserInput.currentChar() !== '@') {
            return;
          }
          value = this['import']() || this.plugin() || this.nestableAtRule();
          if (value) {
            return value;
          }
          parserInput.save();
          name = parserInput.$re(/^@[a-z-]+/);
          if (!name) {
            return;
          }
          nonVendorSpecificName = name;
          if (name.charAt(1) == '-' && name.indexOf('-', 2) > 0) {
            nonVendorSpecificName = "@".concat(name.slice(name.indexOf('-', 2) + 1));
          }
          switch (nonVendorSpecificName) {
            case '@charset':
              hasIdentifier = true;
              hasBlock = false;
              break;
            case '@namespace':
              hasExpression = true;
              hasBlock = false;
              break;
            case '@keyframes':
            case '@counter-style':
              hasIdentifier = true;
              break;
            case '@document':
            case '@supports':
              hasUnknown = true;
              isRooted = false;
              break;
            default:
              hasUnknown = true;
              break;
          }
          parserInput.commentStore.length = 0;
          if (hasIdentifier) {
            value = this.entity();
            if (!value) {
              error("expected ".concat(name, " identifier"));
            }
          } else if (hasExpression) {
            value = this.expression();
            if (!value) {
              error("expected ".concat(name, " expression"));
            }
          } else if (hasUnknown) {
            value = this.permissiveValue(/^[{;]/);
            hasBlock = parserInput.currentChar() === '{';
            if (!value) {
              if (!hasBlock && parserInput.currentChar() !== ';') {
                error("".concat(name, " rule is missing block or ending semi-colon"));
              }
            } else if (!value.value) {
              value = null;
            }
          }
          if (hasBlock) {
            rules = this.blockRuleset();
          }
          if (rules || !hasBlock && value && parserInput.$char(';')) {
            parserInput.forget();
            return new tree_1.default.AtRule(name, value, rules, index + currentIndex, fileInfo, context.dumpLineNumbers ? getDebugInfo(index) : null, isRooted);
          }
          parserInput.restore('at-rule options not recognised');
        },
        //
        // A Value is a comma-delimited list of Expressions
        //
        //     font-family: Baskerville, Georgia, serif;
        //
        // In a Rule, a Value represents everything after the `:`,
        // and before the `;`.
        //
        value: function () {
          var e;
          var expressions = [];
          var index = parserInput.i;
          do {
            e = this.expression();
            if (e) {
              expressions.push(e);
              if (!parserInput.$char(',')) {
                break;
              }
            }
          } while (e);
          if (expressions.length > 0) {
            return new tree_1.default.Value(expressions, index + currentIndex);
          }
        },
        important: function () {
          if (parserInput.currentChar() === '!') {
            return parserInput.$re(/^! *important/);
          }
        },
        sub: function () {
          var a;
          var e;
          parserInput.save();
          if (parserInput.$char('(')) {
            a = this.addition();
            if (a && parserInput.$char(')')) {
              parserInput.forget();
              e = new tree_1.default.Expression([a]);
              e.parens = true;
              return e;
            }
            parserInput.restore('Expected \')\'');
            return;
          }
          parserInput.restore();
        },
        multiplication: function () {
          var m;
          var a;
          var op;
          var operation;
          var isSpaced;
          m = this.operand();
          if (m) {
            isSpaced = parserInput.isWhitespace(-1);
            while (true) {
              if (parserInput.peek(/^\/[*/]/)) {
                break;
              }
              parserInput.save();
              op = parserInput.$char('/') || parserInput.$char('*') || parserInput.$str('./');
              if (!op) {
                parserInput.forget();
                break;
              }
              a = this.operand();
              if (!a) {
                parserInput.restore();
                break;
              }
              parserInput.forget();
              m.parensInOp = true;
              a.parensInOp = true;
              operation = new tree_1.default.Operation(op, [operation || m, a], isSpaced);
              isSpaced = parserInput.isWhitespace(-1);
            }
            return operation || m;
          }
        },
        addition: function () {
          var m;
          var a;
          var op;
          var operation;
          var isSpaced;
          m = this.multiplication();
          if (m) {
            isSpaced = parserInput.isWhitespace(-1);
            while (true) {
              op = parserInput.$re(/^[-+]\s+/) || !isSpaced && (parserInput.$char('+') || parserInput.$char('-'));
              if (!op) {
                break;
              }
              a = this.multiplication();
              if (!a) {
                break;
              }
              m.parensInOp = true;
              a.parensInOp = true;
              operation = new tree_1.default.Operation(op, [operation || m, a], isSpaced);
              isSpaced = parserInput.isWhitespace(-1);
            }
            return operation || m;
          }
        },
        conditions: function () {
          var a;
          var b;
          var index = parserInput.i;
          var condition;
          a = this.condition(true);
          if (a) {
            while (true) {
              if (!parserInput.peek(/^,\s*(not\s*)?\(/) || !parserInput.$char(',')) {
                break;
              }
              b = this.condition(true);
              if (!b) {
                break;
              }
              condition = new tree_1.default.Condition('or', condition || a, b, index + currentIndex);
            }
            return condition || a;
          }
        },
        condition: function (needsParens) {
          var result;
          var logical;
          var next;
          function or() {
            return parserInput.$str('or');
          }
          result = this.conditionAnd(needsParens);
          if (!result) {
            return;
          }
          logical = or();
          if (logical) {
            next = this.condition(needsParens);
            if (next) {
              result = new tree_1.default.Condition(logical, result, next);
            } else {
              return;
            }
          }
          return result;
        },
        conditionAnd: function (needsParens) {
          var result;
          var logical;
          var next;
          var self = this;
          function insideCondition() {
            var cond = self.negatedCondition(needsParens) || self.parenthesisCondition(needsParens);
            if (!cond && !needsParens) {
              return self.atomicCondition(needsParens);
            }
            return cond;
          }
          function and() {
            return parserInput.$str('and');
          }
          result = insideCondition();
          if (!result) {
            return;
          }
          logical = and();
          if (logical) {
            next = this.conditionAnd(needsParens);
            if (next) {
              result = new tree_1.default.Condition(logical, result, next);
            } else {
              return;
            }
          }
          return result;
        },
        negatedCondition: function (needsParens) {
          if (parserInput.$str('not')) {
            var result = this.parenthesisCondition(needsParens);
            if (result) {
              result.negate = !result.negate;
            }
            return result;
          }
        },
        parenthesisCondition: function (needsParens) {
          function tryConditionFollowedByParenthesis(me) {
            var body;
            parserInput.save();
            body = me.condition(needsParens);
            if (!body) {
              parserInput.restore();
              return;
            }
            if (!parserInput.$char(')')) {
              parserInput.restore();
              return;
            }
            parserInput.forget();
            return body;
          }
          var body;
          parserInput.save();
          if (!parserInput.$str('(')) {
            parserInput.restore();
            return;
          }
          body = tryConditionFollowedByParenthesis(this);
          if (body) {
            parserInput.forget();
            return body;
          }
          body = this.atomicCondition(needsParens);
          if (!body) {
            parserInput.restore();
            return;
          }
          if (!parserInput.$char(')')) {
            parserInput.restore("expected ')' got '".concat(parserInput.currentChar(), "'"));
            return;
          }
          parserInput.forget();
          return body;
        },
        atomicCondition: function (needsParens, preparsedCond) {
          var entities = this.entities;
          var index = parserInput.i;
          var a;
          var b;
          var c;
          var op;
          var cond = function () {
            return this.addition() || entities.keyword() || entities.quoted() || entities.mixinLookup();
          }.bind(this);
          if (preparsedCond) {
            a = preparsedCond;
          } else {
            a = cond();
          }
          if (a) {
            if (parserInput.$char('>')) {
              if (parserInput.$char('=')) {
                op = '>=';
              } else {
                op = '>';
              }
            } else if (parserInput.$char('<')) {
              if (parserInput.$char('=')) {
                op = '<=';
              } else {
                op = '<';
              }
            } else if (parserInput.$char('=')) {
              if (parserInput.$char('>')) {
                op = '=>';
              } else if (parserInput.$char('<')) {
                op = '=<';
              } else {
                op = '=';
              }
            }
            if (op) {
              b = cond();
              if (b) {
                c = new tree_1.default.Condition(op, a, b, index + currentIndex, false);
              } else {
                error('expected expression');
              }
            } else if (!preparsedCond) {
              c = new tree_1.default.Condition('=', a, new tree_1.default.Keyword('true'), index + currentIndex, false);
            }
            return c;
          }
        },
        //
        // An operand is anything that can be part of an operation,
        // such as a Color, or a Variable
        //
        operand: function () {
          var entities = this.entities;
          var negate;
          if (parserInput.peek(/^-[@$(]/)) {
            negate = parserInput.$char('-');
          }
          var o = this.sub() || entities.dimension() || entities.color() || entities.variable() || entities.property() || entities.call() || entities.quoted(true) || entities.colorKeyword() || entities.mixinLookup();
          if (negate) {
            o.parensInOp = true;
            o = new tree_1.default.Negative(o);
          }
          return o;
        },
        //
        // Expressions either represent mathematical operations,
        // or white-space delimited Entities.
        //
        //     1px solid black
        //     @var * 2
        //
        expression: function () {
          var entities = [];
          var e;
          var delim;
          var index = parserInput.i;
          do {
            e = this.comment();
            if (e) {
              entities.push(e);
              continue;
            }
            e = this.addition() || this.entity();
            if (e instanceof tree_1.default.Comment) {
              e = null;
            }
            if (e) {
              entities.push(e);
              // operations do not allow keyword "/" dimension (e.g. small/20px) so we support that here
              if (!parserInput.peek(/^\/[/*]/)) {
                delim = parserInput.$char('/');
                if (delim) {
                  entities.push(new tree_1.default.Anonymous(delim, index + currentIndex));
                }
              }
            }
          } while (e);
          if (entities.length > 0) {
            return new tree_1.default.Expression(entities);
          }
        },
        property: function () {
          var name = parserInput.$re(/^(\*?-?[_a-zA-Z0-9-]+)\s*:/);
          if (name) {
            return name[1];
          }
        },
        ruleProperty: function () {
          var name = [];
          var index = [];
          var s;
          var k;
          parserInput.save();
          var simpleProperty = parserInput.$re(/^([_a-zA-Z0-9-]+)\s*:/);
          if (simpleProperty) {
            name = [new tree_1.default.Keyword(simpleProperty[1])];
            parserInput.forget();
            return name;
          }
          function match(re) {
            var i = parserInput.i;
            var chunk = parserInput.$re(re);
            if (chunk) {
              index.push(i);
              return name.push(chunk[1]);
            }
          }
          match(/^(\*?)/);
          while (true) {
            if (!match(/^((?:[\w-]+)|(?:[@$]\{[\w-]+\}))/)) {
              break;
            }
          }
          if (name.length > 1 && match(/^((?:\+_|\+)?)\s*:/)) {
            parserInput.forget();
            // at last, we have the complete match now. move forward,
            // convert name particles to tree objects and return:
            if (name[0] === '') {
              name.shift();
              index.shift();
            }
            for (k = 0; k < name.length; k++) {
              s = name[k];
              name[k] = s.charAt(0) !== '@' && s.charAt(0) !== '$' ? new tree_1.default.Keyword(s) : s.charAt(0) === '@' ? new tree_1.default.Variable("@".concat(s.slice(2, -1)), index[k] + currentIndex, fileInfo) : new tree_1.default.Property("$".concat(s.slice(2, -1)), index[k] + currentIndex, fileInfo);
            }
            return name;
          }
          parserInput.restore();
        }
      }
    };
  };
  Parser.serializeVars = function (vars) {
    var s = '';
    for (var name_1 in vars) {
      if (Object.hasOwnProperty.call(vars, name_1)) {
        var value = vars[name_1];
        s += "".concat((name_1[0] === '@' ? '' : '@') + name_1, ": ").concat(value).concat(String(value).slice(-1) === ';' ? '' : ';');
      }
    }
    return s;
  };
  parser.default = Parser;
  return parser;
}

var hasRequiredSelector;
function requireSelector() {
  if (hasRequiredSelector) return selector;
  hasRequiredSelector = 1;
  Object.defineProperty(selector, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var node_1 = tslib_1.__importDefault(requireNode());
  var element_1 = tslib_1.__importDefault(requireElement());
  var less_error_1 = tslib_1.__importDefault(requireLessError());
  var utils = tslib_1.__importStar(requireUtils());
  var parser_1 = tslib_1.__importDefault(requireParser());
  var Selector = function (elements, extendList, condition, index, currentFileInfo, visibilityInfo) {
    this.extendList = extendList;
    this.condition = condition;
    this.evaldCondition = !condition;
    this._index = index;
    this._fileInfo = currentFileInfo;
    this.elements = this.getElements(elements);
    this.mixinElements_ = undefined;
    this.copyVisibilityInfo(visibilityInfo);
    this.setParent(this.elements, this);
  };
  Selector.prototype = Object.assign(new node_1.default(), {
    type: 'Selector',
    accept: function (visitor) {
      if (this.elements) {
        this.elements = visitor.visitArray(this.elements);
      }
      if (this.extendList) {
        this.extendList = visitor.visitArray(this.extendList);
      }
      if (this.condition) {
        this.condition = visitor.visit(this.condition);
      }
    },
    createDerived: function (elements, extendList, evaldCondition) {
      elements = this.getElements(elements);
      var newSelector = new Selector(elements, extendList || this.extendList, null, this.getIndex(), this.fileInfo(), this.visibilityInfo());
      newSelector.evaldCondition = !utils.isNullOrUndefined(evaldCondition) ? evaldCondition : this.evaldCondition;
      newSelector.mediaEmpty = this.mediaEmpty;
      return newSelector;
    },
    getElements: function (els) {
      if (!els) {
        return [new element_1.default('', '&', false, this._index, this._fileInfo)];
      }
      if (typeof els === 'string') {
        new parser_1.default(this.parse.context, this.parse.importManager, this._fileInfo, this._index).parseNode(els, ['selector'], function (err, result) {
          if (err) {
            throw new less_error_1.default({
              index: err.index,
              message: err.message
            }, this.parse.imports, this._fileInfo.filename);
          }
          els = result[0].elements;
        });
      }
      return els;
    },
    createEmptySelectors: function () {
      var el = new element_1.default('', '&', false, this._index, this._fileInfo),
        sels = [new Selector([el], null, null, this._index, this._fileInfo)];
      sels[0].mediaEmpty = true;
      return sels;
    },
    match: function (other) {
      var elements = this.elements;
      var len = elements.length;
      var olen;
      var i;
      other = other.mixinElements();
      olen = other.length;
      if (olen === 0 || len < olen) {
        return 0;
      } else {
        for (i = 0; i < olen; i++) {
          if (elements[i].value !== other[i]) {
            return 0;
          }
        }
      }
      return olen; // return number of matched elements
    },
    mixinElements: function () {
      if (this.mixinElements_) {
        return this.mixinElements_;
      }
      var elements = this.elements.map(function (v) {
        return v.combinator.value + (v.value.value || v.value);
      }).join('').match(/[,&#*.\w-]([\w-]|(\\.))*/g);
      if (elements) {
        if (elements[0] === '&') {
          elements.shift();
        }
      } else {
        elements = [];
      }
      return this.mixinElements_ = elements;
    },
    isJustParentSelector: function () {
      return !this.mediaEmpty && this.elements.length === 1 && this.elements[0].value === '&' && (this.elements[0].combinator.value === ' ' || this.elements[0].combinator.value === '');
    },
    eval: function (context) {
      var evaldCondition = this.condition && this.condition.eval(context);
      var elements = this.elements;
      var extendList = this.extendList;
      elements = elements && elements.map(function (e) {
        return e.eval(context);
      });
      extendList = extendList && extendList.map(function (extend) {
        return extend.eval(context);
      });
      return this.createDerived(elements, extendList, evaldCondition);
    },
    genCSS: function (context, output) {
      var i, element;
      if ((!context || !context.firstSelector) && this.elements[0].combinator.value === '') {
        output.add(' ', this.fileInfo(), this.getIndex());
      }
      for (i = 0; i < this.elements.length; i++) {
        element = this.elements[i];
        element.genCSS(context, output);
      }
    },
    getIsOutput: function () {
      return this.evaldCondition;
    }
  });
  selector.default = Selector;
  return selector;
}

var ruleset = {};

var declaration = {};

var value = {};

var hasRequiredValue;
function requireValue() {
  if (hasRequiredValue) return value;
  hasRequiredValue = 1;
  Object.defineProperty(value, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var node_1 = tslib_1.__importDefault(requireNode());
  var Value = function (value) {
    if (!value) {
      throw new Error('Value requires an array argument');
    }
    if (!Array.isArray(value)) {
      this.value = [value];
    } else {
      this.value = value;
    }
  };
  Value.prototype = Object.assign(new node_1.default(), {
    type: 'Value',
    accept: function (visitor) {
      if (this.value) {
        this.value = visitor.visitArray(this.value);
      }
    },
    eval: function (context) {
      if (this.value.length === 1) {
        return this.value[0].eval(context);
      } else {
        return new Value(this.value.map(function (v) {
          return v.eval(context);
        }));
      }
    },
    genCSS: function (context, output) {
      var i;
      for (i = 0; i < this.value.length; i++) {
        this.value[i].genCSS(context, output);
        if (i + 1 < this.value.length) {
          output.add(context && context.compress ? ',' : ', ');
        }
      }
    }
  });
  value.default = Value;
  return value;
}

var keyword = {};

var hasRequiredKeyword;
function requireKeyword() {
  if (hasRequiredKeyword) return keyword;
  hasRequiredKeyword = 1;
  Object.defineProperty(keyword, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var node_1 = tslib_1.__importDefault(requireNode());
  var Keyword = function (value) {
    this.value = value;
  };
  Keyword.prototype = Object.assign(new node_1.default(), {
    type: 'Keyword',
    genCSS: function (context, output) {
      if (this.value === '%') {
        throw {
          type: 'Syntax',
          message: 'Invalid % without number'
        };
      }
      output.add(this.value);
    }
  });
  Keyword.True = new Keyword('true');
  Keyword.False = new Keyword('false');
  keyword.default = Keyword;
  return keyword;
}

var anonymous = {};

var hasRequiredAnonymous;
function requireAnonymous() {
  if (hasRequiredAnonymous) return anonymous;
  hasRequiredAnonymous = 1;
  Object.defineProperty(anonymous, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var node_1 = tslib_1.__importDefault(requireNode());
  var Anonymous = function (value, index, currentFileInfo, mapLines, rulesetLike, visibilityInfo) {
    this.value = value;
    this._index = index;
    this._fileInfo = currentFileInfo;
    this.mapLines = mapLines;
    this.rulesetLike = typeof rulesetLike === 'undefined' ? false : rulesetLike;
    this.allowRoot = true;
    this.copyVisibilityInfo(visibilityInfo);
  };
  Anonymous.prototype = Object.assign(new node_1.default(), {
    type: 'Anonymous',
    eval: function () {
      return new Anonymous(this.value, this._index, this._fileInfo, this.mapLines, this.rulesetLike, this.visibilityInfo());
    },
    compare: function (other) {
      return other.toCSS && this.toCSS() === other.toCSS() ? 0 : undefined;
    },
    isRulesetLike: function () {
      return this.rulesetLike;
    },
    genCSS: function (context, output) {
      this.nodeVisible = Boolean(this.value);
      if (this.nodeVisible) {
        output.add(this.value, this._fileInfo, this._index, this.mapLines);
      }
    }
  });
  anonymous.default = Anonymous;
  return anonymous;
}

var hasRequiredDeclaration;
function requireDeclaration() {
  if (hasRequiredDeclaration) return declaration;
  hasRequiredDeclaration = 1;
  Object.defineProperty(declaration, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var node_1 = tslib_1.__importDefault(requireNode());
  var value_1 = tslib_1.__importDefault(requireValue());
  var keyword_1 = tslib_1.__importDefault(requireKeyword());
  var anonymous_1 = tslib_1.__importDefault(requireAnonymous());
  var Constants = tslib_1.__importStar(requireConstants());
  var MATH = Constants.Math;
  function evalName(context, name) {
    var value = '';
    var i;
    var n = name.length;
    var output = {
      add: function (s) {
        value += s;
      }
    };
    for (i = 0; i < n; i++) {
      name[i].eval(context).genCSS(context, output);
    }
    return value;
  }
  var Declaration = function (name, value, important, merge, index, currentFileInfo, inline, variable) {
    this.name = name;
    this.value = value instanceof node_1.default ? value : new value_1.default([value ? new anonymous_1.default(value) : null]);
    this.important = important ? " ".concat(important.trim()) : '';
    this.merge = merge;
    this._index = index;
    this._fileInfo = currentFileInfo;
    this.inline = inline || false;
    this.variable = variable !== undefined ? variable : name.charAt && name.charAt(0) === '@';
    this.allowRoot = true;
    this.setParent(this.value, this);
  };
  Declaration.prototype = Object.assign(new node_1.default(), {
    type: 'Declaration',
    genCSS: function (context, output) {
      output.add(this.name + (context.compress ? ':' : ': '), this.fileInfo(), this.getIndex());
      try {
        this.value.genCSS(context, output);
      } catch (e) {
        e.index = this._index;
        e.filename = this._fileInfo.filename;
        throw e;
      }
      output.add(this.important + (this.inline || context.lastRule && context.compress ? '' : ';'), this._fileInfo, this._index);
    },
    eval: function (context) {
      var mathBypass = false,
        prevMath,
        name = this.name,
        evaldValue,
        variable = this.variable;
      if (typeof name !== 'string') {
        // expand 'primitive' name directly to get
        // things faster (~10% for benchmark.less):
        name = name.length === 1 && name[0] instanceof keyword_1.default ? name[0].value : evalName(context, name);
        variable = false; // never treat expanded interpolation as new variable name
      }
      // @todo remove when parens-division is default
      if (name === 'font' && context.math === MATH.ALWAYS) {
        mathBypass = true;
        prevMath = context.math;
        context.math = MATH.PARENS_DIVISION;
      }
      try {
        context.importantScope.push({});
        evaldValue = this.value.eval(context);
        if (!this.variable && evaldValue.type === 'DetachedRuleset') {
          throw {
            message: 'Rulesets cannot be evaluated on a property.',
            index: this.getIndex(),
            filename: this.fileInfo().filename
          };
        }
        var important = this.important;
        var importantResult = context.importantScope.pop();
        if (!important && importantResult.important) {
          important = importantResult.important;
        }
        return new Declaration(name, evaldValue, important, this.merge, this.getIndex(), this.fileInfo(), this.inline, variable);
      } catch (e) {
        if (typeof e.index !== 'number') {
          e.index = this.getIndex();
          e.filename = this.fileInfo().filename;
        }
        throw e;
      } finally {
        if (mathBypass) {
          context.math = prevMath;
        }
      }
    },
    makeImportant: function () {
      return new Declaration(this.name, this.value, '!important', this.merge, this.getIndex(), this.fileInfo(), this.inline);
    }
  });
  declaration.default = Declaration;
  return declaration;
}

var comment = {};

var debugInfo = {};

var hasRequiredDebugInfo;
function requireDebugInfo() {
  if (hasRequiredDebugInfo) return debugInfo;
  hasRequiredDebugInfo = 1;
  Object.defineProperty(debugInfo, "__esModule", {
    value: true
  });
  function asComment(ctx) {
    return "/* line ".concat(ctx.debugInfo.lineNumber, ", ").concat(ctx.debugInfo.fileName, " */\n");
  }
  function asMediaQuery(ctx) {
    var filenameWithProtocol = ctx.debugInfo.fileName;
    if (!/^[a-z]+:\/\//i.test(filenameWithProtocol)) {
      filenameWithProtocol = "file://".concat(filenameWithProtocol);
    }
    return "@media -sass-debug-info{filename{font-family:".concat(filenameWithProtocol.replace(/([.:/\\])/g, function (a) {
      if (a == '\\') {
        a = '/';
      }
      return "\\".concat(a);
    }), "}line{font-family:\\00003").concat(ctx.debugInfo.lineNumber, "}}\n");
  }
  function debugInfo$1(context, ctx, lineSeparator) {
    var result = '';
    if (context.dumpLineNumbers && !context.compress) {
      switch (context.dumpLineNumbers) {
        case 'comments':
          result = asComment(ctx);
          break;
        case 'mediaquery':
          result = asMediaQuery(ctx);
          break;
        case 'all':
          result = asComment(ctx) + (lineSeparator || '') + asMediaQuery(ctx);
          break;
      }
    }
    return result;
  }
  debugInfo.default = debugInfo$1;
  return debugInfo;
}

var hasRequiredComment;
function requireComment() {
  if (hasRequiredComment) return comment;
  hasRequiredComment = 1;
  Object.defineProperty(comment, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var node_1 = tslib_1.__importDefault(requireNode());
  var debug_info_1 = tslib_1.__importDefault(requireDebugInfo());
  var Comment = function (value, isLineComment, index, currentFileInfo) {
    this.value = value;
    this.isLineComment = isLineComment;
    this._index = index;
    this._fileInfo = currentFileInfo;
    this.allowRoot = true;
  };
  Comment.prototype = Object.assign(new node_1.default(), {
    type: 'Comment',
    genCSS: function (context, output) {
      if (this.debugInfo) {
        output.add((0, debug_info_1.default)(context, this), this.fileInfo(), this.getIndex());
      }
      output.add(this.value);
    },
    isSilent: function (context) {
      var isCompressed = context.compress && this.value[2] !== '!';
      return this.isLineComment || isCompressed;
    }
  });
  comment.default = Comment;
  return comment;
}

var _default = {};

var hasRequired_default;
function require_default() {
  if (hasRequired_default) return _default;
  hasRequired_default = 1;
  Object.defineProperty(_default, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var keyword_1 = tslib_1.__importDefault(requireKeyword());
  var utils = tslib_1.__importStar(requireUtils());
  var defaultFunc = {
    eval: function () {
      var v = this.value_;
      var e = this.error_;
      if (e) {
        throw e;
      }
      if (!utils.isNullOrUndefined(v)) {
        return v ? keyword_1.default.True : keyword_1.default.False;
      }
    },
    value: function (v) {
      this.value_ = v;
    },
    error: function (e) {
      this.error_ = e;
    },
    reset: function () {
      this.value_ = this.error_ = null;
    }
  };
  _default.default = defaultFunc;
  return _default;
}

var hasRequiredRuleset;
function requireRuleset() {
  if (hasRequiredRuleset) return ruleset;
  hasRequiredRuleset = 1;
  Object.defineProperty(ruleset, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var node_1 = tslib_1.__importDefault(requireNode());
  var declaration_1 = tslib_1.__importDefault(requireDeclaration());
  var keyword_1 = tslib_1.__importDefault(requireKeyword());
  var comment_1 = tslib_1.__importDefault(requireComment());
  var paren_1 = tslib_1.__importDefault(requireParen());
  var selector_1 = tslib_1.__importDefault(requireSelector());
  var element_1 = tslib_1.__importDefault(requireElement());
  var anonymous_1 = tslib_1.__importDefault(requireAnonymous());
  var contexts_1 = tslib_1.__importDefault(requireContexts());
  var function_registry_1 = tslib_1.__importDefault(requireFunctionRegistry());
  var default_1 = tslib_1.__importDefault(require_default());
  var debug_info_1 = tslib_1.__importDefault(requireDebugInfo());
  var utils = tslib_1.__importStar(requireUtils());
  var parser_1 = tslib_1.__importDefault(requireParser());
  var Ruleset = function (selectors, rules, strictImports, visibilityInfo) {
    this.selectors = selectors;
    this.rules = rules;
    this._lookups = {};
    this._variables = null;
    this._properties = null;
    this.strictImports = strictImports;
    this.copyVisibilityInfo(visibilityInfo);
    this.allowRoot = true;
    this.setParent(this.selectors, this);
    this.setParent(this.rules, this);
  };
  Ruleset.prototype = Object.assign(new node_1.default(), {
    type: 'Ruleset',
    isRuleset: true,
    isRulesetLike: function () {
      return true;
    },
    accept: function (visitor) {
      if (this.paths) {
        this.paths = visitor.visitArray(this.paths, true);
      } else if (this.selectors) {
        this.selectors = visitor.visitArray(this.selectors);
      }
      if (this.rules && this.rules.length) {
        this.rules = visitor.visitArray(this.rules);
      }
    },
    eval: function (context) {
      var selectors;
      var selCnt;
      var selector;
      var i;
      var hasVariable;
      var hasOnePassingSelector = false;
      if (this.selectors && (selCnt = this.selectors.length)) {
        selectors = new Array(selCnt);
        default_1.default.error({
          type: 'Syntax',
          message: 'it is currently only allowed in parametric mixin guards,'
        });
        for (i = 0; i < selCnt; i++) {
          selector = this.selectors[i].eval(context);
          for (var j = 0; j < selector.elements.length; j++) {
            if (selector.elements[j].isVariable) {
              hasVariable = true;
              break;
            }
          }
          selectors[i] = selector;
          if (selector.evaldCondition) {
            hasOnePassingSelector = true;
          }
        }
        if (hasVariable) {
          var toParseSelectors = new Array(selCnt);
          for (i = 0; i < selCnt; i++) {
            selector = selectors[i];
            toParseSelectors[i] = selector.toCSS(context);
          }
          var startingIndex = selectors[0].getIndex();
          var selectorFileInfo = selectors[0].fileInfo();
          new parser_1.default(context, this.parse.importManager, selectorFileInfo, startingIndex).parseNode(toParseSelectors.join(','), ['selectors'], function (err, result) {
            if (result) {
              selectors = utils.flattenArray(result);
            }
          });
        }
        default_1.default.reset();
      } else {
        hasOnePassingSelector = true;
      }
      var rules = this.rules ? utils.copyArray(this.rules) : null;
      var ruleset = new Ruleset(selectors, rules, this.strictImports, this.visibilityInfo());
      var rule;
      var subRule;
      ruleset.originalRuleset = this;
      ruleset.root = this.root;
      ruleset.firstRoot = this.firstRoot;
      ruleset.allowImports = this.allowImports;
      if (this.debugInfo) {
        ruleset.debugInfo = this.debugInfo;
      }
      if (!hasOnePassingSelector) {
        rules.length = 0;
      }
      // inherit a function registry from the frames stack when possible;
      // otherwise from the global registry
      ruleset.functionRegistry = function (frames) {
        var i = 0;
        var n = frames.length;
        var found;
        for (; i !== n; ++i) {
          found = frames[i].functionRegistry;
          if (found) {
            return found;
          }
        }
        return function_registry_1.default;
      }(context.frames).inherit();
      // push the current ruleset to the frames stack
      var ctxFrames = context.frames;
      ctxFrames.unshift(ruleset);
      // currrent selectors
      var ctxSelectors = context.selectors;
      if (!ctxSelectors) {
        context.selectors = ctxSelectors = [];
      }
      ctxSelectors.unshift(this.selectors);
      // Evaluate imports
      if (ruleset.root || ruleset.allowImports || !ruleset.strictImports) {
        ruleset.evalImports(context);
      }
      // Store the frames around mixin definitions,
      // so they can be evaluated like closures when the time comes.
      var rsRules = ruleset.rules;
      for (i = 0; rule = rsRules[i]; i++) {
        if (rule.evalFirst) {
          rsRules[i] = rule.eval(context);
        }
      }
      var mediaBlockCount = context.mediaBlocks && context.mediaBlocks.length || 0;
      // Evaluate mixin calls.
      for (i = 0; rule = rsRules[i]; i++) {
        if (rule.type === 'MixinCall') {
          /* jshint loopfunc:true */
          rules = rule.eval(context).filter(function (r) {
            if (r instanceof declaration_1.default && r.variable) {
              // do not pollute the scope if the variable is
              // already there. consider returning false here
              // but we need a way to "return" variable from mixins
              return !ruleset.variable(r.name);
            }
            return true;
          });
          rsRules.splice.apply(rsRules, [i, 1].concat(rules));
          i += rules.length - 1;
          ruleset.resetCache();
        } else if (rule.type === 'VariableCall') {
          /* jshint loopfunc:true */
          rules = rule.eval(context).rules.filter(function (r) {
            if (r instanceof declaration_1.default && r.variable) {
              // do not pollute the scope at all
              return false;
            }
            return true;
          });
          rsRules.splice.apply(rsRules, [i, 1].concat(rules));
          i += rules.length - 1;
          ruleset.resetCache();
        }
      }
      // Evaluate everything else
      for (i = 0; rule = rsRules[i]; i++) {
        if (!rule.evalFirst) {
          rsRules[i] = rule = rule.eval ? rule.eval(context) : rule;
        }
      }
      // Evaluate everything else
      for (i = 0; rule = rsRules[i]; i++) {
        // for rulesets, check if it is a css guard and can be removed
        if (rule instanceof Ruleset && rule.selectors && rule.selectors.length === 1) {
          // check if it can be folded in (e.g. & where)
          if (rule.selectors[0] && rule.selectors[0].isJustParentSelector()) {
            rsRules.splice(i--, 1);
            for (var j = 0; subRule = rule.rules[j]; j++) {
              if (subRule instanceof node_1.default) {
                subRule.copyVisibilityInfo(rule.visibilityInfo());
                if (!(subRule instanceof declaration_1.default) || !subRule.variable) {
                  rsRules.splice(++i, 0, subRule);
                }
              }
            }
          }
        }
      }
      // Pop the stack
      ctxFrames.shift();
      ctxSelectors.shift();
      if (context.mediaBlocks) {
        for (i = mediaBlockCount; i < context.mediaBlocks.length; i++) {
          context.mediaBlocks[i].bubbleSelectors(selectors);
        }
      }
      return ruleset;
    },
    evalImports: function (context) {
      var rules = this.rules;
      var i;
      var importRules;
      if (!rules) {
        return;
      }
      for (i = 0; i < rules.length; i++) {
        if (rules[i].type === 'Import') {
          importRules = rules[i].eval(context);
          if (importRules && (importRules.length || importRules.length === 0)) {
            rules.splice.apply(rules, [i, 1].concat(importRules));
            i += importRules.length - 1;
          } else {
            rules.splice(i, 1, importRules);
          }
          this.resetCache();
        }
      }
    },
    makeImportant: function () {
      var result = new Ruleset(this.selectors, this.rules.map(function (r) {
        if (r.makeImportant) {
          return r.makeImportant();
        } else {
          return r;
        }
      }), this.strictImports, this.visibilityInfo());
      return result;
    },
    matchArgs: function (args) {
      return !args || args.length === 0;
    },
    // lets you call a css selector with a guard
    matchCondition: function (args, context) {
      var lastSelector = this.selectors[this.selectors.length - 1];
      if (!lastSelector.evaldCondition) {
        return false;
      }
      if (lastSelector.condition && !lastSelector.condition.eval(new contexts_1.default.Eval(context, context.frames))) {
        return false;
      }
      return true;
    },
    resetCache: function () {
      this._rulesets = null;
      this._variables = null;
      this._properties = null;
      this._lookups = {};
    },
    variables: function () {
      if (!this._variables) {
        this._variables = !this.rules ? {} : this.rules.reduce(function (hash, r) {
          if (r instanceof declaration_1.default && r.variable === true) {
            hash[r.name] = r;
          }
          // when evaluating variables in an import statement, imports have not been eval'd
          // so we need to go inside import statements.
          // guard against root being a string (in the case of inlined less)
          if (r.type === 'Import' && r.root && r.root.variables) {
            var vars = r.root.variables();
            for (var name_1 in vars) {
              // eslint-disable-next-line no-prototype-builtins
              if (vars.hasOwnProperty(name_1)) {
                hash[name_1] = r.root.variable(name_1);
              }
            }
          }
          return hash;
        }, {});
      }
      return this._variables;
    },
    properties: function () {
      if (!this._properties) {
        this._properties = !this.rules ? {} : this.rules.reduce(function (hash, r) {
          if (r instanceof declaration_1.default && r.variable !== true) {
            var name_2 = r.name.length === 1 && r.name[0] instanceof keyword_1.default ? r.name[0].value : r.name;
            // Properties don't overwrite as they can merge
            if (!hash["$".concat(name_2)]) {
              hash["$".concat(name_2)] = [r];
            } else {
              hash["$".concat(name_2)].push(r);
            }
          }
          return hash;
        }, {});
      }
      return this._properties;
    },
    variable: function (name) {
      var decl = this.variables()[name];
      if (decl) {
        return this.parseValue(decl);
      }
    },
    property: function (name) {
      var decl = this.properties()[name];
      if (decl) {
        return this.parseValue(decl);
      }
    },
    lastDeclaration: function () {
      for (var i = this.rules.length; i > 0; i--) {
        var decl = this.rules[i - 1];
        if (decl instanceof declaration_1.default) {
          return this.parseValue(decl);
        }
      }
    },
    parseValue: function (toParse) {
      var self = this;
      function transformDeclaration(decl) {
        if (decl.value instanceof anonymous_1.default && !decl.parsed) {
          if (typeof decl.value.value === 'string') {
            new parser_1.default(this.parse.context, this.parse.importManager, decl.fileInfo(), decl.value.getIndex()).parseNode(decl.value.value, ['value', 'important'], function (err, result) {
              if (err) {
                decl.parsed = true;
              }
              if (result) {
                decl.value = result[0];
                decl.important = result[1] || '';
                decl.parsed = true;
              }
            });
          } else {
            decl.parsed = true;
          }
          return decl;
        } else {
          return decl;
        }
      }
      if (!Array.isArray(toParse)) {
        return transformDeclaration.call(self, toParse);
      } else {
        var nodes_1 = [];
        toParse.forEach(function (n) {
          nodes_1.push(transformDeclaration.call(self, n));
        });
        return nodes_1;
      }
    },
    rulesets: function () {
      if (!this.rules) {
        return [];
      }
      var filtRules = [];
      var rules = this.rules;
      var i;
      var rule;
      for (i = 0; rule = rules[i]; i++) {
        if (rule.isRuleset) {
          filtRules.push(rule);
        }
      }
      return filtRules;
    },
    prependRule: function (rule) {
      var rules = this.rules;
      if (rules) {
        rules.unshift(rule);
      } else {
        this.rules = [rule];
      }
      this.setParent(rule, this);
    },
    find: function (selector, self, filter) {
      self = self || this;
      var rules = [];
      var match;
      var foundMixins;
      var key = selector.toCSS();
      if (key in this._lookups) {
        return this._lookups[key];
      }
      this.rulesets().forEach(function (rule) {
        if (rule !== self) {
          for (var j = 0; j < rule.selectors.length; j++) {
            match = selector.match(rule.selectors[j]);
            if (match) {
              if (selector.elements.length > match) {
                if (!filter || filter(rule)) {
                  foundMixins = rule.find(new selector_1.default(selector.elements.slice(match)), self, filter);
                  for (var i = 0; i < foundMixins.length; ++i) {
                    foundMixins[i].path.push(rule);
                  }
                  Array.prototype.push.apply(rules, foundMixins);
                }
              } else {
                rules.push({
                  rule: rule,
                  path: []
                });
              }
              break;
            }
          }
        }
      });
      this._lookups[key] = rules;
      return rules;
    },
    genCSS: function (context, output) {
      var i;
      var j;
      var charsetRuleNodes = [];
      var ruleNodes = [];
      var
      // Line number debugging
      debugInfo;
      var rule;
      var path;
      context.tabLevel = context.tabLevel || 0;
      if (!this.root) {
        context.tabLevel++;
      }
      var tabRuleStr = context.compress ? '' : Array(context.tabLevel + 1).join('  ');
      var tabSetStr = context.compress ? '' : Array(context.tabLevel).join('  ');
      var sep;
      var charsetNodeIndex = 0;
      var importNodeIndex = 0;
      for (i = 0; rule = this.rules[i]; i++) {
        if (rule instanceof comment_1.default) {
          if (importNodeIndex === i) {
            importNodeIndex++;
          }
          ruleNodes.push(rule);
        } else if (rule.isCharset && rule.isCharset()) {
          ruleNodes.splice(charsetNodeIndex, 0, rule);
          charsetNodeIndex++;
          importNodeIndex++;
        } else if (rule.type === 'Import') {
          ruleNodes.splice(importNodeIndex, 0, rule);
          importNodeIndex++;
        } else {
          ruleNodes.push(rule);
        }
      }
      ruleNodes = charsetRuleNodes.concat(ruleNodes);
      // If this is the root node, we don't render
      // a selector, or {}.
      if (!this.root) {
        debugInfo = (0, debug_info_1.default)(context, this, tabSetStr);
        if (debugInfo) {
          output.add(debugInfo);
          output.add(tabSetStr);
        }
        var paths = this.paths;
        var pathCnt = paths.length;
        var pathSubCnt = void 0;
        sep = context.compress ? ',' : ",\n".concat(tabSetStr);
        for (i = 0; i < pathCnt; i++) {
          path = paths[i];
          if (!(pathSubCnt = path.length)) {
            continue;
          }
          if (i > 0) {
            output.add(sep);
          }
          context.firstSelector = true;
          path[0].genCSS(context, output);
          context.firstSelector = false;
          for (j = 1; j < pathSubCnt; j++) {
            path[j].genCSS(context, output);
          }
        }
        output.add((context.compress ? '{' : ' {\n') + tabRuleStr);
      }
      // Compile rules and rulesets
      for (i = 0; rule = ruleNodes[i]; i++) {
        if (i + 1 === ruleNodes.length) {
          context.lastRule = true;
        }
        var currentLastRule = context.lastRule;
        if (rule.isRulesetLike(rule)) {
          context.lastRule = false;
        }
        if (rule.genCSS) {
          rule.genCSS(context, output);
        } else if (rule.value) {
          output.add(rule.value.toString());
        }
        context.lastRule = currentLastRule;
        if (!context.lastRule && rule.isVisible()) {
          output.add(context.compress ? '' : "\n".concat(tabRuleStr));
        } else {
          context.lastRule = false;
        }
      }
      if (!this.root) {
        output.add(context.compress ? '}' : "\n".concat(tabSetStr, "}"));
        context.tabLevel--;
      }
      if (!output.isEmpty() && !context.compress && this.firstRoot) {
        output.add('\n');
      }
    },
    joinSelectors: function (paths, context, selectors) {
      for (var s = 0; s < selectors.length; s++) {
        this.joinSelector(paths, context, selectors[s]);
      }
    },
    joinSelector: function (paths, context, selector) {
      function createParenthesis(elementsToPak, originalElement) {
        var replacementParen, j;
        if (elementsToPak.length === 0) {
          replacementParen = new paren_1.default(elementsToPak[0]);
        } else {
          var insideParent = new Array(elementsToPak.length);
          for (j = 0; j < elementsToPak.length; j++) {
            insideParent[j] = new element_1.default(null, elementsToPak[j], originalElement.isVariable, originalElement._index, originalElement._fileInfo);
          }
          replacementParen = new paren_1.default(new selector_1.default(insideParent));
        }
        return replacementParen;
      }
      function createSelector(containedElement, originalElement) {
        var element, selector;
        element = new element_1.default(null, containedElement, originalElement.isVariable, originalElement._index, originalElement._fileInfo);
        selector = new selector_1.default([element]);
        return selector;
      }
      // joins selector path from `beginningPath` with selector path in `addPath`
      // `replacedElement` contains element that is being replaced by `addPath`
      // returns concatenated path
      function addReplacementIntoPath(beginningPath, addPath, replacedElement, originalSelector) {
        var newSelectorPath, lastSelector, newJoinedSelector;
        // our new selector path
        newSelectorPath = [];
        // construct the joined selector - if & is the first thing this will be empty,
        // if not newJoinedSelector will be the last set of elements in the selector
        if (beginningPath.length > 0) {
          newSelectorPath = utils.copyArray(beginningPath);
          lastSelector = newSelectorPath.pop();
          newJoinedSelector = originalSelector.createDerived(utils.copyArray(lastSelector.elements));
        } else {
          newJoinedSelector = originalSelector.createDerived([]);
        }
        if (addPath.length > 0) {
          // /deep/ is a CSS4 selector - (removed, so should deprecate)
          // that is valid without anything in front of it
          // so if the & does not have a combinator that is "" or " " then
          // and there is a combinator on the parent, then grab that.
          // this also allows + a { & .b { .a & { ... though not sure why you would want to do that
          var combinator = replacedElement.combinator;
          var parentEl = addPath[0].elements[0];
          if (combinator.emptyOrWhitespace && !parentEl.combinator.emptyOrWhitespace) {
            combinator = parentEl.combinator;
          }
          // join the elements so far with the first part of the parent
          newJoinedSelector.elements.push(new element_1.default(combinator, parentEl.value, replacedElement.isVariable, replacedElement._index, replacedElement._fileInfo));
          newJoinedSelector.elements = newJoinedSelector.elements.concat(addPath[0].elements.slice(1));
        }
        // now add the joined selector - but only if it is not empty
        if (newJoinedSelector.elements.length !== 0) {
          newSelectorPath.push(newJoinedSelector);
        }
        // put together the parent selectors after the join (e.g. the rest of the parent)
        if (addPath.length > 1) {
          var restOfPath = addPath.slice(1);
          restOfPath = restOfPath.map(function (selector) {
            return selector.createDerived(selector.elements, []);
          });
          newSelectorPath = newSelectorPath.concat(restOfPath);
        }
        return newSelectorPath;
      }
      // joins selector path from `beginningPath` with every selector path in `addPaths` array
      // `replacedElement` contains element that is being replaced by `addPath`
      // returns array with all concatenated paths
      function addAllReplacementsIntoPath(beginningPath, addPaths, replacedElement, originalSelector, result) {
        var j;
        for (j = 0; j < beginningPath.length; j++) {
          var newSelectorPath = addReplacementIntoPath(beginningPath[j], addPaths, replacedElement, originalSelector);
          result.push(newSelectorPath);
        }
        return result;
      }
      function mergeElementsOnToSelectors(elements, selectors) {
        var i, sel;
        if (elements.length === 0) {
          return;
        }
        if (selectors.length === 0) {
          selectors.push([new selector_1.default(elements)]);
          return;
        }
        for (i = 0; sel = selectors[i]; i++) {
          // if the previous thing in sel is a parent this needs to join on to it
          if (sel.length > 0) {
            sel[sel.length - 1] = sel[sel.length - 1].createDerived(sel[sel.length - 1].elements.concat(elements));
          } else {
            sel.push(new selector_1.default(elements));
          }
        }
      }
      // replace all parent selectors inside `inSelector` by content of `context` array
      // resulting selectors are returned inside `paths` array
      // returns true if `inSelector` contained at least one parent selector
      function replaceParentSelector(paths, context, inSelector) {
        // The paths are [[Selector]]
        // The first list is a list of comma separated selectors
        // The inner list is a list of inheritance separated selectors
        // e.g.
        // .a, .b {
        //   .c {
        //   }
        // }
        // == [[.a] [.c]] [[.b] [.c]]
        //
        var i,
          j,
          k,
          currentElements,
          newSelectors,
          selectorsMultiplied,
          sel,
          el,
          hadParentSelector = false,
          length,
          lastSelector;
        function findNestedSelector(element) {
          var maybeSelector;
          if (!(element.value instanceof paren_1.default)) {
            return null;
          }
          maybeSelector = element.value.value;
          if (!(maybeSelector instanceof selector_1.default)) {
            return null;
          }
          return maybeSelector;
        }
        // the elements from the current selector so far
        currentElements = [];
        // the current list of new selectors to add to the path.
        // We will build it up. We initiate it with one empty selector as we "multiply" the new selectors
        // by the parents
        newSelectors = [[]];
        for (i = 0; el = inSelector.elements[i]; i++) {
          // non parent reference elements just get added
          if (el.value !== '&') {
            var nestedSelector = findNestedSelector(el);
            if (nestedSelector !== null) {
              // merge the current list of non parent selector elements
              // on to the current list of selectors to add
              mergeElementsOnToSelectors(currentElements, newSelectors);
              var nestedPaths = [];
              var replaced = void 0;
              var replacedNewSelectors = [];
              replaced = replaceParentSelector(nestedPaths, context, nestedSelector);
              hadParentSelector = hadParentSelector || replaced;
              // the nestedPaths array should have only one member - replaceParentSelector does not multiply selectors
              for (k = 0; k < nestedPaths.length; k++) {
                var replacementSelector = createSelector(createParenthesis(nestedPaths[k], el), el);
                addAllReplacementsIntoPath(newSelectors, [replacementSelector], el, inSelector, replacedNewSelectors);
              }
              newSelectors = replacedNewSelectors;
              currentElements = [];
            } else {
              currentElements.push(el);
            }
          } else {
            hadParentSelector = true;
            // the new list of selectors to add
            selectorsMultiplied = [];
            // merge the current list of non parent selector elements
            // on to the current list of selectors to add
            mergeElementsOnToSelectors(currentElements, newSelectors);
            // loop through our current selectors
            for (j = 0; j < newSelectors.length; j++) {
              sel = newSelectors[j];
              // if we don't have any parent paths, the & might be in a mixin so that it can be used
              // whether there are parents or not
              if (context.length === 0) {
                // the combinator used on el should now be applied to the next element instead so that
                // it is not lost
                if (sel.length > 0) {
                  sel[0].elements.push(new element_1.default(el.combinator, '', el.isVariable, el._index, el._fileInfo));
                }
                selectorsMultiplied.push(sel);
              } else {
                // and the parent selectors
                for (k = 0; k < context.length; k++) {
                  // We need to put the current selectors
                  // then join the last selector's elements on to the parents selectors
                  var newSelectorPath = addReplacementIntoPath(sel, context[k], el, inSelector);
                  // add that to our new set of selectors
                  selectorsMultiplied.push(newSelectorPath);
                }
              }
            }
            // our new selectors has been multiplied, so reset the state
            newSelectors = selectorsMultiplied;
            currentElements = [];
          }
        }
        // if we have any elements left over (e.g. .a& .b == .b)
        // add them on to all the current selectors
        mergeElementsOnToSelectors(currentElements, newSelectors);
        for (i = 0; i < newSelectors.length; i++) {
          length = newSelectors[i].length;
          if (length > 0) {
            paths.push(newSelectors[i]);
            lastSelector = newSelectors[i][length - 1];
            newSelectors[i][length - 1] = lastSelector.createDerived(lastSelector.elements, inSelector.extendList);
          }
        }
        return hadParentSelector;
      }
      function deriveSelector(visibilityInfo, deriveFrom) {
        var newSelector = deriveFrom.createDerived(deriveFrom.elements, deriveFrom.extendList, deriveFrom.evaldCondition);
        newSelector.copyVisibilityInfo(visibilityInfo);
        return newSelector;
      }
      // joinSelector code follows
      var i, newPaths, hadParentSelector;
      newPaths = [];
      hadParentSelector = replaceParentSelector(newPaths, context, selector);
      if (!hadParentSelector) {
        if (context.length > 0) {
          newPaths = [];
          for (i = 0; i < context.length; i++) {
            var concatenated = context[i].map(deriveSelector.bind(this, selector.visibilityInfo()));
            concatenated.push(selector);
            newPaths.push(concatenated);
          }
        } else {
          newPaths = [[selector]];
        }
      }
      for (i = 0; i < newPaths.length; i++) {
        paths.push(newPaths[i]);
      }
    }
  });
  ruleset.default = Ruleset;
  return ruleset;
}

var hasRequiredAtrule;
function requireAtrule() {
  if (hasRequiredAtrule) return atrule;
  hasRequiredAtrule = 1;
  Object.defineProperty(atrule, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var node_1 = tslib_1.__importDefault(requireNode());
  var selector_1 = tslib_1.__importDefault(requireSelector());
  var ruleset_1 = tslib_1.__importDefault(requireRuleset());
  var anonymous_1 = tslib_1.__importDefault(requireAnonymous());
  var AtRule = function (name, value, rules, index, currentFileInfo, debugInfo, isRooted, visibilityInfo) {
    var i;
    this.name = name;
    this.value = value instanceof node_1.default ? value : value ? new anonymous_1.default(value) : value;
    if (rules) {
      if (Array.isArray(rules)) {
        this.rules = rules;
      } else {
        this.rules = [rules];
        this.rules[0].selectors = new selector_1.default([], null, null, index, currentFileInfo).createEmptySelectors();
      }
      for (i = 0; i < this.rules.length; i++) {
        this.rules[i].allowImports = true;
      }
      this.setParent(this.rules, this);
    }
    this._index = index;
    this._fileInfo = currentFileInfo;
    this.debugInfo = debugInfo;
    this.isRooted = isRooted || false;
    this.copyVisibilityInfo(visibilityInfo);
    this.allowRoot = true;
  };
  AtRule.prototype = Object.assign(new node_1.default(), {
    type: 'AtRule',
    accept: function (visitor) {
      var value = this.value,
        rules = this.rules;
      if (rules) {
        this.rules = visitor.visitArray(rules);
      }
      if (value) {
        this.value = visitor.visit(value);
      }
    },
    isRulesetLike: function () {
      return this.rules || !this.isCharset();
    },
    isCharset: function () {
      return '@charset' === this.name;
    },
    genCSS: function (context, output) {
      var value = this.value,
        rules = this.rules;
      output.add(this.name, this.fileInfo(), this.getIndex());
      if (value) {
        output.add(' ');
        value.genCSS(context, output);
      }
      if (rules) {
        this.outputRuleset(context, output, rules);
      } else {
        output.add(';');
      }
    },
    eval: function (context) {
      var mediaPathBackup,
        mediaBlocksBackup,
        value = this.value,
        rules = this.rules;
      // media stored inside other atrule should not bubble over it
      // backpup media bubbling information
      mediaPathBackup = context.mediaPath;
      mediaBlocksBackup = context.mediaBlocks;
      // deleted media bubbling information
      context.mediaPath = [];
      context.mediaBlocks = [];
      if (value) {
        value = value.eval(context);
      }
      if (rules) {
        // assuming that there is only one rule at this point - that is how parser constructs the rule
        rules = [rules[0].eval(context)];
        rules[0].root = true;
      }
      // restore media bubbling information
      context.mediaPath = mediaPathBackup;
      context.mediaBlocks = mediaBlocksBackup;
      return new AtRule(this.name, value, rules, this.getIndex(), this.fileInfo(), this.debugInfo, this.isRooted, this.visibilityInfo());
    },
    variable: function (name) {
      if (this.rules) {
        // assuming that there is only one rule at this point - that is how parser constructs the rule
        return ruleset_1.default.prototype.variable.call(this.rules[0], name);
      }
    },
    find: function () {
      if (this.rules) {
        // assuming that there is only one rule at this point - that is how parser constructs the rule
        return ruleset_1.default.prototype.find.apply(this.rules[0], arguments);
      }
    },
    rulesets: function () {
      if (this.rules) {
        // assuming that there is only one rule at this point - that is how parser constructs the rule
        return ruleset_1.default.prototype.rulesets.apply(this.rules[0]);
      }
    },
    outputRuleset: function (context, output, rules) {
      var ruleCnt = rules.length;
      var i;
      context.tabLevel = (context.tabLevel | 0) + 1;
      // Compressed
      if (context.compress) {
        output.add('{');
        for (i = 0; i < ruleCnt; i++) {
          rules[i].genCSS(context, output);
        }
        output.add('}');
        context.tabLevel--;
        return;
      }
      // Non-compressed
      var tabSetStr = "\n".concat(Array(context.tabLevel).join('  ')),
        tabRuleStr = "".concat(tabSetStr, "  ");
      if (!ruleCnt) {
        output.add(" {".concat(tabSetStr, "}"));
      } else {
        output.add(" {".concat(tabRuleStr));
        rules[0].genCSS(context, output);
        for (i = 1; i < ruleCnt; i++) {
          output.add(tabRuleStr);
          rules[i].genCSS(context, output);
        }
        output.add("".concat(tabSetStr, "}"));
      }
      context.tabLevel--;
    }
  });
  atrule.default = AtRule;
  return atrule;
}

var detachedRuleset = {};

var hasRequiredDetachedRuleset;
function requireDetachedRuleset() {
  if (hasRequiredDetachedRuleset) return detachedRuleset;
  hasRequiredDetachedRuleset = 1;
  Object.defineProperty(detachedRuleset, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var node_1 = tslib_1.__importDefault(requireNode());
  var contexts_1 = tslib_1.__importDefault(requireContexts());
  var utils = tslib_1.__importStar(requireUtils());
  var DetachedRuleset = function (ruleset, frames) {
    this.ruleset = ruleset;
    this.frames = frames;
    this.setParent(this.ruleset, this);
  };
  DetachedRuleset.prototype = Object.assign(new node_1.default(), {
    type: 'DetachedRuleset',
    evalFirst: true,
    accept: function (visitor) {
      this.ruleset = visitor.visit(this.ruleset);
    },
    eval: function (context) {
      var frames = this.frames || utils.copyArray(context.frames);
      return new DetachedRuleset(this.ruleset, frames);
    },
    callEval: function (context) {
      return this.ruleset.eval(this.frames ? new contexts_1.default.Eval(context, this.frames.concat(context.frames)) : context);
    }
  });
  detachedRuleset.default = DetachedRuleset;
  return detachedRuleset;
}

var operation = {};

var dimension = {};

var unit = {};

var hasRequiredUnit;
function requireUnit() {
  if (hasRequiredUnit) return unit;
  hasRequiredUnit = 1;
  Object.defineProperty(unit, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var node_1 = tslib_1.__importDefault(requireNode());
  var unit_conversions_1 = tslib_1.__importDefault(requireUnitConversions());
  var utils = tslib_1.__importStar(requireUtils());
  var Unit = function (numerator, denominator, backupUnit) {
    this.numerator = numerator ? utils.copyArray(numerator).sort() : [];
    this.denominator = denominator ? utils.copyArray(denominator).sort() : [];
    if (backupUnit) {
      this.backupUnit = backupUnit;
    } else if (numerator && numerator.length) {
      this.backupUnit = numerator[0];
    }
  };
  Unit.prototype = Object.assign(new node_1.default(), {
    type: 'Unit',
    clone: function () {
      return new Unit(utils.copyArray(this.numerator), utils.copyArray(this.denominator), this.backupUnit);
    },
    genCSS: function (context, output) {
      // Dimension checks the unit is singular and throws an error if in strict math mode.
      var strictUnits = context && context.strictUnits;
      if (this.numerator.length === 1) {
        output.add(this.numerator[0]); // the ideal situation
      } else if (!strictUnits && this.backupUnit) {
        output.add(this.backupUnit);
      } else if (!strictUnits && this.denominator.length) {
        output.add(this.denominator[0]);
      }
    },
    toString: function () {
      var i,
        returnStr = this.numerator.join('*');
      for (i = 0; i < this.denominator.length; i++) {
        returnStr += "/".concat(this.denominator[i]);
      }
      return returnStr;
    },
    compare: function (other) {
      return this.is(other.toString()) ? 0 : undefined;
    },
    is: function (unitString) {
      return this.toString().toUpperCase() === unitString.toUpperCase();
    },
    isLength: function () {
      return RegExp('^(px|em|ex|ch|rem|in|cm|mm|pc|pt|ex|vw|vh|vmin|vmax)$', 'gi').test(this.toCSS());
    },
    isEmpty: function () {
      return this.numerator.length === 0 && this.denominator.length === 0;
    },
    isSingular: function () {
      return this.numerator.length <= 1 && this.denominator.length === 0;
    },
    map: function (callback) {
      var i;
      for (i = 0; i < this.numerator.length; i++) {
        this.numerator[i] = callback(this.numerator[i], false);
      }
      for (i = 0; i < this.denominator.length; i++) {
        this.denominator[i] = callback(this.denominator[i], true);
      }
    },
    usedUnits: function () {
      var group;
      var result = {};
      var mapUnit;
      var groupName;
      mapUnit = function (atomicUnit) {
        // eslint-disable-next-line no-prototype-builtins
        if (group.hasOwnProperty(atomicUnit) && !result[groupName]) {
          result[groupName] = atomicUnit;
        }
        return atomicUnit;
      };
      for (groupName in unit_conversions_1.default) {
        // eslint-disable-next-line no-prototype-builtins
        if (unit_conversions_1.default.hasOwnProperty(groupName)) {
          group = unit_conversions_1.default[groupName];
          this.map(mapUnit);
        }
      }
      return result;
    },
    cancel: function () {
      var counter = {};
      var atomicUnit;
      var i;
      for (i = 0; i < this.numerator.length; i++) {
        atomicUnit = this.numerator[i];
        counter[atomicUnit] = (counter[atomicUnit] || 0) + 1;
      }
      for (i = 0; i < this.denominator.length; i++) {
        atomicUnit = this.denominator[i];
        counter[atomicUnit] = (counter[atomicUnit] || 0) - 1;
      }
      this.numerator = [];
      this.denominator = [];
      for (atomicUnit in counter) {
        // eslint-disable-next-line no-prototype-builtins
        if (counter.hasOwnProperty(atomicUnit)) {
          var count = counter[atomicUnit];
          if (count > 0) {
            for (i = 0; i < count; i++) {
              this.numerator.push(atomicUnit);
            }
          } else if (count < 0) {
            for (i = 0; i < -count; i++) {
              this.denominator.push(atomicUnit);
            }
          }
        }
      }
      this.numerator.sort();
      this.denominator.sort();
    }
  });
  unit.default = Unit;
  return unit;
}

var hasRequiredDimension;
function requireDimension() {
  if (hasRequiredDimension) return dimension;
  hasRequiredDimension = 1;
  Object.defineProperty(dimension, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  /* eslint-disable no-prototype-builtins */
  var node_1 = tslib_1.__importDefault(requireNode());
  var unit_conversions_1 = tslib_1.__importDefault(requireUnitConversions());
  var unit_1 = tslib_1.__importDefault(requireUnit());
  var color_1 = tslib_1.__importDefault(requireColor$1());
  //
  // A number with a unit
  //
  var Dimension = function (value, unit) {
    this.value = parseFloat(value);
    if (isNaN(this.value)) {
      throw new Error('Dimension is not a number.');
    }
    this.unit = unit && unit instanceof unit_1.default ? unit : new unit_1.default(unit ? [unit] : undefined);
    this.setParent(this.unit, this);
  };
  Dimension.prototype = Object.assign(new node_1.default(), {
    type: 'Dimension',
    accept: function (visitor) {
      this.unit = visitor.visit(this.unit);
    },
    // remove when Nodes have JSDoc types
    // eslint-disable-next-line no-unused-vars
    eval: function (context) {
      return this;
    },
    toColor: function () {
      return new color_1.default([this.value, this.value, this.value]);
    },
    genCSS: function (context, output) {
      if (context && context.strictUnits && !this.unit.isSingular()) {
        throw new Error("Multiple units in dimension. Correct the units or use the unit function. Bad unit: ".concat(this.unit.toString()));
      }
      var value = this.fround(context, this.value);
      var strValue = String(value);
      if (value !== 0 && value < 0.000001 && value > -0.000001) {
        // would be output 1e-6 etc.
        strValue = value.toFixed(20).replace(/0+$/, '');
      }
      if (context && context.compress) {
        // Zero values doesn't need a unit
        if (value === 0 && this.unit.isLength()) {
          output.add(strValue);
          return;
        }
        // Float values doesn't need a leading zero
        if (value > 0 && value < 1) {
          strValue = strValue.substr(1);
        }
      }
      output.add(strValue);
      this.unit.genCSS(context, output);
    },
    // In an operation between two Dimensions,
    // we default to the first Dimension's unit,
    // so `1px + 2` will yield `3px`.
    operate: function (context, op, other) {
      /* jshint noempty:false */
      var value = this._operate(context, op, this.value, other.value);
      var unit = this.unit.clone();
      if (op === '+' || op === '-') {
        if (unit.numerator.length === 0 && unit.denominator.length === 0) {
          unit = other.unit.clone();
          if (this.unit.backupUnit) {
            unit.backupUnit = this.unit.backupUnit;
          }
        } else if (other.unit.numerator.length === 0 && unit.denominator.length === 0) ; else {
          other = other.convertTo(this.unit.usedUnits());
          if (context.strictUnits && other.unit.toString() !== unit.toString()) {
            throw new Error('Incompatible units. Change the units or use the unit function. ' + "Bad units: '".concat(unit.toString(), "' and '").concat(other.unit.toString(), "'."));
          }
          value = this._operate(context, op, this.value, other.value);
        }
      } else if (op === '*') {
        unit.numerator = unit.numerator.concat(other.unit.numerator).sort();
        unit.denominator = unit.denominator.concat(other.unit.denominator).sort();
        unit.cancel();
      } else if (op === '/') {
        unit.numerator = unit.numerator.concat(other.unit.denominator).sort();
        unit.denominator = unit.denominator.concat(other.unit.numerator).sort();
        unit.cancel();
      }
      return new Dimension(value, unit);
    },
    compare: function (other) {
      var a, b;
      if (!(other instanceof Dimension)) {
        return undefined;
      }
      if (this.unit.isEmpty() || other.unit.isEmpty()) {
        a = this;
        b = other;
      } else {
        a = this.unify();
        b = other.unify();
        if (a.unit.compare(b.unit) !== 0) {
          return undefined;
        }
      }
      return node_1.default.numericCompare(a.value, b.value);
    },
    unify: function () {
      return this.convertTo({
        length: 'px',
        duration: 's',
        angle: 'rad'
      });
    },
    convertTo: function (conversions) {
      var value = this.value;
      var unit = this.unit.clone();
      var i;
      var groupName;
      var group;
      var targetUnit;
      var derivedConversions = {};
      var applyUnit;
      if (typeof conversions === 'string') {
        for (i in unit_conversions_1.default) {
          if (unit_conversions_1.default[i].hasOwnProperty(conversions)) {
            derivedConversions = {};
            derivedConversions[i] = conversions;
          }
        }
        conversions = derivedConversions;
      }
      applyUnit = function (atomicUnit, denominator) {
        if (group.hasOwnProperty(atomicUnit)) {
          if (denominator) {
            value = value / (group[atomicUnit] / group[targetUnit]);
          } else {
            value = value * (group[atomicUnit] / group[targetUnit]);
          }
          return targetUnit;
        }
        return atomicUnit;
      };
      for (groupName in conversions) {
        if (conversions.hasOwnProperty(groupName)) {
          targetUnit = conversions[groupName];
          group = unit_conversions_1.default[groupName];
          unit.map(applyUnit);
        }
      }
      unit.cancel();
      return new Dimension(value, unit);
    }
  });
  dimension.default = Dimension;
  return dimension;
}

var hasRequiredOperation;
function requireOperation() {
  if (hasRequiredOperation) return operation;
  hasRequiredOperation = 1;
  Object.defineProperty(operation, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var node_1 = tslib_1.__importDefault(requireNode());
  var color_1 = tslib_1.__importDefault(requireColor$1());
  var dimension_1 = tslib_1.__importDefault(requireDimension());
  var Constants = tslib_1.__importStar(requireConstants());
  var MATH = Constants.Math;
  var Operation = function (op, operands, isSpaced) {
    this.op = op.trim();
    this.operands = operands;
    this.isSpaced = isSpaced;
  };
  Operation.prototype = Object.assign(new node_1.default(), {
    type: 'Operation',
    accept: function (visitor) {
      this.operands = visitor.visitArray(this.operands);
    },
    eval: function (context) {
      var a = this.operands[0].eval(context),
        b = this.operands[1].eval(context),
        op;
      if (context.isMathOn(this.op)) {
        op = this.op === './' ? '/' : this.op;
        if (a instanceof dimension_1.default && b instanceof color_1.default) {
          a = a.toColor();
        }
        if (b instanceof dimension_1.default && a instanceof color_1.default) {
          b = b.toColor();
        }
        if (!a.operate || !b.operate) {
          if ((a instanceof Operation || b instanceof Operation) && a.op === '/' && context.math === MATH.PARENS_DIVISION) {
            return new Operation(this.op, [a, b], this.isSpaced);
          }
          throw {
            type: 'Operation',
            message: 'Operation on an invalid type'
          };
        }
        return a.operate(context, op, b);
      } else {
        return new Operation(this.op, [a, b], this.isSpaced);
      }
    },
    genCSS: function (context, output) {
      this.operands[0].genCSS(context, output);
      if (this.isSpaced) {
        output.add(' ');
      }
      output.add(this.op);
      if (this.isSpaced) {
        output.add(' ');
      }
      this.operands[1].genCSS(context, output);
    }
  });
  operation.default = Operation;
  return operation;
}

var variable = {};

var call = {};

var functionCaller = {};

var expression = {};

var hasRequiredExpression;
function requireExpression() {
  if (hasRequiredExpression) return expression;
  hasRequiredExpression = 1;
  Object.defineProperty(expression, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var node_1 = tslib_1.__importDefault(requireNode());
  var paren_1 = tslib_1.__importDefault(requireParen());
  var comment_1 = tslib_1.__importDefault(requireComment());
  var dimension_1 = tslib_1.__importDefault(requireDimension());
  var anonymous_1 = tslib_1.__importDefault(requireAnonymous());
  var Expression = function (value, noSpacing) {
    this.value = value;
    this.noSpacing = noSpacing;
    if (!value) {
      throw new Error('Expression requires an array parameter');
    }
  };
  Expression.prototype = Object.assign(new node_1.default(), {
    type: 'Expression',
    accept: function (visitor) {
      this.value = visitor.visitArray(this.value);
    },
    eval: function (context) {
      var returnValue;
      var mathOn = context.isMathOn();
      var inParenthesis = this.parens;
      var doubleParen = false;
      if (inParenthesis) {
        context.inParenthesis();
      }
      if (this.value.length > 1) {
        returnValue = new Expression(this.value.map(function (e) {
          if (!e.eval) {
            return e;
          }
          return e.eval(context);
        }), this.noSpacing);
      } else if (this.value.length === 1) {
        if (this.value[0].parens && !this.value[0].parensInOp && !context.inCalc) {
          doubleParen = true;
        }
        returnValue = this.value[0].eval(context);
      } else {
        returnValue = this;
      }
      if (inParenthesis) {
        context.outOfParenthesis();
      }
      if (this.parens && this.parensInOp && !mathOn && !doubleParen && !(returnValue instanceof dimension_1.default)) {
        returnValue = new paren_1.default(returnValue);
      }
      return returnValue;
    },
    genCSS: function (context, output) {
      for (var i = 0; i < this.value.length; i++) {
        this.value[i].genCSS(context, output);
        if (!this.noSpacing && i + 1 < this.value.length) {
          if (i + 1 < this.value.length && !(this.value[i + 1] instanceof anonymous_1.default) || this.value[i + 1] instanceof anonymous_1.default && this.value[i + 1].value !== ',') {
            output.add(' ');
          }
        }
      }
    },
    throwAwayComments: function () {
      this.value = this.value.filter(function (v) {
        return !(v instanceof comment_1.default);
      });
    }
  });
  expression.default = Expression;
  return expression;
}

var hasRequiredFunctionCaller;
function requireFunctionCaller() {
  if (hasRequiredFunctionCaller) return functionCaller;
  hasRequiredFunctionCaller = 1;
  Object.defineProperty(functionCaller, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var expression_1 = tslib_1.__importDefault(requireExpression());
  var functionCaller$1 = /** @class */function () {
    function functionCaller(name, context, index, currentFileInfo) {
      this.name = name.toLowerCase();
      this.index = index;
      this.context = context;
      this.currentFileInfo = currentFileInfo;
      this.func = context.frames[0].functionRegistry.get(this.name);
    }
    functionCaller.prototype.isValid = function () {
      return Boolean(this.func);
    };
    functionCaller.prototype.call = function (args) {
      var _this = this;
      if (!Array.isArray(args)) {
        args = [args];
      }
      var evalArgs = this.func.evalArgs;
      if (evalArgs !== false) {
        args = args.map(function (a) {
          return a.eval(_this.context);
        });
      }
      var commentFilter = function (item) {
        return !(item.type === 'Comment');
      };
      // This code is terrible and should be replaced as per this issue...
      // https://github.com/less/less.js/issues/2477
      args = args.filter(commentFilter).map(function (item) {
        if (item.type === 'Expression') {
          var subNodes = item.value.filter(commentFilter);
          if (subNodes.length === 1) {
            // https://github.com/less/less.js/issues/3616
            if (item.parens && subNodes[0].op === '/') {
              return item;
            }
            return subNodes[0];
          } else {
            return new expression_1.default(subNodes);
          }
        }
        return item;
      });
      if (evalArgs === false) {
        return this.func.apply(this, tslib_1.__spreadArray([this.context], args, false));
      }
      return this.func.apply(this, args);
    };
    return functionCaller;
  }();
  functionCaller.default = functionCaller$1;
  return functionCaller;
}

var hasRequiredCall;
function requireCall() {
  if (hasRequiredCall) return call;
  hasRequiredCall = 1;
  Object.defineProperty(call, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var node_1 = tslib_1.__importDefault(requireNode());
  var anonymous_1 = tslib_1.__importDefault(requireAnonymous());
  var function_caller_1 = tslib_1.__importDefault(requireFunctionCaller());
  //
  // A function call node.
  //
  var Call = function (name, args, index, currentFileInfo) {
    this.name = name;
    this.args = args;
    this.calc = name === 'calc';
    this._index = index;
    this._fileInfo = currentFileInfo;
  };
  Call.prototype = Object.assign(new node_1.default(), {
    type: 'Call',
    accept: function (visitor) {
      if (this.args) {
        this.args = visitor.visitArray(this.args);
      }
    },
    //
    // When evaluating a function call,
    // we either find the function in the functionRegistry,
    // in which case we call it, passing the  evaluated arguments,
    // if this returns null or we cannot find the function, we
    // simply print it out as it appeared originally [2].
    //
    // The reason why we evaluate the arguments, is in the case where
    // we try to pass a variable to a function, like: `saturate(@color)`.
    // The function should receive the value, not the variable.
    //
    eval: function (context) {
      var _this = this;
      /**
       * Turn off math for calc(), and switch back on for evaluating nested functions
       */
      var currentMathContext = context.mathOn;
      context.mathOn = !this.calc;
      if (this.calc || context.inCalc) {
        context.enterCalc();
      }
      var exitCalc = function () {
        if (_this.calc || context.inCalc) {
          context.exitCalc();
        }
        context.mathOn = currentMathContext;
      };
      var result;
      var funcCaller = new function_caller_1.default(this.name, context, this.getIndex(), this.fileInfo());
      if (funcCaller.isValid()) {
        try {
          result = funcCaller.call(this.args);
          exitCalc();
        } catch (e) {
          // eslint-disable-next-line no-prototype-builtins
          if (e.hasOwnProperty('line') && e.hasOwnProperty('column')) {
            throw e;
          }
          throw {
            type: e.type || 'Runtime',
            message: "Error evaluating function `".concat(this.name, "`").concat(e.message ? ": ".concat(e.message) : ''),
            index: this.getIndex(),
            filename: this.fileInfo().filename,
            line: e.lineNumber,
            column: e.columnNumber
          };
        }
      }
      if (result !== null && result !== undefined) {
        // Results that that are not nodes are cast as Anonymous nodes
        // Falsy values or booleans are returned as empty nodes
        if (!(result instanceof node_1.default)) {
          if (!result || result === true) {
            result = new anonymous_1.default(null);
          } else {
            result = new anonymous_1.default(result.toString());
          }
        }
        result._index = this._index;
        result._fileInfo = this._fileInfo;
        return result;
      }
      var args = this.args.map(function (a) {
        return a.eval(context);
      });
      exitCalc();
      return new Call(this.name, args, this.getIndex(), this.fileInfo());
    },
    genCSS: function (context, output) {
      output.add("".concat(this.name, "("), this.fileInfo(), this.getIndex());
      for (var i = 0; i < this.args.length; i++) {
        this.args[i].genCSS(context, output);
        if (i + 1 < this.args.length) {
          output.add(', ');
        }
      }
      output.add(')');
    }
  });
  call.default = Call;
  return call;
}

var hasRequiredVariable;
function requireVariable() {
  if (hasRequiredVariable) return variable;
  hasRequiredVariable = 1;
  Object.defineProperty(variable, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var node_1 = tslib_1.__importDefault(requireNode());
  var call_1 = tslib_1.__importDefault(requireCall());
  var Variable = function (name, index, currentFileInfo) {
    this.name = name;
    this._index = index;
    this._fileInfo = currentFileInfo;
  };
  Variable.prototype = Object.assign(new node_1.default(), {
    type: 'Variable',
    eval: function (context) {
      var variable,
        name = this.name;
      if (name.indexOf('@@') === 0) {
        name = "@".concat(new Variable(name.slice(1), this.getIndex(), this.fileInfo()).eval(context).value);
      }
      if (this.evaluating) {
        throw {
          type: 'Name',
          message: "Recursive variable definition for ".concat(name),
          filename: this.fileInfo().filename,
          index: this.getIndex()
        };
      }
      this.evaluating = true;
      variable = this.find(context.frames, function (frame) {
        var v = frame.variable(name);
        if (v) {
          if (v.important) {
            var importantScope = context.importantScope[context.importantScope.length - 1];
            importantScope.important = v.important;
          }
          // If in calc, wrap vars in a function call to cascade evaluate args first
          if (context.inCalc) {
            return new call_1.default('_SELF', [v.value]).eval(context);
          } else {
            return v.value.eval(context);
          }
        }
      });
      if (variable) {
        this.evaluating = false;
        return variable;
      } else {
        throw {
          type: 'Name',
          message: "variable ".concat(name, " is undefined"),
          filename: this.fileInfo().filename,
          index: this.getIndex()
        };
      }
    },
    find: function (obj, fun) {
      for (var i = 0, r = void 0; i < obj.length; i++) {
        r = fun.call(obj, obj[i]);
        if (r) {
          return r;
        }
      }
      return null;
    }
  });
  variable.default = Variable;
  return variable;
}

var property = {};

var hasRequiredProperty;
function requireProperty() {
  if (hasRequiredProperty) return property;
  hasRequiredProperty = 1;
  Object.defineProperty(property, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var node_1 = tslib_1.__importDefault(requireNode());
  var declaration_1 = tslib_1.__importDefault(requireDeclaration());
  var Property = function (name, index, currentFileInfo) {
    this.name = name;
    this._index = index;
    this._fileInfo = currentFileInfo;
  };
  Property.prototype = Object.assign(new node_1.default(), {
    type: 'Property',
    eval: function (context) {
      var property;
      var name = this.name;
      // TODO: shorten this reference
      var mergeRules = context.pluginManager.less.visitors.ToCSSVisitor.prototype._mergeRules;
      if (this.evaluating) {
        throw {
          type: 'Name',
          message: "Recursive property reference for ".concat(name),
          filename: this.fileInfo().filename,
          index: this.getIndex()
        };
      }
      this.evaluating = true;
      property = this.find(context.frames, function (frame) {
        var v;
        var vArr = frame.property(name);
        if (vArr) {
          for (var i = 0; i < vArr.length; i++) {
            v = vArr[i];
            vArr[i] = new declaration_1.default(v.name, v.value, v.important, v.merge, v.index, v.currentFileInfo, v.inline, v.variable);
          }
          mergeRules(vArr);
          v = vArr[vArr.length - 1];
          if (v.important) {
            var importantScope = context.importantScope[context.importantScope.length - 1];
            importantScope.important = v.important;
          }
          v = v.value.eval(context);
          return v;
        }
      });
      if (property) {
        this.evaluating = false;
        return property;
      } else {
        throw {
          type: 'Name',
          message: "Property '".concat(name, "' is undefined"),
          filename: this.currentFileInfo.filename,
          index: this.index
        };
      }
    },
    find: function (obj, fun) {
      for (var i = 0, r = void 0; i < obj.length; i++) {
        r = fun.call(obj, obj[i]);
        if (r) {
          return r;
        }
      }
      return null;
    }
  });
  property.default = Property;
  return property;
}

var attribute = {};

var hasRequiredAttribute;
function requireAttribute() {
  if (hasRequiredAttribute) return attribute;
  hasRequiredAttribute = 1;
  Object.defineProperty(attribute, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var node_1 = tslib_1.__importDefault(requireNode());
  var Attribute = function (key, op, value, cif) {
    this.key = key;
    this.op = op;
    this.value = value;
    this.cif = cif;
  };
  Attribute.prototype = Object.assign(new node_1.default(), {
    type: 'Attribute',
    eval: function (context) {
      return new Attribute(this.key.eval ? this.key.eval(context) : this.key, this.op, this.value && this.value.eval ? this.value.eval(context) : this.value, this.cif);
    },
    genCSS: function (context, output) {
      output.add(this.toCSS(context));
    },
    toCSS: function (context) {
      var value = this.key.toCSS ? this.key.toCSS(context) : this.key;
      if (this.op) {
        value += this.op;
        value += this.value.toCSS ? this.value.toCSS(context) : this.value;
      }
      if (this.cif) {
        value = value + ' ' + this.cif;
      }
      return "[".concat(value, "]");
    }
  });
  attribute.default = Attribute;
  return attribute;
}

var quoted = {};

var hasRequiredQuoted;
function requireQuoted() {
  if (hasRequiredQuoted) return quoted;
  hasRequiredQuoted = 1;
  Object.defineProperty(quoted, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var node_1 = tslib_1.__importDefault(requireNode());
  var variable_1 = tslib_1.__importDefault(requireVariable());
  var property_1 = tslib_1.__importDefault(requireProperty());
  var Quoted = function (str, content, escaped, index, currentFileInfo) {
    this.escaped = escaped === undefined ? true : escaped;
    this.value = content || '';
    this.quote = str.charAt(0);
    this._index = index;
    this._fileInfo = currentFileInfo;
    this.variableRegex = /@\{([\w-]+)\}/g;
    this.propRegex = /\$\{([\w-]+)\}/g;
    this.allowRoot = escaped;
  };
  Quoted.prototype = Object.assign(new node_1.default(), {
    type: 'Quoted',
    genCSS: function (context, output) {
      if (!this.escaped) {
        output.add(this.quote, this.fileInfo(), this.getIndex());
      }
      output.add(this.value);
      if (!this.escaped) {
        output.add(this.quote);
      }
    },
    containsVariables: function () {
      return this.value.match(this.variableRegex);
    },
    eval: function (context) {
      var that = this;
      var value = this.value;
      var variableReplacement = function (_, name) {
        var v = new variable_1.default("@".concat(name), that.getIndex(), that.fileInfo()).eval(context, true);
        return v instanceof Quoted ? v.value : v.toCSS();
      };
      var propertyReplacement = function (_, name) {
        var v = new property_1.default("$".concat(name), that.getIndex(), that.fileInfo()).eval(context, true);
        return v instanceof Quoted ? v.value : v.toCSS();
      };
      function iterativeReplace(value, regexp, replacementFnc) {
        var evaluatedValue = value;
        do {
          value = evaluatedValue.toString();
          evaluatedValue = value.replace(regexp, replacementFnc);
        } while (value !== evaluatedValue);
        return evaluatedValue;
      }
      value = iterativeReplace(value, this.variableRegex, variableReplacement);
      value = iterativeReplace(value, this.propRegex, propertyReplacement);
      return new Quoted(this.quote + value + this.quote, value, this.escaped, this.getIndex(), this.fileInfo());
    },
    compare: function (other) {
      // when comparing quoted strings allow the quote to differ
      if (other.type === 'Quoted' && !this.escaped && !other.escaped) {
        return node_1.default.numericCompare(this.value, other.value);
      } else {
        return other.toCSS && this.toCSS() === other.toCSS() ? 0 : undefined;
      }
    }
  });
  quoted.default = Quoted;
  return quoted;
}

var url = {};

var hasRequiredUrl;
function requireUrl() {
  if (hasRequiredUrl) return url;
  hasRequiredUrl = 1;
  Object.defineProperty(url, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var node_1 = tslib_1.__importDefault(requireNode());
  function escapePath(path) {
    return path.replace(/[()'"\s]/g, function (match) {
      return "\\".concat(match);
    });
  }
  var URL = function (val, index, currentFileInfo, isEvald) {
    this.value = val;
    this._index = index;
    this._fileInfo = currentFileInfo;
    this.isEvald = isEvald;
  };
  URL.prototype = Object.assign(new node_1.default(), {
    type: 'Url',
    accept: function (visitor) {
      this.value = visitor.visit(this.value);
    },
    genCSS: function (context, output) {
      output.add('url(');
      this.value.genCSS(context, output);
      output.add(')');
    },
    eval: function (context) {
      var val = this.value.eval(context);
      var rootpath;
      if (!this.isEvald) {
        // Add the rootpath if the URL requires a rewrite
        rootpath = this.fileInfo() && this.fileInfo().rootpath;
        if (typeof rootpath === 'string' && typeof val.value === 'string' && context.pathRequiresRewrite(val.value)) {
          if (!val.quote) {
            rootpath = escapePath(rootpath);
          }
          val.value = context.rewritePath(val.value, rootpath);
        } else {
          val.value = context.normalizePath(val.value);
        }
        // Add url args if enabled
        if (context.urlArgs) {
          if (!val.value.match(/^\s*data:/)) {
            var delimiter = val.value.indexOf('?') === -1 ? '?' : '&';
            var urlArgs = delimiter + context.urlArgs;
            if (val.value.indexOf('#') !== -1) {
              val.value = val.value.replace('#', "".concat(urlArgs, "#"));
            } else {
              val.value += urlArgs;
            }
          }
        }
      }
      return new URL(val, this.getIndex(), this.fileInfo(), true);
    }
  });
  url.default = URL;
  return url;
}

var _import = {};

var media = {};

var nestedAtRule = {};

var hasRequiredNestedAtRule;
function requireNestedAtRule() {
  if (hasRequiredNestedAtRule) return nestedAtRule;
  hasRequiredNestedAtRule = 1;
  Object.defineProperty(nestedAtRule, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var ruleset_1 = tslib_1.__importDefault(requireRuleset());
  var value_1 = tslib_1.__importDefault(requireValue());
  var selector_1 = tslib_1.__importDefault(requireSelector());
  var anonymous_1 = tslib_1.__importDefault(requireAnonymous());
  var expression_1 = tslib_1.__importDefault(requireExpression());
  var utils = tslib_1.__importStar(requireUtils());
  var NestableAtRulePrototype = {
    isRulesetLike: function () {
      return true;
    },
    accept: function (visitor) {
      if (this.features) {
        this.features = visitor.visit(this.features);
      }
      if (this.rules) {
        this.rules = visitor.visitArray(this.rules);
      }
    },
    evalTop: function (context) {
      var result = this;
      // Render all dependent Media blocks.
      if (context.mediaBlocks.length > 1) {
        var selectors = new selector_1.default([], null, null, this.getIndex(), this.fileInfo()).createEmptySelectors();
        result = new ruleset_1.default(selectors, context.mediaBlocks);
        result.multiMedia = true;
        result.copyVisibilityInfo(this.visibilityInfo());
        this.setParent(result, this);
      }
      delete context.mediaBlocks;
      delete context.mediaPath;
      return result;
    },
    evalNested: function (context) {
      var i;
      var value;
      var path = context.mediaPath.concat([this]);
      // Extract the media-query conditions separated with `,` (OR).
      for (i = 0; i < path.length; i++) {
        value = path[i].features instanceof value_1.default ? path[i].features.value : path[i].features;
        path[i] = Array.isArray(value) ? value : [value];
      }
      // Trace all permutations to generate the resulting media-query.
      //
      // (a, b and c) with nested (d, e) ->
      //    a and d
      //    a and e
      //    b and c and d
      //    b and c and e
      this.features = new value_1.default(this.permute(path).map(function (path) {
        path = path.map(function (fragment) {
          return fragment.toCSS ? fragment : new anonymous_1.default(fragment);
        });
        for (i = path.length - 1; i > 0; i--) {
          path.splice(i, 0, new anonymous_1.default('and'));
        }
        return new expression_1.default(path);
      }));
      this.setParent(this.features, this);
      // Fake a tree-node that doesn't output anything.
      return new ruleset_1.default([], []);
    },
    permute: function (arr) {
      if (arr.length === 0) {
        return [];
      } else if (arr.length === 1) {
        return arr[0];
      } else {
        var result = [];
        var rest = this.permute(arr.slice(1));
        for (var i = 0; i < rest.length; i++) {
          for (var j = 0; j < arr[0].length; j++) {
            result.push([arr[0][j]].concat(rest[i]));
          }
        }
        return result;
      }
    },
    bubbleSelectors: function (selectors) {
      if (!selectors) {
        return;
      }
      this.rules = [new ruleset_1.default(utils.copyArray(selectors), [this.rules[0]])];
      this.setParent(this.rules, this);
    }
  };
  nestedAtRule.default = NestableAtRulePrototype;
  return nestedAtRule;
}

var hasRequiredMedia;
function requireMedia() {
  if (hasRequiredMedia) return media;
  hasRequiredMedia = 1;
  Object.defineProperty(media, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var ruleset_1 = tslib_1.__importDefault(requireRuleset());
  var value_1 = tslib_1.__importDefault(requireValue());
  var selector_1 = tslib_1.__importDefault(requireSelector());
  var atrule_1 = tslib_1.__importDefault(requireAtrule());
  var nested_at_rule_1 = tslib_1.__importDefault(requireNestedAtRule());
  var Media = function (value, features, index, currentFileInfo, visibilityInfo) {
    this._index = index;
    this._fileInfo = currentFileInfo;
    var selectors = new selector_1.default([], null, null, this._index, this._fileInfo).createEmptySelectors();
    this.features = new value_1.default(features);
    this.rules = [new ruleset_1.default(selectors, value)];
    this.rules[0].allowImports = true;
    this.copyVisibilityInfo(visibilityInfo);
    this.allowRoot = true;
    this.setParent(selectors, this);
    this.setParent(this.features, this);
    this.setParent(this.rules, this);
  };
  Media.prototype = Object.assign(new atrule_1.default(), tslib_1.__assign(tslib_1.__assign({
    type: 'Media'
  }, nested_at_rule_1.default), {
    genCSS: function (context, output) {
      output.add('@media ', this._fileInfo, this._index);
      this.features.genCSS(context, output);
      this.outputRuleset(context, output, this.rules);
    },
    eval: function (context) {
      if (!context.mediaBlocks) {
        context.mediaBlocks = [];
        context.mediaPath = [];
      }
      var media = new Media(null, [], this._index, this._fileInfo, this.visibilityInfo());
      if (this.debugInfo) {
        this.rules[0].debugInfo = this.debugInfo;
        media.debugInfo = this.debugInfo;
      }
      media.features = this.features.eval(context);
      context.mediaPath.push(media);
      context.mediaBlocks.push(media);
      this.rules[0].functionRegistry = context.frames[0].functionRegistry.inherit();
      context.frames.unshift(this.rules[0]);
      media.rules = [this.rules[0].eval(context)];
      context.frames.shift();
      context.mediaPath.pop();
      return context.mediaPath.length === 0 ? media.evalTop(context) : media.evalNested(context);
    }
  }));
  media.default = Media;
  return media;
}

var hasRequired_import;
function require_import() {
  if (hasRequired_import) return _import;
  hasRequired_import = 1;
  Object.defineProperty(_import, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var node_1 = tslib_1.__importDefault(requireNode());
  var media_1 = tslib_1.__importDefault(requireMedia());
  var url_1 = tslib_1.__importDefault(requireUrl());
  var quoted_1 = tslib_1.__importDefault(requireQuoted());
  var ruleset_1 = tslib_1.__importDefault(requireRuleset());
  var anonymous_1 = tslib_1.__importDefault(requireAnonymous());
  var utils = tslib_1.__importStar(requireUtils());
  var less_error_1 = tslib_1.__importDefault(requireLessError());
  //
  // CSS @import node
  //
  // The general strategy here is that we don't want to wait
  // for the parsing to be completed, before we start importing
  // the file. That's because in the context of a browser,
  // most of the time will be spent waiting for the server to respond.
  //
  // On creation, we push the import path to our import queue, though
  // `import,push`, we also pass it a callback, which it'll call once
  // the file has been fetched, and parsed.
  //
  var Import = function (path, features, options, index, currentFileInfo, visibilityInfo) {
    this.options = options;
    this._index = index;
    this._fileInfo = currentFileInfo;
    this.path = path;
    this.features = features;
    this.allowRoot = true;
    if (this.options.less !== undefined || this.options.inline) {
      this.css = !this.options.less || this.options.inline;
    } else {
      var pathValue = this.getPath();
      if (pathValue && /[#.&?]css([?;].*)?$/.test(pathValue)) {
        this.css = true;
      }
    }
    this.copyVisibilityInfo(visibilityInfo);
    this.setParent(this.features, this);
    this.setParent(this.path, this);
  };
  Import.prototype = Object.assign(new node_1.default(), {
    type: 'Import',
    accept: function (visitor) {
      if (this.features) {
        this.features = visitor.visit(this.features);
      }
      this.path = visitor.visit(this.path);
      if (!this.options.isPlugin && !this.options.inline && this.root) {
        this.root = visitor.visit(this.root);
      }
    },
    genCSS: function (context, output) {
      if (this.css && this.path._fileInfo.reference === undefined) {
        output.add('@import ', this._fileInfo, this._index);
        this.path.genCSS(context, output);
        if (this.features) {
          output.add(' ');
          this.features.genCSS(context, output);
        }
        output.add(';');
      }
    },
    getPath: function () {
      return this.path instanceof url_1.default ? this.path.value.value : this.path.value;
    },
    isVariableImport: function () {
      var path = this.path;
      if (path instanceof url_1.default) {
        path = path.value;
      }
      if (path instanceof quoted_1.default) {
        return path.containsVariables();
      }
      return true;
    },
    evalForImport: function (context) {
      var path = this.path;
      if (path instanceof url_1.default) {
        path = path.value;
      }
      return new Import(path.eval(context), this.features, this.options, this._index, this._fileInfo, this.visibilityInfo());
    },
    evalPath: function (context) {
      var path = this.path.eval(context);
      var fileInfo = this._fileInfo;
      if (!(path instanceof url_1.default)) {
        // Add the rootpath if the URL requires a rewrite
        var pathValue = path.value;
        if (fileInfo && pathValue && context.pathRequiresRewrite(pathValue)) {
          path.value = context.rewritePath(pathValue, fileInfo.rootpath);
        } else {
          path.value = context.normalizePath(path.value);
        }
      }
      return path;
    },
    eval: function (context) {
      var result = this.doEval(context);
      if (this.options.reference || this.blocksVisibility()) {
        if (result.length || result.length === 0) {
          result.forEach(function (node) {
            node.addVisibilityBlock();
          });
        } else {
          result.addVisibilityBlock();
        }
      }
      return result;
    },
    doEval: function (context) {
      var ruleset;
      var registry;
      var features = this.features && this.features.eval(context);
      if (this.options.isPlugin) {
        if (this.root && this.root.eval) {
          try {
            this.root.eval(context);
          } catch (e) {
            e.message = 'Plugin error during evaluation';
            throw new less_error_1.default(e, this.root.imports, this.root.filename);
          }
        }
        registry = context.frames[0] && context.frames[0].functionRegistry;
        if (registry && this.root && this.root.functions) {
          registry.addMultiple(this.root.functions);
        }
        return [];
      }
      if (this.skip) {
        if (typeof this.skip === 'function') {
          this.skip = this.skip();
        }
        if (this.skip) {
          return [];
        }
      }
      if (this.options.inline) {
        var contents = new anonymous_1.default(this.root, 0, {
          filename: this.importedFilename,
          reference: this.path._fileInfo && this.path._fileInfo.reference
        }, true, true);
        return this.features ? new media_1.default([contents], this.features.value) : [contents];
      } else if (this.css) {
        var newImport = new Import(this.evalPath(context), features, this.options, this._index);
        if (!newImport.css && this.error) {
          throw this.error;
        }
        return newImport;
      } else if (this.root) {
        ruleset = new ruleset_1.default(null, utils.copyArray(this.root.rules));
        ruleset.evalImports(context);
        return this.features ? new media_1.default(ruleset.rules, this.features.value) : ruleset.rules;
      } else {
        return [];
      }
    }
  });
  _import.default = Import;
  return _import;
}

var javascript = {};

var jsEvalNode = {};

var hasRequiredJsEvalNode;
function requireJsEvalNode() {
  if (hasRequiredJsEvalNode) return jsEvalNode;
  hasRequiredJsEvalNode = 1;
  Object.defineProperty(jsEvalNode, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var node_1 = tslib_1.__importDefault(requireNode());
  var variable_1 = tslib_1.__importDefault(requireVariable());
  var JsEvalNode = function () {};
  JsEvalNode.prototype = Object.assign(new node_1.default(), {
    evaluateJavaScript: function (expression, context) {
      var result;
      var that = this;
      var evalContext = {};
      if (!context.javascriptEnabled) {
        throw {
          message: 'Inline JavaScript is not enabled. Is it set in your options?',
          filename: this.fileInfo().filename,
          index: this.getIndex()
        };
      }
      expression = expression.replace(/@\{([\w-]+)\}/g, function (_, name) {
        return that.jsify(new variable_1.default("@".concat(name), that.getIndex(), that.fileInfo()).eval(context));
      });
      try {
        expression = new Function("return (".concat(expression, ")"));
      } catch (e) {
        throw {
          message: "JavaScript evaluation error: ".concat(e.message, " from `").concat(expression, "`"),
          filename: this.fileInfo().filename,
          index: this.getIndex()
        };
      }
      var variables = context.frames[0].variables();
      for (var k in variables) {
        // eslint-disable-next-line no-prototype-builtins
        if (variables.hasOwnProperty(k)) {
          evalContext[k.slice(1)] = {
            value: variables[k].value,
            toJS: function () {
              return this.value.eval(context).toCSS();
            }
          };
        }
      }
      try {
        result = expression.call(evalContext);
      } catch (e) {
        throw {
          message: "JavaScript evaluation error: '".concat(e.name, ": ").concat(e.message.replace(/["]/g, '\''), "'"),
          filename: this.fileInfo().filename,
          index: this.getIndex()
        };
      }
      return result;
    },
    jsify: function (obj) {
      if (Array.isArray(obj.value) && obj.value.length > 1) {
        return "[".concat(obj.value.map(function (v) {
          return v.toCSS();
        }).join(', '), "]");
      } else {
        return obj.toCSS();
      }
    }
  });
  jsEvalNode.default = JsEvalNode;
  return jsEvalNode;
}

var hasRequiredJavascript;
function requireJavascript() {
  if (hasRequiredJavascript) return javascript;
  hasRequiredJavascript = 1;
  Object.defineProperty(javascript, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var js_eval_node_1 = tslib_1.__importDefault(requireJsEvalNode());
  var dimension_1 = tslib_1.__importDefault(requireDimension());
  var quoted_1 = tslib_1.__importDefault(requireQuoted());
  var anonymous_1 = tslib_1.__importDefault(requireAnonymous());
  var JavaScript = function (string, escaped, index, currentFileInfo) {
    this.escaped = escaped;
    this.expression = string;
    this._index = index;
    this._fileInfo = currentFileInfo;
  };
  JavaScript.prototype = Object.assign(new js_eval_node_1.default(), {
    type: 'JavaScript',
    eval: function (context) {
      var result = this.evaluateJavaScript(this.expression, context);
      var type = typeof result;
      if (type === 'number' && !isNaN(result)) {
        return new dimension_1.default(result);
      } else if (type === 'string') {
        return new quoted_1.default("\"".concat(result, "\""), result, this.escaped, this._index);
      } else if (Array.isArray(result)) {
        return new anonymous_1.default(result.join(', '));
      } else {
        return new anonymous_1.default(result);
      }
    }
  });
  javascript.default = JavaScript;
  return javascript;
}

var assignment = {};

var hasRequiredAssignment;
function requireAssignment() {
  if (hasRequiredAssignment) return assignment;
  hasRequiredAssignment = 1;
  Object.defineProperty(assignment, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var node_1 = tslib_1.__importDefault(requireNode());
  var Assignment = function (key, val) {
    this.key = key;
    this.value = val;
  };
  Assignment.prototype = Object.assign(new node_1.default(), {
    type: 'Assignment',
    accept: function (visitor) {
      this.value = visitor.visit(this.value);
    },
    eval: function (context) {
      if (this.value.eval) {
        return new Assignment(this.key, this.value.eval(context));
      }
      return this;
    },
    genCSS: function (context, output) {
      output.add("".concat(this.key, "="));
      if (this.value.genCSS) {
        this.value.genCSS(context, output);
      } else {
        output.add(this.value);
      }
    }
  });
  assignment.default = Assignment;
  return assignment;
}

var condition = {};

var hasRequiredCondition;
function requireCondition() {
  if (hasRequiredCondition) return condition;
  hasRequiredCondition = 1;
  Object.defineProperty(condition, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var node_1 = tslib_1.__importDefault(requireNode());
  var Condition = function (op, l, r, i, negate) {
    this.op = op.trim();
    this.lvalue = l;
    this.rvalue = r;
    this._index = i;
    this.negate = negate;
  };
  Condition.prototype = Object.assign(new node_1.default(), {
    type: 'Condition',
    accept: function (visitor) {
      this.lvalue = visitor.visit(this.lvalue);
      this.rvalue = visitor.visit(this.rvalue);
    },
    eval: function (context) {
      var result = function (op, a, b) {
        switch (op) {
          case 'and':
            return a && b;
          case 'or':
            return a || b;
          default:
            switch (node_1.default.compare(a, b)) {
              case -1:
                return op === '<' || op === '=<' || op === '<=';
              case 0:
                return op === '=' || op === '>=' || op === '=<' || op === '<=';
              case 1:
                return op === '>' || op === '>=';
              default:
                return false;
            }
        }
      }(this.op, this.lvalue.eval(context), this.rvalue.eval(context));
      return this.negate ? !result : result;
    }
  });
  condition.default = Condition;
  return condition;
}

var queryInParens = {};

var hasRequiredQueryInParens;
function requireQueryInParens() {
  if (hasRequiredQueryInParens) return queryInParens;
  hasRequiredQueryInParens = 1;
  Object.defineProperty(queryInParens, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var node_1 = tslib_1.__importDefault(requireNode());
  var QueryInParens = function (op, l, m, op2, r, i) {
    this.op = op.trim();
    this.lvalue = l;
    this.mvalue = m;
    this.op2 = op2 ? op2.trim() : null;
    this.rvalue = r;
    this._index = i;
  };
  QueryInParens.prototype = Object.assign(new node_1.default(), {
    type: 'QueryInParens',
    accept: function (visitor) {
      this.lvalue = visitor.visit(this.lvalue);
      this.mvalue = visitor.visit(this.mvalue);
      if (this.rvalue) {
        this.rvalue = visitor.visit(this.rvalue);
      }
    },
    eval: function (context) {
      this.lvalue = this.lvalue.eval(context);
      this.mvalue = this.mvalue.eval(context);
      if (this.rvalue) {
        this.rvalue = this.rvalue.eval(context);
      }
      return this;
    },
    genCSS: function (context, output) {
      this.lvalue.genCSS(context, output);
      output.add(' ' + this.op + ' ');
      this.mvalue.genCSS(context, output);
      if (this.rvalue) {
        output.add(' ' + this.op2 + ' ');
        this.rvalue.genCSS(context, output);
      }
    }
  });
  queryInParens.default = QueryInParens;
  return queryInParens;
}

var container = {};

var hasRequiredContainer;
function requireContainer() {
  if (hasRequiredContainer) return container;
  hasRequiredContainer = 1;
  Object.defineProperty(container, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var ruleset_1 = tslib_1.__importDefault(requireRuleset());
  var value_1 = tslib_1.__importDefault(requireValue());
  var selector_1 = tslib_1.__importDefault(requireSelector());
  var atrule_1 = tslib_1.__importDefault(requireAtrule());
  var nested_at_rule_1 = tslib_1.__importDefault(requireNestedAtRule());
  var Container = function (value, features, index, currentFileInfo, visibilityInfo) {
    this._index = index;
    this._fileInfo = currentFileInfo;
    var selectors = new selector_1.default([], null, null, this._index, this._fileInfo).createEmptySelectors();
    this.features = new value_1.default(features);
    this.rules = [new ruleset_1.default(selectors, value)];
    this.rules[0].allowImports = true;
    this.copyVisibilityInfo(visibilityInfo);
    this.allowRoot = true;
    this.setParent(selectors, this);
    this.setParent(this.features, this);
    this.setParent(this.rules, this);
  };
  Container.prototype = Object.assign(new atrule_1.default(), tslib_1.__assign(tslib_1.__assign({
    type: 'Container'
  }, nested_at_rule_1.default), {
    genCSS: function (context, output) {
      output.add('@container ', this._fileInfo, this._index);
      this.features.genCSS(context, output);
      this.outputRuleset(context, output, this.rules);
    },
    eval: function (context) {
      if (!context.mediaBlocks) {
        context.mediaBlocks = [];
        context.mediaPath = [];
      }
      var media = new Container(null, [], this._index, this._fileInfo, this.visibilityInfo());
      if (this.debugInfo) {
        this.rules[0].debugInfo = this.debugInfo;
        media.debugInfo = this.debugInfo;
      }
      media.features = this.features.eval(context);
      context.mediaPath.push(media);
      context.mediaBlocks.push(media);
      this.rules[0].functionRegistry = context.frames[0].functionRegistry.inherit();
      context.frames.unshift(this.rules[0]);
      media.rules = [this.rules[0].eval(context)];
      context.frames.shift();
      context.mediaPath.pop();
      return context.mediaPath.length === 0 ? media.evalTop(context) : media.evalNested(context);
    }
  }));
  container.default = Container;
  return container;
}

var unicodeDescriptor = {};

var hasRequiredUnicodeDescriptor;
function requireUnicodeDescriptor() {
  if (hasRequiredUnicodeDescriptor) return unicodeDescriptor;
  hasRequiredUnicodeDescriptor = 1;
  Object.defineProperty(unicodeDescriptor, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var node_1 = tslib_1.__importDefault(requireNode());
  var UnicodeDescriptor = function (value) {
    this.value = value;
  };
  UnicodeDescriptor.prototype = Object.assign(new node_1.default(), {
    type: 'UnicodeDescriptor'
  });
  unicodeDescriptor.default = UnicodeDescriptor;
  return unicodeDescriptor;
}

var negative = {};

var hasRequiredNegative;
function requireNegative() {
  if (hasRequiredNegative) return negative;
  hasRequiredNegative = 1;
  Object.defineProperty(negative, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var node_1 = tslib_1.__importDefault(requireNode());
  var operation_1 = tslib_1.__importDefault(requireOperation());
  var dimension_1 = tslib_1.__importDefault(requireDimension());
  var Negative = function (node) {
    this.value = node;
  };
  Negative.prototype = Object.assign(new node_1.default(), {
    type: 'Negative',
    genCSS: function (context, output) {
      output.add('-');
      this.value.genCSS(context, output);
    },
    eval: function (context) {
      if (context.isMathOn()) {
        return new operation_1.default('*', [new dimension_1.default(-1), this.value]).eval(context);
      }
      return new Negative(this.value.eval(context));
    }
  });
  negative.default = Negative;
  return negative;
}

var extend = {};

var hasRequiredExtend;
function requireExtend() {
  if (hasRequiredExtend) return extend;
  hasRequiredExtend = 1;
  Object.defineProperty(extend, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var node_1 = tslib_1.__importDefault(requireNode());
  var selector_1 = tslib_1.__importDefault(requireSelector());
  var Extend = function (selector, option, index, currentFileInfo, visibilityInfo) {
    this.selector = selector;
    this.option = option;
    this.object_id = Extend.next_id++;
    this.parent_ids = [this.object_id];
    this._index = index;
    this._fileInfo = currentFileInfo;
    this.copyVisibilityInfo(visibilityInfo);
    this.allowRoot = true;
    switch (option) {
      case 'all':
        this.allowBefore = true;
        this.allowAfter = true;
        break;
      default:
        this.allowBefore = false;
        this.allowAfter = false;
        break;
    }
    this.setParent(this.selector, this);
  };
  Extend.prototype = Object.assign(new node_1.default(), {
    type: 'Extend',
    accept: function (visitor) {
      this.selector = visitor.visit(this.selector);
    },
    eval: function (context) {
      return new Extend(this.selector.eval(context), this.option, this.getIndex(), this.fileInfo(), this.visibilityInfo());
    },
    // remove when Nodes have JSDoc types
    // eslint-disable-next-line no-unused-vars
    clone: function (context) {
      return new Extend(this.selector, this.option, this.getIndex(), this.fileInfo(), this.visibilityInfo());
    },
    // it concatenates (joins) all selectors in selector array
    findSelfSelectors: function (selectors) {
      var selfElements = [],
        i,
        selectorElements;
      for (i = 0; i < selectors.length; i++) {
        selectorElements = selectors[i].elements;
        // duplicate the logic in genCSS function inside the selector node.
        // future TODO - move both logics into the selector joiner visitor
        if (i > 0 && selectorElements.length && selectorElements[0].combinator.value === '') {
          selectorElements[0].combinator.value = ' ';
        }
        selfElements = selfElements.concat(selectors[i].elements);
      }
      this.selfSelectors = [new selector_1.default(selfElements)];
      this.selfSelectors[0].copyVisibilityInfo(this.visibilityInfo());
    }
  });
  Extend.next_id = 0;
  extend.default = Extend;
  return extend;
}

var variableCall = {};

var hasRequiredVariableCall;
function requireVariableCall() {
  if (hasRequiredVariableCall) return variableCall;
  hasRequiredVariableCall = 1;
  Object.defineProperty(variableCall, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var node_1 = tslib_1.__importDefault(requireNode());
  var variable_1 = tslib_1.__importDefault(requireVariable());
  var ruleset_1 = tslib_1.__importDefault(requireRuleset());
  var detached_ruleset_1 = tslib_1.__importDefault(requireDetachedRuleset());
  var less_error_1 = tslib_1.__importDefault(requireLessError());
  var VariableCall = function (variable, index, currentFileInfo) {
    this.variable = variable;
    this._index = index;
    this._fileInfo = currentFileInfo;
    this.allowRoot = true;
  };
  VariableCall.prototype = Object.assign(new node_1.default(), {
    type: 'VariableCall',
    eval: function (context) {
      var rules;
      var detachedRuleset = new variable_1.default(this.variable, this.getIndex(), this.fileInfo()).eval(context);
      var error = new less_error_1.default({
        message: "Could not evaluate variable call ".concat(this.variable)
      });
      if (!detachedRuleset.ruleset) {
        if (detachedRuleset.rules) {
          rules = detachedRuleset;
        } else if (Array.isArray(detachedRuleset)) {
          rules = new ruleset_1.default('', detachedRuleset);
        } else if (Array.isArray(detachedRuleset.value)) {
          rules = new ruleset_1.default('', detachedRuleset.value);
        } else {
          throw error;
        }
        detachedRuleset = new detached_ruleset_1.default(rules);
      }
      if (detachedRuleset.ruleset) {
        return detachedRuleset.callEval(context);
      }
      throw error;
    }
  });
  variableCall.default = VariableCall;
  return variableCall;
}

var namespaceValue = {};

var hasRequiredNamespaceValue;
function requireNamespaceValue() {
  if (hasRequiredNamespaceValue) return namespaceValue;
  hasRequiredNamespaceValue = 1;
  Object.defineProperty(namespaceValue, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var node_1 = tslib_1.__importDefault(requireNode());
  var variable_1 = tslib_1.__importDefault(requireVariable());
  var ruleset_1 = tslib_1.__importDefault(requireRuleset());
  var selector_1 = tslib_1.__importDefault(requireSelector());
  var NamespaceValue = function (ruleCall, lookups, index, fileInfo) {
    this.value = ruleCall;
    this.lookups = lookups;
    this._index = index;
    this._fileInfo = fileInfo;
  };
  NamespaceValue.prototype = Object.assign(new node_1.default(), {
    type: 'NamespaceValue',
    eval: function (context) {
      var i,
        name,
        rules = this.value.eval(context);
      for (i = 0; i < this.lookups.length; i++) {
        name = this.lookups[i];
        /**
         * Eval'd DRs return rulesets.
         * Eval'd mixins return rules, so let's make a ruleset if we need it.
         * We need to do this because of late parsing of values
         */
        if (Array.isArray(rules)) {
          rules = new ruleset_1.default([new selector_1.default()], rules);
        }
        if (name === '') {
          rules = rules.lastDeclaration();
        } else if (name.charAt(0) === '@') {
          if (name.charAt(1) === '@') {
            name = "@".concat(new variable_1.default(name.substr(1)).eval(context).value);
          }
          if (rules.variables) {
            rules = rules.variable(name);
          }
          if (!rules) {
            throw {
              type: 'Name',
              message: "variable ".concat(name, " not found"),
              filename: this.fileInfo().filename,
              index: this.getIndex()
            };
          }
        } else {
          if (name.substring(0, 2) === '$@') {
            name = "$".concat(new variable_1.default(name.substr(1)).eval(context).value);
          } else {
            name = name.charAt(0) === '$' ? name : "$".concat(name);
          }
          if (rules.properties) {
            rules = rules.property(name);
          }
          if (!rules) {
            throw {
              type: 'Name',
              message: "property \"".concat(name.substr(1), "\" not found"),
              filename: this.fileInfo().filename,
              index: this.getIndex()
            };
          }
          // Properties are an array of values, since a ruleset can have multiple props.
          // We pick the last one (the "cascaded" value)
          rules = rules[rules.length - 1];
        }
        if (rules.value) {
          rules = rules.eval(context).value;
        }
        if (rules.ruleset) {
          rules = rules.ruleset.eval(context);
        }
      }
      return rules;
    }
  });
  namespaceValue.default = NamespaceValue;
  return namespaceValue;
}

var mixinCall = {};

var mixinDefinition = {};

var hasRequiredMixinDefinition;
function requireMixinDefinition() {
  if (hasRequiredMixinDefinition) return mixinDefinition;
  hasRequiredMixinDefinition = 1;
  Object.defineProperty(mixinDefinition, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var selector_1 = tslib_1.__importDefault(requireSelector());
  var element_1 = tslib_1.__importDefault(requireElement());
  var ruleset_1 = tslib_1.__importDefault(requireRuleset());
  var declaration_1 = tslib_1.__importDefault(requireDeclaration());
  var detached_ruleset_1 = tslib_1.__importDefault(requireDetachedRuleset());
  var expression_1 = tslib_1.__importDefault(requireExpression());
  var contexts_1 = tslib_1.__importDefault(requireContexts());
  var utils = tslib_1.__importStar(requireUtils());
  var Definition = function (name, params, rules, condition, variadic, frames, visibilityInfo) {
    this.name = name || 'anonymous mixin';
    this.selectors = [new selector_1.default([new element_1.default(null, name, false, this._index, this._fileInfo)])];
    this.params = params;
    this.condition = condition;
    this.variadic = variadic;
    this.arity = params.length;
    this.rules = rules;
    this._lookups = {};
    var optionalParameters = [];
    this.required = params.reduce(function (count, p) {
      if (!p.name || p.name && !p.value) {
        return count + 1;
      } else {
        optionalParameters.push(p.name);
        return count;
      }
    }, 0);
    this.optionalParameters = optionalParameters;
    this.frames = frames;
    this.copyVisibilityInfo(visibilityInfo);
    this.allowRoot = true;
  };
  Definition.prototype = Object.assign(new ruleset_1.default(), {
    type: 'MixinDefinition',
    evalFirst: true,
    accept: function (visitor) {
      if (this.params && this.params.length) {
        this.params = visitor.visitArray(this.params);
      }
      this.rules = visitor.visitArray(this.rules);
      if (this.condition) {
        this.condition = visitor.visit(this.condition);
      }
    },
    evalParams: function (context, mixinEnv, args, evaldArguments) {
      /* jshint boss:true */
      var frame = new ruleset_1.default(null, null);
      var varargs;
      var arg;
      var params = utils.copyArray(this.params);
      var i;
      var j;
      var val;
      var name;
      var isNamedFound;
      var argIndex;
      var argsLength = 0;
      if (mixinEnv.frames && mixinEnv.frames[0] && mixinEnv.frames[0].functionRegistry) {
        frame.functionRegistry = mixinEnv.frames[0].functionRegistry.inherit();
      }
      mixinEnv = new contexts_1.default.Eval(mixinEnv, [frame].concat(mixinEnv.frames));
      if (args) {
        args = utils.copyArray(args);
        argsLength = args.length;
        for (i = 0; i < argsLength; i++) {
          arg = args[i];
          if (name = arg && arg.name) {
            isNamedFound = false;
            for (j = 0; j < params.length; j++) {
              if (!evaldArguments[j] && name === params[j].name) {
                evaldArguments[j] = arg.value.eval(context);
                frame.prependRule(new declaration_1.default(name, arg.value.eval(context)));
                isNamedFound = true;
                break;
              }
            }
            if (isNamedFound) {
              args.splice(i, 1);
              i--;
              continue;
            } else {
              throw {
                type: 'Runtime',
                message: "Named argument for ".concat(this.name, " ").concat(args[i].name, " not found")
              };
            }
          }
        }
      }
      argIndex = 0;
      for (i = 0; i < params.length; i++) {
        if (evaldArguments[i]) {
          continue;
        }
        arg = args && args[argIndex];
        if (name = params[i].name) {
          if (params[i].variadic) {
            varargs = [];
            for (j = argIndex; j < argsLength; j++) {
              varargs.push(args[j].value.eval(context));
            }
            frame.prependRule(new declaration_1.default(name, new expression_1.default(varargs).eval(context)));
          } else {
            val = arg && arg.value;
            if (val) {
              // This was a mixin call, pass in a detached ruleset of it's eval'd rules
              if (Array.isArray(val)) {
                val = new detached_ruleset_1.default(new ruleset_1.default('', val));
              } else {
                val = val.eval(context);
              }
            } else if (params[i].value) {
              val = params[i].value.eval(mixinEnv);
              frame.resetCache();
            } else {
              throw {
                type: 'Runtime',
                message: "wrong number of arguments for ".concat(this.name, " (").concat(argsLength, " for ").concat(this.arity, ")")
              };
            }
            frame.prependRule(new declaration_1.default(name, val));
            evaldArguments[i] = val;
          }
        }
        if (params[i].variadic && args) {
          for (j = argIndex; j < argsLength; j++) {
            evaldArguments[j] = args[j].value.eval(context);
          }
        }
        argIndex++;
      }
      return frame;
    },
    makeImportant: function () {
      var rules = !this.rules ? this.rules : this.rules.map(function (r) {
        if (r.makeImportant) {
          return r.makeImportant(true);
        } else {
          return r;
        }
      });
      var result = new Definition(this.name, this.params, rules, this.condition, this.variadic, this.frames);
      return result;
    },
    eval: function (context) {
      return new Definition(this.name, this.params, this.rules, this.condition, this.variadic, this.frames || utils.copyArray(context.frames));
    },
    evalCall: function (context, args, important) {
      var _arguments = [];
      var mixinFrames = this.frames ? this.frames.concat(context.frames) : context.frames;
      var frame = this.evalParams(context, new contexts_1.default.Eval(context, mixinFrames), args, _arguments);
      var rules;
      var ruleset;
      frame.prependRule(new declaration_1.default('@arguments', new expression_1.default(_arguments).eval(context)));
      rules = utils.copyArray(this.rules);
      ruleset = new ruleset_1.default(null, rules);
      ruleset.originalRuleset = this;
      ruleset = ruleset.eval(new contexts_1.default.Eval(context, [this, frame].concat(mixinFrames)));
      if (important) {
        ruleset = ruleset.makeImportant();
      }
      return ruleset;
    },
    matchCondition: function (args, context) {
      if (this.condition && !this.condition.eval(new contexts_1.default.Eval(context, [this.evalParams(context, /* the parameter variables */new contexts_1.default.Eval(context, this.frames ? this.frames.concat(context.frames) : context.frames), args, [])].concat(this.frames || []) // the parent namespace/mixin frames
      .concat(context.frames)))) {
        // the current environment frames
        return false;
      }
      return true;
    },
    matchArgs: function (args, context) {
      var allArgsCnt = args && args.length || 0;
      var len;
      var optionalParameters = this.optionalParameters;
      var requiredArgsCnt = !args ? 0 : args.reduce(function (count, p) {
        if (optionalParameters.indexOf(p.name) < 0) {
          return count + 1;
        } else {
          return count;
        }
      }, 0);
      if (!this.variadic) {
        if (requiredArgsCnt < this.required) {
          return false;
        }
        if (allArgsCnt > this.params.length) {
          return false;
        }
      } else {
        if (requiredArgsCnt < this.required - 1) {
          return false;
        }
      }
      // check patterns
      len = Math.min(requiredArgsCnt, this.arity);
      for (var i = 0; i < len; i++) {
        if (!this.params[i].name && !this.params[i].variadic) {
          if (args[i].value.eval(context).toCSS() != this.params[i].value.eval(context).toCSS()) {
            return false;
          }
        }
      }
      return true;
    }
  });
  mixinDefinition.default = Definition;
  return mixinDefinition;
}

var hasRequiredMixinCall;
function requireMixinCall() {
  if (hasRequiredMixinCall) return mixinCall;
  hasRequiredMixinCall = 1;
  Object.defineProperty(mixinCall, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var node_1 = tslib_1.__importDefault(requireNode());
  var selector_1 = tslib_1.__importDefault(requireSelector());
  var mixin_definition_1 = tslib_1.__importDefault(requireMixinDefinition());
  var default_1 = tslib_1.__importDefault(require_default());
  var MixinCall = function (elements, args, index, currentFileInfo, important) {
    this.selector = new selector_1.default(elements);
    this.arguments = args || [];
    this._index = index;
    this._fileInfo = currentFileInfo;
    this.important = important;
    this.allowRoot = true;
    this.setParent(this.selector, this);
  };
  MixinCall.prototype = Object.assign(new node_1.default(), {
    type: 'MixinCall',
    accept: function (visitor) {
      if (this.selector) {
        this.selector = visitor.visit(this.selector);
      }
      if (this.arguments.length) {
        this.arguments = visitor.visitArray(this.arguments);
      }
    },
    eval: function (context) {
      var mixins;
      var mixin;
      var mixinPath;
      var args = [];
      var arg;
      var argValue;
      var rules = [];
      var match = false;
      var i;
      var m;
      var f;
      var isRecursive;
      var isOneFound;
      var candidates = [];
      var candidate;
      var conditionResult = [];
      var defaultResult;
      var defFalseEitherCase = -1;
      var defNone = 0;
      var defTrue = 1;
      var defFalse = 2;
      var count;
      var originalRuleset;
      var noArgumentsFilter;
      this.selector = this.selector.eval(context);
      function calcDefGroup(mixin, mixinPath) {
        var f, p, namespace;
        for (f = 0; f < 2; f++) {
          conditionResult[f] = true;
          default_1.default.value(f);
          for (p = 0; p < mixinPath.length && conditionResult[f]; p++) {
            namespace = mixinPath[p];
            if (namespace.matchCondition) {
              conditionResult[f] = conditionResult[f] && namespace.matchCondition(null, context);
            }
          }
          if (mixin.matchCondition) {
            conditionResult[f] = conditionResult[f] && mixin.matchCondition(args, context);
          }
        }
        if (conditionResult[0] || conditionResult[1]) {
          if (conditionResult[0] != conditionResult[1]) {
            return conditionResult[1] ? defTrue : defFalse;
          }
          return defNone;
        }
        return defFalseEitherCase;
      }
      for (i = 0; i < this.arguments.length; i++) {
        arg = this.arguments[i];
        argValue = arg.value.eval(context);
        if (arg.expand && Array.isArray(argValue.value)) {
          argValue = argValue.value;
          for (m = 0; m < argValue.length; m++) {
            args.push({
              value: argValue[m]
            });
          }
        } else {
          args.push({
            name: arg.name,
            value: argValue
          });
        }
      }
      noArgumentsFilter = function (rule) {
        return rule.matchArgs(null, context);
      };
      for (i = 0; i < context.frames.length; i++) {
        if ((mixins = context.frames[i].find(this.selector, null, noArgumentsFilter)).length > 0) {
          isOneFound = true;
          // To make `default()` function independent of definition order we have two "subpasses" here.
          // At first we evaluate each guard *twice* (with `default() == true` and `default() == false`),
          // and build candidate list with corresponding flags. Then, when we know all possible matches,
          // we make a final decision.
          for (m = 0; m < mixins.length; m++) {
            mixin = mixins[m].rule;
            mixinPath = mixins[m].path;
            isRecursive = false;
            for (f = 0; f < context.frames.length; f++) {
              if (!(mixin instanceof mixin_definition_1.default) && mixin === (context.frames[f].originalRuleset || context.frames[f])) {
                isRecursive = true;
                break;
              }
            }
            if (isRecursive) {
              continue;
            }
            if (mixin.matchArgs(args, context)) {
              candidate = {
                mixin: mixin,
                group: calcDefGroup(mixin, mixinPath)
              };
              if (candidate.group !== defFalseEitherCase) {
                candidates.push(candidate);
              }
              match = true;
            }
          }
          default_1.default.reset();
          count = [0, 0, 0];
          for (m = 0; m < candidates.length; m++) {
            count[candidates[m].group]++;
          }
          if (count[defNone] > 0) {
            defaultResult = defFalse;
          } else {
            defaultResult = defTrue;
            if (count[defTrue] + count[defFalse] > 1) {
              throw {
                type: 'Runtime',
                message: "Ambiguous use of `default()` found when matching for `".concat(this.format(args), "`"),
                index: this.getIndex(),
                filename: this.fileInfo().filename
              };
            }
          }
          for (m = 0; m < candidates.length; m++) {
            candidate = candidates[m].group;
            if (candidate === defNone || candidate === defaultResult) {
              try {
                mixin = candidates[m].mixin;
                if (!(mixin instanceof mixin_definition_1.default)) {
                  originalRuleset = mixin.originalRuleset || mixin;
                  mixin = new mixin_definition_1.default('', [], mixin.rules, null, false, null, originalRuleset.visibilityInfo());
                  mixin.originalRuleset = originalRuleset;
                }
                var newRules = mixin.evalCall(context, args, this.important).rules;
                this._setVisibilityToReplacement(newRules);
                Array.prototype.push.apply(rules, newRules);
              } catch (e) {
                throw {
                  message: e.message,
                  index: this.getIndex(),
                  filename: this.fileInfo().filename,
                  stack: e.stack
                };
              }
            }
          }
          if (match) {
            return rules;
          }
        }
      }
      if (isOneFound) {
        throw {
          type: 'Runtime',
          message: "No matching definition was found for `".concat(this.format(args), "`"),
          index: this.getIndex(),
          filename: this.fileInfo().filename
        };
      } else {
        throw {
          type: 'Name',
          message: "".concat(this.selector.toCSS().trim(), " is undefined"),
          index: this.getIndex(),
          filename: this.fileInfo().filename
        };
      }
    },
    _setVisibilityToReplacement: function (replacement) {
      var i, rule;
      if (this.blocksVisibility()) {
        for (i = 0; i < replacement.length; i++) {
          rule = replacement[i];
          rule.addVisibilityBlock();
        }
      }
    },
    format: function (args) {
      return "".concat(this.selector.toCSS().trim(), "(").concat(args ? args.map(function (a) {
        var argValue = '';
        if (a.name) {
          argValue += "".concat(a.name, ":");
        }
        if (a.value.toCSS) {
          argValue += a.value.toCSS();
        } else {
          argValue += '???';
        }
        return argValue;
      }).join(', ') : '', ")");
    }
  });
  mixinCall.default = MixinCall;
  return mixinCall;
}

var hasRequiredTree;
function requireTree() {
  if (hasRequiredTree) return tree;
  hasRequiredTree = 1;
  Object.defineProperty(tree, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var node_1 = tslib_1.__importDefault(requireNode());
  var color_1 = tslib_1.__importDefault(requireColor$1());
  var atrule_1 = tslib_1.__importDefault(requireAtrule());
  var detached_ruleset_1 = tslib_1.__importDefault(requireDetachedRuleset());
  var operation_1 = tslib_1.__importDefault(requireOperation());
  var dimension_1 = tslib_1.__importDefault(requireDimension());
  var unit_1 = tslib_1.__importDefault(requireUnit());
  var keyword_1 = tslib_1.__importDefault(requireKeyword());
  var variable_1 = tslib_1.__importDefault(requireVariable());
  var property_1 = tslib_1.__importDefault(requireProperty());
  var ruleset_1 = tslib_1.__importDefault(requireRuleset());
  var element_1 = tslib_1.__importDefault(requireElement());
  var attribute_1 = tslib_1.__importDefault(requireAttribute());
  var combinator_1 = tslib_1.__importDefault(requireCombinator());
  var selector_1 = tslib_1.__importDefault(requireSelector());
  var quoted_1 = tslib_1.__importDefault(requireQuoted());
  var expression_1 = tslib_1.__importDefault(requireExpression());
  var declaration_1 = tslib_1.__importDefault(requireDeclaration());
  var call_1 = tslib_1.__importDefault(requireCall());
  var url_1 = tslib_1.__importDefault(requireUrl());
  var import_1 = tslib_1.__importDefault(require_import());
  var comment_1 = tslib_1.__importDefault(requireComment());
  var anonymous_1 = tslib_1.__importDefault(requireAnonymous());
  var value_1 = tslib_1.__importDefault(requireValue());
  var javascript_1 = tslib_1.__importDefault(requireJavascript());
  var assignment_1 = tslib_1.__importDefault(requireAssignment());
  var condition_1 = tslib_1.__importDefault(requireCondition());
  var query_in_parens_1 = tslib_1.__importDefault(requireQueryInParens());
  var paren_1 = tslib_1.__importDefault(requireParen());
  var media_1 = tslib_1.__importDefault(requireMedia());
  var container_1 = tslib_1.__importDefault(requireContainer());
  var unicode_descriptor_1 = tslib_1.__importDefault(requireUnicodeDescriptor());
  var negative_1 = tslib_1.__importDefault(requireNegative());
  var extend_1 = tslib_1.__importDefault(requireExtend());
  var variable_call_1 = tslib_1.__importDefault(requireVariableCall());
  var namespace_value_1 = tslib_1.__importDefault(requireNamespaceValue());
  // mixins
  var mixin_call_1 = tslib_1.__importDefault(requireMixinCall());
  var mixin_definition_1 = tslib_1.__importDefault(requireMixinDefinition());
  tree.default = {
    Node: node_1.default,
    Color: color_1.default,
    AtRule: atrule_1.default,
    DetachedRuleset: detached_ruleset_1.default,
    Operation: operation_1.default,
    Dimension: dimension_1.default,
    Unit: unit_1.default,
    Keyword: keyword_1.default,
    Variable: variable_1.default,
    Property: property_1.default,
    Ruleset: ruleset_1.default,
    Element: element_1.default,
    Attribute: attribute_1.default,
    Combinator: combinator_1.default,
    Selector: selector_1.default,
    Quoted: quoted_1.default,
    Expression: expression_1.default,
    Declaration: declaration_1.default,
    Call: call_1.default,
    URL: url_1.default,
    Import: import_1.default,
    Comment: comment_1.default,
    Anonymous: anonymous_1.default,
    Value: value_1.default,
    JavaScript: javascript_1.default,
    Assignment: assignment_1.default,
    Condition: condition_1.default,
    Paren: paren_1.default,
    Media: media_1.default,
    Container: container_1.default,
    QueryInParens: query_in_parens_1.default,
    UnicodeDescriptor: unicode_descriptor_1.default,
    Negative: negative_1.default,
    Extend: extend_1.default,
    VariableCall: variable_call_1.default,
    NamespaceValue: namespace_value_1.default,
    mixin: {
      Call: mixin_call_1.default,
      Definition: mixin_definition_1.default
    }
  };
  return tree;
}

var abstractPluginLoader = {};

var hasRequiredAbstractPluginLoader;
function requireAbstractPluginLoader() {
  if (hasRequiredAbstractPluginLoader) return abstractPluginLoader;
  hasRequiredAbstractPluginLoader = 1;
  Object.defineProperty(abstractPluginLoader, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var function_registry_1 = tslib_1.__importDefault(requireFunctionRegistry());
  var less_error_1 = tslib_1.__importDefault(requireLessError());
  var AbstractPluginLoader = /** @class */function () {
    function AbstractPluginLoader() {
      // Implemented by Node.js plugin loader
      this.require = function () {
        return null;
      };
    }
    AbstractPluginLoader.prototype.evalPlugin = function (contents, context, imports, pluginOptions, fileInfo) {
      var loader, registry, pluginObj, localModule, pluginManager, filename, result;
      pluginManager = context.pluginManager;
      if (fileInfo) {
        if (typeof fileInfo === 'string') {
          filename = fileInfo;
        } else {
          filename = fileInfo.filename;
        }
      }
      var shortname = new this.less.FileManager().extractUrlParts(filename).filename;
      if (filename) {
        pluginObj = pluginManager.get(filename);
        if (pluginObj) {
          result = this.trySetOptions(pluginObj, filename, shortname, pluginOptions);
          if (result) {
            return result;
          }
          try {
            if (pluginObj.use) {
              pluginObj.use.call(this.context, pluginObj);
            }
          } catch (e) {
            e.message = e.message || 'Error during @plugin call';
            return new less_error_1.default(e, imports, filename);
          }
          return pluginObj;
        }
      }
      localModule = {
        exports: {},
        pluginManager: pluginManager,
        fileInfo: fileInfo
      };
      registry = function_registry_1.default.create();
      var registerPlugin = function (obj) {
        pluginObj = obj;
      };
      try {
        loader = new Function('module', 'require', 'registerPlugin', 'functions', 'tree', 'less', 'fileInfo', contents);
        loader(localModule, this.require(filename), registerPlugin, registry, this.less.tree, this.less, fileInfo);
      } catch (e) {
        return new less_error_1.default(e, imports, filename);
      }
      if (!pluginObj) {
        pluginObj = localModule.exports;
      }
      pluginObj = this.validatePlugin(pluginObj, filename, shortname);
      if (pluginObj instanceof less_error_1.default) {
        return pluginObj;
      }
      if (pluginObj) {
        pluginObj.imports = imports;
        pluginObj.filename = filename;
        // For < 3.x (or unspecified minVersion) - setOptions() before install()
        if (!pluginObj.minVersion || this.compareVersion('3.0.0', pluginObj.minVersion) < 0) {
          result = this.trySetOptions(pluginObj, filename, shortname, pluginOptions);
          if (result) {
            return result;
          }
        }
        // Run on first load
        pluginManager.addPlugin(pluginObj, fileInfo.filename, registry);
        pluginObj.functions = registry.getLocalFunctions();
        // Need to call setOptions again because the pluginObj might have functions
        result = this.trySetOptions(pluginObj, filename, shortname, pluginOptions);
        if (result) {
          return result;
        }
        // Run every @plugin call
        try {
          if (pluginObj.use) {
            pluginObj.use.call(this.context, pluginObj);
          }
        } catch (e) {
          e.message = e.message || 'Error during @plugin call';
          return new less_error_1.default(e, imports, filename);
        }
      } else {
        return new less_error_1.default({
          message: 'Not a valid plugin'
        }, imports, filename);
      }
      return pluginObj;
    };
    AbstractPluginLoader.prototype.trySetOptions = function (plugin, filename, name, options) {
      if (options && !plugin.setOptions) {
        return new less_error_1.default({
          message: "Options have been provided but the plugin ".concat(name, " does not support any options.")
        });
      }
      try {
        plugin.setOptions && plugin.setOptions(options);
      } catch (e) {
        return new less_error_1.default(e);
      }
    };
    AbstractPluginLoader.prototype.validatePlugin = function (plugin, filename, name) {
      if (plugin) {
        // support plugins being a function
        // so that the plugin can be more usable programmatically
        if (typeof plugin === 'function') {
          plugin = new plugin();
        }
        if (plugin.minVersion) {
          if (this.compareVersion(plugin.minVersion, this.less.version) < 0) {
            return new less_error_1.default({
              message: "Plugin ".concat(name, " requires version ").concat(this.versionToString(plugin.minVersion))
            });
          }
        }
        return plugin;
      }
      return null;
    };
    AbstractPluginLoader.prototype.compareVersion = function (aVersion, bVersion) {
      if (typeof aVersion === 'string') {
        aVersion = aVersion.match(/^(\d+)\.?(\d+)?\.?(\d+)?/);
        aVersion.shift();
      }
      for (var i = 0; i < aVersion.length; i++) {
        if (aVersion[i] !== bVersion[i]) {
          return parseInt(aVersion[i]) > parseInt(bVersion[i]) ? -1 : 1;
        }
      }
      return 0;
    };
    AbstractPluginLoader.prototype.versionToString = function (version) {
      var versionString = '';
      for (var i = 0; i < version.length; i++) {
        versionString += (versionString ? '.' : '') + version[i];
      }
      return versionString;
    };
    AbstractPluginLoader.prototype.printUsage = function (plugins) {
      for (var i = 0; i < plugins.length; i++) {
        var plugin = plugins[i];
        if (plugin.printUsage) {
          plugin.printUsage();
        }
      }
    };
    return AbstractPluginLoader;
  }();
  abstractPluginLoader.default = AbstractPluginLoader;
  return abstractPluginLoader;
}

var functions = {};

var boolean = {};

var hasRequiredBoolean;
function requireBoolean() {
  if (hasRequiredBoolean) return boolean;
  hasRequiredBoolean = 1;
  Object.defineProperty(boolean, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var anonymous_1 = tslib_1.__importDefault(requireAnonymous());
  var keyword_1 = tslib_1.__importDefault(requireKeyword());
  function boolean$1(condition) {
    return condition ? keyword_1.default.True : keyword_1.default.False;
  }
  /**
   * Functions with evalArgs set to false are sent context
   * as the first argument.
   */
  function If(context, condition, trueValue, falseValue) {
    return condition.eval(context) ? trueValue.eval(context) : falseValue ? falseValue.eval(context) : new anonymous_1.default();
  }
  If.evalArgs = false;
  function isdefined(context, variable) {
    try {
      variable.eval(context);
      return keyword_1.default.True;
    } catch (e) {
      return keyword_1.default.False;
    }
  }
  isdefined.evalArgs = false;
  boolean.default = {
    isdefined: isdefined,
    boolean: boolean$1,
    'if': If
  };
  return boolean;
}

var color = {};

var hasRequiredColor;
function requireColor() {
  if (hasRequiredColor) return color;
  hasRequiredColor = 1;
  Object.defineProperty(color, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var dimension_1 = tslib_1.__importDefault(requireDimension());
  var color_1 = tslib_1.__importDefault(requireColor$1());
  var quoted_1 = tslib_1.__importDefault(requireQuoted());
  var anonymous_1 = tslib_1.__importDefault(requireAnonymous());
  var expression_1 = tslib_1.__importDefault(requireExpression());
  var operation_1 = tslib_1.__importDefault(requireOperation());
  var colorFunctions;
  function clamp(val) {
    return Math.min(1, Math.max(0, val));
  }
  function hsla(origColor, hsl) {
    var color = colorFunctions.hsla(hsl.h, hsl.s, hsl.l, hsl.a);
    if (color) {
      if (origColor.value && /^(rgb|hsl)/.test(origColor.value)) {
        color.value = origColor.value;
      } else {
        color.value = 'rgb';
      }
      return color;
    }
  }
  function toHSL(color) {
    if (color.toHSL) {
      return color.toHSL();
    } else {
      throw new Error('Argument cannot be evaluated to a color');
    }
  }
  function toHSV(color) {
    if (color.toHSV) {
      return color.toHSV();
    } else {
      throw new Error('Argument cannot be evaluated to a color');
    }
  }
  function number(n) {
    if (n instanceof dimension_1.default) {
      return parseFloat(n.unit.is('%') ? n.value / 100 : n.value);
    } else if (typeof n === 'number') {
      return n;
    } else {
      throw {
        type: 'Argument',
        message: 'color functions take numbers as parameters'
      };
    }
  }
  function scaled(n, size) {
    if (n instanceof dimension_1.default && n.unit.is('%')) {
      return parseFloat(n.value * size / 100);
    } else {
      return number(n);
    }
  }
  colorFunctions = {
    rgb: function (r, g, b) {
      var a = 1;
      /**
       * Comma-less syntax
       *   e.g. rgb(0 128 255 / 50%)
       */
      if (r instanceof expression_1.default) {
        var val = r.value;
        r = val[0];
        g = val[1];
        b = val[2];
        /**
         * @todo - should this be normalized in
         *   function caller? Or parsed differently?
         */
        if (b instanceof operation_1.default) {
          var op = b;
          b = op.operands[0];
          a = op.operands[1];
        }
      }
      var color = colorFunctions.rgba(r, g, b, a);
      if (color) {
        color.value = 'rgb';
        return color;
      }
    },
    rgba: function (r, g, b, a) {
      try {
        if (r instanceof color_1.default) {
          if (g) {
            a = number(g);
          } else {
            a = r.alpha;
          }
          return new color_1.default(r.rgb, a, 'rgba');
        }
        var rgb = [r, g, b].map(function (c) {
          return scaled(c, 255);
        });
        a = number(a);
        return new color_1.default(rgb, a, 'rgba');
      } catch (e) {}
    },
    hsl: function (h, s, l) {
      var a = 1;
      if (h instanceof expression_1.default) {
        var val = h.value;
        h = val[0];
        s = val[1];
        l = val[2];
        if (l instanceof operation_1.default) {
          var op = l;
          l = op.operands[0];
          a = op.operands[1];
        }
      }
      var color = colorFunctions.hsla(h, s, l, a);
      if (color) {
        color.value = 'hsl';
        return color;
      }
    },
    hsla: function (h, s, l, a) {
      var m1;
      var m2;
      function hue(h) {
        h = h < 0 ? h + 1 : h > 1 ? h - 1 : h;
        if (h * 6 < 1) {
          return m1 + (m2 - m1) * h * 6;
        } else if (h * 2 < 1) {
          return m2;
        } else if (h * 3 < 2) {
          return m1 + (m2 - m1) * (2 / 3 - h) * 6;
        } else {
          return m1;
        }
      }
      try {
        if (h instanceof color_1.default) {
          if (s) {
            a = number(s);
          } else {
            a = h.alpha;
          }
          return new color_1.default(h.rgb, a, 'hsla');
        }
        h = number(h) % 360 / 360;
        s = clamp(number(s));
        l = clamp(number(l));
        a = clamp(number(a));
        m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
        m1 = l * 2 - m2;
        var rgb = [hue(h + 1 / 3) * 255, hue(h) * 255, hue(h - 1 / 3) * 255];
        a = number(a);
        return new color_1.default(rgb, a, 'hsla');
      } catch (e) {}
    },
    hsv: function (h, s, v) {
      return colorFunctions.hsva(h, s, v, 1.0);
    },
    hsva: function (h, s, v, a) {
      h = number(h) % 360 / 360 * 360;
      s = number(s);
      v = number(v);
      a = number(a);
      var i;
      var f;
      i = Math.floor(h / 60 % 6);
      f = h / 60 - i;
      var vs = [v, v * (1 - s), v * (1 - f * s), v * (1 - (1 - f) * s)];
      var perm = [[0, 3, 1], [2, 0, 1], [1, 0, 3], [1, 2, 0], [3, 1, 0], [0, 1, 2]];
      return colorFunctions.rgba(vs[perm[i][0]] * 255, vs[perm[i][1]] * 255, vs[perm[i][2]] * 255, a);
    },
    hue: function (color) {
      return new dimension_1.default(toHSL(color).h);
    },
    saturation: function (color) {
      return new dimension_1.default(toHSL(color).s * 100, '%');
    },
    lightness: function (color) {
      return new dimension_1.default(toHSL(color).l * 100, '%');
    },
    hsvhue: function (color) {
      return new dimension_1.default(toHSV(color).h);
    },
    hsvsaturation: function (color) {
      return new dimension_1.default(toHSV(color).s * 100, '%');
    },
    hsvvalue: function (color) {
      return new dimension_1.default(toHSV(color).v * 100, '%');
    },
    red: function (color) {
      return new dimension_1.default(color.rgb[0]);
    },
    green: function (color) {
      return new dimension_1.default(color.rgb[1]);
    },
    blue: function (color) {
      return new dimension_1.default(color.rgb[2]);
    },
    alpha: function (color) {
      return new dimension_1.default(toHSL(color).a);
    },
    luma: function (color) {
      return new dimension_1.default(color.luma() * color.alpha * 100, '%');
    },
    luminance: function (color) {
      var luminance = 0.2126 * color.rgb[0] / 255 + 0.7152 * color.rgb[1] / 255 + 0.0722 * color.rgb[2] / 255;
      return new dimension_1.default(luminance * color.alpha * 100, '%');
    },
    saturate: function (color, amount, method) {
      // filter: saturate(3.2);
      // should be kept as is, so check for color
      if (!color.rgb) {
        return null;
      }
      var hsl = toHSL(color);
      if (typeof method !== 'undefined' && method.value === 'relative') {
        hsl.s += hsl.s * amount.value / 100;
      } else {
        hsl.s += amount.value / 100;
      }
      hsl.s = clamp(hsl.s);
      return hsla(color, hsl);
    },
    desaturate: function (color, amount, method) {
      var hsl = toHSL(color);
      if (typeof method !== 'undefined' && method.value === 'relative') {
        hsl.s -= hsl.s * amount.value / 100;
      } else {
        hsl.s -= amount.value / 100;
      }
      hsl.s = clamp(hsl.s);
      return hsla(color, hsl);
    },
    lighten: function (color, amount, method) {
      var hsl = toHSL(color);
      if (typeof method !== 'undefined' && method.value === 'relative') {
        hsl.l += hsl.l * amount.value / 100;
      } else {
        hsl.l += amount.value / 100;
      }
      hsl.l = clamp(hsl.l);
      return hsla(color, hsl);
    },
    darken: function (color, amount, method) {
      var hsl = toHSL(color);
      if (typeof method !== 'undefined' && method.value === 'relative') {
        hsl.l -= hsl.l * amount.value / 100;
      } else {
        hsl.l -= amount.value / 100;
      }
      hsl.l = clamp(hsl.l);
      return hsla(color, hsl);
    },
    fadein: function (color, amount, method) {
      var hsl = toHSL(color);
      if (typeof method !== 'undefined' && method.value === 'relative') {
        hsl.a += hsl.a * amount.value / 100;
      } else {
        hsl.a += amount.value / 100;
      }
      hsl.a = clamp(hsl.a);
      return hsla(color, hsl);
    },
    fadeout: function (color, amount, method) {
      var hsl = toHSL(color);
      if (typeof method !== 'undefined' && method.value === 'relative') {
        hsl.a -= hsl.a * amount.value / 100;
      } else {
        hsl.a -= amount.value / 100;
      }
      hsl.a = clamp(hsl.a);
      return hsla(color, hsl);
    },
    fade: function (color, amount) {
      var hsl = toHSL(color);
      hsl.a = amount.value / 100;
      hsl.a = clamp(hsl.a);
      return hsla(color, hsl);
    },
    spin: function (color, amount) {
      var hsl = toHSL(color);
      var hue = (hsl.h + amount.value) % 360;
      hsl.h = hue < 0 ? 360 + hue : hue;
      return hsla(color, hsl);
    },
    //
    // Copyright (c) 2006-2009 Hampton Catlin, Natalie Weizenbaum, and Chris Eppstein
    // http://sass-lang.com
    //
    mix: function (color1, color2, weight) {
      if (!weight) {
        weight = new dimension_1.default(50);
      }
      var p = weight.value / 100.0;
      var w = p * 2 - 1;
      var a = toHSL(color1).a - toHSL(color2).a;
      var w1 = ((w * a == -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
      var w2 = 1 - w1;
      var rgb = [color1.rgb[0] * w1 + color2.rgb[0] * w2, color1.rgb[1] * w1 + color2.rgb[1] * w2, color1.rgb[2] * w1 + color2.rgb[2] * w2];
      var alpha = color1.alpha * p + color2.alpha * (1 - p);
      return new color_1.default(rgb, alpha);
    },
    greyscale: function (color) {
      return colorFunctions.desaturate(color, new dimension_1.default(100));
    },
    contrast: function (color, dark, light, threshold) {
      // filter: contrast(3.2);
      // should be kept as is, so check for color
      if (!color.rgb) {
        return null;
      }
      if (typeof light === 'undefined') {
        light = colorFunctions.rgba(255, 255, 255, 1.0);
      }
      if (typeof dark === 'undefined') {
        dark = colorFunctions.rgba(0, 0, 0, 1.0);
      }
      // Figure out which is actually light and dark:
      if (dark.luma() > light.luma()) {
        var t = light;
        light = dark;
        dark = t;
      }
      if (typeof threshold === 'undefined') {
        threshold = 0.43;
      } else {
        threshold = number(threshold);
      }
      if (color.luma() < threshold) {
        return light;
      } else {
        return dark;
      }
    },
    // Changes made in 2.7.0 - Reverted in 3.0.0
    // contrast: function (color, color1, color2, threshold) {
    //     // Return which of `color1` and `color2` has the greatest contrast with `color`
    //     // according to the standard WCAG contrast ratio calculation.
    //     // http://www.w3.org/TR/WCAG20/#contrast-ratiodef
    //     // The threshold param is no longer used, in line with SASS.
    //     // filter: contrast(3.2);
    //     // should be kept as is, so check for color
    //     if (!color.rgb) {
    //         return null;
    //     }
    //     if (typeof color1 === 'undefined') {
    //         color1 = colorFunctions.rgba(0, 0, 0, 1.0);
    //     }
    //     if (typeof color2 === 'undefined') {
    //         color2 = colorFunctions.rgba(255, 255, 255, 1.0);
    //     }
    //     var contrast1, contrast2;
    //     var luma = color.luma();
    //     var luma1 = color1.luma();
    //     var luma2 = color2.luma();
    //     // Calculate contrast ratios for each color
    //     if (luma > luma1) {
    //         contrast1 = (luma + 0.05) / (luma1 + 0.05);
    //     } else {
    //         contrast1 = (luma1 + 0.05) / (luma + 0.05);
    //     }
    //     if (luma > luma2) {
    //         contrast2 = (luma + 0.05) / (luma2 + 0.05);
    //     } else {
    //         contrast2 = (luma2 + 0.05) / (luma + 0.05);
    //     }
    //     if (contrast1 > contrast2) {
    //         return color1;
    //     } else {
    //         return color2;
    //     }
    // },
    argb: function (color) {
      return new anonymous_1.default(color.toARGB());
    },
    color: function (c) {
      if (c instanceof quoted_1.default && /^#([A-Fa-f0-9]{8}|[A-Fa-f0-9]{6}|[A-Fa-f0-9]{3,4})$/i.test(c.value)) {
        var val = c.value.slice(1);
        return new color_1.default(val, undefined, "#".concat(val));
      }
      if (c instanceof color_1.default || (c = color_1.default.fromKeyword(c.value))) {
        c.value = undefined;
        return c;
      }
      throw {
        type: 'Argument',
        message: 'argument must be a color keyword or 3|4|6|8 digit hex e.g. #FFF'
      };
    },
    tint: function (color, amount) {
      return colorFunctions.mix(colorFunctions.rgb(255, 255, 255), color, amount);
    },
    shade: function (color, amount) {
      return colorFunctions.mix(colorFunctions.rgb(0, 0, 0), color, amount);
    }
  };
  color.default = colorFunctions;
  return color;
}

var colorBlending = {};

var hasRequiredColorBlending;
function requireColorBlending() {
  if (hasRequiredColorBlending) return colorBlending;
  hasRequiredColorBlending = 1;
  Object.defineProperty(colorBlending, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var color_1 = tslib_1.__importDefault(requireColor$1());
  // Color Blending
  // ref: http://www.w3.org/TR/compositing-1
  function colorBlend(mode, color1, color2) {
    var ab = color1.alpha; // result
    var
    // backdrop
    cb;
    var as = color2.alpha;
    var
    // source
    cs;
    var ar;
    var cr;
    var r = [];
    ar = as + ab * (1 - as);
    for (var i = 0; i < 3; i++) {
      cb = color1.rgb[i] / 255;
      cs = color2.rgb[i] / 255;
      cr = mode(cb, cs);
      if (ar) {
        cr = (as * cs + ab * (cb - as * (cb + cs - cr))) / ar;
      }
      r[i] = cr * 255;
    }
    return new color_1.default(r, ar);
  }
  var colorBlendModeFunctions = {
    multiply: function (cb, cs) {
      return cb * cs;
    },
    screen: function (cb, cs) {
      return cb + cs - cb * cs;
    },
    overlay: function (cb, cs) {
      cb *= 2;
      return cb <= 1 ? colorBlendModeFunctions.multiply(cb, cs) : colorBlendModeFunctions.screen(cb - 1, cs);
    },
    softlight: function (cb, cs) {
      var d = 1;
      var e = cb;
      if (cs > 0.5) {
        e = 1;
        d = cb > 0.25 ? Math.sqrt(cb) : ((16 * cb - 12) * cb + 4) * cb;
      }
      return cb - (1 - 2 * cs) * e * (d - cb);
    },
    hardlight: function (cb, cs) {
      return colorBlendModeFunctions.overlay(cs, cb);
    },
    difference: function (cb, cs) {
      return Math.abs(cb - cs);
    },
    exclusion: function (cb, cs) {
      return cb + cs - 2 * cb * cs;
    },
    // non-w3c functions:
    average: function (cb, cs) {
      return (cb + cs) / 2;
    },
    negation: function (cb, cs) {
      return 1 - Math.abs(cb + cs - 1);
    }
  };
  for (var f in colorBlendModeFunctions) {
    // eslint-disable-next-line no-prototype-builtins
    if (colorBlendModeFunctions.hasOwnProperty(f)) {
      colorBlend[f] = colorBlend.bind(null, colorBlendModeFunctions[f]);
    }
  }
  colorBlending.default = colorBlend;
  return colorBlending;
}

var dataUri = {};

var hasRequiredDataUri;
function requireDataUri() {
  if (hasRequiredDataUri) return dataUri;
  hasRequiredDataUri = 1;
  Object.defineProperty(dataUri, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var quoted_1 = tslib_1.__importDefault(requireQuoted());
  var url_1 = tslib_1.__importDefault(requireUrl());
  var utils = tslib_1.__importStar(requireUtils());
  var logger_1 = tslib_1.__importDefault(requireLogger());
  dataUri.default = function (environment) {
    var fallback = function (functionThis, node) {
      return new url_1.default(node, functionThis.index, functionThis.currentFileInfo).eval(functionThis.context);
    };
    return {
      'data-uri': function (mimetypeNode, filePathNode) {
        if (!filePathNode) {
          filePathNode = mimetypeNode;
          mimetypeNode = null;
        }
        var mimetype = mimetypeNode && mimetypeNode.value;
        var filePath = filePathNode.value;
        var currentFileInfo = this.currentFileInfo;
        var currentDirectory = currentFileInfo.rewriteUrls ? currentFileInfo.currentDirectory : currentFileInfo.entryPath;
        var fragmentStart = filePath.indexOf('#');
        var fragment = '';
        if (fragmentStart !== -1) {
          fragment = filePath.slice(fragmentStart);
          filePath = filePath.slice(0, fragmentStart);
        }
        var context = utils.clone(this.context);
        context.rawBuffer = true;
        var fileManager = environment.getFileManager(filePath, currentDirectory, context, environment, true);
        if (!fileManager) {
          return fallback(this, filePathNode);
        }
        var useBase64 = false;
        // detect the mimetype if not given
        if (!mimetypeNode) {
          mimetype = environment.mimeLookup(filePath);
          if (mimetype === 'image/svg+xml') {
            useBase64 = false;
          } else {
            // use base 64 unless it's an ASCII or UTF-8 format
            var charset = environment.charsetLookup(mimetype);
            useBase64 = ['US-ASCII', 'UTF-8'].indexOf(charset) < 0;
          }
          if (useBase64) {
            mimetype += ';base64';
          }
        } else {
          useBase64 = /;base64$/.test(mimetype);
        }
        var fileSync = fileManager.loadFileSync(filePath, currentDirectory, context, environment);
        if (!fileSync.contents) {
          logger_1.default.warn("Skipped data-uri embedding of ".concat(filePath, " because file not found"));
          return fallback(this, filePathNode || mimetypeNode);
        }
        var buf = fileSync.contents;
        if (useBase64 && !environment.encodeBase64) {
          return fallback(this, filePathNode);
        }
        buf = useBase64 ? environment.encodeBase64(buf) : encodeURIComponent(buf);
        var uri = "data:".concat(mimetype, ",").concat(buf).concat(fragment);
        return new url_1.default(new quoted_1.default("\"".concat(uri, "\""), uri, false, this.index, this.currentFileInfo), this.index, this.currentFileInfo);
      }
    };
  };
  return dataUri;
}

var list = {};

var hasRequiredList;
function requireList() {
  if (hasRequiredList) return list;
  hasRequiredList = 1;
  Object.defineProperty(list, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var comment_1 = tslib_1.__importDefault(requireComment());
  var node_1 = tslib_1.__importDefault(requireNode());
  var dimension_1 = tslib_1.__importDefault(requireDimension());
  var declaration_1 = tslib_1.__importDefault(requireDeclaration());
  var expression_1 = tslib_1.__importDefault(requireExpression());
  var ruleset_1 = tslib_1.__importDefault(requireRuleset());
  var selector_1 = tslib_1.__importDefault(requireSelector());
  var element_1 = tslib_1.__importDefault(requireElement());
  var quoted_1 = tslib_1.__importDefault(requireQuoted());
  var value_1 = tslib_1.__importDefault(requireValue());
  var getItemsFromNode = function (node) {
    // handle non-array values as an array of length 1
    // return 'undefined' if index is invalid
    var items = Array.isArray(node.value) ? node.value : Array(node);
    return items;
  };
  list.default = {
    _SELF: function (n) {
      return n;
    },
    '~': function () {
      var expr = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        expr[_i] = arguments[_i];
      }
      if (expr.length === 1) {
        return expr[0];
      }
      return new value_1.default(expr);
    },
    extract: function (values, index) {
      // (1-based index)
      index = index.value - 1;
      return getItemsFromNode(values)[index];
    },
    length: function (values) {
      return new dimension_1.default(getItemsFromNode(values).length);
    },
    /**
     * Creates a Less list of incremental values.
     * Modeled after Lodash's range function, also exists natively in PHP
     *
     * @param {Dimension} [start=1]
     * @param {Dimension} end  - e.g. 10 or 10px - unit is added to output
     * @param {Dimension} [step=1]
     */
    range: function (start, end, step) {
      var from;
      var to;
      var stepValue = 1;
      var list = [];
      if (end) {
        to = end;
        from = start.value;
        if (step) {
          stepValue = step.value;
        }
      } else {
        from = 1;
        to = start;
      }
      for (var i = from; i <= to.value; i += stepValue) {
        list.push(new dimension_1.default(i, to.unit));
      }
      return new expression_1.default(list);
    },
    each: function (list, rs) {
      var _this = this;
      var rules = [];
      var newRules;
      var iterator;
      var tryEval = function (val) {
        if (val instanceof node_1.default) {
          return val.eval(_this.context);
        }
        return val;
      };
      if (list.value && !(list instanceof quoted_1.default)) {
        if (Array.isArray(list.value)) {
          iterator = list.value.map(tryEval);
        } else {
          iterator = [tryEval(list.value)];
        }
      } else if (list.ruleset) {
        iterator = tryEval(list.ruleset).rules;
      } else if (list.rules) {
        iterator = list.rules.map(tryEval);
      } else if (Array.isArray(list)) {
        iterator = list.map(tryEval);
      } else {
        iterator = [tryEval(list)];
      }
      var valueName = '@value';
      var keyName = '@key';
      var indexName = '@index';
      if (rs.params) {
        valueName = rs.params[0] && rs.params[0].name;
        keyName = rs.params[1] && rs.params[1].name;
        indexName = rs.params[2] && rs.params[2].name;
        rs = rs.rules;
      } else {
        rs = rs.ruleset;
      }
      for (var i = 0; i < iterator.length; i++) {
        var key = void 0;
        var value = void 0;
        var item = iterator[i];
        if (item instanceof declaration_1.default) {
          key = typeof item.name === 'string' ? item.name : item.name[0].value;
          value = item.value;
        } else {
          key = new dimension_1.default(i + 1);
          value = item;
        }
        if (item instanceof comment_1.default) {
          continue;
        }
        newRules = rs.rules.slice(0);
        if (valueName) {
          newRules.push(new declaration_1.default(valueName, value, false, false, this.index, this.currentFileInfo));
        }
        if (indexName) {
          newRules.push(new declaration_1.default(indexName, new dimension_1.default(i + 1), false, false, this.index, this.currentFileInfo));
        }
        if (keyName) {
          newRules.push(new declaration_1.default(keyName, key, false, false, this.index, this.currentFileInfo));
        }
        rules.push(new ruleset_1.default([new selector_1.default([new element_1.default('', '&')])], newRules, rs.strictImports, rs.visibilityInfo()));
      }
      return new ruleset_1.default([new selector_1.default([new element_1.default('', '&')])], rules, rs.strictImports, rs.visibilityInfo()).eval(this.context);
    }
  };
  return list;
}

var math = {};

var mathHelper = {};

var hasRequiredMathHelper;
function requireMathHelper() {
  if (hasRequiredMathHelper) return mathHelper;
  hasRequiredMathHelper = 1;
  Object.defineProperty(mathHelper, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var dimension_1 = tslib_1.__importDefault(requireDimension());
  var MathHelper = function (fn, unit, n) {
    if (!(n instanceof dimension_1.default)) {
      throw {
        type: 'Argument',
        message: 'argument must be a number'
      };
    }
    if (unit === null) {
      unit = n.unit;
    } else {
      n = n.unify();
    }
    return new dimension_1.default(fn(parseFloat(n.value)), unit);
  };
  mathHelper.default = MathHelper;
  return mathHelper;
}

var hasRequiredMath;
function requireMath() {
  if (hasRequiredMath) return math;
  hasRequiredMath = 1;
  Object.defineProperty(math, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var math_helper_js_1 = tslib_1.__importDefault(requireMathHelper());
  var mathFunctions = {
    // name,  unit
    ceil: null,
    floor: null,
    sqrt: null,
    abs: null,
    tan: '',
    sin: '',
    cos: '',
    atan: 'rad',
    asin: 'rad',
    acos: 'rad'
  };
  for (var f in mathFunctions) {
    // eslint-disable-next-line no-prototype-builtins
    if (mathFunctions.hasOwnProperty(f)) {
      mathFunctions[f] = math_helper_js_1.default.bind(null, Math[f], mathFunctions[f]);
    }
  }
  mathFunctions.round = function (n, f) {
    var fraction = typeof f === 'undefined' ? 0 : f.value;
    return (0, math_helper_js_1.default)(function (num) {
      return num.toFixed(fraction);
    }, null, n);
  };
  math.default = mathFunctions;
  return math;
}

var number = {};

var hasRequiredNumber;
function requireNumber() {
  if (hasRequiredNumber) return number;
  hasRequiredNumber = 1;
  Object.defineProperty(number, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var dimension_1 = tslib_1.__importDefault(requireDimension());
  var anonymous_1 = tslib_1.__importDefault(requireAnonymous());
  var math_helper_js_1 = tslib_1.__importDefault(requireMathHelper());
  var minMax = function (isMin, args) {
    var _this = this;
    args = Array.prototype.slice.call(args);
    switch (args.length) {
      case 0:
        throw {
          type: 'Argument',
          message: 'one or more arguments required'
        };
    }
    var i; // key is the unit.toString() for unified Dimension values,
    var j;
    var current;
    var currentUnified;
    var referenceUnified;
    var unit;
    var unitStatic;
    var unitClone;
    var
    // elems only contains original argument values.
    order = [];
    var values = {};
    // value is the index into the order array.
    for (i = 0; i < args.length; i++) {
      current = args[i];
      if (!(current instanceof dimension_1.default)) {
        if (Array.isArray(args[i].value)) {
          Array.prototype.push.apply(args, Array.prototype.slice.call(args[i].value));
          continue;
        } else {
          throw {
            type: 'Argument',
            message: 'incompatible types'
          };
        }
      }
      currentUnified = current.unit.toString() === '' && unitClone !== undefined ? new dimension_1.default(current.value, unitClone).unify() : current.unify();
      unit = currentUnified.unit.toString() === '' && unitStatic !== undefined ? unitStatic : currentUnified.unit.toString();
      unitStatic = unit !== '' && unitStatic === undefined || unit !== '' && order[0].unify().unit.toString() === '' ? unit : unitStatic;
      unitClone = unit !== '' && unitClone === undefined ? current.unit.toString() : unitClone;
      j = values[''] !== undefined && unit !== '' && unit === unitStatic ? values[''] : values[unit];
      if (j === undefined) {
        if (unitStatic !== undefined && unit !== unitStatic) {
          throw {
            type: 'Argument',
            message: 'incompatible types'
          };
        }
        values[unit] = order.length;
        order.push(current);
        continue;
      }
      referenceUnified = order[j].unit.toString() === '' && unitClone !== undefined ? new dimension_1.default(order[j].value, unitClone).unify() : order[j].unify();
      if (isMin && currentUnified.value < referenceUnified.value || !isMin && currentUnified.value > referenceUnified.value) {
        order[j] = current;
      }
    }
    if (order.length == 1) {
      return order[0];
    }
    args = order.map(function (a) {
      return a.toCSS(_this.context);
    }).join(this.context.compress ? ',' : ', ');
    return new anonymous_1.default("".concat(isMin ? 'min' : 'max', "(").concat(args, ")"));
  };
  number.default = {
    min: function () {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      try {
        return minMax.call(this, true, args);
      } catch (e) {}
    },
    max: function () {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      try {
        return minMax.call(this, false, args);
      } catch (e) {}
    },
    convert: function (val, unit) {
      return val.convertTo(unit.value);
    },
    pi: function () {
      return new dimension_1.default(Math.PI);
    },
    mod: function (a, b) {
      return new dimension_1.default(a.value % b.value, a.unit);
    },
    pow: function (x, y) {
      if (typeof x === 'number' && typeof y === 'number') {
        x = new dimension_1.default(x);
        y = new dimension_1.default(y);
      } else if (!(x instanceof dimension_1.default) || !(y instanceof dimension_1.default)) {
        throw {
          type: 'Argument',
          message: 'arguments must be numbers'
        };
      }
      return new dimension_1.default(Math.pow(x.value, y.value), x.unit);
    },
    percentage: function (n) {
      var result = (0, math_helper_js_1.default)(function (num) {
        return num * 100;
      }, '%', n);
      return result;
    }
  };
  return number;
}

var string = {};

var hasRequiredString;
function requireString() {
  if (hasRequiredString) return string;
  hasRequiredString = 1;
  Object.defineProperty(string, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var quoted_1 = tslib_1.__importDefault(requireQuoted());
  var anonymous_1 = tslib_1.__importDefault(requireAnonymous());
  var javascript_1 = tslib_1.__importDefault(requireJavascript());
  string.default = {
    e: function (str) {
      return new quoted_1.default('"', str instanceof javascript_1.default ? str.evaluated : str.value, true);
    },
    escape: function (str) {
      return new anonymous_1.default(encodeURI(str.value).replace(/=/g, '%3D').replace(/:/g, '%3A').replace(/#/g, '%23').replace(/;/g, '%3B').replace(/\(/g, '%28').replace(/\)/g, '%29'));
    },
    replace: function (string, pattern, replacement, flags) {
      var result = string.value;
      replacement = replacement.type === 'Quoted' ? replacement.value : replacement.toCSS();
      result = result.replace(new RegExp(pattern.value, flags ? flags.value : ''), replacement);
      return new quoted_1.default(string.quote || '', result, string.escaped);
    },
    '%': function (string /* arg, arg, ... */) {
      var args = Array.prototype.slice.call(arguments, 1);
      var result = string.value;
      var _loop_1 = function (i) {
        /* jshint loopfunc:true */
        result = result.replace(/%[sda]/i, function (token) {
          var value = args[i].type === 'Quoted' && token.match(/s/i) ? args[i].value : args[i].toCSS();
          return token.match(/[A-Z]$/) ? encodeURIComponent(value) : value;
        });
      };
      for (var i = 0; i < args.length; i++) {
        _loop_1(i);
      }
      result = result.replace(/%%/g, '%');
      return new quoted_1.default(string.quote || '', result, string.escaped);
    }
  };
  return string;
}

var svg = {};

var hasRequiredSvg;
function requireSvg() {
  if (hasRequiredSvg) return svg;
  hasRequiredSvg = 1;
  Object.defineProperty(svg, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var dimension_1 = tslib_1.__importDefault(requireDimension());
  var color_1 = tslib_1.__importDefault(requireColor$1());
  var expression_1 = tslib_1.__importDefault(requireExpression());
  var quoted_1 = tslib_1.__importDefault(requireQuoted());
  var url_1 = tslib_1.__importDefault(requireUrl());
  svg.default = function () {
    return {
      'svg-gradient': function (direction) {
        var stops;
        var gradientDirectionSvg;
        var gradientType = 'linear';
        var rectangleDimension = 'x="0" y="0" width="1" height="1"';
        var renderEnv = {
          compress: false
        };
        var returner;
        var directionValue = direction.toCSS(renderEnv);
        var i;
        var color;
        var position;
        var positionValue;
        var alpha;
        function throwArgumentDescriptor() {
          throw {
            type: 'Argument',
            message: 'svg-gradient expects direction, start_color [start_position], [color position,]...,' + ' end_color [end_position] or direction, color list'
          };
        }
        if (arguments.length == 2) {
          if (arguments[1].value.length < 2) {
            throwArgumentDescriptor();
          }
          stops = arguments[1].value;
        } else if (arguments.length < 3) {
          throwArgumentDescriptor();
        } else {
          stops = Array.prototype.slice.call(arguments, 1);
        }
        switch (directionValue) {
          case 'to bottom':
            gradientDirectionSvg = 'x1="0%" y1="0%" x2="0%" y2="100%"';
            break;
          case 'to right':
            gradientDirectionSvg = 'x1="0%" y1="0%" x2="100%" y2="0%"';
            break;
          case 'to bottom right':
            gradientDirectionSvg = 'x1="0%" y1="0%" x2="100%" y2="100%"';
            break;
          case 'to top right':
            gradientDirectionSvg = 'x1="0%" y1="100%" x2="100%" y2="0%"';
            break;
          case 'ellipse':
          case 'ellipse at center':
            gradientType = 'radial';
            gradientDirectionSvg = 'cx="50%" cy="50%" r="75%"';
            rectangleDimension = 'x="-50" y="-50" width="101" height="101"';
            break;
          default:
            throw {
              type: 'Argument',
              message: 'svg-gradient direction must be \'to bottom\', \'to right\',' + ' \'to bottom right\', \'to top right\' or \'ellipse at center\''
            };
        }
        returner = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 1 1\"><".concat(gradientType, "Gradient id=\"g\" ").concat(gradientDirectionSvg, ">");
        for (i = 0; i < stops.length; i += 1) {
          if (stops[i] instanceof expression_1.default) {
            color = stops[i].value[0];
            position = stops[i].value[1];
          } else {
            color = stops[i];
            position = undefined;
          }
          if (!(color instanceof color_1.default) || !((i === 0 || i + 1 === stops.length) && position === undefined) && !(position instanceof dimension_1.default)) {
            throwArgumentDescriptor();
          }
          positionValue = position ? position.toCSS(renderEnv) : i === 0 ? '0%' : '100%';
          alpha = color.alpha;
          returner += "<stop offset=\"".concat(positionValue, "\" stop-color=\"").concat(color.toRGB(), "\"").concat(alpha < 1 ? " stop-opacity=\"".concat(alpha, "\"") : '', "/>");
        }
        returner += "</".concat(gradientType, "Gradient><rect ").concat(rectangleDimension, " fill=\"url(#g)\" /></svg>");
        returner = encodeURIComponent(returner);
        returner = "data:image/svg+xml,".concat(returner);
        return new url_1.default(new quoted_1.default("'".concat(returner, "'"), returner, false, this.index, this.currentFileInfo), this.index, this.currentFileInfo);
      }
    };
  };
  return svg;
}

var types$1 = {};

var hasRequiredTypes$1;
function requireTypes$1() {
  if (hasRequiredTypes$1) return types$1;
  hasRequiredTypes$1 = 1;
  Object.defineProperty(types$1, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var keyword_1 = tslib_1.__importDefault(requireKeyword());
  var detached_ruleset_1 = tslib_1.__importDefault(requireDetachedRuleset());
  var dimension_1 = tslib_1.__importDefault(requireDimension());
  var color_1 = tslib_1.__importDefault(requireColor$1());
  var quoted_1 = tslib_1.__importDefault(requireQuoted());
  var anonymous_1 = tslib_1.__importDefault(requireAnonymous());
  var url_1 = tslib_1.__importDefault(requireUrl());
  var operation_1 = tslib_1.__importDefault(requireOperation());
  var isa = function (n, Type) {
    return n instanceof Type ? keyword_1.default.True : keyword_1.default.False;
  };
  var isunit = function (n, unit) {
    if (unit === undefined) {
      throw {
        type: 'Argument',
        message: 'missing the required second argument to isunit.'
      };
    }
    unit = typeof unit.value === 'string' ? unit.value : unit;
    if (typeof unit !== 'string') {
      throw {
        type: 'Argument',
        message: 'Second argument to isunit should be a unit or a string.'
      };
    }
    return n instanceof dimension_1.default && n.unit.is(unit) ? keyword_1.default.True : keyword_1.default.False;
  };
  types$1.default = {
    isruleset: function (n) {
      return isa(n, detached_ruleset_1.default);
    },
    iscolor: function (n) {
      return isa(n, color_1.default);
    },
    isnumber: function (n) {
      return isa(n, dimension_1.default);
    },
    isstring: function (n) {
      return isa(n, quoted_1.default);
    },
    iskeyword: function (n) {
      return isa(n, keyword_1.default);
    },
    isurl: function (n) {
      return isa(n, url_1.default);
    },
    ispixel: function (n) {
      return isunit(n, 'px');
    },
    ispercentage: function (n) {
      return isunit(n, '%');
    },
    isem: function (n) {
      return isunit(n, 'em');
    },
    isunit: isunit,
    unit: function (val, unit) {
      if (!(val instanceof dimension_1.default)) {
        throw {
          type: 'Argument',
          message: "the first argument to unit must be a number".concat(val instanceof operation_1.default ? '. Have you forgotten parenthesis?' : '')
        };
      }
      if (unit) {
        if (unit instanceof keyword_1.default) {
          unit = unit.value;
        } else {
          unit = unit.toCSS();
        }
      } else {
        unit = '';
      }
      return new dimension_1.default(val.value, unit);
    },
    'get-unit': function (n) {
      return new anonymous_1.default(n.unit);
    }
  };
  return types$1;
}

var style = {};

var hasRequiredStyle;
function requireStyle() {
  if (hasRequiredStyle) return style;
  hasRequiredStyle = 1;
  Object.defineProperty(style, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var variable_1 = tslib_1.__importDefault(requireVariable());
  var variable_2 = tslib_1.__importDefault(requireVariable());
  var styleExpression = function (args) {
    var _this = this;
    args = Array.prototype.slice.call(args);
    switch (args.length) {
      case 0:
        throw {
          type: 'Argument',
          message: 'one or more arguments required'
        };
    }
    var entityList = [new variable_1.default(args[0].value, this.index, this.currentFileInfo).eval(this.context)];
    args = entityList.map(function (a) {
      return a.toCSS(_this.context);
    }).join(this.context.compress ? ',' : ', ');
    return new variable_2.default("style(".concat(args, ")"));
  };
  style.default = {
    style: function () {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      try {
        return styleExpression.call(this, args);
      } catch (e) {}
    }
  };
  return style;
}

var hasRequiredFunctions;
function requireFunctions() {
  if (hasRequiredFunctions) return functions;
  hasRequiredFunctions = 1;
  Object.defineProperty(functions, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var function_registry_1 = tslib_1.__importDefault(requireFunctionRegistry());
  var function_caller_1 = tslib_1.__importDefault(requireFunctionCaller());
  var boolean_1 = tslib_1.__importDefault(requireBoolean());
  var default_1 = tslib_1.__importDefault(require_default());
  var color_1 = tslib_1.__importDefault(requireColor());
  var color_blending_1 = tslib_1.__importDefault(requireColorBlending());
  var data_uri_1 = tslib_1.__importDefault(requireDataUri());
  var list_1 = tslib_1.__importDefault(requireList());
  var math_1 = tslib_1.__importDefault(requireMath());
  var number_1 = tslib_1.__importDefault(requireNumber());
  var string_1 = tslib_1.__importDefault(requireString());
  var svg_1 = tslib_1.__importDefault(requireSvg());
  var types_1 = tslib_1.__importDefault(requireTypes$1());
  var style_1 = tslib_1.__importDefault(requireStyle());
  functions.default = function (environment) {
    var functions = {
      functionRegistry: function_registry_1.default,
      functionCaller: function_caller_1.default
    };
    // register functions
    function_registry_1.default.addMultiple(boolean_1.default);
    function_registry_1.default.add('default', default_1.default.eval.bind(default_1.default));
    function_registry_1.default.addMultiple(color_1.default);
    function_registry_1.default.addMultiple(color_blending_1.default);
    function_registry_1.default.addMultiple((0, data_uri_1.default)(environment));
    function_registry_1.default.addMultiple(list_1.default);
    function_registry_1.default.addMultiple(math_1.default);
    function_registry_1.default.addMultiple(number_1.default);
    function_registry_1.default.addMultiple(string_1.default);
    function_registry_1.default.addMultiple((0, svg_1.default)(environment));
    function_registry_1.default.addMultiple(types_1.default);
    function_registry_1.default.addMultiple(style_1.default);
    return functions;
  };
  return functions;
}

var transformTree = {};

var hasRequiredTransformTree;
function requireTransformTree() {
  if (hasRequiredTransformTree) return transformTree;
  hasRequiredTransformTree = 1;
  Object.defineProperty(transformTree, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var contexts_1 = tslib_1.__importDefault(requireContexts());
  var visitors_1 = tslib_1.__importDefault(requireVisitors());
  var tree_1 = tslib_1.__importDefault(requireTree());
  function default_1(root, options) {
    options = options || {};
    var evaldRoot;
    var variables = options.variables;
    var evalEnv = new contexts_1.default.Eval(options);
    //
    // Allows setting variables with a hash, so:
    //
    //   `{ color: new tree.Color('#f01') }` will become:
    //
    //   new tree.Declaration('@color',
    //     new tree.Value([
    //       new tree.Expression([
    //         new tree.Color('#f01')
    //       ])
    //     ])
    //   )
    //
    if (typeof variables === 'object' && !Array.isArray(variables)) {
      variables = Object.keys(variables).map(function (k) {
        var value = variables[k];
        if (!(value instanceof tree_1.default.Value)) {
          if (!(value instanceof tree_1.default.Expression)) {
            value = new tree_1.default.Expression([value]);
          }
          value = new tree_1.default.Value([value]);
        }
        return new tree_1.default.Declaration("@".concat(k), value, false, null, 0);
      });
      evalEnv.frames = [new tree_1.default.Ruleset(null, variables)];
    }
    var visitors = [new visitors_1.default.JoinSelectorVisitor(), new visitors_1.default.MarkVisibleSelectorsVisitor(true), new visitors_1.default.ExtendVisitor(), new visitors_1.default.ToCSSVisitor({
      compress: Boolean(options.compress)
    })];
    var preEvalVisitors = [];
    var v;
    var visitorIterator;
    /**
     * first() / get() allows visitors to be added while visiting
     *
     * @todo Add scoping for visitors just like functions for @plugin; right now they're global
     */
    if (options.pluginManager) {
      visitorIterator = options.pluginManager.visitor();
      for (var i = 0; i < 2; i++) {
        visitorIterator.first();
        while (v = visitorIterator.get()) {
          if (v.isPreEvalVisitor) {
            if (i === 0 || preEvalVisitors.indexOf(v) === -1) {
              preEvalVisitors.push(v);
              v.run(root);
            }
          } else {
            if (i === 0 || visitors.indexOf(v) === -1) {
              if (v.isPreVisitor) {
                visitors.unshift(v);
              } else {
                visitors.push(v);
              }
            }
          }
        }
      }
    }
    evaldRoot = root.eval(evalEnv);
    for (var i = 0; i < visitors.length; i++) {
      visitors[i].run(evaldRoot);
    }
    // Run any remaining visitors added after eval pass
    if (options.pluginManager) {
      visitorIterator.first();
      while (v = visitorIterator.get()) {
        if (visitors.indexOf(v) === -1 && preEvalVisitors.indexOf(v) === -1) {
          v.run(evaldRoot);
        }
      }
    }
    return evaldRoot;
  }
  transformTree.default = default_1;
  return transformTree;
}

var pluginManager = {};

var hasRequiredPluginManager;
function requirePluginManager() {
  if (hasRequiredPluginManager) return pluginManager;
  hasRequiredPluginManager = 1;
  Object.defineProperty(pluginManager, "__esModule", {
    value: true
  });
  /**
   * Plugin Manager
   */
  var PluginManager = /** @class */function () {
    function PluginManager(less) {
      this.less = less;
      this.visitors = [];
      this.preProcessors = [];
      this.postProcessors = [];
      this.installedPlugins = [];
      this.fileManagers = [];
      this.iterator = -1;
      this.pluginCache = {};
      this.Loader = new less.PluginLoader(less);
    }
    /**
     * Adds all the plugins in the array
     * @param {Array} plugins
     */
    PluginManager.prototype.addPlugins = function (plugins) {
      if (plugins) {
        for (var i = 0; i < plugins.length; i++) {
          this.addPlugin(plugins[i]);
        }
      }
    };
    /**
     *
     * @param plugin
     * @param {String} filename
     */
    PluginManager.prototype.addPlugin = function (plugin, filename, functionRegistry) {
      this.installedPlugins.push(plugin);
      if (filename) {
        this.pluginCache[filename] = plugin;
      }
      if (plugin.install) {
        plugin.install(this.less, this, functionRegistry || this.less.functions.functionRegistry);
      }
    };
    /**
     *
     * @param filename
     */
    PluginManager.prototype.get = function (filename) {
      return this.pluginCache[filename];
    };
    /**
     * Adds a visitor. The visitor object has options on itself to determine
     * when it should run.
     * @param visitor
     */
    PluginManager.prototype.addVisitor = function (visitor) {
      this.visitors.push(visitor);
    };
    /**
     * Adds a pre processor object
     * @param {object} preProcessor
     * @param {number} priority - guidelines 1 = before import, 1000 = import, 2000 = after import
     */
    PluginManager.prototype.addPreProcessor = function (preProcessor, priority) {
      var indexToInsertAt;
      for (indexToInsertAt = 0; indexToInsertAt < this.preProcessors.length; indexToInsertAt++) {
        if (this.preProcessors[indexToInsertAt].priority >= priority) {
          break;
        }
      }
      this.preProcessors.splice(indexToInsertAt, 0, {
        preProcessor: preProcessor,
        priority: priority
      });
    };
    /**
     * Adds a post processor object
     * @param {object} postProcessor
     * @param {number} priority - guidelines 1 = before compression, 1000 = compression, 2000 = after compression
     */
    PluginManager.prototype.addPostProcessor = function (postProcessor, priority) {
      var indexToInsertAt;
      for (indexToInsertAt = 0; indexToInsertAt < this.postProcessors.length; indexToInsertAt++) {
        if (this.postProcessors[indexToInsertAt].priority >= priority) {
          break;
        }
      }
      this.postProcessors.splice(indexToInsertAt, 0, {
        postProcessor: postProcessor,
        priority: priority
      });
    };
    /**
     *
     * @param manager
     */
    PluginManager.prototype.addFileManager = function (manager) {
      this.fileManagers.push(manager);
    };
    /**
     *
     * @returns {Array}
     * @private
     */
    PluginManager.prototype.getPreProcessors = function () {
      var preProcessors = [];
      for (var i = 0; i < this.preProcessors.length; i++) {
        preProcessors.push(this.preProcessors[i].preProcessor);
      }
      return preProcessors;
    };
    /**
     *
     * @returns {Array}
     * @private
     */
    PluginManager.prototype.getPostProcessors = function () {
      var postProcessors = [];
      for (var i = 0; i < this.postProcessors.length; i++) {
        postProcessors.push(this.postProcessors[i].postProcessor);
      }
      return postProcessors;
    };
    /**
     *
     * @returns {Array}
     * @private
     */
    PluginManager.prototype.getVisitors = function () {
      return this.visitors;
    };
    PluginManager.prototype.visitor = function () {
      var self = this;
      return {
        first: function () {
          self.iterator = -1;
          return self.visitors[self.iterator];
        },
        get: function () {
          self.iterator += 1;
          return self.visitors[self.iterator];
        }
      };
    };
    /**
     *
     * @returns {Array}
     * @private
     */
    PluginManager.prototype.getFileManagers = function () {
      return this.fileManagers;
    };
    return PluginManager;
  }();
  var pm;
  var PluginManagerFactory = function (less, newFactory) {
    if (newFactory || !pm) {
      pm = new PluginManager(less);
    }
    return pm;
  };
  //
  pluginManager.default = PluginManagerFactory;
  return pluginManager;
}

var sourceMapOutput = {};

var hasRequiredSourceMapOutput;
function requireSourceMapOutput() {
  if (hasRequiredSourceMapOutput) return sourceMapOutput;
  hasRequiredSourceMapOutput = 1;
  Object.defineProperty(sourceMapOutput, "__esModule", {
    value: true
  });
  function default_1(environment) {
    var SourceMapOutput = /** @class */function () {
      function SourceMapOutput(options) {
        this._css = [];
        this._rootNode = options.rootNode;
        this._contentsMap = options.contentsMap;
        this._contentsIgnoredCharsMap = options.contentsIgnoredCharsMap;
        if (options.sourceMapFilename) {
          this._sourceMapFilename = options.sourceMapFilename.replace(/\\/g, '/');
        }
        this._outputFilename = options.outputFilename;
        this.sourceMapURL = options.sourceMapURL;
        if (options.sourceMapBasepath) {
          this._sourceMapBasepath = options.sourceMapBasepath.replace(/\\/g, '/');
        }
        if (options.sourceMapRootpath) {
          this._sourceMapRootpath = options.sourceMapRootpath.replace(/\\/g, '/');
          if (this._sourceMapRootpath.charAt(this._sourceMapRootpath.length - 1) !== '/') {
            this._sourceMapRootpath += '/';
          }
        } else {
          this._sourceMapRootpath = '';
        }
        this._outputSourceFiles = options.outputSourceFiles;
        this._sourceMapGeneratorConstructor = environment.getSourceMapGenerator();
        this._lineNumber = 0;
        this._column = 0;
      }
      SourceMapOutput.prototype.removeBasepath = function (path) {
        if (this._sourceMapBasepath && path.indexOf(this._sourceMapBasepath) === 0) {
          path = path.substring(this._sourceMapBasepath.length);
          if (path.charAt(0) === '\\' || path.charAt(0) === '/') {
            path = path.substring(1);
          }
        }
        return path;
      };
      SourceMapOutput.prototype.normalizeFilename = function (filename) {
        filename = filename.replace(/\\/g, '/');
        filename = this.removeBasepath(filename);
        return (this._sourceMapRootpath || '') + filename;
      };
      SourceMapOutput.prototype.add = function (chunk, fileInfo, index, mapLines) {
        // ignore adding empty strings
        if (!chunk) {
          return;
        }
        var lines, sourceLines, columns, sourceColumns, i;
        if (fileInfo && fileInfo.filename) {
          var inputSource = this._contentsMap[fileInfo.filename];
          // remove vars/banner added to the top of the file
          if (this._contentsIgnoredCharsMap[fileInfo.filename]) {
            // adjust the index
            index -= this._contentsIgnoredCharsMap[fileInfo.filename];
            if (index < 0) {
              index = 0;
            }
            // adjust the source
            inputSource = inputSource.slice(this._contentsIgnoredCharsMap[fileInfo.filename]);
          }
          /**
           * ignore empty content, or failsafe
           * if contents map is incorrect
           */
          if (inputSource === undefined) {
            this._css.push(chunk);
            return;
          }
          inputSource = inputSource.substring(0, index);
          sourceLines = inputSource.split('\n');
          sourceColumns = sourceLines[sourceLines.length - 1];
        }
        lines = chunk.split('\n');
        columns = lines[lines.length - 1];
        if (fileInfo && fileInfo.filename) {
          if (!mapLines) {
            this._sourceMapGenerator.addMapping({
              generated: {
                line: this._lineNumber + 1,
                column: this._column
              },
              original: {
                line: sourceLines.length,
                column: sourceColumns.length
              },
              source: this.normalizeFilename(fileInfo.filename)
            });
          } else {
            for (i = 0; i < lines.length; i++) {
              this._sourceMapGenerator.addMapping({
                generated: {
                  line: this._lineNumber + i + 1,
                  column: i === 0 ? this._column : 0
                },
                original: {
                  line: sourceLines.length + i,
                  column: i === 0 ? sourceColumns.length : 0
                },
                source: this.normalizeFilename(fileInfo.filename)
              });
            }
          }
        }
        if (lines.length === 1) {
          this._column += columns.length;
        } else {
          this._lineNumber += lines.length - 1;
          this._column = columns.length;
        }
        this._css.push(chunk);
      };
      SourceMapOutput.prototype.isEmpty = function () {
        return this._css.length === 0;
      };
      SourceMapOutput.prototype.toCSS = function (context) {
        this._sourceMapGenerator = new this._sourceMapGeneratorConstructor({
          file: this._outputFilename,
          sourceRoot: null
        });
        if (this._outputSourceFiles) {
          for (var filename in this._contentsMap) {
            // eslint-disable-next-line no-prototype-builtins
            if (this._contentsMap.hasOwnProperty(filename)) {
              var source = this._contentsMap[filename];
              if (this._contentsIgnoredCharsMap[filename]) {
                source = source.slice(this._contentsIgnoredCharsMap[filename]);
              }
              this._sourceMapGenerator.setSourceContent(this.normalizeFilename(filename), source);
            }
          }
        }
        this._rootNode.genCSS(context, this);
        if (this._css.length > 0) {
          var sourceMapURL = void 0;
          var sourceMapContent = JSON.stringify(this._sourceMapGenerator.toJSON());
          if (this.sourceMapURL) {
            sourceMapURL = this.sourceMapURL;
          } else if (this._sourceMapFilename) {
            sourceMapURL = this._sourceMapFilename;
          }
          this.sourceMapURL = sourceMapURL;
          this.sourceMap = sourceMapContent;
        }
        return this._css.join('');
      };
      return SourceMapOutput;
    }();
    return SourceMapOutput;
  }
  sourceMapOutput.default = default_1;
  return sourceMapOutput;
}

var sourceMapBuilder = {};

var hasRequiredSourceMapBuilder;
function requireSourceMapBuilder() {
  if (hasRequiredSourceMapBuilder) return sourceMapBuilder;
  hasRequiredSourceMapBuilder = 1;
  Object.defineProperty(sourceMapBuilder, "__esModule", {
    value: true
  });
  function default_1(SourceMapOutput, environment) {
    var SourceMapBuilder = /** @class */function () {
      function SourceMapBuilder(options) {
        this.options = options;
      }
      SourceMapBuilder.prototype.toCSS = function (rootNode, options, imports) {
        var sourceMapOutput = new SourceMapOutput({
          contentsIgnoredCharsMap: imports.contentsIgnoredChars,
          rootNode: rootNode,
          contentsMap: imports.contents,
          sourceMapFilename: this.options.sourceMapFilename,
          sourceMapURL: this.options.sourceMapURL,
          outputFilename: this.options.sourceMapOutputFilename,
          sourceMapBasepath: this.options.sourceMapBasepath,
          sourceMapRootpath: this.options.sourceMapRootpath,
          outputSourceFiles: this.options.outputSourceFiles,
          sourceMapGenerator: this.options.sourceMapGenerator,
          sourceMapFileInline: this.options.sourceMapFileInline,
          disableSourcemapAnnotation: this.options.disableSourcemapAnnotation
        });
        var css = sourceMapOutput.toCSS(options);
        this.sourceMap = sourceMapOutput.sourceMap;
        this.sourceMapURL = sourceMapOutput.sourceMapURL;
        if (this.options.sourceMapInputFilename) {
          this.sourceMapInputFilename = sourceMapOutput.normalizeFilename(this.options.sourceMapInputFilename);
        }
        if (this.options.sourceMapBasepath !== undefined && this.sourceMapURL !== undefined) {
          this.sourceMapURL = sourceMapOutput.removeBasepath(this.sourceMapURL);
        }
        return css + this.getCSSAppendage();
      };
      SourceMapBuilder.prototype.getCSSAppendage = function () {
        var sourceMapURL = this.sourceMapURL;
        if (this.options.sourceMapFileInline) {
          if (this.sourceMap === undefined) {
            return '';
          }
          sourceMapURL = "data:application/json;base64,".concat(environment.encodeBase64(this.sourceMap));
        }
        if (this.options.disableSourcemapAnnotation) {
          return '';
        }
        if (sourceMapURL) {
          return "/*# sourceMappingURL=".concat(sourceMapURL, " */");
        }
        return '';
      };
      SourceMapBuilder.prototype.getExternalSourceMap = function () {
        return this.sourceMap;
      };
      SourceMapBuilder.prototype.setExternalSourceMap = function (sourceMap) {
        this.sourceMap = sourceMap;
      };
      SourceMapBuilder.prototype.isInline = function () {
        return this.options.sourceMapFileInline;
      };
      SourceMapBuilder.prototype.getSourceMapURL = function () {
        return this.sourceMapURL;
      };
      SourceMapBuilder.prototype.getOutputFilename = function () {
        return this.options.sourceMapOutputFilename;
      };
      SourceMapBuilder.prototype.getInputFilename = function () {
        return this.sourceMapInputFilename;
      };
      return SourceMapBuilder;
    }();
    return SourceMapBuilder;
  }
  sourceMapBuilder.default = default_1;
  return sourceMapBuilder;
}

var parseTree = {};

var hasRequiredParseTree;
function requireParseTree() {
  if (hasRequiredParseTree) return parseTree;
  hasRequiredParseTree = 1;
  Object.defineProperty(parseTree, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var less_error_1 = tslib_1.__importDefault(requireLessError());
  var transform_tree_1 = tslib_1.__importDefault(requireTransformTree());
  var logger_1 = tslib_1.__importDefault(requireLogger());
  function default_1(SourceMapBuilder) {
    var ParseTree = /** @class */function () {
      function ParseTree(root, imports) {
        this.root = root;
        this.imports = imports;
      }
      ParseTree.prototype.toCSS = function (options) {
        var evaldRoot;
        var result = {};
        var sourceMapBuilder;
        try {
          evaldRoot = (0, transform_tree_1.default)(this.root, options);
        } catch (e) {
          throw new less_error_1.default(e, this.imports);
        }
        try {
          var compress = Boolean(options.compress);
          if (compress) {
            logger_1.default.warn('The compress option has been deprecated. ' + 'We recommend you use a dedicated css minifier, for instance see less-plugin-clean-css.');
          }
          var toCSSOptions = {
            compress: compress,
            dumpLineNumbers: options.dumpLineNumbers,
            strictUnits: Boolean(options.strictUnits),
            numPrecision: 8
          };
          if (options.sourceMap) {
            sourceMapBuilder = new SourceMapBuilder(options.sourceMap);
            result.css = sourceMapBuilder.toCSS(evaldRoot, toCSSOptions, this.imports);
          } else {
            result.css = evaldRoot.toCSS(toCSSOptions);
          }
        } catch (e) {
          throw new less_error_1.default(e, this.imports);
        }
        if (options.pluginManager) {
          var postProcessors = options.pluginManager.getPostProcessors();
          for (var i = 0; i < postProcessors.length; i++) {
            result.css = postProcessors[i].process(result.css, {
              sourceMap: sourceMapBuilder,
              options: options,
              imports: this.imports
            });
          }
        }
        if (options.sourceMap) {
          result.map = sourceMapBuilder.getExternalSourceMap();
        }
        result.imports = [];
        for (var file in this.imports.files) {
          if (Object.prototype.hasOwnProperty.call(this.imports.files, file) && file !== this.imports.rootFilename) {
            result.imports.push(file);
          }
        }
        return result;
      };
      return ParseTree;
    }();
    return ParseTree;
  }
  parseTree.default = default_1;
  return parseTree;
}

var importManager = {};

var hasRequiredImportManager;
function requireImportManager() {
  if (hasRequiredImportManager) return importManager;
  hasRequiredImportManager = 1;
  Object.defineProperty(importManager, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var contexts_1 = tslib_1.__importDefault(requireContexts());
  var parser_1 = tslib_1.__importDefault(requireParser());
  var less_error_1 = tslib_1.__importDefault(requireLessError());
  var utils = tslib_1.__importStar(requireUtils());
  var logger_1 = tslib_1.__importDefault(requireLogger());
  function default_1(environment) {
    // FileInfo = {
    //  'rewriteUrls' - option - whether to adjust URL's to be relative
    //  'filename' - full resolved filename of current file
    //  'rootpath' - path to append to normal URLs for this node
    //  'currentDirectory' - path to the current file, absolute
    //  'rootFilename' - filename of the base file
    //  'entryPath' - absolute path to the entry file
    //  'reference' - whether the file should not be output and only output parts that are referenced
    var ImportManager = /** @class */function () {
      function ImportManager(less, context, rootFileInfo) {
        this.less = less;
        this.rootFilename = rootFileInfo.filename;
        this.paths = context.paths || []; // Search paths, when importing
        this.contents = {}; // map - filename to contents of all the files
        this.contentsIgnoredChars = {}; // map - filename to lines at the beginning of each file to ignore
        this.mime = context.mime;
        this.error = null;
        this.context = context;
        // Deprecated? Unused outside of here, could be useful.
        this.queue = []; // Files which haven't been imported yet
        this.files = {}; // Holds the imported parse trees.
      }
      /**
       * Add an import to be imported
       * @param path - the raw path
       * @param tryAppendExtension - whether to try appending a file extension (.less or .js if the path has no extension)
       * @param currentFileInfo - the current file info (used for instance to work out relative paths)
       * @param importOptions - import options
       * @param callback - callback for when it is imported
       */
      ImportManager.prototype.push = function (path, tryAppendExtension, currentFileInfo, importOptions, callback) {
        var importManager = this,
          pluginLoader = this.context.pluginManager.Loader;
        this.queue.push(path);
        var fileParsedFunc = function (e, root, fullPath) {
          importManager.queue.splice(importManager.queue.indexOf(path), 1); // Remove the path from the queue
          var importedEqualsRoot = fullPath === importManager.rootFilename;
          if (importOptions.optional && e) {
            callback(null, {
              rules: []
            }, false, null);
            logger_1.default.info("The file ".concat(fullPath, " was skipped because it was not found and the import was marked optional."));
          } else {
            // Inline imports aren't cached here.
            // If we start to cache them, please make sure they won't conflict with non-inline imports of the
            // same name as they used to do before this comment and the condition below have been added.
            if (!importManager.files[fullPath] && !importOptions.inline) {
              importManager.files[fullPath] = {
                root: root,
                options: importOptions
              };
            }
            if (e && !importManager.error) {
              importManager.error = e;
            }
            callback(e, root, importedEqualsRoot, fullPath);
          }
        };
        var newFileInfo = {
          rewriteUrls: this.context.rewriteUrls,
          entryPath: currentFileInfo.entryPath,
          rootpath: currentFileInfo.rootpath,
          rootFilename: currentFileInfo.rootFilename
        };
        var fileManager = environment.getFileManager(path, currentFileInfo.currentDirectory, this.context, environment);
        if (!fileManager) {
          fileParsedFunc({
            message: "Could not find a file-manager for ".concat(path)
          });
          return;
        }
        var loadFileCallback = function (loadedFile) {
          var plugin;
          var resolvedFilename = loadedFile.filename;
          var contents = loadedFile.contents.replace(/^\uFEFF/, '');
          // Pass on an updated rootpath if path of imported file is relative and file
          // is in a (sub|sup) directory
          //
          // Examples:
          // - If path of imported file is 'module/nav/nav.less' and rootpath is 'less/',
          //   then rootpath should become 'less/module/nav/'
          // - If path of imported file is '../mixins.less' and rootpath is 'less/',
          //   then rootpath should become 'less/../'
          newFileInfo.currentDirectory = fileManager.getPath(resolvedFilename);
          if (newFileInfo.rewriteUrls) {
            newFileInfo.rootpath = fileManager.join(importManager.context.rootpath || '', fileManager.pathDiff(newFileInfo.currentDirectory, newFileInfo.entryPath));
            if (!fileManager.isPathAbsolute(newFileInfo.rootpath) && fileManager.alwaysMakePathsAbsolute()) {
              newFileInfo.rootpath = fileManager.join(newFileInfo.entryPath, newFileInfo.rootpath);
            }
          }
          newFileInfo.filename = resolvedFilename;
          var newEnv = new contexts_1.default.Parse(importManager.context);
          newEnv.processImports = false;
          importManager.contents[resolvedFilename] = contents;
          if (currentFileInfo.reference || importOptions.reference) {
            newFileInfo.reference = true;
          }
          if (importOptions.isPlugin) {
            plugin = pluginLoader.evalPlugin(contents, newEnv, importManager, importOptions.pluginArgs, newFileInfo);
            if (plugin instanceof less_error_1.default) {
              fileParsedFunc(plugin, null, resolvedFilename);
            } else {
              fileParsedFunc(null, plugin, resolvedFilename);
            }
          } else if (importOptions.inline) {
            fileParsedFunc(null, contents, resolvedFilename);
          } else {
            // import (multiple) parse trees apparently get altered and can't be cached.
            // TODO: investigate why this is
            if (importManager.files[resolvedFilename] && !importManager.files[resolvedFilename].options.multiple && !importOptions.multiple) {
              fileParsedFunc(null, importManager.files[resolvedFilename].root, resolvedFilename);
            } else {
              new parser_1.default(newEnv, importManager, newFileInfo).parse(contents, function (e, root) {
                fileParsedFunc(e, root, resolvedFilename);
              });
            }
          }
        };
        var loadedFile;
        var promise;
        var context = utils.clone(this.context);
        if (tryAppendExtension) {
          context.ext = importOptions.isPlugin ? '.js' : '.less';
        }
        if (importOptions.isPlugin) {
          context.mime = 'application/javascript';
          if (context.syncImport) {
            loadedFile = pluginLoader.loadPluginSync(path, currentFileInfo.currentDirectory, context, environment, fileManager);
          } else {
            promise = pluginLoader.loadPlugin(path, currentFileInfo.currentDirectory, context, environment, fileManager);
          }
        } else {
          if (context.syncImport) {
            loadedFile = fileManager.loadFileSync(path, currentFileInfo.currentDirectory, context, environment);
          } else {
            promise = fileManager.loadFile(path, currentFileInfo.currentDirectory, context, environment, function (err, loadedFile) {
              if (err) {
                fileParsedFunc(err);
              } else {
                loadFileCallback(loadedFile);
              }
            });
          }
        }
        if (loadedFile) {
          if (!loadedFile.filename) {
            fileParsedFunc(loadedFile);
          } else {
            loadFileCallback(loadedFile);
          }
        } else if (promise) {
          promise.then(loadFileCallback, fileParsedFunc);
        }
      };
      return ImportManager;
    }();
    return ImportManager;
  }
  importManager.default = default_1;
  return importManager;
}

var parse = {};

var hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse;
  hasRequiredParse = 1;
  Object.defineProperty(parse, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var contexts_1 = tslib_1.__importDefault(requireContexts());
  var parser_1 = tslib_1.__importDefault(requireParser());
  var plugin_manager_1 = tslib_1.__importDefault(requirePluginManager());
  var less_error_1 = tslib_1.__importDefault(requireLessError());
  var utils = tslib_1.__importStar(requireUtils());
  function default_1(environment, ParseTree, ImportManager) {
    var parse = function (input, options, callback) {
      if (typeof options === 'function') {
        callback = options;
        options = utils.copyOptions(this.options, {});
      } else {
        options = utils.copyOptions(this.options, options || {});
      }
      if (!callback) {
        var self_1 = this;
        return new Promise(function (resolve, reject) {
          parse.call(self_1, input, options, function (err, output) {
            if (err) {
              reject(err);
            } else {
              resolve(output);
            }
          });
        });
      } else {
        var context_1;
        var rootFileInfo = void 0;
        var pluginManager_1 = new plugin_manager_1.default(this, !options.reUsePluginManager);
        options.pluginManager = pluginManager_1;
        context_1 = new contexts_1.default.Parse(options);
        if (options.rootFileInfo) {
          rootFileInfo = options.rootFileInfo;
        } else {
          var filename = options.filename || 'input';
          var entryPath = filename.replace(/[^/\\]*$/, '');
          rootFileInfo = {
            filename: filename,
            rewriteUrls: context_1.rewriteUrls,
            rootpath: context_1.rootpath || '',
            currentDirectory: entryPath,
            entryPath: entryPath,
            rootFilename: filename
          };
          // add in a missing trailing slash
          if (rootFileInfo.rootpath && rootFileInfo.rootpath.slice(-1) !== '/') {
            rootFileInfo.rootpath += '/';
          }
        }
        var imports_1 = new ImportManager(this, context_1, rootFileInfo);
        this.importManager = imports_1;
        // TODO: allow the plugins to be just a list of paths or names
        // Do an async plugin queue like lessc
        if (options.plugins) {
          options.plugins.forEach(function (plugin) {
            var evalResult, contents;
            if (plugin.fileContent) {
              contents = plugin.fileContent.replace(/^\uFEFF/, '');
              evalResult = pluginManager_1.Loader.evalPlugin(contents, context_1, imports_1, plugin.options, plugin.filename);
              if (evalResult instanceof less_error_1.default) {
                return callback(evalResult);
              }
            } else {
              pluginManager_1.addPlugin(plugin);
            }
          });
        }
        new parser_1.default(context_1, imports_1, rootFileInfo).parse(input, function (e, root) {
          if (e) {
            return callback(e);
          }
          callback(null, root, imports_1, options);
        }, options);
      }
    };
    return parse;
  }
  parse.default = default_1;
  return parse;
}

var render = {};

var hasRequiredRender;
function requireRender() {
  if (hasRequiredRender) return render;
  hasRequiredRender = 1;
  Object.defineProperty(render, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var utils = tslib_1.__importStar(requireUtils());
  function default_1(environment, ParseTree) {
    var render = function (input, options, callback) {
      if (typeof options === 'function') {
        callback = options;
        options = utils.copyOptions(this.options, {});
      } else {
        options = utils.copyOptions(this.options, options || {});
      }
      if (!callback) {
        var self_1 = this;
        return new Promise(function (resolve, reject) {
          render.call(self_1, input, options, function (err, output) {
            if (err) {
              reject(err);
            } else {
              resolve(output);
            }
          });
        });
      } else {
        this.parse(input, options, function (err, root, imports, options) {
          if (err) {
            return callback(err);
          }
          var result;
          try {
            var parseTree = new ParseTree(root, imports);
            result = parseTree.toCSS(options);
          } catch (err) {
            return callback(err);
          }
          callback(null, result);
        });
      }
    };
    return render;
  }
  render.default = default_1;
  return render;
}

var name = "less";
var version = "4.2.1";
var description = "Leaner CSS";
var homepage = "http://lesscss.org";
var author = {
	name: "Alexis Sellier",
	email: "self@cloudhead.net"
};
var contributors = [
	"The Core Less Team"
];
var bugs = {
	url: "https://github.com/less/less.js/issues"
};
var repository = {
	type: "git",
	url: "https://github.com/less/less.js.git"
};
var master = {
	url: "https://github.com/less/less.js/blob/master/",
	raw: "https://raw.githubusercontent.com/less/less.js/master/"
};
var license = "Apache-2.0";
var bin = {
	lessc: "./bin/lessc"
};
var main = "index";
var module$1 = "./lib/less-node/index";
var directories = {
	test: "./test"
};
var browser = "./dist/less.js";
var engines = {
	node: ">=6"
};
var scripts = {
	test: "grunt test",
	grunt: "grunt",
	lint: "eslint '**/*.{ts,js}'",
	"lint:fix": "eslint '**/*.{ts,js}' --fix",
	build: "npm-run-all clean compile",
	clean: "shx rm -rf ./lib tsconfig.tsbuildinfo",
	compile: "tsc -p tsconfig.build.json",
	"copy:root": "shx cp -rf ./dist ../../",
	dev: "tsc -p tsconfig.build.json -w",
	prepublishOnly: "grunt dist"
};
var optionalDependencies = {
	errno: "^0.1.1",
	"graceful-fs": "^4.1.2",
	"image-size": "~0.5.0",
	"make-dir": "^2.1.0",
	mime: "^1.4.1",
	needle: "^3.1.0",
	"source-map": "~0.6.0"
};
var devDependencies = {
	"@less/test-data": "^4.2.1",
	"@less/test-import-module": "^4.0.0",
	"@rollup/plugin-commonjs": "^17.0.0",
	"@rollup/plugin-json": "^4.1.0",
	"@rollup/plugin-node-resolve": "^11.0.0",
	"@typescript-eslint/eslint-plugin": "^4.28.0",
	"@typescript-eslint/parser": "^4.28.0",
	benny: "^3.6.12",
	"bootstrap-less-port": "0.3.0",
	chai: "^4.2.0",
	"cross-env": "^7.0.3",
	diff: "^3.2.0",
	eslint: "^7.29.0",
	"fs-extra": "^8.1.0",
	"git-rev": "^0.2.1",
	globby: "^10.0.1",
	grunt: "^1.0.4",
	"grunt-cli": "^1.3.2",
	"grunt-contrib-clean": "^1.0.0",
	"grunt-contrib-connect": "^1.0.2",
	"grunt-eslint": "^23.0.0",
	"grunt-saucelabs": "^9.0.1",
	"grunt-shell": "^1.3.0",
	"html-template-tag": "^3.2.0",
	"jit-grunt": "^0.10.0",
	"less-plugin-autoprefix": "^1.5.1",
	"less-plugin-clean-css": "^1.5.1",
	minimist: "^1.2.0",
	mocha: "^6.2.1",
	"mocha-headless-chrome": "^4.0.0",
	"mocha-teamcity-reporter": "^3.0.0",
	nock: "^11.8.2",
	"npm-run-all": "^4.1.5",
	"performance-now": "^0.2.0",
	phin: "^2.2.3",
	promise: "^7.1.1",
	"read-glob": "^3.0.0",
	resolve: "^1.17.0",
	rollup: "^2.52.2",
	"rollup-plugin-terser": "^5.1.1",
	"rollup-plugin-typescript2": "^0.29.0",
	semver: "^6.3.0",
	shx: "^0.3.2",
	"time-grunt": "^1.3.0",
	"ts-node": "^10.9.1",
	typescript: "^4.3.4",
	uikit: "2.27.4"
};
var keywords = [
	"compile less",
	"css nesting",
	"css variable",
	"css",
	"gradients css",
	"gradients css3",
	"less compiler",
	"less css",
	"less mixins",
	"less",
	"less.js",
	"lesscss",
	"mixins",
	"nested css",
	"parser",
	"preprocessor",
	"bootstrap css",
	"bootstrap less",
	"style",
	"styles",
	"stylesheet",
	"variables in css",
	"css less"
];
var rawcurrent = "https://raw.github.com/less/less.js/v";
var sourcearchive = "https://github.com/less/less.js/archive/v";
var dependencies = {
	"copy-anything": "^2.0.1",
	"parse-node-version": "^1.0.1",
	tslib: "^2.3.0"
};
var gitHead = "1df9072ee9ebdadc791bf35dfb1dbc3ef9f1948f";
var require$$21 = {
	name: name,
	version: version,
	description: description,
	homepage: homepage,
	author: author,
	contributors: contributors,
	bugs: bugs,
	repository: repository,
	master: master,
	license: license,
	bin: bin,
	main: main,
	module: module$1,
	directories: directories,
	browser: browser,
	engines: engines,
	scripts: scripts,
	optionalDependencies: optionalDependencies,
	devDependencies: devDependencies,
	keywords: keywords,
	rawcurrent: rawcurrent,
	sourcearchive: sourcearchive,
	dependencies: dependencies,
	gitHead: gitHead
};

var parseNodeVersion_1;
var hasRequiredParseNodeVersion;
function requireParseNodeVersion() {
  if (hasRequiredParseNodeVersion) return parseNodeVersion_1;
  hasRequiredParseNodeVersion = 1;
  function parseNodeVersion(version) {
    var match = version.match(/^v(\d{1,2})\.(\d{1,2})\.(\d{1,2})(?:-([0-9A-Za-z-.]+))?(?:\+([0-9A-Za-z-.]+))?$/); // eslint-disable-line max-len
    if (!match) {
      throw new Error('Unable to parse: ' + version);
    }
    var res = {
      major: parseInt(match[1], 10),
      minor: parseInt(match[2], 10),
      patch: parseInt(match[3], 10),
      pre: match[4] || '',
      build: match[5] || ''
    };
    return res;
  }
  parseNodeVersion_1 = parseNodeVersion;
  return parseNodeVersion_1;
}

var hasRequiredLess;
function requireLess() {
  if (hasRequiredLess) return less$1;
  hasRequiredLess = 1;
  Object.defineProperty(less$1, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var environment_1 = tslib_1.__importDefault(requireEnvironment());
  var data_1 = tslib_1.__importDefault(requireData());
  var tree_1 = tslib_1.__importDefault(requireTree());
  var abstract_file_manager_1 = tslib_1.__importDefault(requireAbstractFileManager());
  var abstract_plugin_loader_1 = tslib_1.__importDefault(requireAbstractPluginLoader());
  var visitors_1 = tslib_1.__importDefault(requireVisitors());
  var parser_1 = tslib_1.__importDefault(requireParser());
  var functions_1 = tslib_1.__importDefault(requireFunctions());
  var contexts_1 = tslib_1.__importDefault(requireContexts());
  var less_error_1 = tslib_1.__importDefault(requireLessError());
  var transform_tree_1 = tslib_1.__importDefault(requireTransformTree());
  var utils = tslib_1.__importStar(requireUtils());
  var plugin_manager_1 = tslib_1.__importDefault(requirePluginManager());
  var logger_1 = tslib_1.__importDefault(requireLogger());
  var source_map_output_1 = tslib_1.__importDefault(requireSourceMapOutput());
  var source_map_builder_1 = tslib_1.__importDefault(requireSourceMapBuilder());
  var parse_tree_1 = tslib_1.__importDefault(requireParseTree());
  var import_manager_1 = tslib_1.__importDefault(requireImportManager());
  var parse_1 = tslib_1.__importDefault(requireParse());
  var render_1 = tslib_1.__importDefault(requireRender());
  var package_json_1 = require$$21;
  var parse_node_version_1 = tslib_1.__importDefault(requireParseNodeVersion());
  function default_1(environment, fileManagers) {
    var sourceMapOutput, sourceMapBuilder, parseTree, importManager;
    environment = new environment_1.default(environment, fileManagers);
    sourceMapOutput = (0, source_map_output_1.default)(environment);
    sourceMapBuilder = (0, source_map_builder_1.default)(sourceMapOutput, environment);
    parseTree = (0, parse_tree_1.default)(sourceMapBuilder);
    importManager = (0, import_manager_1.default)(environment);
    var render = (0, render_1.default)(environment, parseTree, importManager);
    var parse = (0, parse_1.default)(environment, parseTree, importManager);
    var v = (0, parse_node_version_1.default)("v".concat(package_json_1.version));
    var initial = {
      version: [v.major, v.minor, v.patch],
      data: data_1.default,
      tree: tree_1.default,
      Environment: environment_1.default,
      AbstractFileManager: abstract_file_manager_1.default,
      AbstractPluginLoader: abstract_plugin_loader_1.default,
      environment: environment,
      visitors: visitors_1.default,
      Parser: parser_1.default,
      functions: (0, functions_1.default)(environment),
      contexts: contexts_1.default,
      SourceMapOutput: sourceMapOutput,
      SourceMapBuilder: sourceMapBuilder,
      ParseTree: parseTree,
      ImportManager: importManager,
      render: render,
      parse: parse,
      LessError: less_error_1.default,
      transformTree: transform_tree_1.default,
      utils: utils,
      PluginManager: plugin_manager_1.default,
      logger: logger_1.default
    };
    // Create a public API
    var ctor = function (t) {
      return function () {
        var obj = Object.create(t.prototype);
        t.apply(obj, Array.prototype.slice.call(arguments, 0));
        return obj;
      };
    };
    var t;
    var api = Object.create(initial);
    for (var n in initial.tree) {
      /* eslint guard-for-in: 0 */
      t = initial.tree[n];
      if (typeof t === 'function') {
        api[n.toLowerCase()] = ctor(t);
      } else {
        api[n] = Object.create(null);
        for (var o in t) {
          /* eslint guard-for-in: 0 */
          api[n][o.toLowerCase()] = ctor(t[o]);
        }
      }
    }
    /**
     * Some of the functions assume a `this` context of the API object,
     * which causes it to fail when wrapped for ES6 imports.
     *
     * An assumed `this` should be removed in the future.
     */
    initial.parse = initial.parse.bind(api);
    initial.render = initial.render.bind(api);
    return api;
  }
  less$1.default = default_1;
  return less$1;
}

var lesscHelper = {};

var hasRequiredLesscHelper;
function requireLesscHelper() {
  if (hasRequiredLesscHelper) return lesscHelper;
  hasRequiredLesscHelper = 1;
  (function (exports) {
    // lessc_helper.js
    //
    //      helper functions for lessc
    var lessc_helper = {
      // Stylize a string
      stylize: function (str, style) {
        var styles = {
          'reset': [0, 0],
          'bold': [1, 22],
          'inverse': [7, 27],
          'underline': [4, 24],
          'yellow': [33, 39],
          'green': [32, 39],
          'red': [31, 39],
          'grey': [90, 39]
        };
        return "\u001B[".concat(styles[style][0], "m").concat(str, "\u001B[").concat(styles[style][1], "m");
      },
      // Print command line options
      printUsage: function () {
        console.log('usage: lessc [option option=parameter ...] <source> [destination]');
        console.log('');
        console.log('If source is set to `-\' (dash or hyphen-minus), input is read from stdin.');
        console.log('');
        console.log('options:');
        console.log('  -h, --help                   Prints help (this message) and exit.');
        console.log('  --include-path=PATHS         Sets include paths. Separated by `:\'. `;\' also supported on windows.');
        console.log('  -M, --depends                Outputs a makefile import dependency list to stdout.');
        console.log('  --no-color                   Disables colorized output.');
        console.log('  --ie-compat                  Enables IE8 compatibility checks.');
        console.log('  --js                         Enables inline JavaScript in less files');
        console.log('  -l, --lint                   Syntax check only (lint).');
        console.log('  -s, --silent                 Suppresses output of error messages.');
        console.log('  --strict-imports             Forces evaluation of imports.');
        console.log('  --insecure                   Allows imports from insecure https hosts.');
        console.log('  -v, --version                Prints version number and exit.');
        console.log('  --verbose                    Be verbose.');
        console.log('  --source-map[=FILENAME]      Outputs a v3 sourcemap to the filename (or output filename.map).');
        console.log('  --source-map-rootpath=X      Adds this path onto the sourcemap filename and less file paths.');
        console.log('  --source-map-basepath=X      Sets sourcemap base path, defaults to current working directory.');
        console.log('  --source-map-include-source  Puts the less files into the map instead of referencing them.');
        console.log('  --source-map-inline          Puts the map (and any less files) as a base64 data uri into the output css file.');
        console.log('  --source-map-url=URL         Sets a custom URL to map file, for sourceMappingURL comment');
        console.log('                               in generated CSS file.');
        console.log('  --source-map-no-annotation   Excludes the sourceMappingURL comment from the output css file.');
        console.log('  -rp, --rootpath=URL          Sets rootpath for url rewriting in relative imports and urls');
        console.log('                               Works with or without the relative-urls option.');
        console.log('  -ru=, --rewrite-urls=        Rewrites URLs to make them relative to the base less file.');
        console.log('    all|local|off              \'all\' rewrites all URLs, \'local\' just those starting with a \'.\'');
        console.log('');
        console.log('  -m=, --math=');
        console.log('     always                    Less will eagerly perform math operations always.');
        console.log('     parens-division           Math performed except for division (/) operator');
        console.log('     parens | strict           Math only performed inside parentheses');
        console.log('     strict-legacy             Parens required in very strict terms (legacy --strict-math)');
        console.log('');
        console.log('  -su=on|off                   Allows mixed units, e.g. 1px+1em or 1px*1px which have units');
        console.log('  --strict-units=on|off        that cannot be represented.');
        console.log('  --global-var=\'VAR=VALUE\'     Defines a variable that can be referenced by the file.');
        console.log('  --modify-var=\'VAR=VALUE\'     Modifies a variable already declared in the file.');
        console.log('  --url-args=\'QUERYSTRING\'     Adds params into url tokens (e.g. 42, cb=42 or \'a=1&b=2\')');
        console.log('  --plugin=PLUGIN=OPTIONS      Loads a plugin. You can also omit the --plugin= if the plugin begins');
        console.log('                               less-plugin. E.g. the clean css plugin is called less-plugin-clean-css');
        console.log('                               once installed (npm install less-plugin-clean-css), use either with');
        console.log('                               --plugin=less-plugin-clean-css or just --clean-css');
        console.log('                               specify options afterwards e.g. --plugin=less-plugin-clean-css="advanced"');
        console.log('                               or --clean-css="advanced"');
        console.log('  --disable-plugin-rule        Disallow @plugin statements');
        console.log('');
        console.log('-------------------------- Deprecated ----------------');
        console.log('  -sm=on|off               Legacy parens-only math. Use --math');
        console.log('  --strict-math=on|off     ');
        console.log('');
        console.log('  --line-numbers=TYPE      Outputs filename and line numbers.');
        console.log('                           TYPE can be either \'comments\', which will output');
        console.log('                           the debug info within comments, \'mediaquery\'');
        console.log('                           that will output the information within a fake');
        console.log('                           media query which is compatible with the SASS');
        console.log('                           format, and \'all\' which will do both.');
        console.log('  -x, --compress           Compresses output by removing some whitespaces.');
        console.log('                           We recommend you use a dedicated minifer like less-plugin-clean-css');
        console.log('');
        console.log('Report bugs to: http://github.com/less/less.js/issues');
        console.log('Home page: <http://lesscss.org/>');
      }
    };
    // Exports helper functions
    // eslint-disable-next-line no-prototype-builtins
    for (var h in lessc_helper) {
      if (lessc_helper.hasOwnProperty(h)) {
        exports[h] = lessc_helper[h];
      }
    }
  })(lesscHelper);
  return lesscHelper;
}

var pluginLoader = {};

var hasRequiredPluginLoader;
function requirePluginLoader() {
  if (hasRequiredPluginLoader) return pluginLoader;
  hasRequiredPluginLoader = 1;
  Object.defineProperty(pluginLoader, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var path_1 = tslib_1.__importDefault(require$$1$1);
  var abstract_plugin_loader_js_1 = tslib_1.__importDefault(requireAbstractPluginLoader());
  /**
   * Node Plugin Loader
   */
  var PluginLoader = function (less) {
    this.less = less;
    this.require = function (prefix) {
      prefix = path_1.default.dirname(prefix);
      return function (id) {
        var str = id.substr(0, 2);
        if (str === '..' || str === './') {
          return commonjsRequire(path_1.default.join(prefix, id));
        } else {
          return commonjsRequire(id);
        }
      };
    };
  };
  PluginLoader.prototype = Object.assign(new abstract_plugin_loader_js_1.default(), {
    loadPlugin: function (filename, basePath, context, environment, fileManager) {
      var prefix = filename.slice(0, 1);
      var explicit = prefix === '.' || prefix === '/' || filename.slice(-3).toLowerCase() === '.js';
      if (!explicit) {
        context.prefixes = ['less-plugin-', ''];
      }
      if (context.syncImport) {
        return fileManager.loadFileSync(filename, basePath, context, environment);
      }
      return new Promise(function (fulfill, reject) {
        fileManager.loadFile(filename, basePath, context, environment).then(function (data) {
          try {
            fulfill(data);
          } catch (e) {
            console.log(e);
            reject(e);
          }
        }).catch(function (err) {
          reject(err);
        });
      });
    },
    loadPluginSync: function (filename, basePath, context, environment, fileManager) {
      context.syncImport = true;
      return this.loadPlugin(filename, basePath, context, environment, fileManager);
    }
  });
  pluginLoader.default = PluginLoader;
  return pluginLoader;
}

var defaultOptions = {};

var hasRequiredDefaultOptions;
function requireDefaultOptions() {
  if (hasRequiredDefaultOptions) return defaultOptions;
  hasRequiredDefaultOptions = 1;
  Object.defineProperty(defaultOptions, "__esModule", {
    value: true
  });
  // Export a new default each time
  function default_1() {
    return {
      /* Inline Javascript - @plugin still allowed */
      javascriptEnabled: false,
      /* Outputs a makefile import dependency list to stdout. */
      depends: false,
      /* (DEPRECATED) Compress using less built-in compression.
       * This does an okay job but does not utilise all the tricks of
       * dedicated css compression. */
      compress: false,
      /* Runs the less parser and just reports errors without any output. */
      lint: false,
      /* Sets available include paths.
       * If the file in an @import rule does not exist at that exact location,
       * less will look for it at the location(s) passed to this option.
       * You might use this for instance to specify a path to a library which
       * you want to be referenced simply and relatively in the less files. */
      paths: [],
      /* color output in the terminal */
      color: true,
      /* The strictImports controls whether the compiler will allow an @import inside of either
       * @media blocks or (a later addition) other selector blocks.
       * See: https://github.com/less/less.js/issues/656 */
      strictImports: false,
      /* Allow Imports from Insecure HTTPS Hosts */
      insecure: false,
      /* Allows you to add a path to every generated import and url in your css.
       * This does not affect less import statements that are processed, just ones
       * that are left in the output css. */
      rootpath: '',
      /* By default URLs are kept as-is, so if you import a file in a sub-directory
       * that references an image, exactly the same URL will be output in the css.
       * This option allows you to re-write URL's in imported files so that the
       * URL is always relative to the base imported file */
      rewriteUrls: false,
      /* How to process math
       *   0 always           - eagerly try to solve all operations
       *   1 parens-division  - require parens for division "/"
       *   2 parens | strict  - require parens for all operations
       *   3 strict-legacy    - legacy strict behavior (super-strict)
       */
      math: 1,
      /* Without this option, less attempts to guess at the output unit when it does maths. */
      strictUnits: false,
      /* Effectively the declaration is put at the top of your base Less file,
       * meaning it can be used but it also can be overridden if this variable
       * is defined in the file. */
      globalVars: null,
      /* As opposed to the global variable option, this puts the declaration at the
       * end of your base file, meaning it will override anything defined in your Less file. */
      modifyVars: null,
      /* This option allows you to specify a argument to go on to every URL.  */
      urlArgs: ''
    };
  }
  defaultOptions.default = default_1;
  return defaultOptions;
}

var imageSize = {};

var lib = {exports: {}};

var types;
var hasRequiredTypes;
function requireTypes() {
  if (hasRequiredTypes) return types;
  hasRequiredTypes = 1;
  types = ['bmp', 'gif', 'jpg', 'png', 'psd', 'svg', 'tiff', 'webp', 'dds'];
  return types;
}

var detector;
var hasRequiredDetector;
function requireDetector() {
  if (hasRequiredDetector) return detector;
  hasRequiredDetector = 1;
  var typeMap = {};
  var types = requireTypes();

  // load all available handlers
  types.forEach(function (type) {
    typeMap[type] = commonjsRequire('./types/' + type).detect;
  });
  detector = function (buffer, filepath) {
    var type, result;
    for (type in typeMap) {
      result = typeMap[type](buffer, filepath);
      if (result) {
        return type;
      }
    }
  };
  return detector;
}

var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib.exports;
  hasRequiredLib = 1;
  var fs = require$$0$5;
  var path = require$$1$1;
  var detector = requireDetector();
  var handlers = {};
  var types = requireTypes();

  // load all available handlers
  types.forEach(function (type) {
    handlers[type] = commonjsRequire('./types/' + type);
  });

  // Maximum buffer size, with a default of 128 kilobytes.
  // TO-DO: make this adaptive based on the initial signature of the image
  var MaxBufferSize = 128 * 1024;
  function lookup(buffer, filepath) {
    // detect the file type.. don't rely on the extension
    var type = detector(buffer, filepath);

    // find an appropriate handler for this file type
    if (type in handlers) {
      var size = handlers[type].calculate(buffer, filepath);
      if (size !== false) {
        size.type = type;
        return size;
      }
    }

    // throw up, if we don't understand the file
    throw new TypeError('unsupported file type: ' + type + ' (file: ' + filepath + ')');
  }
  function asyncFileToBuffer(filepath, callback) {
    // open the file in read only mode
    fs.open(filepath, 'r', function (err, descriptor) {
      if (err) {
        return callback(err);
      }
      var size = fs.fstatSync(descriptor).size;
      if (size <= 0) {
        return callback(new Error("File size is not greater than 0  " + filepath));
      }
      var bufferSize = Math.min(size, MaxBufferSize);
      var buffer = new Buffer(bufferSize);
      // read first buffer block from the file, asynchronously
      fs.read(descriptor, buffer, 0, bufferSize, 0, function (err) {
        if (err) {
          return callback(err);
        }
        // close the file, we are done
        fs.close(descriptor, function (err) {
          callback(err, buffer);
        });
      });
    });
  }
  function syncFileToBuffer(filepath) {
    // read from the file, synchronously
    var descriptor = fs.openSync(filepath, 'r');
    var size = fs.fstatSync(descriptor).size;
    var bufferSize = Math.min(size, MaxBufferSize);
    var buffer = new Buffer(bufferSize);
    fs.readSync(descriptor, buffer, 0, bufferSize, 0);
    fs.closeSync(descriptor);
    return buffer;
  }

  /**
   * @params input - buffer or relative/absolute path of the image file
   * @params callback - optional function for async detection
   */
  lib.exports = function (input, callback) {
    // Handle buffer input
    if (Buffer.isBuffer(input)) {
      return lookup(input);
    }

    // input should be a string at this point
    if (typeof input !== 'string') {
      throw new TypeError('invalid invocation');
    }

    // resolve the file path
    var filepath = path.resolve(input);
    if (typeof callback === 'function') {
      asyncFileToBuffer(filepath, function (err, buffer) {
        if (err) {
          return callback(err);
        }

        // return the dimensions
        var dimensions;
        try {
          dimensions = lookup(buffer, filepath);
        } catch (e) {
          err = e;
        }
        callback(err, dimensions);
      });
    } else {
      var buffer = syncFileToBuffer(filepath);
      return lookup(buffer, filepath);
    }
  };
  lib.exports.types = types;
  return lib.exports;
}

var hasRequiredImageSize;
function requireImageSize() {
  if (hasRequiredImageSize) return imageSize;
  hasRequiredImageSize = 1;
  Object.defineProperty(imageSize, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var dimension_1 = tslib_1.__importDefault(requireDimension());
  var expression_1 = tslib_1.__importDefault(requireExpression());
  var function_registry_1 = tslib_1.__importDefault(requireFunctionRegistry());
  imageSize.default = function (environment) {
    function imageSize(functionContext, filePathNode) {
      var filePath = filePathNode.value;
      var currentFileInfo = functionContext.currentFileInfo;
      var currentDirectory = currentFileInfo.rewriteUrls ? currentFileInfo.currentDirectory : currentFileInfo.entryPath;
      var fragmentStart = filePath.indexOf('#');
      if (fragmentStart !== -1) {
        filePath = filePath.slice(0, fragmentStart);
      }
      var fileManager = environment.getFileManager(filePath, currentDirectory, functionContext.context, environment, true);
      if (!fileManager) {
        throw {
          type: 'File',
          message: "Can not set up FileManager for ".concat(filePathNode)
        };
      }
      var fileSync = fileManager.loadFileSync(filePath, currentDirectory, functionContext.context, environment);
      if (fileSync.error) {
        throw fileSync.error;
      }
      var sizeOf = requireLib();
      return sizeOf(fileSync.filename);
    }
    var imageFunctions = {
      'image-size': function (filePathNode) {
        var size = imageSize(this, filePathNode);
        return new expression_1.default([new dimension_1.default(size.width, 'px'), new dimension_1.default(size.height, 'px')]);
      },
      'image-width': function (filePathNode) {
        var size = imageSize(this, filePathNode);
        return new dimension_1.default(size.width, 'px');
      },
      'image-height': function (filePathNode) {
        var size = imageSize(this, filePathNode);
        return new dimension_1.default(size.height, 'px');
      }
    };
    function_registry_1.default.addMultiple(imageFunctions);
  };
  return imageSize;
}

var hasRequiredLessNode;
function requireLessNode() {
  if (hasRequiredLessNode) return lessNode;
  hasRequiredLessNode = 1;
  Object.defineProperty(lessNode, "__esModule", {
    value: true
  });
  var tslib_1 = require$$0$2;
  var environment_1 = tslib_1.__importDefault(requireEnvironment$1());
  var file_manager_1 = tslib_1.__importDefault(requireFileManager());
  var url_file_manager_1 = tslib_1.__importDefault(requireUrlFileManager());
  var less_1 = tslib_1.__importDefault(requireLess());
  var less = (0, less_1.default)(environment_1.default, [new file_manager_1.default(), new url_file_manager_1.default()]);
  var lessc_helper_1 = tslib_1.__importDefault(requireLesscHelper());
  // allow people to create less with their own environment
  less.createFromEnvironment = less_1.default;
  less.lesscHelper = lessc_helper_1.default;
  less.PluginLoader = requirePluginLoader().default;
  less.fs = requireFs().default;
  less.FileManager = file_manager_1.default;
  less.UrlFileManager = url_file_manager_1.default;
  // Set up options
  less.options = requireDefaultOptions().default();
  // provide image-size functionality
  requireImageSize().default(less.environment);
  lessNode.default = less;
  return lessNode;
}

var lessNodeExports = requireLessNode();
var less = /*@__PURE__*/getDefaultExportFromCjs(lessNodeExports);

function normalize(strArray) {
  var resultArray = [];
  if (strArray.length === 0) {
    return '';
  }
  if (typeof strArray[0] !== 'string') {
    throw new TypeError('Url must be a string. Received ' + strArray[0]);
  }

  // If the first part is a plain protocol, we combine it with the next part.
  if (strArray[0].match(/^[^/:]+:\/*$/) && strArray.length > 1) {
    var first = strArray.shift();
    strArray[0] = first + strArray[0];
  }

  // There must be two or three slashes in the file protocol, two slashes in anything else.
  if (strArray[0].match(/^file:\/\/\//)) {
    strArray[0] = strArray[0].replace(/^([^/:]+):\/*/, '$1:///');
  } else {
    strArray[0] = strArray[0].replace(/^([^/:]+):\/*/, '$1://');
  }
  for (var i = 0; i < strArray.length; i++) {
    var component = strArray[i];
    if (typeof component !== 'string') {
      throw new TypeError('Url must be a string. Received ' + component);
    }
    if (component === '') {
      continue;
    }
    if (i > 0) {
      // Removing the starting slashes for each component but the first.
      component = component.replace(/^[\/]+/, '');
    }
    if (i < strArray.length - 1) {
      // Removing the ending slashes for each component but the last.
      component = component.replace(/[\/]+$/, '');
    } else {
      // For the last component we will combine multiple slashes to a single one.
      component = component.replace(/[\/]+$/, '/');
    }
    resultArray.push(component);
  }
  var str = resultArray.join('/');
  // Each input component is now separated by a single slash except the possible first plain protocol part.

  // remove trailing slash before parameters or hash
  str = str.replace(/\/(\?|&|#[^!])/g, '$1');

  // replace ? in parameters with &
  var parts = str.split('?');
  str = parts.shift() + (parts.length > 0 ? '?' : '') + parts.join('&');
  return str;
}
function urlJoin() {
  var input;
  if (typeof arguments[0] === 'object') {
    input = arguments[0];
  } else {
    input = [].slice.call(arguments);
  }
  return normalize(input);
}

const fse = /*@__PURE__*/requireLib$3();
const {
  renderFile
} = requireEjs();
const {
  minify
} = requireHtmlminifier();
const {
  robots
} = requireCjs();
const {
  SitemapStream,
  streamToPromise
} = requireDist$1();
const moment = requireMoment();
try {
  //const sourceData = require('./render_data.json');

  // 
  const renderDataPath = process.argv.find(t => t.endsWith('.json'));
  // TODO:  appDir
  // TODO: buildDir
  // TODO: menus.link  => /
  // TODO: tags[0].count 
  // TODO:  commentSetting
  // TODO:  minify  html
  const sourceData = fse.readJsonSync(renderDataPath);
  // 
  const siteData = {
    posts: sourceData.posts,
    tags: sourceData.tags,
    menus: sourceData.menus,
    themeConfig: sourceData.themeConfig,
    customConfig: sourceData.customConfig,
    utils: {
      now: moment.now(),
      moment: moment
    },
    isHomepage: sourceData.isHomepage
  };
  // 
  const appDir = sourceData.appDir;
  // 
  const buildDir = sourceData.buildDir;
  // 
  const themePath = urlJoin(appDir, 'themes', sourceData.themeConfig.selectTheme);
  //  post
  const showPosts = sourceData.posts.filter(item => !item.hideInList);
  /**
   * 
   * @type {import('sitemap/dist/lib/types').SitemapItemLoose[]}
   */
  const siteMapUrls = [];

  /**
   *  css
   * @return {Promise<void>}
   */
  async function buildCss() {
    let stylesPath = urlJoin(themePath, 'assets', 'styles');
    let lessFilePath = urlJoin(stylesPath, 'main.css');
    let cssFolderPath = urlJoin(buildDir, 'styles', 'main.css');
    let result = '';

    //  css 
    if (fse.pathExistsSync(lessFilePath)) {
      result += fse.readFileSync(lessFilePath, 'utf8');
    } else {
      //  less 
      lessFilePath = urlJoin(stylesPath, 'main.less');
      if (fse.pathExistsSync(lessFilePath)) {
        let lessString = fse.readFileSync(lessFilePath, 'utf8');
        //  less
        await new Promise((resolve, reject) => {
          less.render(lessString, {
            filename: lessFilePath
          }, (err, data) => {
            if (err) {
              data = {
                css: ''
              };
            }
            result += data.css;
            resolve();
          });
        });
      }
    }
    //  css 
    let styleOverridePath = urlJoin(themePath, 'style-override.js');
    if (!fse.pathExistsSync(styleOverridePath)) {
      let customCss = commonjsRequire(styleOverridePath)(siteData);
      result += customCss;
    }
    // 
    fse.outputFileSync(cssFolderPath, result);
  }

  /**
   *  url 
   * @param {string} url url 
   */
  function recordUrl(url) {
    const {
      generateSiteMap,
      domain
    } = sourceData.themeConfig;
    if (!generateSiteMap) return;
    //  url 
    siteMapUrls.push({
      url: urlJoin(domain, url, '/'),
      priority: 0.5,
      changefreq: 'daily'
    });
  }

  /**
   * Ejs 
   * @param {string} path 
   * @param {any} data 
   * @param {string} url  url 
   * @return {Promise<string>} html 
   */
  async function renderFileAction(path, data, url) {
    let html = '';
    // 
    await renderFile(path, data, {}, (err, data) => {
      if (err) data = '';
      html += data;
    });
    //  url
    recordUrl(url);
    //  html
    if (sourceData.minify) {
      try {
        html = minify(html, {
          collapseWhitespace: true,
          minifyCSS: true,
          minifyJS: true,
          removeComments: true,
          quoteCharacter: '\''
        });
      } catch (e) {
        return html;
      }
    }
    return html;
  }

  /**
   * 
   * @param {string} urlPath , home => '', archive => '/archives', tag => '/tag/tag.slug'
   * @param {'index.ejs' | 'archives.ejs' | 'tag.ejs'} templatePath 
   * @param {number} pageSize  post 
   * @param {Array} postList post 
   * @param {null | function(value: any): any} update 
   * @return {Promise<void>}
   */
  async function buildPostList(urlPath = '', templatePath = 'index.ejs', pageSize = sourceData.themeConfig.postPageSize || 10, postList = null, update = null) {
    //  post 
    postList = postList != null ? postList : showPosts;
    // 
    const renderTemplatePath = urlJoin(themePath, 'templates', `${templatePath}`);

    // 
    if (templatePath === 'archives.ejs') {
      postList = showPosts.sort((a, b) => Date.parse(b.date) - Date.parse(a.date));
    }
    // 
    const renderData = {
      menus: sourceData.menus,
      posts: [],
      pagination: {
        prev: '',
        next: ''
      },
      themeConfig: sourceData.themeConfig,
      site: siteData
    };
    // html
    let html = '';
    // 
    let domain = urlJoin(sourceData.themeConfig.domain, urlPath);
    // , tag 
    let skipEmpty = templatePath === 'tag.ejs';

    /**
     * 
     * @param {number} i
     * @return {boolean}
     */
    function condition(i) {
      // tag:  post 
      if (skipEmpty) {
        return (i - 1) * pageSize < postList.length;
      }
      //  post 
      return (i - 1) * pageSize <= postList.length;
    }
    for (let i = 1; condition(i); i++) {
      //  pageSize 
      renderData.posts = postList.slice((i - 1) * pageSize, i * pageSize);
      // home  urlPath == ''
      renderData.site.isHomepage = !urlPath && i <= 1;
      // i <= 1 => urlPath
      // i > 1 => {urlPath}/page/{i}
      const currentUrlPaths = [urlPath, ...(i <= 1 ? [] : ['page', `${i}`])];
      // i <= 1 => ''
      // i == 2 => {domain}/
      // i > 2 => {domain}/page/{i - 1}
      renderData.pagination.prev = i <= 1 ? '' : i > 2 ? urlJoin(domain, 'page', `${i - 1}/`) : urlJoin(domain, '/');
      // i * pageSize >= postList.length => ''
      // i * pageSize < postList.length => {domain}/page/{i + 1}
      renderData.pagination.next = i * pageSize >= postList.length ? '' : urlJoin(domain, 'page', `${i + 1}/`);
      // 
      const currentUrlPath = urlJoin(currentUrlPaths);
      // 
      fse.ensureDirSync(urlJoin(buildDir, currentUrlPath));
      // 
      let renderPath = urlJoin(buildDir, currentUrlPath, 'index.html');
      // 
      html = await renderFileAction(renderTemplatePath, update ? update(renderData) : renderData, currentUrlPath);
      // 
      fse.outputFileSync(renderPath, html);
    }
  }

  /**
   * 
   * @return {Promise<void>}
   */
  async function buildTags() {
    // tags 
    const tagsFolder = urlJoin(buildDir, 'tags');
    // tags 
    const renderPath = urlJoin(tagsFolder, 'index.html');
    // 
    const renderData = {
      tags: sourceData.tags,
      menus: sourceData.menus,
      themeConfig: sourceData.themeConfig,
      site: siteData
    };
    //  tags 
    fse.ensureDirSync(tagsFolder);
    //  HTML,  tags 
    const html = await renderFileAction(urlJoin(themePath, 'templates', 'tags.ejs'), renderData, 'tags');
    // 
    fse.outputFileSync(renderPath, html);
  }

  /**
   * 
   * @return {Promise<void>}
   */
  async function buildPostDetail() {
    for (let i = 0; i < sourceData.posts.length; i++) {
      // 
      const post = {
        ...sourceData.posts[i]
      };
      // 
      if (!post.hideInList) {
        //  prev  next 
        let prev = sourceData.posts.slice(0, i).reverse().find(p => !p.hideInList);
        let next = sourceData.posts.slice(i + 1).find(p => !p.hideInList);
        if (prev) post.prevPost = prev;
        if (next) post.nextPost = next;
      }
      // 
      const renderData = {
        menus: sourceData.menus,
        post,
        themeConfig: sourceData.themeConfig,
        commentSetting: sourceData.commentSetting,
        site: siteData
      };
      // post  url 
      const urlPath = urlJoin(`${sourceData.themeConfig.postPath}`, post.fileName);
      // post 
      const renderFolderPath = urlJoin(buildDir, urlPath);
      //  HTML,  post 
      const html = await renderFileAction(urlJoin(themePath, 'templates', 'post.ejs'), renderData, urlPath);
      // 
      fse.ensureDirSync(renderFolderPath);
      // 
      fse.outputFileSync(urlJoin(renderFolderPath, 'index.html'), html);
    }
  }

  /**
   * 
   * @return {Promise<void>}
   */
  async function buildTagDetail() {
    // 
    const usedTags = sourceData.tags.filter(tag => tag.used);
    for (const currentTag of usedTags) {
      //  showPosts  currentTag.slug 
      let postList = showPosts.filter(post => post.tags.find(tag => tag.slug === currentTag.slug));
      //  tag 
      await buildPostList(urlJoin(sourceData.themeConfig.tagPath, currentTag.slug), 'tag.ejs', sourceData.themeConfig.postPageSize, postList, data => {
        data.tag = currentTag;
        return data;
      });
    }
  }

  /**
   * 
   * @return {Promise<void>}
   */
  async function buildCustomPage() {
    // 
    const temps = new Set(['index.ejs', 'post.ejs', 'tag.ejs', 'tags.ejs', 'archives.ejs',
    //  Glidea  Glidea 
    'images.ejs', 'media.ejs', 'post-images.ejs', 'styles.ejs', 'tag.ejs', 'tags.ejs']);
    //  templates 
    const files = fse.readdirSync(urlJoin(themePath, 'templates'), {
      withFileTypes: true
    });
    // 
    const customTemplates = files.filter(item => item.isFile() && !temps.has(item.name)).map(item => item.name);
    // 
    const renderData = {
      menus: sourceData.menus,
      themeConfig: sourceData.themeConfig,
      commentSetting: sourceData.commentSetting,
      site: siteData
    };
    // 
    for (const name of customTemplates) {
      //  custom.ejs => custom
      const fileName = name.substring(0, name.length - 4);
      // 
      let templatePath = urlJoin(themePath, 'templates', name);
      // 
      let renderFolder = urlJoin(buildDir, fileName);
      // 
      let renderPath = urlJoin(renderFolder, 'index.html');
      // 404 
      if (name === '404.ejs') {
        renderFolder = buildDir;
        renderPath = urlJoin(renderFolder, '404.html');
      }
      // 
      fse.ensureDirSync(renderFolder);
      //  HTML
      const html = await renderFileAction(templatePath, renderData, fileName);
      // 
      fse.outputFileSync(renderPath, html);
    }
  }

  /**
   * 
   * @return {Promise<void>}
   */
  async function buildSiteMap() {
    const {
      generateSiteMap,
      robotsText,
      domain
    } = sourceData.themeConfig;
    // generateSiteMap == false 
    if (!generateSiteMap) return;
    //  Robots.txt 
    const robotsTxt = robots.parse(robotsText || '');
    robotsTxt.append('Sitemap', urlJoin(domain, 'sitemap.xml'));
    // 
    fse.outputFileSync(urlJoin(buildDir, 'robots.txt'), robots.serialize(robotsTxt));
    //  url 
    const sitemap = new SitemapStream({
      hostname: domain
    });
    for (const data of siteMapUrls) {
      sitemap.write(data, 'utf-8');
    }
    sitemap.end();
    const result = await streamToPromise(sitemap);
    // 
    fse.outputFileSync(urlJoin(buildDir, 'sitemap.xml'), result.toString());
  }

  /**
   * 
   * @return {Promise<void>}
   */
  async function build() {
    const {
      archivePath,
      archivesPageSize,
      postPageSize
    } = sourceData.themeConfig;
    await buildCss();
    // 
    await buildPostList('', 'index.ejs', postPageSize);
    // 
    await buildPostList(urlJoin('/', archivePath), 'archives.ejs', archivesPageSize);
    // 
    await buildTags();
    //  post 
    await buildPostDetail();
    //  tag 
    await buildTagDetail();
    // 
    await buildCustomPage();
    // 
    await buildSiteMap();
  }
  build().then(() => console.log(true)).catch(e => console.log(false, 'build', e));

  //--------------------------- rollup.config.js ---------------------------
  /*
  import babel from '@rollup/plugin-babel'
  import commonjs from '@rollup/plugin-commonjs'
  import json from '@rollup/plugin-json'
  import { nodeResolve } from '@rollup/plugin-node-resolve'
  import { defineConfig, InputPluginOption } from 'rollup'
  import replace from '@rollup/plugin-replace';
    export default defineConfig([
    {
      input: './lib/index.js',
      output: {
        file: './dist/cjs/index.js',
        format: 'cjs'
      },
      plugins: [
        nodeResolve({preferBuiltins: true}),
        commonjs({transformMixedEsModules: true}),
        json(),
        babel({ babelHelpers: 'bundled' }),
        replace({
          preventAssignment: true,
          //'\.URL(': '.Url(',
        }),
      ],
    }
  ])*/

  //--------------------------- uglify-js ---------------------------
  /**
   *  node_modules/uglify-js/tools/node.js  exports.FILES 
   *  exports.FILES  var fs = require("fs"); ,  exports.FILES 
   *  rollup ncc 
   */
} catch (e) {
  console.log(false, e);
}
